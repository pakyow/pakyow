(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.Babel = {}));
}(this, (function (exports) { 'use strict';

  var context = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get types () { return t; },
    get DEFAULT_EXTENSIONS () { return DEFAULT_EXTENSIONS; },
    get OptionManager () { return OptionManager; },
    get Plugin () { return Plugin$1; },
    get File () { return File$2; },
    get buildExternalHelpers () { return babelBuildExternalHelpers; },
    get resolvePlugin () { return resolvePlugin; },
    get resolvePreset () { return resolvePreset; },
    get version () { return version$1; },
    get getEnv () { return getEnv; },
    get tokTypes () { return types; },
    get traverse () { return traverse$1; },
    get template () { return template; },
    get createConfigItem () { return createConfigItem; },
    get loadPartialConfig () { return loadPartialConfig$1; },
    get loadPartialConfigSync () { return loadPartialConfigSync; },
    get loadPartialConfigAsync () { return loadPartialConfigAsync; },
    get loadOptions () { return loadOptions; },
    get loadOptionsSync () { return loadOptionsSync; },
    get loadOptionsAsync () { return loadOptionsAsync; },
    get transform () { return transform; },
    get transformSync () { return transformSync; },
    get transformAsync () { return transformAsync; },
    get transformFile () { return transformFile$1; },
    get transformFileSync () { return transformFileSync; },
    get transformFileAsync () { return transformFileAsync; },
    get transformFromAst () { return transformFromAst; },
    get transformFromAstSync () { return transformFromAstSync; },
    get transformFromAstAsync () { return transformFromAstAsync; },
    get parse () { return parse$3; },
    get parseSync () { return parseSync; },
    get parseAsync () { return parseAsync; }
  });

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    strings.raw = raw;
    return strings;
  }

  function shallowEqual(actual, expected) {
    var keys = Object.keys(expected);

    for (var _i = 0, _arr = keys; _i < _arr.length; _i++) {
      var key = _arr[_i];

      if (actual[key] !== expected[key]) {
        return false;
      }
    }

    return true;
  }

  function isArrayExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArrayExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isAssignmentExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "AssignmentExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBinaryExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BinaryExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInterpreterDirective(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InterpreterDirective") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDirective(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Directive") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDirectiveLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DirectiveLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBlockStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BlockStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBreakStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BreakStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isCallExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "CallExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isCatchClause(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "CatchClause") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isConditionalExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ConditionalExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isContinueStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ContinueStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDebuggerStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DebuggerStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDoWhileStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DoWhileStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEmptyStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EmptyStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExpressionStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExpressionStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFile(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "File") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isForInStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ForInStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isForStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ForStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isIdentifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Identifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isIfStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "IfStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLabeledStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "LabeledStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStringLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "StringLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNumericLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NumericLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNullLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NullLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBooleanLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BooleanLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRegExpLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RegExpLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLogicalExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "LogicalExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isMemberExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "MemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNewExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NewExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isProgram(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Program") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRestElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RestElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isReturnStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ReturnStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSequenceExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SequenceExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isParenthesizedExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ParenthesizedExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSwitchCase(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SwitchCase") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSwitchStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SwitchStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isThisExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ThisExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isThrowStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ThrowStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTryStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TryStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUnaryExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "UnaryExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUpdateExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "UpdateExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isVariableDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "VariableDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isVariableDeclarator(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "VariableDeclarator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isWhileStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "WhileStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isWithStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "WithStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isAssignmentPattern(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "AssignmentPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isArrayPattern(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArrayPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isArrowFunctionExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArrowFunctionExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportAllDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportAllDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportDefaultDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportDefaultDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportNamedDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportNamedDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isForOfStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ForOfStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportDefaultSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportDefaultSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportNamespaceSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isMetaProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "MetaProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectPattern(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSpreadElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SpreadElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSuper(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Super") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTaggedTemplateExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TaggedTemplateExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTemplateElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TemplateElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTemplateLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TemplateLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isYieldExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "YieldExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isAnyTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "AnyTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isArrayTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArrayTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBooleanTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BooleanTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BooleanLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNullLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NullLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassImplements(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassImplements") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareClass(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareClass") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareFunction(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareInterface(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareInterface") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareModule(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareModule") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareModuleExports(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareModuleExports") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareTypeAlias(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareTypeAlias") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareOpaqueType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareOpaqueType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareVariable(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareVariable") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareExportDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareExportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareExportAllDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareExportAllDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclaredPredicate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclaredPredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExistsTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExistsTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionTypeParam(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionTypeParam") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isGenericTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "GenericTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInferredPredicate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InferredPredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInterfaceExtends(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InterfaceExtends") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInterfaceDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InterfaceDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInterfaceTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InterfaceTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isIntersectionTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "IntersectionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isMixedTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "MixedTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEmptyTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EmptyTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNullableTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NullableTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NumberLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNumberTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NumberTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeInternalSlot(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeInternalSlot") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeCallProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeCallProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeIndexer(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeIndexer") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeSpreadProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeSpreadProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isOpaqueType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "OpaqueType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isQualifiedTypeIdentifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "QualifiedTypeIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStringLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "StringLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStringTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "StringTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSymbolTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SymbolTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isThisTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ThisTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTupleTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TupleTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeofTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeofTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeAlias(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeAlias") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeCastExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeCastExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeParameter(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeParameter") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeParameterDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeParameterInstantiation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUnionTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "UnionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isVariance(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Variance") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isVoidTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "VoidTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumBooleanBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumBooleanBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumNumberBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumNumberBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumStringBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumStringBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumSymbolBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumSymbolBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumBooleanMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumBooleanMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumNumberMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumNumberMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumStringMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumStringMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumDefaultedMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumDefaultedMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXAttribute(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXClosingElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXClosingElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXEmptyExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXEmptyExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXExpressionContainer(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXExpressionContainer") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXSpreadChild(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXSpreadChild") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXIdentifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXMemberExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXMemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXNamespacedName(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXNamespacedName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXOpeningElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXOpeningElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXSpreadAttribute(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXSpreadAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXText(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXText") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXFragment(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXOpeningFragment(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXOpeningFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXClosingFragment(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXClosingFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNoop(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Noop") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPlaceholder(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Placeholder") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isV8IntrinsicIdentifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "V8IntrinsicIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isArgumentPlaceholder(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArgumentPlaceholder") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isAwaitExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "AwaitExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBindExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BindExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isOptionalMemberExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "OptionalMemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPipelineTopicExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PipelineTopicExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPipelineBareFunction(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PipelineBareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPipelinePrimaryTopicReference(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PipelinePrimaryTopicReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isOptionalCallExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "OptionalCallExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassPrivateProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassPrivateProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassPrivateMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassPrivateMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImport(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Import") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDecorator(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Decorator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDoExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DoExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportDefaultSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportDefaultSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportNamespaceSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPrivateName(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PrivateName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBigIntLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BigIntLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRecordExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RecordExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTupleExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TupleExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSParameterProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSParameterProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSDeclareFunction(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSDeclareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSDeclareMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSDeclareMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSQualifiedName(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSQualifiedName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSCallSignatureDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSCallSignatureDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSConstructSignatureDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSConstructSignatureDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSPropertySignature(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSPropertySignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSMethodSignature(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSMethodSignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSIndexSignature(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSIndexSignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSAnyKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSAnyKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSBooleanKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSBooleanKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSBigIntKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSBigIntKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNeverKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNeverKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNullKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNullKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNumberKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNumberKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSObjectKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSObjectKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSStringKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSStringKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSSymbolKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSSymbolKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSUndefinedKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSUndefinedKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSUnknownKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSUnknownKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSVoidKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSVoidKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSThisType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSThisType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSFunctionType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSFunctionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSConstructorType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSConstructorType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeReference(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypePredicate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypePredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeQuery(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeQuery") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSArrayType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSArrayType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTupleType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTupleType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSOptionalType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSOptionalType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSRestType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSRestType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSUnionType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSUnionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSIntersectionType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSIntersectionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSConditionalType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSConditionalType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSInferType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSInferType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSParenthesizedType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSParenthesizedType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeOperator(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeOperator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSIndexedAccessType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSIndexedAccessType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSMappedType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSMappedType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSLiteralType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSLiteralType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSExpressionWithTypeArguments(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSExpressionWithTypeArguments") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSInterfaceDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSInterfaceDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSInterfaceBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSInterfaceBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeAliasDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeAliasDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSAsExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSAsExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeAssertion(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeAssertion") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSEnumDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSEnumDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSEnumMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSEnumMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSModuleDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSModuleDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSModuleBlock(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSModuleBlock") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSImportType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSImportType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSImportEqualsDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSImportEqualsDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSExternalModuleReference(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSExternalModuleReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNonNullExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNonNullExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSExportAssignment(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSExportAssignment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNamespaceExportDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNamespaceExportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeParameterInstantiation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeParameterDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeParameter(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeParameter") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Expression" || "ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "AwaitExpression" === nodeType || "BindExpression" === nodeType || "OptionalMemberExpression" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "OptionalCallExpression" === nodeType || "Import" === nodeType || "DoExpression" === nodeType || "BigIntLiteral" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBinary(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Binary" || "BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isScopable(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Scopable" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBlockParent(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BlockParent" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBlock(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Block" || "BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Statement" || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTerminatorless(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Terminatorless" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isCompletionStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "CompletionStatement" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isConditional(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Conditional" || "ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLoop(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Loop" || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isWhile(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "While" || "DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExpressionWrapper(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExpressionWrapper" || "ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFor(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "For" || "ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isForXStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ForXStatement" || "ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunction(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Function" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionParent(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionParent" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPureish(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Pureish" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Declaration" || "FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPatternLike(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PatternLike" || "Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLVal(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "LVal" || "Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSEntityName(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSEntityName" || "Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Literal" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUserWhitespacable(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "UserWhitespacable" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Method" || "ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectMember" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Property" || "ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUnaryLike(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "UnaryLike" || "UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPattern(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Pattern" || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClass(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Class" || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isModuleDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ModuleDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isModuleSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ModuleSpecifier" || "ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlow(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Flow" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlowType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FlowType" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlowBaseAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FlowBaseAnnotation" || "AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlowDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FlowDeclaration" || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlowPredicate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FlowPredicate" || "DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumBody" || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumMember" || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSX(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSX" || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPrivate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Private" || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeElement" || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSType" || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NumberLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RegexLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RestProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SpreadProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }

  function matchesPattern(member, match, allowPartial) {
    if (!isMemberExpression(member)) return false;
    var parts = Array.isArray(match) ? match : match.split(".");
    var nodes = [];
    var node;

    for (node = member; isMemberExpression(node); node = node.object) {
      nodes.push(node.property);
    }

    nodes.push(node);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;

    for (var i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
      var _node = nodes[j];
      var value = void 0;

      if (isIdentifier(_node)) {
        value = _node.name;
      } else if (isStringLiteral(_node)) {
        value = _node.value;
      } else {
        return false;
      }

      if (parts[i] !== value) return false;
    }

    return true;
  }

  function buildMatchMemberExpression(match, allowPartial) {
    var parts = match.split(".");
    return function (member) {
      return matchesPattern(member, parts, allowPartial);
    };
  }

  var isReactComponent = buildMatchMemberExpression("React.Component");

  function isCompatTag(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  }

  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;

  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  var eq_1 = eq;

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  var _assocIndexOf = assocIndexOf;

  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;

  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;

  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;

  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  var _listCacheSet = listCacheSet;

  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;
  var _ListCache = ListCache;

  function stackClear() {
    this.__data__ = new _ListCache();
    this.size = 0;
  }

  var _stackClear = stackClear;

  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;

  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;

  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function commonjsRequire () {
    throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
  }

  function unwrapExports (x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
    return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
    return n && n['default'] || n;
  }

  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal;

  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  var root = _freeGlobal || freeSelf || Function('return this')();
  var _root = root;

  var Symbol$1 = _root.Symbol;
  var _Symbol = Symbol$1;

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  var _getRawTag = getRawTag;

  var objectProto$1 = Object.prototype;
  var nativeObjectToString$1 = objectProto$1.toString;

  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;

  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  function isFunction$1(value) {
    if (!isObject_1(value)) {
      return false;
    }

    var tag = _baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction$1;

  var coreJsData = _root['__core-js_shared__'];
  var _coreJsData = coreJsData;

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  var _isMasked = isMasked;

  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  var _toSource = toSource;

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto$1 = Function.prototype,
      objectProto$2 = Object.prototype;
  var funcToString$1 = funcProto$1.toString;
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }

    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;

  function getNative(object, key) {
    var value = _getValue(object, key);
    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  var Map$1 = _getNative(_root, 'Map');
  var _Map = Map$1;

  var nativeCreate = _getNative(Object, 'create');
  var _nativeCreate = nativeCreate;

  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;

  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var objectProto$3 = Object.prototype;
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  function hashGet(key) {
    var data = this.__data__;

    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;

  var objectProto$4 = Object.prototype;
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? data[key] !== undefined : hasOwnProperty$3.call(data, key);
  }

  var _hashHas = hashHas;

  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = _nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;

  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;
  var _Hash = Hash;

  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash(),
      'map': new (_Map || _ListCache)(),
      'string': new _Hash()
    };
  }

  var _mapCacheClear = mapCacheClear;

  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  var _isKeyable = isKeyable;

  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  var _getMapData = getMapData;

  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;

  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;

  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;

  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;

  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;
  var _MapCache = MapCache;

  var LARGE_ARRAY_SIZE = 200;

  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof _ListCache) {
      var pairs = data.__data__;

      if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new _MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;

  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  }

  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;
  var _Stack = Stack;

  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }

  var _arrayEach = arrayEach;

  var defineProperty = function () {
    try {
      var func = _getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }();

  var _defineProperty = defineProperty;

  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && _defineProperty) {
      _defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  var _baseAssignValue = baseAssignValue;

  var objectProto$5 = Object.prototype;
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty$4.call(object, key) && eq_1(objValue, value)) || value === undefined && !(key in object)) {
      _baseAssignValue(object, key, value);
    }
  }

  var _assignValue = assignValue;

  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }

      if (isNew) {
        _baseAssignValue(object, key, newValue);
      } else {
        _assignValue(object, key, newValue);
      }
    }

    return object;
  }

  var _copyObject = copyObject;

  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  var _baseTimes = baseTimes;

  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  var argsTag = '[object Arguments]';

  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
  }

  var _baseIsArguments = baseIsArguments;

  var objectProto$6 = Object.prototype;
  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
  var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
  var isArguments = _baseIsArguments(function () {
    return arguments;
  }()) ? _baseIsArguments : function (value) {
    return isObjectLike_1(value) && hasOwnProperty$5.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };
  var isArguments_1 = isArguments;

  var isArray = Array.isArray;
  var isArray_1 = isArray;

  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;

  var isBuffer_1 = createCommonjsModule(function (module, exports) {
  var freeExports =  exports && !exports.nodeType && exports;
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? _root.Buffer : undefined;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
  var isBuffer = nativeIsBuffer || stubFalse_1;
  module.exports = isBuffer;
  });

  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  var _isIndex = isIndex;

  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  var isLength_1 = isLength;

  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  function baseIsTypedArray(value) {
    return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;

  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
  var freeExports =  exports && !exports.nodeType && exports;
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && _freeGlobal.process;

  var nodeUtil = function () {
    try {
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  module.exports = nodeUtil;
  });

  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
  var isTypedArray_1 = isTypedArray;

  var objectProto$7 = Object.prototype;
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || _isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;

  var objectProto$8 = Object.prototype;

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$8;
    return value === proto;
  }

  var _isPrototype = isPrototype;

  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;

  var nativeKeys = _overArg(Object.keys, Object);
  var _nativeKeys = nativeKeys;

  var objectProto$9 = Object.prototype;
  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeys = baseKeys;

  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;

  function keys(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys;

  function baseAssign(object, source) {
    return object && _copyObject(source, keys_1(source), object);
  }

  var _baseAssign = baseAssign;

  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }

  var _nativeKeysIn = nativeKeysIn;

  var objectProto$a = Object.prototype;
  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

  function baseKeysIn(object) {
    if (!isObject_1(object)) {
      return _nativeKeysIn(object);
    }

    var isProto = _isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeysIn = baseKeysIn;

  function keysIn$1(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
  }

  var keysIn_1 = keysIn$1;

  function baseAssignIn(object, source) {
    return object && _copyObject(source, keysIn_1(source), object);
  }

  var _baseAssignIn = baseAssignIn;

  var _cloneBuffer = createCommonjsModule(function (module, exports) {
  var freeExports =  exports && !exports.nodeType && exports;
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? _root.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }

  module.exports = cloneBuffer;
  });

  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }

  var _copyArray = copyArray;

  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  var _arrayFilter = arrayFilter;

  function stubArray() {
    return [];
  }

  var stubArray_1 = stubArray;

  var objectProto$b = Object.prototype;
  var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray_1 : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return _arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };
  var _getSymbols = getSymbols;

  function copySymbols(source, object) {
    return _copyObject(source, _getSymbols(source), object);
  }

  var _copySymbols = copySymbols;

  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  var _arrayPush = arrayPush;

  var getPrototype = _overArg(Object.getPrototypeOf, Object);
  var _getPrototype = getPrototype;

  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function (object) {
    var result = [];

    while (object) {
      _arrayPush(result, _getSymbols(object));
      object = _getPrototype(object);
    }

    return result;
  };
  var _getSymbolsIn = getSymbolsIn;

  function copySymbolsIn(source, object) {
    return _copyObject(source, _getSymbolsIn(source), object);
  }

  var _copySymbolsIn = copySymbolsIn;

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys;

  function getAllKeys(object) {
    return _baseGetAllKeys(object, keys_1, _getSymbols);
  }

  var _getAllKeys = getAllKeys;

  function getAllKeysIn(object) {
    return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
  }

  var _getAllKeysIn = getAllKeysIn;

  var DataView$1 = _getNative(_root, 'DataView');
  var _DataView = DataView$1;

  var Promise$1 = _getNative(_root, 'Promise');
  var _Promise = Promise$1;

  var Set$1 = _getNative(_root, 'Set');
  var _Set = Set$1;

  var WeakMap$1 = _getNative(_root, 'WeakMap');
  var _WeakMap = WeakMap$1;

  var mapTag$1 = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$1 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';
  var dataViewTag$1 = '[object DataView]';
  var dataViewCtorString = _toSource(_DataView),
      mapCtorString = _toSource(_Map),
      promiseCtorString = _toSource(_Promise),
      setCtorString = _toSource(_Set),
      weakMapCtorString = _toSource(_WeakMap);
  var getTag = _baseGetTag;

  if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$1 || _Map && getTag(new _Map()) != mapTag$1 || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag$1 || _WeakMap && getTag(new _WeakMap()) != weakMapTag$1) {
    getTag = function getTag(value) {
      var result = _baseGetTag(value),
          Ctor = result == objectTag$1 ? value.constructor : undefined,
          ctorString = Ctor ? _toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$1;

          case mapCtorString:
            return mapTag$1;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag$1;

          case weakMapCtorString:
            return weakMapTag$1;
        }
      }

      return result;
    };
  }

  var _getTag = getTag;

  var objectProto$c = Object.prototype;
  var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length);

    if (length && typeof array[0] == 'string' && hasOwnProperty$9.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }

    return result;
  }

  var _initCloneArray = initCloneArray;

  var Uint8Array$1 = _root.Uint8Array;
  var _Uint8Array = Uint8Array$1;

  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
    return result;
  }

  var _cloneArrayBuffer = cloneArrayBuffer;

  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  var _cloneDataView = cloneDataView;

  var reFlags = /\w*$/;

  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  var _cloneRegExp = cloneRegExp;

  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  var _cloneSymbol = cloneSymbol;

  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  var _cloneTypedArray = cloneTypedArray;

  var boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      mapTag$2 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$2 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag = '[object Symbol]';
  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]',
      float32Tag$1 = '[object Float32Array]',
      float64Tag$1 = '[object Float64Array]',
      int8Tag$1 = '[object Int8Array]',
      int16Tag$1 = '[object Int16Array]',
      int32Tag$1 = '[object Int32Array]',
      uint8Tag$1 = '[object Uint8Array]',
      uint8ClampedTag$1 = '[object Uint8ClampedArray]',
      uint16Tag$1 = '[object Uint16Array]',
      uint32Tag$1 = '[object Uint32Array]';

  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;

    switch (tag) {
      case arrayBufferTag$1:
        return _cloneArrayBuffer(object);

      case boolTag$1:
      case dateTag$1:
        return new Ctor(+object);

      case dataViewTag$2:
        return _cloneDataView(object, isDeep);

      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return _cloneTypedArray(object, isDeep);

      case mapTag$2:
        return new Ctor();

      case numberTag$1:
      case stringTag$1:
        return new Ctor(object);

      case regexpTag$1:
        return _cloneRegExp(object);

      case setTag$2:
        return new Ctor();

      case symbolTag:
        return _cloneSymbol(object);
    }
  }

  var _initCloneByTag = initCloneByTag;

  var objectCreate = Object.create;

  var baseCreate = function () {
    function object() {}

    return function (proto) {
      if (!isObject_1(proto)) {
        return {};
      }

      if (objectCreate) {
        return objectCreate(proto);
      }

      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  }();

  var _baseCreate = baseCreate;

  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !_isPrototype(object) ? _baseCreate(_getPrototype(object)) : {};
  }

  var _initCloneObject = initCloneObject;

  var mapTag$3 = '[object Map]';

  function baseIsMap(value) {
    return isObjectLike_1(value) && _getTag(value) == mapTag$3;
  }

  var _baseIsMap = baseIsMap;

  var nodeIsMap = _nodeUtil && _nodeUtil.isMap;
  var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;
  var isMap_1 = isMap;

  var setTag$3 = '[object Set]';

  function baseIsSet(value) {
    return isObjectLike_1(value) && _getTag(value) == setTag$3;
  }

  var _baseIsSet = baseIsSet;

  var nodeIsSet = _nodeUtil && _nodeUtil.isSet;
  var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;
  var isSet_1 = isSet;

  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;
  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      boolTag$2 = '[object Boolean]',
      dateTag$2 = '[object Date]',
      errorTag$1 = '[object Error]',
      funcTag$2 = '[object Function]',
      genTag$1 = '[object GeneratorFunction]',
      mapTag$4 = '[object Map]',
      numberTag$2 = '[object Number]',
      objectTag$2 = '[object Object]',
      regexpTag$2 = '[object RegExp]',
      setTag$4 = '[object Set]',
      stringTag$2 = '[object String]',
      symbolTag$1 = '[object Symbol]',
      weakMapTag$2 = '[object WeakMap]';
  var arrayBufferTag$2 = '[object ArrayBuffer]',
      dataViewTag$3 = '[object DataView]',
      float32Tag$2 = '[object Float32Array]',
      float64Tag$2 = '[object Float64Array]',
      int8Tag$2 = '[object Int8Array]',
      int16Tag$2 = '[object Int16Array]',
      int32Tag$2 = '[object Int32Array]',
      uint8Tag$2 = '[object Uint8Array]',
      uint8ClampedTag$2 = '[object Uint8ClampedArray]',
      uint16Tag$2 = '[object Uint16Array]',
      uint32Tag$2 = '[object Uint32Array]';
  var cloneableTags = {};
  cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] = cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] = cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$2] = cloneableTags[setTag$4] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] = cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
  cloneableTags[errorTag$1] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;

  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }

    if (result !== undefined) {
      return result;
    }

    if (!isObject_1(value)) {
      return value;
    }

    var isArr = isArray_1(value);

    if (isArr) {
      result = _initCloneArray(value);

      if (!isDeep) {
        return _copyArray(value, result);
      }
    } else {
      var tag = _getTag(value),
          isFunc = tag == funcTag$2 || tag == genTag$1;

      if (isBuffer_1(value)) {
        return _cloneBuffer(value, isDeep);
      }

      if (tag == objectTag$2 || tag == argsTag$2 || isFunc && !object) {
        result = isFlat || isFunc ? {} : _initCloneObject(value);

        if (!isDeep) {
          return isFlat ? _copySymbolsIn(value, _baseAssignIn(result, value)) : _copySymbols(value, _baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }

        result = _initCloneByTag(value, tag, isDeep);
      }
    }

    stack || (stack = new _Stack());
    var stacked = stack.get(value);

    if (stacked) {
      return stacked;
    }

    stack.set(value, result);

    if (isSet_1(value)) {
      value.forEach(function (subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap_1(value)) {
      value.forEach(function (subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
    }

    var keysFunc = isFull ? isFlat ? _getAllKeysIn : _getAllKeys : isFlat ? keysIn : keys_1;
    var props = isArr ? undefined : keysFunc(value);
    _arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }

      _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  var _baseClone = baseClone;

  var CLONE_SYMBOLS_FLAG$1 = 4;

  function clone(value) {
    return _baseClone(value, CLONE_SYMBOLS_FLAG$1);
  }

  var clone_1 = clone;

  var fastProto = null;

  function FastObject(o) {
    if (fastProto !== null && typeof fastProto.property) {
      var result = fastProto;
      fastProto = FastObject.prototype = null;
      return result;
    }

    fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
    return new FastObject();
  }

  FastObject();

  var toFastProperties = function toFastproperties(o) {
    return FastObject(o);
  };

  var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

  function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
  }

  function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
  }

  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;

  if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
  }

  if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }

    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }

    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }

  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }

    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }

    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }

  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }

    draining = false;

    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }

    if (queue.length) {
      drainQueue();
    }
  }

  function drainQueue() {
    if (draining) {
      return;
    }

    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;

    while (len) {
      currentQueue = queue;
      queue = [];

      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }

      queueIndex = -1;
      len = queue.length;
    }

    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }

  function nextTick(fun) {
    var args = new Array(arguments.length - 1);

    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }

    queue.push(new Item(fun, args));

    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  }

  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }

  Item.prototype.run = function () {
    this.fun.apply(null, this.array);
  };

  var title = 'browser';
  var platform = 'browser';
  var browser = true;
  var env = {};
  var argv = [];
  var version = '';
  var versions = {};
  var release = {};
  var config = {};

  function noop() {}

  var on = noop;
  var addListener = noop;
  var once = noop;
  var off = noop;
  var removeListener = noop;
  var removeAllListeners = noop;
  var emit = noop;
  function binding(name) {
    throw new Error('process.binding is not supported');
  }
  function cwd() {
    return '/';
  }
  function chdir(dir) {
    throw new Error('process.chdir is not supported');
  }
  function umask() {
    return 0;
  }
  var performance = global$1.performance || {};

  var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
    return new Date().getTime();
  };

  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);

    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];

      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }

    return [seconds, nanoseconds];
  }
  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }
  var process = {
    nextTick: nextTick,
    title: title,
    browser: browser,
    env: env,
    argv: argv,
    version: version,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  function isType(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (ALIAS_KEYS[targetType]) return false;
    var aliases = FLIPPED_ALIAS_KEYS[targetType];

    if (aliases) {
      if (aliases[0] === nodeType) return true;

      for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var alias = _ref;
        if (nodeType === alias) return true;
      }
    }

    return false;
  }

  function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    var aliases = PLACEHOLDERS_ALIAS[placeholderType];

    if (aliases) {
      for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var alias = _ref;
        if (targetType === alias) return true;
      }
    }

    return false;
  }

  function is(type, node, opts) {
    if (!node) return false;
    var matches = isType(node.type, type);

    if (!matches) {
      if (!opts && node.type === "Placeholder" && type in FLIPPED_ALIAS_KEYS) {
        return isPlaceholderType(node.expectedNode, type);
      }

      return false;
    }

    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

  function isInAstralSet(code, set) {
    var pos = 0x10000;

    for (var i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }

    return false;
  }

  function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }

    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    }

    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  function isIdentifierName(name) {
    var isFirst = true;

    for (var _i2 = 0, _Array$from2 = Array.from(name); _i2 < _Array$from2.length; _i2++) {
      var _char = _Array$from2[_i2];

      var cp = _char.codePointAt(0);

      if (isFirst) {
        if (!isIdentifierStart(cp)) {
          return false;
        }

        isFirst = false;
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }

    return true;
  }

  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }

  function isValidIdentifier(name, reserved) {
    if (reserved === void 0) {
      reserved = true;
    }

    if (typeof name !== "string") return false;

    if (reserved) {
      if (isKeyword(name) || isStrictReservedWord(name)) {
        return false;
      } else if (name === "await") {
        return false;
      }
    }

    return isIdentifierName(name);
  }

  var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
  var FLATTENABLE_KEYS = ["body", "expressions"];
  var FOR_INIT_KEYS = ["left", "init"];
  var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  var LOGICAL_OPERATORS = ["||", "&&", "??"];
  var UPDATE_OPERATORS = ["++", "--"];
  var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
  var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
  var COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]);
  var BOOLEAN_BINARY_OPERATORS = [].concat(COMPARISON_BINARY_OPERATORS, BOOLEAN_NUMBER_BINARY_OPERATORS);
  var NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  var BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS, BOOLEAN_BINARY_OPERATORS);
  var ASSIGNMENT_OPERATORS = ["=", "+="].concat(NUMBER_BINARY_OPERATORS.map(function (op) {
    return op + "=";
  }));
  var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
  var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
  var STRING_UNARY_OPERATORS = ["typeof"];
  var UNARY_OPERATORS = ["void", "throw"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);
  var INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  var BLOCK_SCOPED_SYMBOL = Symbol["for"]("var used to be block scoped");
  var NOT_LOCAL_BINDING = Symbol["for"]("should not be considered a local binding");

  function validate(node, key, val) {
    if (!node) return;
    var fields = NODE_FIELDS[node.type];
    if (!fields) return;
    var field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
  }
  function validateField(node, key, val, field) {
    if (!field || !field.validate) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
  }
  function validateChild(node, key, val) {
    if (val == null) return;
    var validate = NODE_PARENT_VALIDATIONS[val.type];
    if (!validate) return;
    validate(node, key, val);
  }

  var VISITOR_KEYS = {};
  var ALIAS_KEYS = {};
  var FLIPPED_ALIAS_KEYS = {};
  var NODE_FIELDS = {};
  var BUILDER_KEYS = {};
  var DEPRECATED_KEYS = {};
  var NODE_PARENT_VALIDATIONS = {};

  function getType(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return typeof val;
    }
  }

  function validate$1(validate) {
    return {
      validate: validate
    };
  }
  function typeIs(typeName) {
    return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType.apply(void 0, typeName);
  }
  function validateType(typeName) {
    return validate$1(typeIs(typeName));
  }
  function validateOptional(validate) {
    return {
      validate: validate,
      optional: true
    };
  }
  function validateOptionalType(typeName) {
    return {
      validate: typeIs(typeName),
      optional: true
    };
  }
  function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  }
  function arrayOfType(typeName) {
    return arrayOf(typeIs(typeName));
  }
  function validateArrayOfType(typeName) {
    return validate$1(arrayOfType(typeName));
  }
  function assertEach(callback) {
    function validator(node, key, val) {
      if (!Array.isArray(val)) return;

      for (var i = 0; i < val.length; i++) {
        var subkey = key + "[" + i + "]";
        var v = val[i];
        callback(node, subkey, v);
        if (process.env.BABEL_TYPES_8_BREAKING) validateChild(node, subkey, v);
      }
    }

    validator.each = callback;
    return validator;
  }
  function assertOneOf() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    function validate(node, key, val) {
      if (values.indexOf(val) < 0) {
        throw new TypeError("Property " + key + " expected value to be one of " + JSON.stringify(values) + " but got " + JSON.stringify(val));
      }
    }

    validate.oneOf = values;
    return validate;
  }
  function assertNodeType() {
    for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      types[_key2] = arguments[_key2];
    }

    function validate(node, key, val) {
      for (var _iterator = types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var type = _ref;

        if (is(type, val)) {
          validateChild(node, key, val);
          return;
        }
      }

      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " but instead got " + JSON.stringify(val && val.type));
    }

    validate.oneOfNodeTypes = types;
    return validate;
  }
  function assertNodeOrValueType() {
    for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      types[_key3] = arguments[_key3];
    }

    function validate(node, key, val) {
      for (var _iterator2 = types, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var type = _ref2;

        if (getType(val) === type || is(type, val)) {
          validateChild(node, key, val);
          return;
        }
      }

      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " but instead got " + JSON.stringify(val && val.type));
    }

    validate.oneOfNodeOrValueTypes = types;
    return validate;
  }
  function assertValueType(type) {
    function validate(node, key, val) {
      var valid = getType(val) === type;

      if (!valid) {
        throw new TypeError("Property " + key + " expected type of " + type + " but got " + getType(val));
      }
    }

    validate.type = type;
    return validate;
  }
  function assertShape(shape) {
    function validate(node, key, val) {
      var errors = [];

      for (var _i3 = 0, _Object$keys = Object.keys(shape); _i3 < _Object$keys.length; _i3++) {
        var property = _Object$keys[_i3];

        try {
          validateField(node, property, val[property], shape[property]);
        } catch (error) {
          if (error instanceof TypeError) {
            errors.push(error.message);
            continue;
          }

          throw error;
        }
      }

      if (errors.length) {
        throw new TypeError("Property " + key + " of " + node.type + " expected to have the following:\n" + errors.join("\n"));
      }
    }

    validate.shapeOf = shape;
    return validate;
  }
  function assertOptionalChainStart() {
    function validate(node) {
      var _current2;

      var current = node;

      while (node) {
        var _current = current,
            type = _current.type;

        if (type === "OptionalCallExpression") {
          if (current.optional) return;
          current = current.callee;
          continue;
        }

        if (type === "OptionalMemberExpression") {
          if (current.optional) return;
          current = current.object;
          continue;
        }

        break;
      }

      throw new TypeError("Non-optional " + node.type + " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from " + ((_current2 = current) == null ? void 0 : _current2.type));
    }

    return validate;
  }
  function chain() {
    for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      fns[_key4] = arguments[_key4];
    }

    function validate() {
      for (var _iterator3 = fns, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i4 >= _iterator3.length) break;
          _ref3 = _iterator3[_i4++];
        } else {
          _i4 = _iterator3.next();
          if (_i4.done) break;
          _ref3 = _i4.value;
        }

        var fn = _ref3;
        fn.apply(void 0, arguments);
      }
    }

    validate.chainOf = fns;
    return validate;
  }
  var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
  var validFieldKeys = ["default", "optional", "validate"];
  function defineType(type, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var inherits = opts.inherits && store[opts.inherits] || {};
    var fields = opts.fields;

    if (!fields) {
      fields = {};

      if (inherits.fields) {
        var keys = Object.getOwnPropertyNames(inherits.fields);

        for (var _i5 = 0, _arr = keys; _i5 < _arr.length; _i5++) {
          var key = _arr[_i5];
          var field = inherits.fields[key];
          fields[key] = {
            "default": field["default"],
            optional: field.optional,
            validate: field.validate
          };
        }
      }
    }

    var visitor = opts.visitor || inherits.visitor || [];
    var aliases = opts.aliases || inherits.aliases || [];
    var builder = opts.builder || inherits.builder || opts.visitor || [];

    for (var _i6 = 0, _arr2 = Object.keys(opts); _i6 < _arr2.length; _i6++) {
      var k = _arr2[_i6];

      if (validTypeOpts.indexOf(k) === -1) {
        throw new Error("Unknown type option \"" + k + "\" on " + type);
      }
    }

    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }

    for (var _i7 = 0, _arr3 = visitor.concat(builder); _i7 < _arr3.length; _i7++) {
      var _key5 = _arr3[_i7];
      fields[_key5] = fields[_key5] || {};
    }

    for (var _i8 = 0, _Object$keys2 = Object.keys(fields); _i8 < _Object$keys2.length; _i8++) {
      var _key6 = _Object$keys2[_i8];
      var _field = fields[_key6];

      if (_field["default"] !== undefined && builder.indexOf(_key6) === -1) {
        _field.optional = true;
      }

      if (_field["default"] === undefined) {
        _field["default"] = null;
      } else if (!_field.validate && _field["default"] != null) {
        _field.validate = assertValueType(getType(_field["default"]));
      }

      for (var _i9 = 0, _arr4 = Object.keys(_field); _i9 < _arr4.length; _i9++) {
        var _k = _arr4[_i9];

        if (validFieldKeys.indexOf(_k) === -1) {
          throw new Error("Unknown field key \"" + _k + "\" on " + type + "." + _key6);
        }
      }
    }

    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach(function (alias) {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
      FLIPPED_ALIAS_KEYS[alias].push(type);
    });

    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }

    store[type] = opts;
  }
  var store = {};

  defineType("ArrayExpression", {
    fields: {
      elements: {
        validate: chain(assertValueType("array"), assertEach(assertNodeOrValueType("null", "Expression", "SpreadElement"))),
        "default": !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  defineType("AssignmentExpression", {
    fields: {
      operator: {
        validate: function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return assertValueType("string");
          }

          var identifier = assertOneOf.apply(void 0, ASSIGNMENT_OPERATORS);
          var pattern = assertOneOf("=");
          return function (node, key, val) {
            var validator = is("Pattern", node.left) ? pattern : identifier;
            validator(node, key, val);
          };
        }()
      },
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal") : assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
      },
      right: {
        validate: assertNodeType("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  defineType("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: assertOneOf.apply(void 0, BINARY_OPERATORS)
      },
      left: {
        validate: assertNodeType("Expression")
      },
      right: {
        validate: assertNodeType("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  defineType("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    }
  });
  defineType("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: assertNodeType("DirectiveLiteral")
      }
    }
  });
  defineType("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    }
  });
  defineType("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Directive"))),
        "default": []
      },
      body: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  defineType("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: assertNodeType("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: assertNodeType("Expression", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: assertOneOf(true, false),
        optional: true
      }
    } : {}, {
      typeArguments: {
        validate: assertNodeType("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: assertNodeType("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: true
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  defineType("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      consequent: {
        validate: assertNodeType("Expression")
      },
      alternate: {
        validate: assertNodeType("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  defineType("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: assertNodeType("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("DebuggerStatement", {
    aliases: ["Statement"]
  });
  defineType("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  defineType("EmptyStatement", {
    aliases: ["Statement"]
  });
  defineType("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  defineType("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: assertNodeType("Program")
      }
    }
  });
  defineType("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("VariableDeclaration", "LVal") : assertNodeType("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
      },
      right: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: assertNodeType("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      update: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  var functionCommon = {
    params: {
      validate: chain(assertValueType("array"), assertEach(assertNodeType("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    generator: {
      "default": false
    },
    async: {
      "default": false
    }
  };
  var functionTypeAnnotationCommon = {
    returnType: {
      validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  };
  var functionDeclarationCommon = Object.assign({}, functionCommon, {
    declare: {
      validate: assertValueType("boolean"),
      optional: true
    },
    id: {
      validate: assertNodeType("Identifier"),
      optional: true
    }
  });
  defineType("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, functionDeclarationCommon, {}, functionTypeAnnotationCommon, {
      body: {
        validate: assertNodeType("BlockStatement")
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function () {
      if (!process.env.BABEL_TYPES_8_BREAKING) return function () {};
      var identifier = assertNodeType("Identifier");
      return function (parent, key, node) {
        if (!is("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon, {}, functionTypeAnnotationCommon, {
      id: {
        validate: assertNodeType("Identifier"),
        optional: true
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    })
  });
  var patternLikeCommon = {
    typeAnnotation: {
      validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator")))
    }
  };
  defineType("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon, {
      name: {
        validate: chain(assertValueType("string"), function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (!isValidIdentifier(val, false)) {
            throw new TypeError("\"" + val + "\" is not a valid identifier name");
          }
        })
      },
      optional: {
        validate: assertValueType("boolean"),
        optional: true
      }
    }),
    validate: function validate(parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      var match = /\.(\w+)$/.exec(key);
      if (!match) return;
      var parentKey = match[1];
      var nonComp = {
        computed: false
      };

      if (parentKey === "property") {
        if (is("MemberExpression", parent, nonComp)) return;
        if (is("OptionalMemberExpression", parent, nonComp)) return;
      } else if (parentKey === "key") {
        if (is("Property", parent, nonComp)) return;
        if (is("Method", parent, nonComp)) return;
      } else if (parentKey === "exported") {
        if (is("ExportSpecifier", parent)) return;
      } else if (parentKey === "imported") {
        if (is("ImportSpecifier", parent, {
          imported: node
        })) return;
      } else if (parentKey === "meta") {
        if (is("MetaProperty", parent, {
          meta: node
        })) return;
      }

      if ((isKeyword(node.name) || isReservedWord(node.name)) && node.name !== "this") {
        throw new TypeError("\"" + node.name + "\" is not a valid identifier");
      }
    }
  });
  defineType("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      consequent: {
        validate: assertNodeType("Statement")
      },
      alternate: {
        optional: true,
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: assertNodeType("Identifier")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: assertValueType("number")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: assertValueType("string")
      },
      flags: {
        validate: chain(assertValueType("string"), function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          var invalid = /[^gimsuy]/.exec(val);

          if (invalid) {
            throw new TypeError("\"" + invalid[0] + "\" is not a valid RegExp flag");
          }
        }),
        "default": ""
      }
    }
  });
  defineType("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: assertOneOf.apply(void 0, LOGICAL_OPERATORS)
      },
      left: {
        validate: assertNodeType("Expression")
      },
      right: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("MemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: assertNodeType("Expression")
      },
      property: {
        validate: function () {
          var normal = assertNodeType("Identifier", "PrivateName");
          var computed = assertNodeType("Expression");
          return function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }()
      },
      computed: {
        "default": false
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: assertOneOf(true, false),
        optional: true
      }
    } : {})
  });
  defineType("NewExpression", {
    inherits: "CallExpression"
  });
  defineType("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceFile: {
        validate: assertValueType("string")
      },
      sourceType: {
        validate: assertOneOf("script", "module"),
        "default": "script"
      },
      interpreter: {
        validate: assertNodeType("InterpreterDirective"),
        "default": null,
        optional: true
      },
      directives: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Directive"))),
        "default": []
      },
      body: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  defineType("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("ObjectMethod", "ObjectProperty", "SpreadElement")))
      }
    }
  });
  defineType("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, functionCommon, {}, functionTypeAnnotationCommon, {
      kind: Object.assign({
        validate: assertOneOf("method", "get", "set")
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        "default": "method"
      } : {}),
      computed: {
        "default": false
      },
      key: {
        validate: function () {
          var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
          var computed = assertNodeType("Expression");
          return function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }()
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  defineType("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand"].concat(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []),
    fields: {
      computed: {
        "default": false
      },
      key: {
        validate: function () {
          var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
          var computed = assertNodeType("Expression");
          return function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }()
      },
      value: {
        validate: assertNodeType("Expression", "PatternLike")
      },
      shorthand: {
        validate: chain(assertValueType("boolean"), function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (val && node.computed) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
          }
        }, function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (val && !is("Identifier", node.key)) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }),
        "default": false
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function () {
      var pattern = assertNodeType("Identifier", "Pattern");
      var expression = assertNodeType("Expression");
      return function (parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        var validator = is("ObjectPattern", parent) ? pattern : expression;
        validator(node, "value", node.value);
      };
    }()
  });
  defineType("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon, {
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal") : assertNodeType("Identifier", "Pattern", "MemberExpression")
      }
    }),
    validate: function validate(parent, key) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      var match = /(\w+)\[(\d+)\]/.exec(key);
      if (!match) throw new Error("Internal Babel error: malformed key.");
      var listKey = match[1],
          index = match[2];

      if (parent[listKey].length > index + 1) {
        throw new TypeError("RestElement must be last element of " + listKey);
      }
    }
  });
  defineType("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: assertNodeType("Expression"),
        optional: true
      }
    }
  });
  defineType("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  defineType("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      consequent: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
      }
    }
  });
  defineType("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: assertNodeType("Expression")
      },
      cases: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("SwitchCase")))
      }
    }
  });
  defineType("ThisExpression", {
    aliases: ["Expression"]
  });
  defineType("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: chain(assertNodeType("BlockStatement"), function (node) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (!node.handler && !node.finalizer) {
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
          }
        })
      },
      handler: {
        optional: true,
        validate: assertNodeType("CatchClause")
      },
      finalizer: {
        optional: true,
        validate: assertNodeType("BlockStatement")
      }
    }
  });
  defineType("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        "default": true
      },
      argument: {
        validate: assertNodeType("Expression")
      },
      operator: {
        validate: assertOneOf.apply(void 0, UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  defineType("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        "default": false
      },
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("Expression") : assertNodeType("Identifier", "MemberExpression")
      },
      operator: {
        validate: assertOneOf.apply(void 0, UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  defineType("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      },
      kind: {
        validate: assertOneOf("var", "let", "const")
      },
      declarations: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("VariableDeclarator")))
      }
    },
    validate: function validate(parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      if (!is("ForXStatement", parent, {
        left: node
      })) return;

      if (node.declarations.length !== 1) {
        throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a " + parent.type);
      }
    }
  });
  defineType("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return assertNodeType("LVal");
          }

          var normal = assertNodeType("Identifier", "ArrayPattern", "ObjectPattern");
          var without = assertNodeType("Identifier");
          return function (node, key, val) {
            var validator = node.init ? normal : without;
            validator(node, key, val);
          };
        }()
      },
      definite: {
        optional: true,
        validate: assertValueType("boolean")
      },
      init: {
        optional: true,
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });

  defineType("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon, {
      left: {
        validate: assertNodeType("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
      },
      right: {
        validate: assertNodeType("Expression")
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    })
  });
  defineType("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon, {
      elements: {
        validate: chain(assertValueType("array"), assertEach(assertNodeOrValueType("null", "PatternLike")))
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    })
  });
  defineType("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon, {}, functionTypeAnnotationCommon, {
      expression: {
        validate: assertValueType("boolean")
      },
      body: {
        validate: assertNodeType("BlockStatement", "Expression")
      }
    })
  });
  defineType("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
      }
    }
  });
  defineType("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: assertNodeType("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: assertNodeType("ClassBody")
      },
      superClass: {
        optional: true,
        validate: assertNodeType("Expression")
      },
      superTypeParameters: {
        validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      "implements": {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    }
  });
  defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      },
      "abstract": {
        validate: assertValueType("boolean"),
        optional: true
      }
    },
    validate: function () {
      var identifier = assertNodeType("Identifier");
      return function (parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (!is("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  defineType("ExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: assertNodeType("StringLiteral")
      }
    }
  });
  defineType("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: assertNodeType("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
      }
    }
  });
  defineType("ExportNamedDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: true,
        validate: chain(assertNodeType("Declaration"), function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (val && node.specifiers.length) {
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          }
        }, function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (val && node.source) {
            throw new TypeError("Cannot export a declaration from a source");
          }
        })
      },
      specifiers: {
        "default": [],
        validate: chain(assertValueType("array"), assertEach(function () {
          var sourced = assertNodeType("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
          var sourceless = assertNodeType("ExportSpecifier");
          if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
          return function (node, key, val) {
            var validator = node.source ? sourced : sourceless;
            validator(node, key, val);
          };
        }()))
      },
      source: {
        validate: assertNodeType("StringLiteral"),
        optional: true
      },
      exportKind: validateOptional(assertOneOf("type", "value"))
    }
  });
  defineType("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      },
      exported: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return assertNodeType("VariableDeclaration", "LVal");
          }

          var declaration = assertNodeType("VariableDeclaration");
          var lval = assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
          return function (node, key, val) {
            if (is("VariableDeclaration", val)) {
              declaration(node, key, val);
            } else {
              lval(node, key, val);
            }
          };
        }()
      },
      right: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      },
      "await": {
        "default": false
      }
    }
  });
  defineType("ImportDeclaration", {
    visitor: ["specifiers", "source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration"],
    fields: {
      specifiers: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: assertNodeType("StringLiteral")
      },
      importKind: {
        validate: assertOneOf("type", "typeof", "value"),
        optional: true
      }
    }
  });
  defineType("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      },
      imported: {
        validate: assertNodeType("Identifier")
      },
      importKind: {
        validate: assertOneOf("type", "typeof"),
        optional: true
      }
    }
  });
  defineType("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: chain(assertNodeType("Identifier"), function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          var property;

          switch (val.name) {
            case "function":
              property = "sent";
              break;

            case "new":
              property = "target";
              break;

            case "import":
              property = "meta";
              break;
          }

          if (!is("Identifier", node.property, {
            name: property
          })) {
            throw new TypeError("Unrecognised MetaProperty");
          }
        })
      },
      property: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  var classMethodOrPropertyCommon = {
    "abstract": {
      validate: assertValueType("boolean"),
      optional: true
    },
    accessibility: {
      validate: assertOneOf("public", "private", "protected"),
      optional: true
    },
    "static": {
      "default": false
    },
    computed: {
      "default": false
    },
    optional: {
      validate: assertValueType("boolean"),
      optional: true
    },
    key: {
      validate: chain(function () {
        var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
        var computed = assertNodeType("Expression");
        return function (node, key, val) {
          var validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }(), assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
    }
  };
  var classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, {}, classMethodOrPropertyCommon, {
    kind: {
      validate: assertOneOf("get", "set", "method", "constructor"),
      "default": "method"
    },
    access: {
      validate: chain(assertValueType("string"), assertOneOf("public", "private", "protected")),
      optional: true
    },
    decorators: {
      validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
      optional: true
    }
  });
  defineType("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, {}, functionTypeAnnotationCommon, {
      body: {
        validate: assertNodeType("BlockStatement")
      }
    })
  });
  defineType("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon, {
      properties: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("RestElement", "ObjectProperty")))
      }
    })
  });
  defineType("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("Super", {
    aliases: ["Expression"]
  });
  defineType("TaggedTemplateExpression", {
    visitor: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: assertNodeType("Expression")
      },
      quasi: {
        validate: assertNodeType("TemplateLiteral")
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: assertShape({
          raw: {
            validate: assertValueType("string")
          },
          cooked: {
            validate: assertValueType("string"),
            optional: true
          }
        })
      },
      tail: {
        "default": false
      }
    }
  });
  defineType("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("TemplateElement")))
      },
      expressions: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression")), function (node, key, val) {
          if (node.quasis.length !== val.length + 1) {
            throw new TypeError("Number of " + node.type + " quasis should be exactly one more than the number of expressions.\nExpected " + (val.length + 1) + " quasis but got " + node.quasis.length);
          }
        })
      }
    }
  });
  defineType("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: chain(assertValueType("boolean"), function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (val && !node.argument) {
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
          }
        }),
        "default": false
      },
      argument: {
        optional: true,
        validate: assertNodeType("Expression")
      }
    }
  });

  var defineInterfaceishType = function defineInterfaceishType(name, typeParameterType) {
    if (typeParameterType === void 0) {
      typeParameterType = "TypeParameterDeclaration";
    }

    defineType(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType(typeParameterType),
        "extends": validateOptional(arrayOfType("InterfaceExtends")),
        mixins: validateOptional(arrayOfType("InterfaceExtends")),
        "implements": validateOptional(arrayOfType("ClassImplements")),
        body: validateType("ObjectTypeAnnotation")
      }
    });
  };

  defineType("AnyTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["Flow", "FlowType"],
    fields: {
      elementType: validateType("FlowType")
    }
  });
  defineType("BooleanTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["Flow", "FlowType"],
    fields: {
      value: validate$1(assertValueType("boolean"))
    }
  });
  defineType("NullLiteralTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("ClassImplements", {
    visitor: ["id", "typeParameters"],
    aliases: ["Flow"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("DeclareClass");
  defineType("DeclareFunction", {
    visitor: ["id"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      predicate: validateOptionalType("DeclaredPredicate")
    }
  });
  defineInterfaceishType("DeclareInterface");
  defineType("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType(["Identifier", "StringLiteral"]),
      body: validateType("BlockStatement"),
      kind: validateOptional(assertOneOf("CommonJS", "ES"))
    }
  });
  defineType("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: validateType("TypeAnnotation")
    }
  });
  defineType("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      right: validateType("FlowType")
    }
  });
  defineType("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      supertype: validateOptionalType("FlowType")
    }
  });
  defineType("DeclareVariable", {
    visitor: ["id"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier")
    }
  });
  defineType("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: validateOptionalType("Flow"),
      specifiers: validateOptional(arrayOfType(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: validateOptionalType("StringLiteral"),
      "default": validateOptional(assertValueType("boolean"))
    }
  });
  defineType("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: validateType("StringLiteral"),
      exportKind: validateOptional(assertOneOf("type", "value"))
    }
  });
  defineType("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["Flow", "FlowPredicate"],
    fields: {
      value: validateType("Flow")
    }
  });
  defineType("ExistsTypeAnnotation", {
    aliases: ["Flow", "FlowType"]
  });
  defineType("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["Flow", "FlowType"],
    fields: {
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      params: validate$1(arrayOfType("FunctionTypeParam")),
      rest: validateOptionalType("FunctionTypeParam"),
      returnType: validateType("FlowType")
    }
  });
  defineType("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    aliases: ["Flow"],
    fields: {
      name: validateOptionalType("Identifier"),
      typeAnnotation: validateType("FlowType"),
      optional: validateOptional(assertValueType("boolean"))
    }
  });
  defineType("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["Flow", "FlowType"],
    fields: {
      id: validateType(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: validateOptionalType("TypeParameterInstantiation")
    }
  });
  defineType("InferredPredicate", {
    aliases: ["Flow", "FlowPredicate"]
  });
  defineType("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    aliases: ["Flow"],
    fields: {
      id: validateType(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: validateOptionalType("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("InterfaceDeclaration");
  defineType("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["Flow", "FlowType"],
    fields: {
      "extends": validateOptional(arrayOfType("InterfaceExtends")),
      body: validateType("ObjectTypeAnnotation")
    }
  });
  defineType("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow", "FlowType"],
    fields: {
      types: validate$1(arrayOfType("FlowType"))
    }
  });
  defineType("MixedTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("EmptyTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["Flow", "FlowType"],
    fields: {
      typeAnnotation: validateType("FlowType")
    }
  });
  defineType("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["Flow", "FlowType"],
    fields: {
      value: validate$1(assertValueType("number"))
    }
  });
  defineType("NumberTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["Flow", "FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: validate$1(arrayOfType(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: validateOptional(arrayOfType("ObjectTypeIndexer")),
      callProperties: validateOptional(arrayOfType("ObjectTypeCallProperty")),
      internalSlots: validateOptional(arrayOfType("ObjectTypeInternalSlot")),
      exact: {
        validate: assertValueType("boolean"),
        "default": false
      },
      inexact: validateOptional(assertValueType("boolean"))
    }
  });
  defineType("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      id: validateType("Identifier"),
      value: validateType("FlowType"),
      optional: validate$1(assertValueType("boolean")),
      "static": validate$1(assertValueType("boolean")),
      method: validate$1(assertValueType("boolean"))
    }
  });
  defineType("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      value: validateType("FlowType"),
      "static": validate$1(assertValueType("boolean"))
    }
  });
  defineType("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      id: validateOptionalType("Identifier"),
      key: validateType("FlowType"),
      value: validateType("FlowType"),
      "static": validate$1(assertValueType("boolean")),
      variance: validateOptionalType("Variance")
    }
  });
  defineType("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      key: validateType(["Identifier", "StringLiteral"]),
      value: validateType("FlowType"),
      kind: validate$1(assertOneOf("init", "get", "set")),
      "static": validate$1(assertValueType("boolean")),
      proto: validate$1(assertValueType("boolean")),
      optional: validate$1(assertValueType("boolean")),
      variance: validateOptionalType("Variance")
    }
  });
  defineType("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      argument: validateType("FlowType")
    }
  });
  defineType("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      supertype: validateOptionalType("FlowType"),
      impltype: validateType("FlowType")
    }
  });
  defineType("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    aliases: ["Flow"],
    fields: {
      id: validateType("Identifier"),
      qualification: validateType(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  defineType("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["Flow", "FlowType"],
    fields: {
      value: validate$1(assertValueType("string"))
    }
  });
  defineType("StringTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("SymbolTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("ThisTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow", "FlowType"],
    fields: {
      types: validate$1(arrayOfType("FlowType"))
    }
  });
  defineType("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["Flow", "FlowType"],
    fields: {
      argument: validateType("FlowType")
    }
  });
  defineType("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      right: validateType("FlowType")
    }
  });
  defineType("TypeAnnotation", {
    aliases: ["Flow"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("FlowType")
    }
  });
  defineType("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["Flow", "ExpressionWrapper", "Expression"],
    fields: {
      expression: validateType("Expression"),
      typeAnnotation: validateType("TypeAnnotation")
    }
  });
  defineType("TypeParameter", {
    aliases: ["Flow"],
    visitor: ["bound", "default", "variance"],
    fields: {
      name: validate$1(assertValueType("string")),
      bound: validateOptionalType("TypeAnnotation"),
      "default": validateOptionalType("FlowType"),
      variance: validateOptionalType("Variance")
    }
  });
  defineType("TypeParameterDeclaration", {
    aliases: ["Flow"],
    visitor: ["params"],
    fields: {
      params: validate$1(arrayOfType("TypeParameter"))
    }
  });
  defineType("TypeParameterInstantiation", {
    aliases: ["Flow"],
    visitor: ["params"],
    fields: {
      params: validate$1(arrayOfType("FlowType"))
    }
  });
  defineType("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow", "FlowType"],
    fields: {
      types: validate$1(arrayOfType("FlowType"))
    }
  });
  defineType("Variance", {
    aliases: ["Flow"],
    builder: ["kind"],
    fields: {
      kind: validate$1(assertOneOf("minus", "plus"))
    }
  });
  defineType("VoidTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: validateType("Identifier"),
      body: validateType(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  defineType("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicit: validate$1(assertValueType("boolean")),
      members: validateArrayOfType("EnumBooleanMember")
    }
  });
  defineType("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicit: validate$1(assertValueType("boolean")),
      members: validateArrayOfType("EnumNumberMember")
    }
  });
  defineType("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicit: validate$1(assertValueType("boolean")),
      members: validateArrayOfType(["EnumStringMember", "EnumDefaultedMember"])
    }
  });
  defineType("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: validateArrayOfType("EnumDefaultedMember")
    }
  });
  defineType("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: validateType("Identifier"),
      init: validateType("BooleanLiteral")
    }
  });
  defineType("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: validateType("Identifier"),
      init: validateType("NumericLiteral")
    }
  });
  defineType("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: validateType("Identifier"),
      init: validateType("StringLiteral")
    }
  });
  defineType("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: validateType("Identifier")
    }
  });

  defineType("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["JSX", "Immutable"],
    fields: {
      name: {
        validate: assertNodeType("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: true,
        validate: assertNodeType("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  defineType("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["JSX", "Immutable"],
    fields: {
      name: {
        validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  defineType("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["JSX", "Immutable", "Expression"],
    fields: {
      openingElement: {
        validate: assertNodeType("JSXOpeningElement")
      },
      closingElement: {
        optional: true,
        validate: assertNodeType("JSXClosingElement")
      },
      children: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  defineType("JSXEmptyExpression", {
    aliases: ["JSX"]
  });
  defineType("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["JSX", "Immutable"],
    fields: {
      expression: {
        validate: assertNodeType("Expression", "JSXEmptyExpression")
      }
    }
  });
  defineType("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["JSX", "Immutable"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("JSXIdentifier", {
    builder: ["name"],
    aliases: ["JSX"],
    fields: {
      name: {
        validate: assertValueType("string")
      }
    }
  });
  defineType("JSXMemberExpression", {
    visitor: ["object", "property"],
    aliases: ["JSX"],
    fields: {
      object: {
        validate: assertNodeType("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: assertNodeType("JSXIdentifier")
      }
    }
  });
  defineType("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    aliases: ["JSX"],
    fields: {
      namespace: {
        validate: assertNodeType("JSXIdentifier")
      },
      name: {
        validate: assertNodeType("JSXIdentifier")
      }
    }
  });
  defineType("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["JSX", "Immutable"],
    fields: {
      name: {
        validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        "default": false
      },
      attributes: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("JSXAttribute", "JSXSpreadAttribute")))
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("JSXSpreadAttribute", {
    visitor: ["argument"],
    aliases: ["JSX"],
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("JSXText", {
    aliases: ["JSX", "Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    }
  });
  defineType("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["JSX", "Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: assertNodeType("JSXOpeningFragment")
      },
      closingFragment: {
        validate: assertNodeType("JSXClosingFragment")
      },
      children: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  defineType("JSXOpeningFragment", {
    aliases: ["JSX", "Immutable"]
  });
  defineType("JSXClosingFragment", {
    aliases: ["JSX", "Immutable"]
  });

  var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  var PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };

  for (var _i = 0, _PLACEHOLDERS = PLACEHOLDERS; _i < _PLACEHOLDERS.length; _i++) {
    var type = _PLACEHOLDERS[_i];
    var alias = ALIAS_KEYS[type];
    if (alias && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
  }

  var PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(PLACEHOLDERS_ALIAS).forEach(function (type) {
    PLACEHOLDERS_ALIAS[type].forEach(function (alias) {
      if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }

      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });

  defineType("Noop", {
    visitor: []
  });
  defineType("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: assertNodeType("Identifier")
      },
      expectedNode: {
        validate: assertOneOf.apply(void 0, PLACEHOLDERS)
      }
    }
  });
  defineType("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: assertValueType("string")
      }
    }
  });

  defineType("ArgumentPlaceholder", {});
  defineType("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !process.env.BABEL_TYPES_8_BREAKING ? {} : {
      object: {
        validate: assertNodeType("Expression")
      },
      callee: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, classMethodOrPropertyCommon, {
      value: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      definite: {
        validate: assertValueType("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      },
      readonly: {
        validate: assertValueType("boolean"),
        optional: true
      },
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      }
    })
  });
  defineType("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: assertNodeType("Expression")
      },
      property: {
        validate: function () {
          var normal = assertNodeType("Identifier");
          var computed = assertNodeType("Expression");
          return function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }()
      },
      computed: {
        "default": false
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain(assertValueType("boolean"), assertOptionalChainStart())
      }
    }
  });
  defineType("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
  defineType("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: assertNodeType("Expression")
      },
      arguments: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName")))
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain(assertValueType("boolean"), assertOptionalChainStart())
      },
      typeArguments: {
        validate: assertNodeType("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators"],
    builder: ["key", "value", "decorators"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: assertNodeType("PrivateName")
      },
      value: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    }
  });
  defineType("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, {
      key: {
        validate: assertNodeType("PrivateName")
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    })
  });
  defineType("Import", {
    aliases: ["Expression"]
  });
  defineType("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("DoExpression", {
    visitor: ["body"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: assertNodeType("BlockStatement")
      }
    }
  });
  defineType("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("ObjectProperty", "ObjectMethod", "SpreadElement")))
      }
    }
  });
  defineType("TupleExpression", {
    fields: {
      elements: {
        validate: chain(assertValueType("array"), assertEach(assertNodeOrValueType("null", "Expression", "SpreadElement"))),
        "default": []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });

  var bool = assertValueType("boolean");
  var tSFunctionTypeAnnotationCommon = {
    returnType: {
      validate: assertNodeType("TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: assertNodeType("TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  };
  defineType("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: assertOneOf("public", "private", "protected"),
        optional: true
      },
      readonly: {
        validate: assertValueType("boolean"),
        optional: true
      },
      parameter: {
        validate: assertNodeType("Identifier", "AssignmentPattern")
      }
    }
  });
  defineType("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, functionDeclarationCommon, {}, tSFunctionTypeAnnotationCommon)
  });
  defineType("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, {}, tSFunctionTypeAnnotationCommon)
  });
  defineType("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: validateType("TSEntityName"),
      right: validateType("Identifier")
    }
  });
  var signatureDeclarationCommon = {
    typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
    parameters: validateArrayOfType(["Identifier", "RestElement"]),
    typeAnnotation: validateOptionalType("TSTypeAnnotation")
  };
  var callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon
  };
  defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
  var namedTypeElementCommon = {
    key: validateType("Expression"),
    computed: validate$1(bool),
    optional: validateOptional(bool)
  };
  defineType("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation", "initializer"],
    fields: Object.assign({}, namedTypeElementCommon, {
      readonly: validateOptional(bool),
      typeAnnotation: validateOptionalType("TSTypeAnnotation"),
      initializer: validateOptionalType("Expression")
    })
  });
  defineType("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, signatureDeclarationCommon, {}, namedTypeElementCommon)
  });
  defineType("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: validateOptional(bool),
      parameters: validateArrayOfType("Identifier"),
      typeAnnotation: validateOptionalType("TSTypeAnnotation")
    }
  });
  var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];

  for (var _i$1 = 0, _tsKeywordTypes = tsKeywordTypes; _i$1 < _tsKeywordTypes.length; _i$1++) {
    var type$1 = _tsKeywordTypes[_i$1];
    defineType(type$1, {
      aliases: ["TSType"],
      visitor: [],
      fields: {}
    });
  }

  defineType("TSThisType", {
    aliases: ["TSType"],
    visitor: [],
    fields: {}
  });
  var fnOrCtr = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon
  };
  defineType("TSFunctionType", fnOrCtr);
  defineType("TSConstructorType", fnOrCtr);
  defineType("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: validateType("TSEntityName"),
      typeParameters: validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: validateType(["Identifier", "TSThisType"]),
      typeAnnotation: validateOptionalType("TSTypeAnnotation"),
      asserts: validateOptional(bool)
    }
  });
  defineType("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName"],
    fields: {
      exprName: validateType(["TSEntityName", "TSImportType"])
    }
  });
  defineType("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: validateArrayOfType("TSTypeElement")
    }
  });
  defineType("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: validateType("TSType")
    }
  });
  defineType("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: validateArrayOfType("TSType")
    }
  });
  defineType("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("TSType")
    }
  });
  var unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: validateArrayOfType("TSType")
    }
  };
  defineType("TSUnionType", unionOrIntersection);
  defineType("TSIntersectionType", unionOrIntersection);
  defineType("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: validateType("TSType"),
      extendsType: validateType("TSType"),
      trueType: validateType("TSType"),
      falseType: validateType("TSType")
    }
  });
  defineType("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: validateType("TSTypeParameter")
    }
  });
  defineType("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: validate$1(assertValueType("string")),
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: validateType("TSType"),
      indexType: validateType("TSType")
    }
  });
  defineType("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation"],
    fields: {
      readonly: validateOptional(bool),
      typeParameter: validateType("TSTypeParameter"),
      optional: validateOptional(bool),
      typeAnnotation: validateOptionalType("TSType")
    }
  });
  defineType("TSLiteralType", {
    aliases: ["TSType"],
    visitor: ["literal"],
    fields: {
      literal: validateType(["NumericLiteral", "StringLiteral", "BooleanLiteral"])
    }
  });
  defineType("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: validateType("TSEntityName"),
      typeParameters: validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  defineType("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: validateOptional(bool),
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
      "extends": validateOptional(arrayOfType("TSExpressionWithTypeArguments")),
      body: validateType("TSInterfaceBody")
    }
  });
  defineType("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: validateArrayOfType("TSTypeElement")
    }
  });
  defineType("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: validateOptional(bool),
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSAsExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: validateType("Expression"),
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSTypeAssertion", {
    aliases: ["Expression"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: validateType("TSType"),
      expression: validateType("Expression")
    }
  });
  defineType("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: validateOptional(bool),
      "const": validateOptional(bool),
      id: validateType("Identifier"),
      members: validateArrayOfType("TSEnumMember"),
      initializer: validateOptionalType("Expression")
    }
  });
  defineType("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: validateType(["Identifier", "StringLiteral"]),
      initializer: validateOptionalType("Expression")
    }
  });
  defineType("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: validateOptional(bool),
      global: validateOptional(bool),
      id: validateType(["Identifier", "StringLiteral"]),
      body: validateType(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  defineType("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent"],
    visitor: ["body"],
    fields: {
      body: validateArrayOfType("Statement")
    }
  });
  defineType("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: validateType("StringLiteral"),
      qualifier: validateOptionalType("TSEntityName"),
      typeParameters: validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  defineType("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: validate$1(bool),
      id: validateType("Identifier"),
      moduleReference: validateType(["TSEntityName", "TSExternalModuleReference"])
    }
  });
  defineType("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: validateType("StringLiteral")
    }
  });
  defineType("TSNonNullExpression", {
    aliases: ["Expression"],
    visitor: ["expression"],
    fields: {
      expression: validateType("Expression")
    }
  });
  defineType("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: validateType("Expression")
    }
  });
  defineType("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: validateType("Identifier")
    }
  });
  defineType("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: assertNodeType("TSType")
      }
    }
  });
  defineType("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("TSType")))
      }
    }
  });
  defineType("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("TSTypeParameter")))
      }
    }
  });
  defineType("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: assertValueType("string")
      },
      constraint: {
        validate: assertNodeType("TSType"),
        optional: true
      },
      "default": {
        validate: assertNodeType("TSType"),
        optional: true
      }
    }
  });

  toFastProperties(VISITOR_KEYS);
  toFastProperties(ALIAS_KEYS);
  toFastProperties(FLIPPED_ALIAS_KEYS);
  toFastProperties(NODE_FIELDS);
  toFastProperties(BUILDER_KEYS);
  toFastProperties(DEPRECATED_KEYS);
  toFastProperties(PLACEHOLDERS_ALIAS);
  toFastProperties(PLACEHOLDERS_FLIPPED_ALIAS);
  var TYPES = Object.keys(VISITOR_KEYS).concat(Object.keys(FLIPPED_ALIAS_KEYS)).concat(Object.keys(DEPRECATED_KEYS));

  function builder(type) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var keys = BUILDER_KEYS[type];
    var countArgs = args.length;

    if (countArgs > keys.length) {
      throw new Error(type + ": Too many arguments passed. Received " + countArgs + " but can receive no more than " + keys.length);
    }

    var node = {
      type: type
    };
    var i = 0;
    keys.forEach(function (key) {
      var field = NODE_FIELDS[type][key];
      var arg;
      if (i < countArgs) arg = args[i];
      if (arg === undefined) arg = clone_1(field["default"]);
      node[key] = arg;
      i++;
    });

    for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      validate(node, key, node[key]);
    }

    return node;
  }

  function ArrayExpression() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return builder.apply(void 0, ["ArrayExpression"].concat(args));
  }
  function AssignmentExpression() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return builder.apply(void 0, ["AssignmentExpression"].concat(args));
  }
  function BinaryExpression() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return builder.apply(void 0, ["BinaryExpression"].concat(args));
  }
  function InterpreterDirective() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return builder.apply(void 0, ["InterpreterDirective"].concat(args));
  }
  function Directive() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    return builder.apply(void 0, ["Directive"].concat(args));
  }
  function DirectiveLiteral() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return builder.apply(void 0, ["DirectiveLiteral"].concat(args));
  }
  function BlockStatement() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    return builder.apply(void 0, ["BlockStatement"].concat(args));
  }
  function BreakStatement() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }

    return builder.apply(void 0, ["BreakStatement"].concat(args));
  }
  function CallExpression() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }

    return builder.apply(void 0, ["CallExpression"].concat(args));
  }
  function CatchClause() {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }

    return builder.apply(void 0, ["CatchClause"].concat(args));
  }
  function ConditionalExpression() {
    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      args[_key11] = arguments[_key11];
    }

    return builder.apply(void 0, ["ConditionalExpression"].concat(args));
  }
  function ContinueStatement() {
    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }

    return builder.apply(void 0, ["ContinueStatement"].concat(args));
  }
  function DebuggerStatement() {
    for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      args[_key13] = arguments[_key13];
    }

    return builder.apply(void 0, ["DebuggerStatement"].concat(args));
  }
  function DoWhileStatement() {
    for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
      args[_key14] = arguments[_key14];
    }

    return builder.apply(void 0, ["DoWhileStatement"].concat(args));
  }
  function EmptyStatement() {
    for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
      args[_key15] = arguments[_key15];
    }

    return builder.apply(void 0, ["EmptyStatement"].concat(args));
  }
  function ExpressionStatement() {
    for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
      args[_key16] = arguments[_key16];
    }

    return builder.apply(void 0, ["ExpressionStatement"].concat(args));
  }
  function File() {
    for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
      args[_key17] = arguments[_key17];
    }

    return builder.apply(void 0, ["File"].concat(args));
  }
  function ForInStatement() {
    for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
      args[_key18] = arguments[_key18];
    }

    return builder.apply(void 0, ["ForInStatement"].concat(args));
  }
  function ForStatement() {
    for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
      args[_key19] = arguments[_key19];
    }

    return builder.apply(void 0, ["ForStatement"].concat(args));
  }
  function FunctionDeclaration() {
    for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
      args[_key20] = arguments[_key20];
    }

    return builder.apply(void 0, ["FunctionDeclaration"].concat(args));
  }
  function FunctionExpression() {
    for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
      args[_key21] = arguments[_key21];
    }

    return builder.apply(void 0, ["FunctionExpression"].concat(args));
  }
  function Identifier() {
    for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
      args[_key22] = arguments[_key22];
    }

    return builder.apply(void 0, ["Identifier"].concat(args));
  }
  function IfStatement() {
    for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
      args[_key23] = arguments[_key23];
    }

    return builder.apply(void 0, ["IfStatement"].concat(args));
  }
  function LabeledStatement() {
    for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
      args[_key24] = arguments[_key24];
    }

    return builder.apply(void 0, ["LabeledStatement"].concat(args));
  }
  function StringLiteral() {
    for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {
      args[_key25] = arguments[_key25];
    }

    return builder.apply(void 0, ["StringLiteral"].concat(args));
  }
  function NumericLiteral() {
    for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {
      args[_key26] = arguments[_key26];
    }

    return builder.apply(void 0, ["NumericLiteral"].concat(args));
  }
  function NullLiteral() {
    for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {
      args[_key27] = arguments[_key27];
    }

    return builder.apply(void 0, ["NullLiteral"].concat(args));
  }
  function BooleanLiteral() {
    for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {
      args[_key28] = arguments[_key28];
    }

    return builder.apply(void 0, ["BooleanLiteral"].concat(args));
  }
  function RegExpLiteral() {
    for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {
      args[_key29] = arguments[_key29];
    }

    return builder.apply(void 0, ["RegExpLiteral"].concat(args));
  }
  function LogicalExpression() {
    for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {
      args[_key30] = arguments[_key30];
    }

    return builder.apply(void 0, ["LogicalExpression"].concat(args));
  }
  function MemberExpression() {
    for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {
      args[_key31] = arguments[_key31];
    }

    return builder.apply(void 0, ["MemberExpression"].concat(args));
  }
  function NewExpression() {
    for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {
      args[_key32] = arguments[_key32];
    }

    return builder.apply(void 0, ["NewExpression"].concat(args));
  }
  function Program() {
    for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {
      args[_key33] = arguments[_key33];
    }

    return builder.apply(void 0, ["Program"].concat(args));
  }
  function ObjectExpression() {
    for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {
      args[_key34] = arguments[_key34];
    }

    return builder.apply(void 0, ["ObjectExpression"].concat(args));
  }
  function ObjectMethod() {
    for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {
      args[_key35] = arguments[_key35];
    }

    return builder.apply(void 0, ["ObjectMethod"].concat(args));
  }
  function ObjectProperty() {
    for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {
      args[_key36] = arguments[_key36];
    }

    return builder.apply(void 0, ["ObjectProperty"].concat(args));
  }
  function RestElement() {
    for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {
      args[_key37] = arguments[_key37];
    }

    return builder.apply(void 0, ["RestElement"].concat(args));
  }
  function ReturnStatement() {
    for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {
      args[_key38] = arguments[_key38];
    }

    return builder.apply(void 0, ["ReturnStatement"].concat(args));
  }
  function SequenceExpression() {
    for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {
      args[_key39] = arguments[_key39];
    }

    return builder.apply(void 0, ["SequenceExpression"].concat(args));
  }
  function ParenthesizedExpression() {
    for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {
      args[_key40] = arguments[_key40];
    }

    return builder.apply(void 0, ["ParenthesizedExpression"].concat(args));
  }
  function SwitchCase() {
    for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {
      args[_key41] = arguments[_key41];
    }

    return builder.apply(void 0, ["SwitchCase"].concat(args));
  }
  function SwitchStatement() {
    for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {
      args[_key42] = arguments[_key42];
    }

    return builder.apply(void 0, ["SwitchStatement"].concat(args));
  }
  function ThisExpression() {
    for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {
      args[_key43] = arguments[_key43];
    }

    return builder.apply(void 0, ["ThisExpression"].concat(args));
  }
  function ThrowStatement() {
    for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {
      args[_key44] = arguments[_key44];
    }

    return builder.apply(void 0, ["ThrowStatement"].concat(args));
  }
  function TryStatement() {
    for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {
      args[_key45] = arguments[_key45];
    }

    return builder.apply(void 0, ["TryStatement"].concat(args));
  }
  function UnaryExpression() {
    for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {
      args[_key46] = arguments[_key46];
    }

    return builder.apply(void 0, ["UnaryExpression"].concat(args));
  }
  function UpdateExpression() {
    for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {
      args[_key47] = arguments[_key47];
    }

    return builder.apply(void 0, ["UpdateExpression"].concat(args));
  }
  function VariableDeclaration() {
    for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {
      args[_key48] = arguments[_key48];
    }

    return builder.apply(void 0, ["VariableDeclaration"].concat(args));
  }
  function VariableDeclarator() {
    for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {
      args[_key49] = arguments[_key49];
    }

    return builder.apply(void 0, ["VariableDeclarator"].concat(args));
  }
  function WhileStatement() {
    for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {
      args[_key50] = arguments[_key50];
    }

    return builder.apply(void 0, ["WhileStatement"].concat(args));
  }
  function WithStatement() {
    for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {
      args[_key51] = arguments[_key51];
    }

    return builder.apply(void 0, ["WithStatement"].concat(args));
  }
  function AssignmentPattern() {
    for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {
      args[_key52] = arguments[_key52];
    }

    return builder.apply(void 0, ["AssignmentPattern"].concat(args));
  }
  function ArrayPattern() {
    for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {
      args[_key53] = arguments[_key53];
    }

    return builder.apply(void 0, ["ArrayPattern"].concat(args));
  }
  function ArrowFunctionExpression() {
    for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {
      args[_key54] = arguments[_key54];
    }

    return builder.apply(void 0, ["ArrowFunctionExpression"].concat(args));
  }
  function ClassBody() {
    for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {
      args[_key55] = arguments[_key55];
    }

    return builder.apply(void 0, ["ClassBody"].concat(args));
  }
  function ClassExpression() {
    for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {
      args[_key56] = arguments[_key56];
    }

    return builder.apply(void 0, ["ClassExpression"].concat(args));
  }
  function ClassDeclaration() {
    for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {
      args[_key57] = arguments[_key57];
    }

    return builder.apply(void 0, ["ClassDeclaration"].concat(args));
  }
  function ExportAllDeclaration() {
    for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {
      args[_key58] = arguments[_key58];
    }

    return builder.apply(void 0, ["ExportAllDeclaration"].concat(args));
  }
  function ExportDefaultDeclaration() {
    for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {
      args[_key59] = arguments[_key59];
    }

    return builder.apply(void 0, ["ExportDefaultDeclaration"].concat(args));
  }
  function ExportNamedDeclaration() {
    for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {
      args[_key60] = arguments[_key60];
    }

    return builder.apply(void 0, ["ExportNamedDeclaration"].concat(args));
  }
  function ExportSpecifier() {
    for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {
      args[_key61] = arguments[_key61];
    }

    return builder.apply(void 0, ["ExportSpecifier"].concat(args));
  }
  function ForOfStatement() {
    for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {
      args[_key62] = arguments[_key62];
    }

    return builder.apply(void 0, ["ForOfStatement"].concat(args));
  }
  function ImportDeclaration() {
    for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {
      args[_key63] = arguments[_key63];
    }

    return builder.apply(void 0, ["ImportDeclaration"].concat(args));
  }
  function ImportDefaultSpecifier() {
    for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {
      args[_key64] = arguments[_key64];
    }

    return builder.apply(void 0, ["ImportDefaultSpecifier"].concat(args));
  }
  function ImportNamespaceSpecifier() {
    for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {
      args[_key65] = arguments[_key65];
    }

    return builder.apply(void 0, ["ImportNamespaceSpecifier"].concat(args));
  }
  function ImportSpecifier() {
    for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {
      args[_key66] = arguments[_key66];
    }

    return builder.apply(void 0, ["ImportSpecifier"].concat(args));
  }
  function MetaProperty() {
    for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {
      args[_key67] = arguments[_key67];
    }

    return builder.apply(void 0, ["MetaProperty"].concat(args));
  }
  function ClassMethod() {
    for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {
      args[_key68] = arguments[_key68];
    }

    return builder.apply(void 0, ["ClassMethod"].concat(args));
  }
  function ObjectPattern() {
    for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {
      args[_key69] = arguments[_key69];
    }

    return builder.apply(void 0, ["ObjectPattern"].concat(args));
  }
  function SpreadElement() {
    for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {
      args[_key70] = arguments[_key70];
    }

    return builder.apply(void 0, ["SpreadElement"].concat(args));
  }
  function Super() {
    for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {
      args[_key71] = arguments[_key71];
    }

    return builder.apply(void 0, ["Super"].concat(args));
  }
  function TaggedTemplateExpression() {
    for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {
      args[_key72] = arguments[_key72];
    }

    return builder.apply(void 0, ["TaggedTemplateExpression"].concat(args));
  }
  function TemplateElement() {
    for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {
      args[_key73] = arguments[_key73];
    }

    return builder.apply(void 0, ["TemplateElement"].concat(args));
  }
  function TemplateLiteral() {
    for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {
      args[_key74] = arguments[_key74];
    }

    return builder.apply(void 0, ["TemplateLiteral"].concat(args));
  }
  function YieldExpression() {
    for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {
      args[_key75] = arguments[_key75];
    }

    return builder.apply(void 0, ["YieldExpression"].concat(args));
  }
  function AnyTypeAnnotation() {
    for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {
      args[_key76] = arguments[_key76];
    }

    return builder.apply(void 0, ["AnyTypeAnnotation"].concat(args));
  }
  function ArrayTypeAnnotation() {
    for (var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++) {
      args[_key77] = arguments[_key77];
    }

    return builder.apply(void 0, ["ArrayTypeAnnotation"].concat(args));
  }
  function BooleanTypeAnnotation() {
    for (var _len78 = arguments.length, args = new Array(_len78), _key78 = 0; _key78 < _len78; _key78++) {
      args[_key78] = arguments[_key78];
    }

    return builder.apply(void 0, ["BooleanTypeAnnotation"].concat(args));
  }
  function BooleanLiteralTypeAnnotation() {
    for (var _len79 = arguments.length, args = new Array(_len79), _key79 = 0; _key79 < _len79; _key79++) {
      args[_key79] = arguments[_key79];
    }

    return builder.apply(void 0, ["BooleanLiteralTypeAnnotation"].concat(args));
  }
  function NullLiteralTypeAnnotation() {
    for (var _len80 = arguments.length, args = new Array(_len80), _key80 = 0; _key80 < _len80; _key80++) {
      args[_key80] = arguments[_key80];
    }

    return builder.apply(void 0, ["NullLiteralTypeAnnotation"].concat(args));
  }
  function ClassImplements() {
    for (var _len81 = arguments.length, args = new Array(_len81), _key81 = 0; _key81 < _len81; _key81++) {
      args[_key81] = arguments[_key81];
    }

    return builder.apply(void 0, ["ClassImplements"].concat(args));
  }
  function DeclareClass() {
    for (var _len82 = arguments.length, args = new Array(_len82), _key82 = 0; _key82 < _len82; _key82++) {
      args[_key82] = arguments[_key82];
    }

    return builder.apply(void 0, ["DeclareClass"].concat(args));
  }
  function DeclareFunction() {
    for (var _len83 = arguments.length, args = new Array(_len83), _key83 = 0; _key83 < _len83; _key83++) {
      args[_key83] = arguments[_key83];
    }

    return builder.apply(void 0, ["DeclareFunction"].concat(args));
  }
  function DeclareInterface() {
    for (var _len84 = arguments.length, args = new Array(_len84), _key84 = 0; _key84 < _len84; _key84++) {
      args[_key84] = arguments[_key84];
    }

    return builder.apply(void 0, ["DeclareInterface"].concat(args));
  }
  function DeclareModule() {
    for (var _len85 = arguments.length, args = new Array(_len85), _key85 = 0; _key85 < _len85; _key85++) {
      args[_key85] = arguments[_key85];
    }

    return builder.apply(void 0, ["DeclareModule"].concat(args));
  }
  function DeclareModuleExports() {
    for (var _len86 = arguments.length, args = new Array(_len86), _key86 = 0; _key86 < _len86; _key86++) {
      args[_key86] = arguments[_key86];
    }

    return builder.apply(void 0, ["DeclareModuleExports"].concat(args));
  }
  function DeclareTypeAlias() {
    for (var _len87 = arguments.length, args = new Array(_len87), _key87 = 0; _key87 < _len87; _key87++) {
      args[_key87] = arguments[_key87];
    }

    return builder.apply(void 0, ["DeclareTypeAlias"].concat(args));
  }
  function DeclareOpaqueType() {
    for (var _len88 = arguments.length, args = new Array(_len88), _key88 = 0; _key88 < _len88; _key88++) {
      args[_key88] = arguments[_key88];
    }

    return builder.apply(void 0, ["DeclareOpaqueType"].concat(args));
  }
  function DeclareVariable() {
    for (var _len89 = arguments.length, args = new Array(_len89), _key89 = 0; _key89 < _len89; _key89++) {
      args[_key89] = arguments[_key89];
    }

    return builder.apply(void 0, ["DeclareVariable"].concat(args));
  }
  function DeclareExportDeclaration() {
    for (var _len90 = arguments.length, args = new Array(_len90), _key90 = 0; _key90 < _len90; _key90++) {
      args[_key90] = arguments[_key90];
    }

    return builder.apply(void 0, ["DeclareExportDeclaration"].concat(args));
  }
  function DeclareExportAllDeclaration() {
    for (var _len91 = arguments.length, args = new Array(_len91), _key91 = 0; _key91 < _len91; _key91++) {
      args[_key91] = arguments[_key91];
    }

    return builder.apply(void 0, ["DeclareExportAllDeclaration"].concat(args));
  }
  function DeclaredPredicate() {
    for (var _len92 = arguments.length, args = new Array(_len92), _key92 = 0; _key92 < _len92; _key92++) {
      args[_key92] = arguments[_key92];
    }

    return builder.apply(void 0, ["DeclaredPredicate"].concat(args));
  }
  function ExistsTypeAnnotation() {
    for (var _len93 = arguments.length, args = new Array(_len93), _key93 = 0; _key93 < _len93; _key93++) {
      args[_key93] = arguments[_key93];
    }

    return builder.apply(void 0, ["ExistsTypeAnnotation"].concat(args));
  }
  function FunctionTypeAnnotation() {
    for (var _len94 = arguments.length, args = new Array(_len94), _key94 = 0; _key94 < _len94; _key94++) {
      args[_key94] = arguments[_key94];
    }

    return builder.apply(void 0, ["FunctionTypeAnnotation"].concat(args));
  }
  function FunctionTypeParam() {
    for (var _len95 = arguments.length, args = new Array(_len95), _key95 = 0; _key95 < _len95; _key95++) {
      args[_key95] = arguments[_key95];
    }

    return builder.apply(void 0, ["FunctionTypeParam"].concat(args));
  }
  function GenericTypeAnnotation() {
    for (var _len96 = arguments.length, args = new Array(_len96), _key96 = 0; _key96 < _len96; _key96++) {
      args[_key96] = arguments[_key96];
    }

    return builder.apply(void 0, ["GenericTypeAnnotation"].concat(args));
  }
  function InferredPredicate() {
    for (var _len97 = arguments.length, args = new Array(_len97), _key97 = 0; _key97 < _len97; _key97++) {
      args[_key97] = arguments[_key97];
    }

    return builder.apply(void 0, ["InferredPredicate"].concat(args));
  }
  function InterfaceExtends() {
    for (var _len98 = arguments.length, args = new Array(_len98), _key98 = 0; _key98 < _len98; _key98++) {
      args[_key98] = arguments[_key98];
    }

    return builder.apply(void 0, ["InterfaceExtends"].concat(args));
  }
  function InterfaceDeclaration() {
    for (var _len99 = arguments.length, args = new Array(_len99), _key99 = 0; _key99 < _len99; _key99++) {
      args[_key99] = arguments[_key99];
    }

    return builder.apply(void 0, ["InterfaceDeclaration"].concat(args));
  }
  function InterfaceTypeAnnotation() {
    for (var _len100 = arguments.length, args = new Array(_len100), _key100 = 0; _key100 < _len100; _key100++) {
      args[_key100] = arguments[_key100];
    }

    return builder.apply(void 0, ["InterfaceTypeAnnotation"].concat(args));
  }
  function IntersectionTypeAnnotation() {
    for (var _len101 = arguments.length, args = new Array(_len101), _key101 = 0; _key101 < _len101; _key101++) {
      args[_key101] = arguments[_key101];
    }

    return builder.apply(void 0, ["IntersectionTypeAnnotation"].concat(args));
  }
  function MixedTypeAnnotation() {
    for (var _len102 = arguments.length, args = new Array(_len102), _key102 = 0; _key102 < _len102; _key102++) {
      args[_key102] = arguments[_key102];
    }

    return builder.apply(void 0, ["MixedTypeAnnotation"].concat(args));
  }
  function EmptyTypeAnnotation() {
    for (var _len103 = arguments.length, args = new Array(_len103), _key103 = 0; _key103 < _len103; _key103++) {
      args[_key103] = arguments[_key103];
    }

    return builder.apply(void 0, ["EmptyTypeAnnotation"].concat(args));
  }
  function NullableTypeAnnotation() {
    for (var _len104 = arguments.length, args = new Array(_len104), _key104 = 0; _key104 < _len104; _key104++) {
      args[_key104] = arguments[_key104];
    }

    return builder.apply(void 0, ["NullableTypeAnnotation"].concat(args));
  }
  function NumberLiteralTypeAnnotation() {
    for (var _len105 = arguments.length, args = new Array(_len105), _key105 = 0; _key105 < _len105; _key105++) {
      args[_key105] = arguments[_key105];
    }

    return builder.apply(void 0, ["NumberLiteralTypeAnnotation"].concat(args));
  }
  function NumberTypeAnnotation() {
    for (var _len106 = arguments.length, args = new Array(_len106), _key106 = 0; _key106 < _len106; _key106++) {
      args[_key106] = arguments[_key106];
    }

    return builder.apply(void 0, ["NumberTypeAnnotation"].concat(args));
  }
  function ObjectTypeAnnotation() {
    for (var _len107 = arguments.length, args = new Array(_len107), _key107 = 0; _key107 < _len107; _key107++) {
      args[_key107] = arguments[_key107];
    }

    return builder.apply(void 0, ["ObjectTypeAnnotation"].concat(args));
  }
  function ObjectTypeInternalSlot() {
    for (var _len108 = arguments.length, args = new Array(_len108), _key108 = 0; _key108 < _len108; _key108++) {
      args[_key108] = arguments[_key108];
    }

    return builder.apply(void 0, ["ObjectTypeInternalSlot"].concat(args));
  }
  function ObjectTypeCallProperty() {
    for (var _len109 = arguments.length, args = new Array(_len109), _key109 = 0; _key109 < _len109; _key109++) {
      args[_key109] = arguments[_key109];
    }

    return builder.apply(void 0, ["ObjectTypeCallProperty"].concat(args));
  }
  function ObjectTypeIndexer() {
    for (var _len110 = arguments.length, args = new Array(_len110), _key110 = 0; _key110 < _len110; _key110++) {
      args[_key110] = arguments[_key110];
    }

    return builder.apply(void 0, ["ObjectTypeIndexer"].concat(args));
  }
  function ObjectTypeProperty() {
    for (var _len111 = arguments.length, args = new Array(_len111), _key111 = 0; _key111 < _len111; _key111++) {
      args[_key111] = arguments[_key111];
    }

    return builder.apply(void 0, ["ObjectTypeProperty"].concat(args));
  }
  function ObjectTypeSpreadProperty() {
    for (var _len112 = arguments.length, args = new Array(_len112), _key112 = 0; _key112 < _len112; _key112++) {
      args[_key112] = arguments[_key112];
    }

    return builder.apply(void 0, ["ObjectTypeSpreadProperty"].concat(args));
  }
  function OpaqueType() {
    for (var _len113 = arguments.length, args = new Array(_len113), _key113 = 0; _key113 < _len113; _key113++) {
      args[_key113] = arguments[_key113];
    }

    return builder.apply(void 0, ["OpaqueType"].concat(args));
  }
  function QualifiedTypeIdentifier() {
    for (var _len114 = arguments.length, args = new Array(_len114), _key114 = 0; _key114 < _len114; _key114++) {
      args[_key114] = arguments[_key114];
    }

    return builder.apply(void 0, ["QualifiedTypeIdentifier"].concat(args));
  }
  function StringLiteralTypeAnnotation() {
    for (var _len115 = arguments.length, args = new Array(_len115), _key115 = 0; _key115 < _len115; _key115++) {
      args[_key115] = arguments[_key115];
    }

    return builder.apply(void 0, ["StringLiteralTypeAnnotation"].concat(args));
  }
  function StringTypeAnnotation() {
    for (var _len116 = arguments.length, args = new Array(_len116), _key116 = 0; _key116 < _len116; _key116++) {
      args[_key116] = arguments[_key116];
    }

    return builder.apply(void 0, ["StringTypeAnnotation"].concat(args));
  }
  function SymbolTypeAnnotation() {
    for (var _len117 = arguments.length, args = new Array(_len117), _key117 = 0; _key117 < _len117; _key117++) {
      args[_key117] = arguments[_key117];
    }

    return builder.apply(void 0, ["SymbolTypeAnnotation"].concat(args));
  }
  function ThisTypeAnnotation() {
    for (var _len118 = arguments.length, args = new Array(_len118), _key118 = 0; _key118 < _len118; _key118++) {
      args[_key118] = arguments[_key118];
    }

    return builder.apply(void 0, ["ThisTypeAnnotation"].concat(args));
  }
  function TupleTypeAnnotation() {
    for (var _len119 = arguments.length, args = new Array(_len119), _key119 = 0; _key119 < _len119; _key119++) {
      args[_key119] = arguments[_key119];
    }

    return builder.apply(void 0, ["TupleTypeAnnotation"].concat(args));
  }
  function TypeofTypeAnnotation() {
    for (var _len120 = arguments.length, args = new Array(_len120), _key120 = 0; _key120 < _len120; _key120++) {
      args[_key120] = arguments[_key120];
    }

    return builder.apply(void 0, ["TypeofTypeAnnotation"].concat(args));
  }
  function TypeAlias() {
    for (var _len121 = arguments.length, args = new Array(_len121), _key121 = 0; _key121 < _len121; _key121++) {
      args[_key121] = arguments[_key121];
    }

    return builder.apply(void 0, ["TypeAlias"].concat(args));
  }
  function TypeAnnotation() {
    for (var _len122 = arguments.length, args = new Array(_len122), _key122 = 0; _key122 < _len122; _key122++) {
      args[_key122] = arguments[_key122];
    }

    return builder.apply(void 0, ["TypeAnnotation"].concat(args));
  }
  function TypeCastExpression() {
    for (var _len123 = arguments.length, args = new Array(_len123), _key123 = 0; _key123 < _len123; _key123++) {
      args[_key123] = arguments[_key123];
    }

    return builder.apply(void 0, ["TypeCastExpression"].concat(args));
  }
  function TypeParameter() {
    for (var _len124 = arguments.length, args = new Array(_len124), _key124 = 0; _key124 < _len124; _key124++) {
      args[_key124] = arguments[_key124];
    }

    return builder.apply(void 0, ["TypeParameter"].concat(args));
  }
  function TypeParameterDeclaration() {
    for (var _len125 = arguments.length, args = new Array(_len125), _key125 = 0; _key125 < _len125; _key125++) {
      args[_key125] = arguments[_key125];
    }

    return builder.apply(void 0, ["TypeParameterDeclaration"].concat(args));
  }
  function TypeParameterInstantiation() {
    for (var _len126 = arguments.length, args = new Array(_len126), _key126 = 0; _key126 < _len126; _key126++) {
      args[_key126] = arguments[_key126];
    }

    return builder.apply(void 0, ["TypeParameterInstantiation"].concat(args));
  }
  function UnionTypeAnnotation() {
    for (var _len127 = arguments.length, args = new Array(_len127), _key127 = 0; _key127 < _len127; _key127++) {
      args[_key127] = arguments[_key127];
    }

    return builder.apply(void 0, ["UnionTypeAnnotation"].concat(args));
  }
  function Variance() {
    for (var _len128 = arguments.length, args = new Array(_len128), _key128 = 0; _key128 < _len128; _key128++) {
      args[_key128] = arguments[_key128];
    }

    return builder.apply(void 0, ["Variance"].concat(args));
  }
  function VoidTypeAnnotation() {
    for (var _len129 = arguments.length, args = new Array(_len129), _key129 = 0; _key129 < _len129; _key129++) {
      args[_key129] = arguments[_key129];
    }

    return builder.apply(void 0, ["VoidTypeAnnotation"].concat(args));
  }
  function EnumDeclaration() {
    for (var _len130 = arguments.length, args = new Array(_len130), _key130 = 0; _key130 < _len130; _key130++) {
      args[_key130] = arguments[_key130];
    }

    return builder.apply(void 0, ["EnumDeclaration"].concat(args));
  }
  function EnumBooleanBody() {
    for (var _len131 = arguments.length, args = new Array(_len131), _key131 = 0; _key131 < _len131; _key131++) {
      args[_key131] = arguments[_key131];
    }

    return builder.apply(void 0, ["EnumBooleanBody"].concat(args));
  }
  function EnumNumberBody() {
    for (var _len132 = arguments.length, args = new Array(_len132), _key132 = 0; _key132 < _len132; _key132++) {
      args[_key132] = arguments[_key132];
    }

    return builder.apply(void 0, ["EnumNumberBody"].concat(args));
  }
  function EnumStringBody() {
    for (var _len133 = arguments.length, args = new Array(_len133), _key133 = 0; _key133 < _len133; _key133++) {
      args[_key133] = arguments[_key133];
    }

    return builder.apply(void 0, ["EnumStringBody"].concat(args));
  }
  function EnumSymbolBody() {
    for (var _len134 = arguments.length, args = new Array(_len134), _key134 = 0; _key134 < _len134; _key134++) {
      args[_key134] = arguments[_key134];
    }

    return builder.apply(void 0, ["EnumSymbolBody"].concat(args));
  }
  function EnumBooleanMember() {
    for (var _len135 = arguments.length, args = new Array(_len135), _key135 = 0; _key135 < _len135; _key135++) {
      args[_key135] = arguments[_key135];
    }

    return builder.apply(void 0, ["EnumBooleanMember"].concat(args));
  }
  function EnumNumberMember() {
    for (var _len136 = arguments.length, args = new Array(_len136), _key136 = 0; _key136 < _len136; _key136++) {
      args[_key136] = arguments[_key136];
    }

    return builder.apply(void 0, ["EnumNumberMember"].concat(args));
  }
  function EnumStringMember() {
    for (var _len137 = arguments.length, args = new Array(_len137), _key137 = 0; _key137 < _len137; _key137++) {
      args[_key137] = arguments[_key137];
    }

    return builder.apply(void 0, ["EnumStringMember"].concat(args));
  }
  function EnumDefaultedMember() {
    for (var _len138 = arguments.length, args = new Array(_len138), _key138 = 0; _key138 < _len138; _key138++) {
      args[_key138] = arguments[_key138];
    }

    return builder.apply(void 0, ["EnumDefaultedMember"].concat(args));
  }
  function JSXAttribute() {
    for (var _len139 = arguments.length, args = new Array(_len139), _key139 = 0; _key139 < _len139; _key139++) {
      args[_key139] = arguments[_key139];
    }

    return builder.apply(void 0, ["JSXAttribute"].concat(args));
  }
  function JSXClosingElement() {
    for (var _len140 = arguments.length, args = new Array(_len140), _key140 = 0; _key140 < _len140; _key140++) {
      args[_key140] = arguments[_key140];
    }

    return builder.apply(void 0, ["JSXClosingElement"].concat(args));
  }
  function JSXElement() {
    for (var _len141 = arguments.length, args = new Array(_len141), _key141 = 0; _key141 < _len141; _key141++) {
      args[_key141] = arguments[_key141];
    }

    return builder.apply(void 0, ["JSXElement"].concat(args));
  }
  function JSXEmptyExpression() {
    for (var _len142 = arguments.length, args = new Array(_len142), _key142 = 0; _key142 < _len142; _key142++) {
      args[_key142] = arguments[_key142];
    }

    return builder.apply(void 0, ["JSXEmptyExpression"].concat(args));
  }
  function JSXExpressionContainer() {
    for (var _len143 = arguments.length, args = new Array(_len143), _key143 = 0; _key143 < _len143; _key143++) {
      args[_key143] = arguments[_key143];
    }

    return builder.apply(void 0, ["JSXExpressionContainer"].concat(args));
  }
  function JSXSpreadChild() {
    for (var _len144 = arguments.length, args = new Array(_len144), _key144 = 0; _key144 < _len144; _key144++) {
      args[_key144] = arguments[_key144];
    }

    return builder.apply(void 0, ["JSXSpreadChild"].concat(args));
  }
  function JSXIdentifier() {
    for (var _len145 = arguments.length, args = new Array(_len145), _key145 = 0; _key145 < _len145; _key145++) {
      args[_key145] = arguments[_key145];
    }

    return builder.apply(void 0, ["JSXIdentifier"].concat(args));
  }
  function JSXMemberExpression() {
    for (var _len146 = arguments.length, args = new Array(_len146), _key146 = 0; _key146 < _len146; _key146++) {
      args[_key146] = arguments[_key146];
    }

    return builder.apply(void 0, ["JSXMemberExpression"].concat(args));
  }
  function JSXNamespacedName() {
    for (var _len147 = arguments.length, args = new Array(_len147), _key147 = 0; _key147 < _len147; _key147++) {
      args[_key147] = arguments[_key147];
    }

    return builder.apply(void 0, ["JSXNamespacedName"].concat(args));
  }
  function JSXOpeningElement() {
    for (var _len148 = arguments.length, args = new Array(_len148), _key148 = 0; _key148 < _len148; _key148++) {
      args[_key148] = arguments[_key148];
    }

    return builder.apply(void 0, ["JSXOpeningElement"].concat(args));
  }
  function JSXSpreadAttribute() {
    for (var _len149 = arguments.length, args = new Array(_len149), _key149 = 0; _key149 < _len149; _key149++) {
      args[_key149] = arguments[_key149];
    }

    return builder.apply(void 0, ["JSXSpreadAttribute"].concat(args));
  }
  function JSXText() {
    for (var _len150 = arguments.length, args = new Array(_len150), _key150 = 0; _key150 < _len150; _key150++) {
      args[_key150] = arguments[_key150];
    }

    return builder.apply(void 0, ["JSXText"].concat(args));
  }
  function JSXFragment() {
    for (var _len151 = arguments.length, args = new Array(_len151), _key151 = 0; _key151 < _len151; _key151++) {
      args[_key151] = arguments[_key151];
    }

    return builder.apply(void 0, ["JSXFragment"].concat(args));
  }
  function JSXOpeningFragment() {
    for (var _len152 = arguments.length, args = new Array(_len152), _key152 = 0; _key152 < _len152; _key152++) {
      args[_key152] = arguments[_key152];
    }

    return builder.apply(void 0, ["JSXOpeningFragment"].concat(args));
  }
  function JSXClosingFragment() {
    for (var _len153 = arguments.length, args = new Array(_len153), _key153 = 0; _key153 < _len153; _key153++) {
      args[_key153] = arguments[_key153];
    }

    return builder.apply(void 0, ["JSXClosingFragment"].concat(args));
  }
  function Noop() {
    for (var _len154 = arguments.length, args = new Array(_len154), _key154 = 0; _key154 < _len154; _key154++) {
      args[_key154] = arguments[_key154];
    }

    return builder.apply(void 0, ["Noop"].concat(args));
  }
  function Placeholder() {
    for (var _len155 = arguments.length, args = new Array(_len155), _key155 = 0; _key155 < _len155; _key155++) {
      args[_key155] = arguments[_key155];
    }

    return builder.apply(void 0, ["Placeholder"].concat(args));
  }
  function V8IntrinsicIdentifier() {
    for (var _len156 = arguments.length, args = new Array(_len156), _key156 = 0; _key156 < _len156; _key156++) {
      args[_key156] = arguments[_key156];
    }

    return builder.apply(void 0, ["V8IntrinsicIdentifier"].concat(args));
  }
  function ArgumentPlaceholder() {
    for (var _len157 = arguments.length, args = new Array(_len157), _key157 = 0; _key157 < _len157; _key157++) {
      args[_key157] = arguments[_key157];
    }

    return builder.apply(void 0, ["ArgumentPlaceholder"].concat(args));
  }
  function AwaitExpression() {
    for (var _len158 = arguments.length, args = new Array(_len158), _key158 = 0; _key158 < _len158; _key158++) {
      args[_key158] = arguments[_key158];
    }

    return builder.apply(void 0, ["AwaitExpression"].concat(args));
  }
  function BindExpression() {
    for (var _len159 = arguments.length, args = new Array(_len159), _key159 = 0; _key159 < _len159; _key159++) {
      args[_key159] = arguments[_key159];
    }

    return builder.apply(void 0, ["BindExpression"].concat(args));
  }
  function ClassProperty() {
    for (var _len160 = arguments.length, args = new Array(_len160), _key160 = 0; _key160 < _len160; _key160++) {
      args[_key160] = arguments[_key160];
    }

    return builder.apply(void 0, ["ClassProperty"].concat(args));
  }
  function OptionalMemberExpression() {
    for (var _len161 = arguments.length, args = new Array(_len161), _key161 = 0; _key161 < _len161; _key161++) {
      args[_key161] = arguments[_key161];
    }

    return builder.apply(void 0, ["OptionalMemberExpression"].concat(args));
  }
  function PipelineTopicExpression() {
    for (var _len162 = arguments.length, args = new Array(_len162), _key162 = 0; _key162 < _len162; _key162++) {
      args[_key162] = arguments[_key162];
    }

    return builder.apply(void 0, ["PipelineTopicExpression"].concat(args));
  }
  function PipelineBareFunction() {
    for (var _len163 = arguments.length, args = new Array(_len163), _key163 = 0; _key163 < _len163; _key163++) {
      args[_key163] = arguments[_key163];
    }

    return builder.apply(void 0, ["PipelineBareFunction"].concat(args));
  }
  function PipelinePrimaryTopicReference() {
    for (var _len164 = arguments.length, args = new Array(_len164), _key164 = 0; _key164 < _len164; _key164++) {
      args[_key164] = arguments[_key164];
    }

    return builder.apply(void 0, ["PipelinePrimaryTopicReference"].concat(args));
  }
  function OptionalCallExpression() {
    for (var _len165 = arguments.length, args = new Array(_len165), _key165 = 0; _key165 < _len165; _key165++) {
      args[_key165] = arguments[_key165];
    }

    return builder.apply(void 0, ["OptionalCallExpression"].concat(args));
  }
  function ClassPrivateProperty() {
    for (var _len166 = arguments.length, args = new Array(_len166), _key166 = 0; _key166 < _len166; _key166++) {
      args[_key166] = arguments[_key166];
    }

    return builder.apply(void 0, ["ClassPrivateProperty"].concat(args));
  }
  function ClassPrivateMethod() {
    for (var _len167 = arguments.length, args = new Array(_len167), _key167 = 0; _key167 < _len167; _key167++) {
      args[_key167] = arguments[_key167];
    }

    return builder.apply(void 0, ["ClassPrivateMethod"].concat(args));
  }
  function Import() {
    for (var _len168 = arguments.length, args = new Array(_len168), _key168 = 0; _key168 < _len168; _key168++) {
      args[_key168] = arguments[_key168];
    }

    return builder.apply(void 0, ["Import"].concat(args));
  }
  function Decorator() {
    for (var _len169 = arguments.length, args = new Array(_len169), _key169 = 0; _key169 < _len169; _key169++) {
      args[_key169] = arguments[_key169];
    }

    return builder.apply(void 0, ["Decorator"].concat(args));
  }
  function DoExpression() {
    for (var _len170 = arguments.length, args = new Array(_len170), _key170 = 0; _key170 < _len170; _key170++) {
      args[_key170] = arguments[_key170];
    }

    return builder.apply(void 0, ["DoExpression"].concat(args));
  }
  function ExportDefaultSpecifier() {
    for (var _len171 = arguments.length, args = new Array(_len171), _key171 = 0; _key171 < _len171; _key171++) {
      args[_key171] = arguments[_key171];
    }

    return builder.apply(void 0, ["ExportDefaultSpecifier"].concat(args));
  }
  function ExportNamespaceSpecifier() {
    for (var _len172 = arguments.length, args = new Array(_len172), _key172 = 0; _key172 < _len172; _key172++) {
      args[_key172] = arguments[_key172];
    }

    return builder.apply(void 0, ["ExportNamespaceSpecifier"].concat(args));
  }
  function PrivateName() {
    for (var _len173 = arguments.length, args = new Array(_len173), _key173 = 0; _key173 < _len173; _key173++) {
      args[_key173] = arguments[_key173];
    }

    return builder.apply(void 0, ["PrivateName"].concat(args));
  }
  function BigIntLiteral() {
    for (var _len174 = arguments.length, args = new Array(_len174), _key174 = 0; _key174 < _len174; _key174++) {
      args[_key174] = arguments[_key174];
    }

    return builder.apply(void 0, ["BigIntLiteral"].concat(args));
  }
  function RecordExpression() {
    for (var _len175 = arguments.length, args = new Array(_len175), _key175 = 0; _key175 < _len175; _key175++) {
      args[_key175] = arguments[_key175];
    }

    return builder.apply(void 0, ["RecordExpression"].concat(args));
  }
  function TupleExpression() {
    for (var _len176 = arguments.length, args = new Array(_len176), _key176 = 0; _key176 < _len176; _key176++) {
      args[_key176] = arguments[_key176];
    }

    return builder.apply(void 0, ["TupleExpression"].concat(args));
  }
  function TSParameterProperty() {
    for (var _len177 = arguments.length, args = new Array(_len177), _key177 = 0; _key177 < _len177; _key177++) {
      args[_key177] = arguments[_key177];
    }

    return builder.apply(void 0, ["TSParameterProperty"].concat(args));
  }
  function TSDeclareFunction() {
    for (var _len178 = arguments.length, args = new Array(_len178), _key178 = 0; _key178 < _len178; _key178++) {
      args[_key178] = arguments[_key178];
    }

    return builder.apply(void 0, ["TSDeclareFunction"].concat(args));
  }
  function TSDeclareMethod() {
    for (var _len179 = arguments.length, args = new Array(_len179), _key179 = 0; _key179 < _len179; _key179++) {
      args[_key179] = arguments[_key179];
    }

    return builder.apply(void 0, ["TSDeclareMethod"].concat(args));
  }
  function TSQualifiedName() {
    for (var _len180 = arguments.length, args = new Array(_len180), _key180 = 0; _key180 < _len180; _key180++) {
      args[_key180] = arguments[_key180];
    }

    return builder.apply(void 0, ["TSQualifiedName"].concat(args));
  }
  function TSCallSignatureDeclaration() {
    for (var _len181 = arguments.length, args = new Array(_len181), _key181 = 0; _key181 < _len181; _key181++) {
      args[_key181] = arguments[_key181];
    }

    return builder.apply(void 0, ["TSCallSignatureDeclaration"].concat(args));
  }
  function TSConstructSignatureDeclaration() {
    for (var _len182 = arguments.length, args = new Array(_len182), _key182 = 0; _key182 < _len182; _key182++) {
      args[_key182] = arguments[_key182];
    }

    return builder.apply(void 0, ["TSConstructSignatureDeclaration"].concat(args));
  }
  function TSPropertySignature() {
    for (var _len183 = arguments.length, args = new Array(_len183), _key183 = 0; _key183 < _len183; _key183++) {
      args[_key183] = arguments[_key183];
    }

    return builder.apply(void 0, ["TSPropertySignature"].concat(args));
  }
  function TSMethodSignature() {
    for (var _len184 = arguments.length, args = new Array(_len184), _key184 = 0; _key184 < _len184; _key184++) {
      args[_key184] = arguments[_key184];
    }

    return builder.apply(void 0, ["TSMethodSignature"].concat(args));
  }
  function TSIndexSignature() {
    for (var _len185 = arguments.length, args = new Array(_len185), _key185 = 0; _key185 < _len185; _key185++) {
      args[_key185] = arguments[_key185];
    }

    return builder.apply(void 0, ["TSIndexSignature"].concat(args));
  }
  function TSAnyKeyword() {
    for (var _len186 = arguments.length, args = new Array(_len186), _key186 = 0; _key186 < _len186; _key186++) {
      args[_key186] = arguments[_key186];
    }

    return builder.apply(void 0, ["TSAnyKeyword"].concat(args));
  }
  function TSBooleanKeyword() {
    for (var _len187 = arguments.length, args = new Array(_len187), _key187 = 0; _key187 < _len187; _key187++) {
      args[_key187] = arguments[_key187];
    }

    return builder.apply(void 0, ["TSBooleanKeyword"].concat(args));
  }
  function TSBigIntKeyword() {
    for (var _len188 = arguments.length, args = new Array(_len188), _key188 = 0; _key188 < _len188; _key188++) {
      args[_key188] = arguments[_key188];
    }

    return builder.apply(void 0, ["TSBigIntKeyword"].concat(args));
  }
  function TSNeverKeyword() {
    for (var _len189 = arguments.length, args = new Array(_len189), _key189 = 0; _key189 < _len189; _key189++) {
      args[_key189] = arguments[_key189];
    }

    return builder.apply(void 0, ["TSNeverKeyword"].concat(args));
  }
  function TSNullKeyword() {
    for (var _len190 = arguments.length, args = new Array(_len190), _key190 = 0; _key190 < _len190; _key190++) {
      args[_key190] = arguments[_key190];
    }

    return builder.apply(void 0, ["TSNullKeyword"].concat(args));
  }
  function TSNumberKeyword() {
    for (var _len191 = arguments.length, args = new Array(_len191), _key191 = 0; _key191 < _len191; _key191++) {
      args[_key191] = arguments[_key191];
    }

    return builder.apply(void 0, ["TSNumberKeyword"].concat(args));
  }
  function TSObjectKeyword() {
    for (var _len192 = arguments.length, args = new Array(_len192), _key192 = 0; _key192 < _len192; _key192++) {
      args[_key192] = arguments[_key192];
    }

    return builder.apply(void 0, ["TSObjectKeyword"].concat(args));
  }
  function TSStringKeyword() {
    for (var _len193 = arguments.length, args = new Array(_len193), _key193 = 0; _key193 < _len193; _key193++) {
      args[_key193] = arguments[_key193];
    }

    return builder.apply(void 0, ["TSStringKeyword"].concat(args));
  }
  function TSSymbolKeyword() {
    for (var _len194 = arguments.length, args = new Array(_len194), _key194 = 0; _key194 < _len194; _key194++) {
      args[_key194] = arguments[_key194];
    }

    return builder.apply(void 0, ["TSSymbolKeyword"].concat(args));
  }
  function TSUndefinedKeyword() {
    for (var _len195 = arguments.length, args = new Array(_len195), _key195 = 0; _key195 < _len195; _key195++) {
      args[_key195] = arguments[_key195];
    }

    return builder.apply(void 0, ["TSUndefinedKeyword"].concat(args));
  }
  function TSUnknownKeyword() {
    for (var _len196 = arguments.length, args = new Array(_len196), _key196 = 0; _key196 < _len196; _key196++) {
      args[_key196] = arguments[_key196];
    }

    return builder.apply(void 0, ["TSUnknownKeyword"].concat(args));
  }
  function TSVoidKeyword() {
    for (var _len197 = arguments.length, args = new Array(_len197), _key197 = 0; _key197 < _len197; _key197++) {
      args[_key197] = arguments[_key197];
    }

    return builder.apply(void 0, ["TSVoidKeyword"].concat(args));
  }
  function TSThisType() {
    for (var _len198 = arguments.length, args = new Array(_len198), _key198 = 0; _key198 < _len198; _key198++) {
      args[_key198] = arguments[_key198];
    }

    return builder.apply(void 0, ["TSThisType"].concat(args));
  }
  function TSFunctionType() {
    for (var _len199 = arguments.length, args = new Array(_len199), _key199 = 0; _key199 < _len199; _key199++) {
      args[_key199] = arguments[_key199];
    }

    return builder.apply(void 0, ["TSFunctionType"].concat(args));
  }
  function TSConstructorType() {
    for (var _len200 = arguments.length, args = new Array(_len200), _key200 = 0; _key200 < _len200; _key200++) {
      args[_key200] = arguments[_key200];
    }

    return builder.apply(void 0, ["TSConstructorType"].concat(args));
  }
  function TSTypeReference() {
    for (var _len201 = arguments.length, args = new Array(_len201), _key201 = 0; _key201 < _len201; _key201++) {
      args[_key201] = arguments[_key201];
    }

    return builder.apply(void 0, ["TSTypeReference"].concat(args));
  }
  function TSTypePredicate() {
    for (var _len202 = arguments.length, args = new Array(_len202), _key202 = 0; _key202 < _len202; _key202++) {
      args[_key202] = arguments[_key202];
    }

    return builder.apply(void 0, ["TSTypePredicate"].concat(args));
  }
  function TSTypeQuery() {
    for (var _len203 = arguments.length, args = new Array(_len203), _key203 = 0; _key203 < _len203; _key203++) {
      args[_key203] = arguments[_key203];
    }

    return builder.apply(void 0, ["TSTypeQuery"].concat(args));
  }
  function TSTypeLiteral() {
    for (var _len204 = arguments.length, args = new Array(_len204), _key204 = 0; _key204 < _len204; _key204++) {
      args[_key204] = arguments[_key204];
    }

    return builder.apply(void 0, ["TSTypeLiteral"].concat(args));
  }
  function TSArrayType() {
    for (var _len205 = arguments.length, args = new Array(_len205), _key205 = 0; _key205 < _len205; _key205++) {
      args[_key205] = arguments[_key205];
    }

    return builder.apply(void 0, ["TSArrayType"].concat(args));
  }
  function TSTupleType() {
    for (var _len206 = arguments.length, args = new Array(_len206), _key206 = 0; _key206 < _len206; _key206++) {
      args[_key206] = arguments[_key206];
    }

    return builder.apply(void 0, ["TSTupleType"].concat(args));
  }
  function TSOptionalType() {
    for (var _len207 = arguments.length, args = new Array(_len207), _key207 = 0; _key207 < _len207; _key207++) {
      args[_key207] = arguments[_key207];
    }

    return builder.apply(void 0, ["TSOptionalType"].concat(args));
  }
  function TSRestType() {
    for (var _len208 = arguments.length, args = new Array(_len208), _key208 = 0; _key208 < _len208; _key208++) {
      args[_key208] = arguments[_key208];
    }

    return builder.apply(void 0, ["TSRestType"].concat(args));
  }
  function TSUnionType() {
    for (var _len209 = arguments.length, args = new Array(_len209), _key209 = 0; _key209 < _len209; _key209++) {
      args[_key209] = arguments[_key209];
    }

    return builder.apply(void 0, ["TSUnionType"].concat(args));
  }
  function TSIntersectionType() {
    for (var _len210 = arguments.length, args = new Array(_len210), _key210 = 0; _key210 < _len210; _key210++) {
      args[_key210] = arguments[_key210];
    }

    return builder.apply(void 0, ["TSIntersectionType"].concat(args));
  }
  function TSConditionalType() {
    for (var _len211 = arguments.length, args = new Array(_len211), _key211 = 0; _key211 < _len211; _key211++) {
      args[_key211] = arguments[_key211];
    }

    return builder.apply(void 0, ["TSConditionalType"].concat(args));
  }
  function TSInferType() {
    for (var _len212 = arguments.length, args = new Array(_len212), _key212 = 0; _key212 < _len212; _key212++) {
      args[_key212] = arguments[_key212];
    }

    return builder.apply(void 0, ["TSInferType"].concat(args));
  }
  function TSParenthesizedType() {
    for (var _len213 = arguments.length, args = new Array(_len213), _key213 = 0; _key213 < _len213; _key213++) {
      args[_key213] = arguments[_key213];
    }

    return builder.apply(void 0, ["TSParenthesizedType"].concat(args));
  }
  function TSTypeOperator() {
    for (var _len214 = arguments.length, args = new Array(_len214), _key214 = 0; _key214 < _len214; _key214++) {
      args[_key214] = arguments[_key214];
    }

    return builder.apply(void 0, ["TSTypeOperator"].concat(args));
  }
  function TSIndexedAccessType() {
    for (var _len215 = arguments.length, args = new Array(_len215), _key215 = 0; _key215 < _len215; _key215++) {
      args[_key215] = arguments[_key215];
    }

    return builder.apply(void 0, ["TSIndexedAccessType"].concat(args));
  }
  function TSMappedType() {
    for (var _len216 = arguments.length, args = new Array(_len216), _key216 = 0; _key216 < _len216; _key216++) {
      args[_key216] = arguments[_key216];
    }

    return builder.apply(void 0, ["TSMappedType"].concat(args));
  }
  function TSLiteralType() {
    for (var _len217 = arguments.length, args = new Array(_len217), _key217 = 0; _key217 < _len217; _key217++) {
      args[_key217] = arguments[_key217];
    }

    return builder.apply(void 0, ["TSLiteralType"].concat(args));
  }
  function TSExpressionWithTypeArguments() {
    for (var _len218 = arguments.length, args = new Array(_len218), _key218 = 0; _key218 < _len218; _key218++) {
      args[_key218] = arguments[_key218];
    }

    return builder.apply(void 0, ["TSExpressionWithTypeArguments"].concat(args));
  }
  function TSInterfaceDeclaration() {
    for (var _len219 = arguments.length, args = new Array(_len219), _key219 = 0; _key219 < _len219; _key219++) {
      args[_key219] = arguments[_key219];
    }

    return builder.apply(void 0, ["TSInterfaceDeclaration"].concat(args));
  }
  function TSInterfaceBody() {
    for (var _len220 = arguments.length, args = new Array(_len220), _key220 = 0; _key220 < _len220; _key220++) {
      args[_key220] = arguments[_key220];
    }

    return builder.apply(void 0, ["TSInterfaceBody"].concat(args));
  }
  function TSTypeAliasDeclaration() {
    for (var _len221 = arguments.length, args = new Array(_len221), _key221 = 0; _key221 < _len221; _key221++) {
      args[_key221] = arguments[_key221];
    }

    return builder.apply(void 0, ["TSTypeAliasDeclaration"].concat(args));
  }
  function TSAsExpression() {
    for (var _len222 = arguments.length, args = new Array(_len222), _key222 = 0; _key222 < _len222; _key222++) {
      args[_key222] = arguments[_key222];
    }

    return builder.apply(void 0, ["TSAsExpression"].concat(args));
  }
  function TSTypeAssertion() {
    for (var _len223 = arguments.length, args = new Array(_len223), _key223 = 0; _key223 < _len223; _key223++) {
      args[_key223] = arguments[_key223];
    }

    return builder.apply(void 0, ["TSTypeAssertion"].concat(args));
  }
  function TSEnumDeclaration() {
    for (var _len224 = arguments.length, args = new Array(_len224), _key224 = 0; _key224 < _len224; _key224++) {
      args[_key224] = arguments[_key224];
    }

    return builder.apply(void 0, ["TSEnumDeclaration"].concat(args));
  }
  function TSEnumMember() {
    for (var _len225 = arguments.length, args = new Array(_len225), _key225 = 0; _key225 < _len225; _key225++) {
      args[_key225] = arguments[_key225];
    }

    return builder.apply(void 0, ["TSEnumMember"].concat(args));
  }
  function TSModuleDeclaration() {
    for (var _len226 = arguments.length, args = new Array(_len226), _key226 = 0; _key226 < _len226; _key226++) {
      args[_key226] = arguments[_key226];
    }

    return builder.apply(void 0, ["TSModuleDeclaration"].concat(args));
  }
  function TSModuleBlock() {
    for (var _len227 = arguments.length, args = new Array(_len227), _key227 = 0; _key227 < _len227; _key227++) {
      args[_key227] = arguments[_key227];
    }

    return builder.apply(void 0, ["TSModuleBlock"].concat(args));
  }
  function TSImportType() {
    for (var _len228 = arguments.length, args = new Array(_len228), _key228 = 0; _key228 < _len228; _key228++) {
      args[_key228] = arguments[_key228];
    }

    return builder.apply(void 0, ["TSImportType"].concat(args));
  }
  function TSImportEqualsDeclaration() {
    for (var _len229 = arguments.length, args = new Array(_len229), _key229 = 0; _key229 < _len229; _key229++) {
      args[_key229] = arguments[_key229];
    }

    return builder.apply(void 0, ["TSImportEqualsDeclaration"].concat(args));
  }
  function TSExternalModuleReference() {
    for (var _len230 = arguments.length, args = new Array(_len230), _key230 = 0; _key230 < _len230; _key230++) {
      args[_key230] = arguments[_key230];
    }

    return builder.apply(void 0, ["TSExternalModuleReference"].concat(args));
  }
  function TSNonNullExpression() {
    for (var _len231 = arguments.length, args = new Array(_len231), _key231 = 0; _key231 < _len231; _key231++) {
      args[_key231] = arguments[_key231];
    }

    return builder.apply(void 0, ["TSNonNullExpression"].concat(args));
  }
  function TSExportAssignment() {
    for (var _len232 = arguments.length, args = new Array(_len232), _key232 = 0; _key232 < _len232; _key232++) {
      args[_key232] = arguments[_key232];
    }

    return builder.apply(void 0, ["TSExportAssignment"].concat(args));
  }
  function TSNamespaceExportDeclaration() {
    for (var _len233 = arguments.length, args = new Array(_len233), _key233 = 0; _key233 < _len233; _key233++) {
      args[_key233] = arguments[_key233];
    }

    return builder.apply(void 0, ["TSNamespaceExportDeclaration"].concat(args));
  }
  function TSTypeAnnotation() {
    for (var _len234 = arguments.length, args = new Array(_len234), _key234 = 0; _key234 < _len234; _key234++) {
      args[_key234] = arguments[_key234];
    }

    return builder.apply(void 0, ["TSTypeAnnotation"].concat(args));
  }
  function TSTypeParameterInstantiation() {
    for (var _len235 = arguments.length, args = new Array(_len235), _key235 = 0; _key235 < _len235; _key235++) {
      args[_key235] = arguments[_key235];
    }

    return builder.apply(void 0, ["TSTypeParameterInstantiation"].concat(args));
  }
  function TSTypeParameterDeclaration() {
    for (var _len236 = arguments.length, args = new Array(_len236), _key236 = 0; _key236 < _len236; _key236++) {
      args[_key236] = arguments[_key236];
    }

    return builder.apply(void 0, ["TSTypeParameterDeclaration"].concat(args));
  }
  function TSTypeParameter() {
    for (var _len237 = arguments.length, args = new Array(_len237), _key237 = 0; _key237 < _len237; _key237++) {
      args[_key237] = arguments[_key237];
    }

    return builder.apply(void 0, ["TSTypeParameter"].concat(args));
  }
  function NumberLiteral() {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");

    for (var _len238 = arguments.length, args = new Array(_len238), _key238 = 0; _key238 < _len238; _key238++) {
      args[_key238] = arguments[_key238];
    }

    return NumberLiteral.apply(void 0, ["NumberLiteral"].concat(args));
  }
  function RegexLiteral() {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");

    for (var _len239 = arguments.length, args = new Array(_len239), _key239 = 0; _key239 < _len239; _key239++) {
      args[_key239] = arguments[_key239];
    }

    return RegexLiteral.apply(void 0, ["RegexLiteral"].concat(args));
  }
  function RestProperty() {
    console.trace("The node type RestProperty has been renamed to RestElement");

    for (var _len240 = arguments.length, args = new Array(_len240), _key240 = 0; _key240 < _len240; _key240++) {
      args[_key240] = arguments[_key240];
    }

    return RestProperty.apply(void 0, ["RestProperty"].concat(args));
  }
  function SpreadProperty() {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");

    for (var _len241 = arguments.length, args = new Array(_len241), _key241 = 0; _key241 < _len241; _key241++) {
      args[_key241] = arguments[_key241];
    }

    return SpreadProperty.apply(void 0, ["SpreadProperty"].concat(args));
  }

  function cleanJSXElementLiteralChild(child, args) {
    var lines = child.value.split(/\r\n|\n|\r/);
    var lastNonEmptyLine = 0;

    for (var i = 0; i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }

    var str = "";

    for (var _i = 0; _i < lines.length; _i++) {
      var line = lines[_i];
      var isFirstLine = _i === 0;
      var isLastLine = _i === lines.length - 1;
      var isLastNonEmptyLine = _i === lastNonEmptyLine;
      var trimmedLine = line.replace(/\t/g, " ");

      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, "");
      }

      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, "");
      }

      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }

        str += trimmedLine;
      }
    }

    if (str) args.push(StringLiteral(str));
  }

  function buildChildren(node) {
    var elements = [];

    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];

      if (isJSXText(child)) {
        cleanJSXElementLiteralChild(child, elements);
        continue;
      }

      if (isJSXExpressionContainer(child)) child = child.expression;
      if (isJSXEmptyExpression(child)) continue;
      elements.push(child);
    }

    return elements;
  }

  function isNode(node) {
    return !!(node && VISITOR_KEYS[node.type]);
  }

  function assertNode(node) {
    if (!isNode(node)) {
      var type = node && node.type || JSON.stringify(node);
      throw new TypeError("Not a valid node of type \"" + type + "\"");
    }
  }

  function assert(type, node, opts) {
    if (!is(type, node, opts)) {
      throw new Error("Expected type \"" + type + "\" with option " + JSON.stringify(opts) + ", " + ("but instead got \"" + node.type + "\"."));
    }
  }

  function assertArrayExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ArrayExpression", node, opts);
  }
  function assertAssignmentExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("AssignmentExpression", node, opts);
  }
  function assertBinaryExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("BinaryExpression", node, opts);
  }
  function assertInterpreterDirective(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("InterpreterDirective", node, opts);
  }
  function assertDirective(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Directive", node, opts);
  }
  function assertDirectiveLiteral(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DirectiveLiteral", node, opts);
  }
  function assertBlockStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("BlockStatement", node, opts);
  }
  function assertBreakStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("BreakStatement", node, opts);
  }
  function assertCallExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("CallExpression", node, opts);
  }
  function assertCatchClause(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("CatchClause", node, opts);
  }
  function assertConditionalExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ConditionalExpression", node, opts);
  }
  function assertContinueStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ContinueStatement", node, opts);
  }
  function assertDebuggerStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DebuggerStatement", node, opts);
  }
  function assertDoWhileStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DoWhileStatement", node, opts);
  }
  function assertEmptyStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EmptyStatement", node, opts);
  }
  function assertExpressionStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ExpressionStatement", node, opts);
  }
  function assertFile(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("File", node, opts);
  }
  function assertForInStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ForInStatement", node, opts);
  }
  function assertForStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ForStatement", node, opts);
  }
  function assertFunctionDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("FunctionDeclaration", node, opts);
  }
  function assertFunctionExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("FunctionExpression", node, opts);
  }
  function assertIdentifier(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Identifier", node, opts);
  }
  function assertIfStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("IfStatement", node, opts);
  }
  function assertLabeledStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("LabeledStatement", node, opts);
  }
  function assertStringLiteral(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("StringLiteral", node, opts);
  }
  function assertNumericLiteral(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("NumericLiteral", node, opts);
  }
  function assertNullLiteral(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("NullLiteral", node, opts);
  }
  function assertBooleanLiteral(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("BooleanLiteral", node, opts);
  }
  function assertRegExpLiteral(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("RegExpLiteral", node, opts);
  }
  function assertLogicalExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("LogicalExpression", node, opts);
  }
  function assertMemberExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("MemberExpression", node, opts);
  }
  function assertNewExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("NewExpression", node, opts);
  }
  function assertProgram(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Program", node, opts);
  }
  function assertObjectExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ObjectExpression", node, opts);
  }
  function assertObjectMethod(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ObjectMethod", node, opts);
  }
  function assertObjectProperty(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ObjectProperty", node, opts);
  }
  function assertRestElement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("RestElement", node, opts);
  }
  function assertReturnStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ReturnStatement", node, opts);
  }
  function assertSequenceExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("SequenceExpression", node, opts);
  }
  function assertParenthesizedExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ParenthesizedExpression", node, opts);
  }
  function assertSwitchCase(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("SwitchCase", node, opts);
  }
  function assertSwitchStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("SwitchStatement", node, opts);
  }
  function assertThisExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ThisExpression", node, opts);
  }
  function assertThrowStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ThrowStatement", node, opts);
  }
  function assertTryStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TryStatement", node, opts);
  }
  function assertUnaryExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("UnaryExpression", node, opts);
  }
  function assertUpdateExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("UpdateExpression", node, opts);
  }
  function assertVariableDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("VariableDeclaration", node, opts);
  }
  function assertVariableDeclarator(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("VariableDeclarator", node, opts);
  }
  function assertWhileStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("WhileStatement", node, opts);
  }
  function assertWithStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("WithStatement", node, opts);
  }
  function assertAssignmentPattern(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("AssignmentPattern", node, opts);
  }
  function assertArrayPattern(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ArrayPattern", node, opts);
  }
  function assertArrowFunctionExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ArrowFunctionExpression", node, opts);
  }
  function assertClassBody(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ClassBody", node, opts);
  }
  function assertClassExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ClassExpression", node, opts);
  }
  function assertClassDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ClassDeclaration", node, opts);
  }
  function assertExportAllDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ExportAllDeclaration", node, opts);
  }
  function assertExportDefaultDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ExportDefaultDeclaration", node, opts);
  }
  function assertExportNamedDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ExportNamedDeclaration", node, opts);
  }
  function assertExportSpecifier(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ExportSpecifier", node, opts);
  }
  function assertForOfStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ForOfStatement", node, opts);
  }
  function assertImportDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ImportDeclaration", node, opts);
  }
  function assertImportDefaultSpecifier(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ImportDefaultSpecifier", node, opts);
  }
  function assertImportNamespaceSpecifier(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ImportNamespaceSpecifier", node, opts);
  }
  function assertImportSpecifier(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ImportSpecifier", node, opts);
  }
  function assertMetaProperty(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("MetaProperty", node, opts);
  }
  function assertClassMethod(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ClassMethod", node, opts);
  }
  function assertObjectPattern(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ObjectPattern", node, opts);
  }
  function assertSpreadElement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("SpreadElement", node, opts);
  }
  function assertSuper(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Super", node, opts);
  }
  function assertTaggedTemplateExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TaggedTemplateExpression", node, opts);
  }
  function assertTemplateElement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TemplateElement", node, opts);
  }
  function assertTemplateLiteral(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TemplateLiteral", node, opts);
  }
  function assertYieldExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("YieldExpression", node, opts);
  }
  function assertAnyTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("AnyTypeAnnotation", node, opts);
  }
  function assertArrayTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ArrayTypeAnnotation", node, opts);
  }
  function assertBooleanTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("BooleanTypeAnnotation", node, opts);
  }
  function assertBooleanLiteralTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("BooleanLiteralTypeAnnotation", node, opts);
  }
  function assertNullLiteralTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("NullLiteralTypeAnnotation", node, opts);
  }
  function assertClassImplements(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ClassImplements", node, opts);
  }
  function assertDeclareClass(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DeclareClass", node, opts);
  }
  function assertDeclareFunction(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DeclareFunction", node, opts);
  }
  function assertDeclareInterface(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DeclareInterface", node, opts);
  }
  function assertDeclareModule(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DeclareModule", node, opts);
  }
  function assertDeclareModuleExports(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DeclareModuleExports", node, opts);
  }
  function assertDeclareTypeAlias(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DeclareTypeAlias", node, opts);
  }
  function assertDeclareOpaqueType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DeclareOpaqueType", node, opts);
  }
  function assertDeclareVariable(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DeclareVariable", node, opts);
  }
  function assertDeclareExportDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DeclareExportDeclaration", node, opts);
  }
  function assertDeclareExportAllDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DeclareExportAllDeclaration", node, opts);
  }
  function assertDeclaredPredicate(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DeclaredPredicate", node, opts);
  }
  function assertExistsTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ExistsTypeAnnotation", node, opts);
  }
  function assertFunctionTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("FunctionTypeAnnotation", node, opts);
  }
  function assertFunctionTypeParam(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("FunctionTypeParam", node, opts);
  }
  function assertGenericTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("GenericTypeAnnotation", node, opts);
  }
  function assertInferredPredicate(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("InferredPredicate", node, opts);
  }
  function assertInterfaceExtends(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("InterfaceExtends", node, opts);
  }
  function assertInterfaceDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("InterfaceDeclaration", node, opts);
  }
  function assertInterfaceTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("InterfaceTypeAnnotation", node, opts);
  }
  function assertIntersectionTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("IntersectionTypeAnnotation", node, opts);
  }
  function assertMixedTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("MixedTypeAnnotation", node, opts);
  }
  function assertEmptyTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EmptyTypeAnnotation", node, opts);
  }
  function assertNullableTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("NullableTypeAnnotation", node, opts);
  }
  function assertNumberLiteralTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("NumberLiteralTypeAnnotation", node, opts);
  }
  function assertNumberTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("NumberTypeAnnotation", node, opts);
  }
  function assertObjectTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ObjectTypeAnnotation", node, opts);
  }
  function assertObjectTypeInternalSlot(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ObjectTypeInternalSlot", node, opts);
  }
  function assertObjectTypeCallProperty(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ObjectTypeCallProperty", node, opts);
  }
  function assertObjectTypeIndexer(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ObjectTypeIndexer", node, opts);
  }
  function assertObjectTypeProperty(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ObjectTypeProperty", node, opts);
  }
  function assertObjectTypeSpreadProperty(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ObjectTypeSpreadProperty", node, opts);
  }
  function assertOpaqueType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("OpaqueType", node, opts);
  }
  function assertQualifiedTypeIdentifier(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("QualifiedTypeIdentifier", node, opts);
  }
  function assertStringLiteralTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("StringLiteralTypeAnnotation", node, opts);
  }
  function assertStringTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("StringTypeAnnotation", node, opts);
  }
  function assertSymbolTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("SymbolTypeAnnotation", node, opts);
  }
  function assertThisTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ThisTypeAnnotation", node, opts);
  }
  function assertTupleTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TupleTypeAnnotation", node, opts);
  }
  function assertTypeofTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TypeofTypeAnnotation", node, opts);
  }
  function assertTypeAlias(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TypeAlias", node, opts);
  }
  function assertTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TypeAnnotation", node, opts);
  }
  function assertTypeCastExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TypeCastExpression", node, opts);
  }
  function assertTypeParameter(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TypeParameter", node, opts);
  }
  function assertTypeParameterDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TypeParameterDeclaration", node, opts);
  }
  function assertTypeParameterInstantiation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TypeParameterInstantiation", node, opts);
  }
  function assertUnionTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("UnionTypeAnnotation", node, opts);
  }
  function assertVariance(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Variance", node, opts);
  }
  function assertVoidTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("VoidTypeAnnotation", node, opts);
  }
  function assertEnumDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EnumDeclaration", node, opts);
  }
  function assertEnumBooleanBody(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EnumBooleanBody", node, opts);
  }
  function assertEnumNumberBody(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EnumNumberBody", node, opts);
  }
  function assertEnumStringBody(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EnumStringBody", node, opts);
  }
  function assertEnumSymbolBody(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EnumSymbolBody", node, opts);
  }
  function assertEnumBooleanMember(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EnumBooleanMember", node, opts);
  }
  function assertEnumNumberMember(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EnumNumberMember", node, opts);
  }
  function assertEnumStringMember(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EnumStringMember", node, opts);
  }
  function assertEnumDefaultedMember(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EnumDefaultedMember", node, opts);
  }
  function assertJSXAttribute(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXAttribute", node, opts);
  }
  function assertJSXClosingElement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXClosingElement", node, opts);
  }
  function assertJSXElement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXElement", node, opts);
  }
  function assertJSXEmptyExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXEmptyExpression", node, opts);
  }
  function assertJSXExpressionContainer(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXExpressionContainer", node, opts);
  }
  function assertJSXSpreadChild(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXSpreadChild", node, opts);
  }
  function assertJSXIdentifier(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXIdentifier", node, opts);
  }
  function assertJSXMemberExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXMemberExpression", node, opts);
  }
  function assertJSXNamespacedName(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXNamespacedName", node, opts);
  }
  function assertJSXOpeningElement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXOpeningElement", node, opts);
  }
  function assertJSXSpreadAttribute(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXSpreadAttribute", node, opts);
  }
  function assertJSXText(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXText", node, opts);
  }
  function assertJSXFragment(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXFragment", node, opts);
  }
  function assertJSXOpeningFragment(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXOpeningFragment", node, opts);
  }
  function assertJSXClosingFragment(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSXClosingFragment", node, opts);
  }
  function assertNoop(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Noop", node, opts);
  }
  function assertPlaceholder(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Placeholder", node, opts);
  }
  function assertV8IntrinsicIdentifier(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("V8IntrinsicIdentifier", node, opts);
  }
  function assertArgumentPlaceholder(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ArgumentPlaceholder", node, opts);
  }
  function assertAwaitExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("AwaitExpression", node, opts);
  }
  function assertBindExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("BindExpression", node, opts);
  }
  function assertClassProperty(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ClassProperty", node, opts);
  }
  function assertOptionalMemberExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("OptionalMemberExpression", node, opts);
  }
  function assertPipelineTopicExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("PipelineTopicExpression", node, opts);
  }
  function assertPipelineBareFunction(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("PipelineBareFunction", node, opts);
  }
  function assertPipelinePrimaryTopicReference(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("PipelinePrimaryTopicReference", node, opts);
  }
  function assertOptionalCallExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("OptionalCallExpression", node, opts);
  }
  function assertClassPrivateProperty(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ClassPrivateProperty", node, opts);
  }
  function assertClassPrivateMethod(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ClassPrivateMethod", node, opts);
  }
  function assertImport(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Import", node, opts);
  }
  function assertDecorator(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Decorator", node, opts);
  }
  function assertDoExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("DoExpression", node, opts);
  }
  function assertExportDefaultSpecifier(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ExportDefaultSpecifier", node, opts);
  }
  function assertExportNamespaceSpecifier(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ExportNamespaceSpecifier", node, opts);
  }
  function assertPrivateName(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("PrivateName", node, opts);
  }
  function assertBigIntLiteral(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("BigIntLiteral", node, opts);
  }
  function assertRecordExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("RecordExpression", node, opts);
  }
  function assertTupleExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TupleExpression", node, opts);
  }
  function assertTSParameterProperty(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSParameterProperty", node, opts);
  }
  function assertTSDeclareFunction(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSDeclareFunction", node, opts);
  }
  function assertTSDeclareMethod(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSDeclareMethod", node, opts);
  }
  function assertTSQualifiedName(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSQualifiedName", node, opts);
  }
  function assertTSCallSignatureDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSCallSignatureDeclaration", node, opts);
  }
  function assertTSConstructSignatureDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSConstructSignatureDeclaration", node, opts);
  }
  function assertTSPropertySignature(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSPropertySignature", node, opts);
  }
  function assertTSMethodSignature(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSMethodSignature", node, opts);
  }
  function assertTSIndexSignature(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSIndexSignature", node, opts);
  }
  function assertTSAnyKeyword(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSAnyKeyword", node, opts);
  }
  function assertTSBooleanKeyword(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSBooleanKeyword", node, opts);
  }
  function assertTSBigIntKeyword(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSBigIntKeyword", node, opts);
  }
  function assertTSNeverKeyword(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSNeverKeyword", node, opts);
  }
  function assertTSNullKeyword(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSNullKeyword", node, opts);
  }
  function assertTSNumberKeyword(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSNumberKeyword", node, opts);
  }
  function assertTSObjectKeyword(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSObjectKeyword", node, opts);
  }
  function assertTSStringKeyword(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSStringKeyword", node, opts);
  }
  function assertTSSymbolKeyword(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSSymbolKeyword", node, opts);
  }
  function assertTSUndefinedKeyword(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSUndefinedKeyword", node, opts);
  }
  function assertTSUnknownKeyword(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSUnknownKeyword", node, opts);
  }
  function assertTSVoidKeyword(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSVoidKeyword", node, opts);
  }
  function assertTSThisType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSThisType", node, opts);
  }
  function assertTSFunctionType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSFunctionType", node, opts);
  }
  function assertTSConstructorType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSConstructorType", node, opts);
  }
  function assertTSTypeReference(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTypeReference", node, opts);
  }
  function assertTSTypePredicate(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTypePredicate", node, opts);
  }
  function assertTSTypeQuery(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTypeQuery", node, opts);
  }
  function assertTSTypeLiteral(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTypeLiteral", node, opts);
  }
  function assertTSArrayType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSArrayType", node, opts);
  }
  function assertTSTupleType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTupleType", node, opts);
  }
  function assertTSOptionalType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSOptionalType", node, opts);
  }
  function assertTSRestType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSRestType", node, opts);
  }
  function assertTSUnionType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSUnionType", node, opts);
  }
  function assertTSIntersectionType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSIntersectionType", node, opts);
  }
  function assertTSConditionalType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSConditionalType", node, opts);
  }
  function assertTSInferType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSInferType", node, opts);
  }
  function assertTSParenthesizedType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSParenthesizedType", node, opts);
  }
  function assertTSTypeOperator(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTypeOperator", node, opts);
  }
  function assertTSIndexedAccessType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSIndexedAccessType", node, opts);
  }
  function assertTSMappedType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSMappedType", node, opts);
  }
  function assertTSLiteralType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSLiteralType", node, opts);
  }
  function assertTSExpressionWithTypeArguments(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSExpressionWithTypeArguments", node, opts);
  }
  function assertTSInterfaceDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSInterfaceDeclaration", node, opts);
  }
  function assertTSInterfaceBody(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSInterfaceBody", node, opts);
  }
  function assertTSTypeAliasDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTypeAliasDeclaration", node, opts);
  }
  function assertTSAsExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSAsExpression", node, opts);
  }
  function assertTSTypeAssertion(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTypeAssertion", node, opts);
  }
  function assertTSEnumDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSEnumDeclaration", node, opts);
  }
  function assertTSEnumMember(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSEnumMember", node, opts);
  }
  function assertTSModuleDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSModuleDeclaration", node, opts);
  }
  function assertTSModuleBlock(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSModuleBlock", node, opts);
  }
  function assertTSImportType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSImportType", node, opts);
  }
  function assertTSImportEqualsDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSImportEqualsDeclaration", node, opts);
  }
  function assertTSExternalModuleReference(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSExternalModuleReference", node, opts);
  }
  function assertTSNonNullExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSNonNullExpression", node, opts);
  }
  function assertTSExportAssignment(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSExportAssignment", node, opts);
  }
  function assertTSNamespaceExportDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSNamespaceExportDeclaration", node, opts);
  }
  function assertTSTypeAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTypeAnnotation", node, opts);
  }
  function assertTSTypeParameterInstantiation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTypeParameterInstantiation", node, opts);
  }
  function assertTSTypeParameterDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTypeParameterDeclaration", node, opts);
  }
  function assertTSTypeParameter(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTypeParameter", node, opts);
  }
  function assertExpression(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Expression", node, opts);
  }
  function assertBinary(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Binary", node, opts);
  }
  function assertScopable(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Scopable", node, opts);
  }
  function assertBlockParent(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("BlockParent", node, opts);
  }
  function assertBlock(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Block", node, opts);
  }
  function assertStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Statement", node, opts);
  }
  function assertTerminatorless(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Terminatorless", node, opts);
  }
  function assertCompletionStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("CompletionStatement", node, opts);
  }
  function assertConditional(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Conditional", node, opts);
  }
  function assertLoop(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Loop", node, opts);
  }
  function assertWhile(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("While", node, opts);
  }
  function assertExpressionWrapper(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ExpressionWrapper", node, opts);
  }
  function assertFor(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("For", node, opts);
  }
  function assertForXStatement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ForXStatement", node, opts);
  }
  function assertFunction(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Function", node, opts);
  }
  function assertFunctionParent(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("FunctionParent", node, opts);
  }
  function assertPureish(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Pureish", node, opts);
  }
  function assertDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Declaration", node, opts);
  }
  function assertPatternLike(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("PatternLike", node, opts);
  }
  function assertLVal(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("LVal", node, opts);
  }
  function assertTSEntityName(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSEntityName", node, opts);
  }
  function assertLiteral(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Literal", node, opts);
  }
  function assertImmutable(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Immutable", node, opts);
  }
  function assertUserWhitespacable(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("UserWhitespacable", node, opts);
  }
  function assertMethod(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Method", node, opts);
  }
  function assertObjectMember(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ObjectMember", node, opts);
  }
  function assertProperty(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Property", node, opts);
  }
  function assertUnaryLike(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("UnaryLike", node, opts);
  }
  function assertPattern(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Pattern", node, opts);
  }
  function assertClass(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Class", node, opts);
  }
  function assertModuleDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ModuleDeclaration", node, opts);
  }
  function assertExportDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ExportDeclaration", node, opts);
  }
  function assertModuleSpecifier(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("ModuleSpecifier", node, opts);
  }
  function assertFlow(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Flow", node, opts);
  }
  function assertFlowType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("FlowType", node, opts);
  }
  function assertFlowBaseAnnotation(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("FlowBaseAnnotation", node, opts);
  }
  function assertFlowDeclaration(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("FlowDeclaration", node, opts);
  }
  function assertFlowPredicate(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("FlowPredicate", node, opts);
  }
  function assertEnumBody(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EnumBody", node, opts);
  }
  function assertEnumMember(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("EnumMember", node, opts);
  }
  function assertJSX(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("JSX", node, opts);
  }
  function assertPrivate(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("Private", node, opts);
  }
  function assertTSTypeElement(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSTypeElement", node, opts);
  }
  function assertTSType(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    assert("TSType", node, opts);
  }
  function assertNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    assert("NumberLiteral", node, opts);
  }
  function assertRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    assert("RegexLiteral", node, opts);
  }
  function assertRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    assert("RestProperty", node, opts);
  }
  function assertSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    assert("SpreadProperty", node, opts);
  }

  function createTypeAnnotationBasedOnTypeof(type) {
    if (type === "string") {
      return StringTypeAnnotation();
    } else if (type === "number") {
      return NumberTypeAnnotation();
    } else if (type === "undefined") {
      return VoidTypeAnnotation();
    } else if (type === "boolean") {
      return BooleanTypeAnnotation();
    } else if (type === "function") {
      return GenericTypeAnnotation(Identifier("Function"));
    } else if (type === "object") {
      return GenericTypeAnnotation(Identifier("Object"));
    } else if (type === "symbol") {
      return GenericTypeAnnotation(Identifier("Symbol"));
    } else {
      throw new Error("Invalid typeof value");
    }
  }

  function removeTypeDuplicates(nodes) {
    var generics = {};
    var bases = {};
    var typeGroups = [];
    var types = [];

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) continue;

      if (types.indexOf(node) >= 0) {
        continue;
      }

      if (isAnyTypeAnnotation(node)) {
        return [node];
      }

      if (isFlowBaseAnnotation(node)) {
        bases[node.type] = node;
        continue;
      }

      if (isUnionTypeAnnotation(node)) {
        if (typeGroups.indexOf(node.types) < 0) {
          nodes = nodes.concat(node.types);
          typeGroups.push(node.types);
        }

        continue;
      }

      if (isGenericTypeAnnotation(node)) {
        var name = node.id.name;

        if (generics[name]) {
          var existing = generics[name];

          if (existing.typeParameters) {
            if (node.typeParameters) {
              existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics[name] = node;
        }

        continue;
      }

      types.push(node);
    }

    for (var _i = 0, _Object$keys = Object.keys(bases); _i < _Object$keys.length; _i++) {
      var type = _Object$keys[_i];
      types.push(bases[type]);
    }

    for (var _i2 = 0, _Object$keys2 = Object.keys(generics); _i2 < _Object$keys2.length; _i2++) {
      var _name = _Object$keys2[_i2];
      types.push(generics[_name]);
    }

    return types;
  }

  function createUnionTypeAnnotation(types) {
    var flattened = removeTypeDuplicates(types);

    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return UnionTypeAnnotation(flattened);
    }
  }

  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  function cloneIfNode(obj, deep, withoutLoc) {
    if (obj && typeof obj.type === "string") {
      return cloneNode(obj, deep, withoutLoc);
    }

    return obj;
  }

  function cloneIfNodeOrArray(obj, deep, withoutLoc) {
    if (Array.isArray(obj)) {
      return obj.map(function (node) {
        return cloneIfNode(node, deep, withoutLoc);
      });
    }

    return cloneIfNode(obj, deep, withoutLoc);
  }

  function cloneNode(node, deep, withoutLoc) {
    if (deep === void 0) {
      deep = true;
    }

    if (withoutLoc === void 0) {
      withoutLoc = false;
    }

    if (!node) return node;
    var type = node.type;
    var newNode = {
      type: type
    };

    if (type === "Identifier") {
      newNode.name = node.name;

      if (has(node, "optional") && typeof node.optional === "boolean") {
        newNode.optional = node.optional;
      }

      if (has(node, "typeAnnotation")) {
        newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
      }
    } else if (!has(NODE_FIELDS, type)) {
      throw new Error("Unknown node type: \"" + type + "\"");
    } else {
      for (var _i = 0, _Object$keys = Object.keys(NODE_FIELDS[type]); _i < _Object$keys.length; _i++) {
        var field = _Object$keys[_i];

        if (has(node, field)) {
          if (deep) {
            newNode[field] = type === "File" && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
          } else {
            newNode[field] = node[field];
          }
        }
      }
    }

    if (has(node, "loc")) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node.loc;
      }
    }

    if (has(node, "leadingComments")) {
      newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
    }

    if (has(node, "innerComments")) {
      newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
    }

    if (has(node, "trailingComments")) {
      newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
    }

    if (has(node, "extra")) {
      newNode.extra = Object.assign({}, node.extra);
    }

    return newNode;
  }

  function cloneCommentsWithoutLoc(comments) {
    return comments.map(function (_ref) {
      var type = _ref.type,
          value = _ref.value;
      return {
        type: type,
        value: value,
        loc: null
      };
    });
  }

  function maybeCloneComments(comments, deep, withoutLoc) {
    return deep && withoutLoc ? cloneCommentsWithoutLoc(comments) : comments;
  }

  function clone$1(node) {
    return cloneNode(node, false);
  }

  function cloneDeep(node) {
    return cloneNode(node);
  }

  function cloneDeepWithoutLoc(node) {
    return cloneNode(node, true, true);
  }

  function cloneWithoutLoc(node) {
    return cloneNode(node, false, true);
  }

  function addComments(node, type, comments) {
    if (!comments || !node) return node;
    var key = type + "Comments";

    if (node[key]) {
      if (type === "leading") {
        node[key] = comments.concat(node[key]);
      } else {
        node[key] = node[key].concat(comments);
      }
    } else {
      node[key] = comments;
    }

    return node;
  }

  function addComment(node, type, content, line) {
    return addComments(node, type, [{
      type: line ? "CommentLine" : "CommentBlock",
      value: content
    }]);
  }

  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);

    return this;
  }

  var _setCacheAdd = setCacheAdd;

  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;

  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
    this.__data__ = new _MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  }

  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;
  var _SetCache = SetCache;

  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }

    return -1;
  }

  var _baseFindIndex = baseFindIndex;

  function baseIsNaN(value) {
    return value !== value;
  }

  var _baseIsNaN = baseIsNaN;

  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }

    return -1;
  }

  var _strictIndexOf = strictIndexOf;

  function baseIndexOf(array, value, fromIndex) {
    return value === value ? _strictIndexOf(array, value, fromIndex) : _baseFindIndex(array, _baseIsNaN, fromIndex);
  }

  var _baseIndexOf = baseIndexOf;

  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && _baseIndexOf(array, value, 0) > -1;
  }

  var _arrayIncludes = arrayIncludes;

  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }

    return false;
  }

  var _arrayIncludesWith = arrayIncludesWith;

  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;

  function noop$1() {}

  var noop_1 = noop$1;

  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray;

  var INFINITY = 1 / 0;
  var createSet = !(_Set && 1 / _setToArray(new _Set([, -0]))[1] == INFINITY) ? noop_1 : function (values) {
    return new _Set(values);
  };
  var _createSet = createSet;

  var LARGE_ARRAY_SIZE$1 = 200;

  function baseUniq(array, iteratee, comparator) {
    var index = -1,
        includes = _arrayIncludes,
        length = array.length,
        isCommon = true,
        result = [],
        seen = result;

    if (comparator) {
      isCommon = false;
      includes = _arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE$1) {
      var set = iteratee ? null : _createSet(array);

      if (set) {
        return _setToArray(set);
      }

      isCommon = false;
      includes = _cacheHas;
      seen = new _SetCache();
    } else {
      seen = iteratee ? [] : result;
    }

    outer: while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;

      if (isCommon && computed === computed) {
        var seenIndex = seen.length;

        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }

        if (iteratee) {
          seen.push(computed);
        }

        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }

        result.push(value);
      }
    }

    return result;
  }

  var _baseUniq = baseUniq;

  function uniq(array) {
    return array && array.length ? _baseUniq(array) : [];
  }

  var uniq_1 = uniq;

  function inherit(key, child, parent) {
    if (child && parent) {
      child[key] = uniq_1([].concat(child[key], parent[key]).filter(Boolean));
    }
  }

  function inheritInnerComments(child, parent) {
    inherit("innerComments", child, parent);
  }

  function inheritLeadingComments(child, parent) {
    inherit("leadingComments", child, parent);
  }

  function inheritTrailingComments(child, parent) {
    inherit("trailingComments", child, parent);
  }

  function inheritsComments(child, parent) {
    inheritTrailingComments(child, parent);
    inheritLeadingComments(child, parent);
    inheritInnerComments(child, parent);
    return child;
  }

  function removeComments(node) {
    COMMENT_KEYS.forEach(function (key) {
      node[key] = null;
    });
    return node;
  }

  var EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS["Expression"];
  var BINARY_TYPES = FLIPPED_ALIAS_KEYS["Binary"];
  var SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS["Scopable"];
  var BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS["BlockParent"];
  var BLOCK_TYPES = FLIPPED_ALIAS_KEYS["Block"];
  var STATEMENT_TYPES = FLIPPED_ALIAS_KEYS["Statement"];
  var TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS["Terminatorless"];
  var COMPLETIONSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS["CompletionStatement"];
  var CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS["Conditional"];
  var LOOP_TYPES = FLIPPED_ALIAS_KEYS["Loop"];
  var WHILE_TYPES = FLIPPED_ALIAS_KEYS["While"];
  var EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
  var FOR_TYPES = FLIPPED_ALIAS_KEYS["For"];
  var FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS["ForXStatement"];
  var FUNCTION_TYPES = FLIPPED_ALIAS_KEYS["Function"];
  var FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS["FunctionParent"];
  var PUREISH_TYPES = FLIPPED_ALIAS_KEYS["Pureish"];
  var DECLARATION_TYPES = FLIPPED_ALIAS_KEYS["Declaration"];
  var PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS["PatternLike"];
  var LVAL_TYPES = FLIPPED_ALIAS_KEYS["LVal"];
  var TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS["TSEntityName"];
  var LITERAL_TYPES = FLIPPED_ALIAS_KEYS["Literal"];
  var IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS["Immutable"];
  var USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS["UserWhitespacable"];
  var METHOD_TYPES = FLIPPED_ALIAS_KEYS["Method"];
  var OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS["ObjectMember"];
  var PROPERTY_TYPES = FLIPPED_ALIAS_KEYS["Property"];
  var UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS["UnaryLike"];
  var PATTERN_TYPES = FLIPPED_ALIAS_KEYS["Pattern"];
  var CLASS_TYPES = FLIPPED_ALIAS_KEYS["Class"];
  var MODULEDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
  var EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["ExportDeclaration"];
  var MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
  var FLOW_TYPES = FLIPPED_ALIAS_KEYS["Flow"];
  var FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS["FlowType"];
  var FLOWBASEANNOTATION_TYPES = FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
  var FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["FlowDeclaration"];
  var FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS["FlowPredicate"];
  var ENUMBODY_TYPES = FLIPPED_ALIAS_KEYS["EnumBody"];
  var ENUMMEMBER_TYPES = FLIPPED_ALIAS_KEYS["EnumMember"];
  var JSX_TYPES = FLIPPED_ALIAS_KEYS["JSX"];
  var PRIVATE_TYPES = FLIPPED_ALIAS_KEYS["Private"];
  var TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS["TSTypeElement"];
  var TSTYPE_TYPES = FLIPPED_ALIAS_KEYS["TSType"];

  function toBlock(node, parent) {
    if (isBlockStatement(node)) {
      return node;
    }

    var blockNodes = [];

    if (isEmptyStatement(node)) {
      blockNodes = [];
    } else {
      if (!isStatement(node)) {
        if (isFunction(parent)) {
          node = ReturnStatement(node);
        } else {
          node = ExpressionStatement(node);
        }
      }

      blockNodes = [node];
    }

    return BlockStatement(blockNodes);
  }

  function ensureBlock(node, key) {
    if (key === void 0) {
      key = "body";
    }

    return node[key] = toBlock(node[key], node);
  }

  function toIdentifier(name) {
    name = name + "";
    name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function (match, c) {
      return c ? c.toUpperCase() : "";
    });

    if (!isValidIdentifier(name)) {
      name = "_" + name;
    }

    return name || "_";
  }

  function toBindingIdentifierName(name) {
    name = toIdentifier(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
  }

  function toComputedKey(node, key) {
    if (key === void 0) {
      key = node.key || node.property;
    }

    if (!node.computed && isIdentifier(key)) key = StringLiteral(key.name);
    return key;
  }

  function toExpression(node) {
    if (isExpressionStatement(node)) {
      node = node.expression;
    }

    if (isExpression(node)) {
      return node;
    }

    if (isClass(node)) {
      node.type = "ClassExpression";
    } else if (isFunction(node)) {
      node.type = "FunctionExpression";
    }

    if (!isExpression(node)) {
      throw new Error("cannot turn " + node.type + " to an expression");
    }

    return node;
  }

  function traverseFast(node, enter, opts) {
    if (!node) return;
    var keys = VISITOR_KEYS[node.type];
    if (!keys) return;
    opts = opts || {};
    enter(node, opts);

    for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var key = _ref;
      var subNode = node[key];

      if (Array.isArray(subNode)) {
        for (var _iterator2 = subNode, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
          var _ref2;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
          }

          var _node = _ref2;
          traverseFast(_node, enter, opts);
        }
      } else {
        traverseFast(subNode, enter, opts);
      }
    }
  }

  var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
  var CLEAR_KEYS_PLUS_COMMENTS = COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);
  function removeProperties(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

    for (var _iterator = map, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var key = _ref;
      if (node[key] != null) node[key] = undefined;
    }

    for (var _i2 = 0, _Object$keys = Object.keys(node); _i2 < _Object$keys.length; _i2++) {
      var _key = _Object$keys[_i2];
      if (_key[0] === "_" && node[_key] != null) node[_key] = undefined;
    }

    var symbols = Object.getOwnPropertySymbols(node);

    for (var _iterator2 = symbols, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i3 >= _iterator2.length) break;
        _ref2 = _iterator2[_i3++];
      } else {
        _i3 = _iterator2.next();
        if (_i3.done) break;
        _ref2 = _i3.value;
      }

      var sym = _ref2;
      node[sym] = null;
    }
  }

  function removePropertiesDeep(tree, opts) {
    traverseFast(tree, removeProperties, opts);
    return tree;
  }

  function toKeyAlias(node, key) {
    if (key === void 0) {
      key = node.key;
    }

    var alias;

    if (node.kind === "method") {
      return toKeyAlias.increment() + "";
    } else if (isIdentifier(key)) {
      alias = key.name;
    } else if (isStringLiteral(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify(removePropertiesDeep(cloneNode(key)));
    }

    if (node.computed) {
      alias = "[" + alias + "]";
    }

    if (node["static"]) {
      alias = "static:" + alias;
    }

    return alias;
  }
  toKeyAlias.uid = 0;

  toKeyAlias.increment = function () {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
      return toKeyAlias.uid = 0;
    } else {
      return toKeyAlias.uid++;
    }
  };

  function getBindingIdentifiers(node, duplicates, outerOnly) {
    var search = [].concat(node);
    var ids = Object.create(null);

    while (search.length) {
      var id = search.shift();
      if (!id) continue;
      var keys = getBindingIdentifiers.keys[id.type];

      if (isIdentifier(id)) {
        if (duplicates) {
          var _ids = ids[id.name] = ids[id.name] || [];

          _ids.push(id);
        } else {
          ids[id.name] = id;
        }

        continue;
      }

      if (isExportDeclaration(id)) {
        if (isDeclaration(id.declaration)) {
          search.push(id.declaration);
        }

        continue;
      }

      if (outerOnly) {
        if (isFunctionDeclaration(id)) {
          search.push(id.id);
          continue;
        }

        if (isFunctionExpression(id)) {
          continue;
        }
      }

      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (id[key]) {
            search = search.concat(id[key]);
          }
        }
      }
    }

    return ids;
  }
  getBindingIdentifiers.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };

  function gatherSequenceExpressions(nodes, scope, declars) {
    var exprs = [];
    var ensureLastUndefined = true;

    for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var node = _ref;
      ensureLastUndefined = false;

      if (isExpression(node)) {
        exprs.push(node);
      } else if (isExpressionStatement(node)) {
        exprs.push(node.expression);
      } else if (isVariableDeclaration(node)) {
        if (node.kind !== "var") return;

        for (var _i2 = 0, _arr = node.declarations; _i2 < _arr.length; _i2++) {
          var declar = _arr[_i2];
          var bindings = getBindingIdentifiers(declar);

          for (var _i3 = 0, _Object$keys = Object.keys(bindings); _i3 < _Object$keys.length; _i3++) {
            var key = _Object$keys[_i3];
            declars.push({
              kind: node.kind,
              id: cloneNode(bindings[key])
            });
          }

          if (declar.init) {
            exprs.push(AssignmentExpression("=", declar.id, declar.init));
          }
        }

        ensureLastUndefined = true;
      } else if (isIfStatement(node)) {
        var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
        var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
        if (!consequent || !alternate) return;
        exprs.push(ConditionalExpression(node.test, consequent, alternate));
      } else if (isBlockStatement(node)) {
        var body = gatherSequenceExpressions(node.body, scope, declars);
        if (!body) return;
        exprs.push(body);
      } else if (isEmptyStatement(node)) {
        ensureLastUndefined = true;
      } else {
        return;
      }
    }

    if (ensureLastUndefined) {
      exprs.push(scope.buildUndefinedNode());
    }

    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return SequenceExpression(exprs);
    }
  }

  function toSequenceExpression(nodes, scope) {
    if (!nodes || !nodes.length) return;
    var declars = [];
    var result = gatherSequenceExpressions(nodes, scope, declars);
    if (!result) return;

    for (var _i = 0, _declars = declars; _i < _declars.length; _i++) {
      var declar = _declars[_i];
      scope.push(declar);
    }

    return result;
  }

  function toStatement(node, ignore) {
    if (isStatement(node)) {
      return node;
    }

    var mustHaveId = false;
    var newType;

    if (isClass(node)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if (isFunction(node)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if (isAssignmentExpression(node)) {
      return ExpressionStatement(node);
    }

    if (mustHaveId && !node.id) {
      newType = false;
    }

    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error("cannot turn " + node.type + " to a statement");
      }
    }

    node.type = newType;
    return node;
  }

  var objectTag$3 = '[object Object]';
  var funcProto$2 = Function.prototype,
      objectProto$d = Object.prototype;
  var funcToString$2 = funcProto$2.toString;
  var hasOwnProperty$a = objectProto$d.hasOwnProperty;
  var objectCtorString = funcToString$2.call(Object);

  function isPlainObject(value) {
    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$3) {
      return false;
    }

    var proto = _getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty$a.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
  }

  var isPlainObject_1 = isPlainObject;

  var regexpTag$3 = '[object RegExp]';

  function baseIsRegExp(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == regexpTag$3;
  }

  var _baseIsRegExp = baseIsRegExp;

  var nodeIsRegExp = _nodeUtil && _nodeUtil.isRegExp;
  var isRegExp = nodeIsRegExp ? _baseUnary(nodeIsRegExp) : _baseIsRegExp;
  var isRegExp_1 = isRegExp;

  function valueToNode(value) {
    if (value === undefined) {
      return Identifier("undefined");
    }

    if (value === true || value === false) {
      return BooleanLiteral(value);
    }

    if (value === null) {
      return NullLiteral();
    }

    if (typeof value === "string") {
      return StringLiteral(value);
    }

    if (typeof value === "number") {
      var result;

      if (Number.isFinite(value)) {
        result = NumericLiteral(Math.abs(value));
      } else {
        var numerator;

        if (Number.isNaN(value)) {
          numerator = NumericLiteral(0);
        } else {
          numerator = NumericLiteral(1);
        }

        result = BinaryExpression("/", numerator, NumericLiteral(0));
      }

      if (value < 0 || Object.is(value, -0)) {
        result = UnaryExpression("-", result);
      }

      return result;
    }

    if (isRegExp_1(value)) {
      var pattern = value.source;
      var flags = value.toString().match(/\/([a-z]+|)$/)[1];
      return RegExpLiteral(pattern, flags);
    }

    if (Array.isArray(value)) {
      return ArrayExpression(value.map(valueToNode));
    }

    if (isPlainObject_1(value)) {
      var props = [];

      for (var _i = 0, _Object$keys = Object.keys(value); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var nodeKey = void 0;

        if (isValidIdentifier(key)) {
          nodeKey = Identifier(key);
        } else {
          nodeKey = StringLiteral(key);
        }

        props.push(ObjectProperty(nodeKey, valueToNode(value[key])));
      }

      return ObjectExpression(props);
    }

    throw new Error("don't know how to turn this value into a node");
  }

  function appendToMemberExpression(member, append, computed) {
    if (computed === void 0) {
      computed = false;
    }

    member.object = MemberExpression(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
  }

  function inherits(child, parent) {
    if (!child || !parent) return child;

    for (var _i = 0, _arr = INHERIT_KEYS.optional; _i < _arr.length; _i++) {
      var key = _arr[_i];

      if (child[key] == null) {
        child[key] = parent[key];
      }
    }

    for (var _i2 = 0, _Object$keys = Object.keys(parent); _i2 < _Object$keys.length; _i2++) {
      var _key = _Object$keys[_i2];
      if (_key[0] === "_" && _key !== "__clone") child[_key] = parent[_key];
    }

    for (var _i3 = 0, _arr2 = INHERIT_KEYS.force; _i3 < _arr2.length; _i3++) {
      var _key2 = _arr2[_i3];
      child[_key2] = parent[_key2];
    }

    inheritsComments(child, parent);
    return child;
  }

  function prependToMemberExpression(member, prepend) {
    member.object = MemberExpression(prepend, member.object);
    return member;
  }

  function getOuterBindingIdentifiers(node, duplicates) {
    return getBindingIdentifiers(node, duplicates, true);
  }

  function traverse(node, handlers, state) {
    if (typeof handlers === "function") {
      handlers = {
        enter: handlers
      };
    }

    var _ref = handlers,
        enter = _ref.enter,
        exit = _ref.exit;
    traverseSimpleImpl(node, enter, exit, state, []);
  }

  function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    var keys = VISITOR_KEYS[node.type];
    if (!keys) return;
    if (enter) enter(node, ancestors, state);

    for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref2 = _i.value;
      }

      var key = _ref2;
      var subNode = node[key];

      if (Array.isArray(subNode)) {
        for (var i = 0; i < subNode.length; i++) {
          var child = subNode[i];
          if (!child) continue;
          ancestors.push({
            node: node,
            key: key,
            index: i
          });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({
          node: node,
          key: key
        });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }

    if (exit) exit(node, ancestors, state);
  }

  function isBinding(node, parent, grandparent) {
    if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
      return false;
    }

    var keys = getBindingIdentifiers.keys[parent.type];

    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = parent[key];

        if (Array.isArray(val)) {
          if (val.indexOf(node) >= 0) return true;
        } else {
          if (val === node) return true;
        }
      }
    }

    return false;
  }

  function isLet(node) {
    return isVariableDeclaration(node) && (node.kind !== "var" || node[BLOCK_SCOPED_SYMBOL]);
  }

  function isBlockScoped(node) {
    return isFunctionDeclaration(node) || isClassDeclaration(node) || isLet(node);
  }

  function isImmutable(node) {
    if (isType(node.type, "Immutable")) return true;

    if (isIdentifier(node)) {
      if (node.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }

    return false;
  }

  function isNodesEquivalent(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
      return a === b;
    }

    if (a.type !== b.type) {
      return false;
    }

    var fields = Object.keys(NODE_FIELDS[a.type] || a.type);
    var visitorKeys = VISITOR_KEYS[a.type];

    for (var _i = 0, _fields = fields; _i < _fields.length; _i++) {
      var field = _fields[_i];

      if (typeof a[field] !== typeof b[field]) {
        return false;
      }

      if (a[field] == null && b[field] == null) {
        continue;
      } else if (a[field] == null || b[field] == null) {
        return false;
      }

      if (Array.isArray(a[field])) {
        if (!Array.isArray(b[field])) {
          return false;
        }

        if (a[field].length !== b[field].length) {
          return false;
        }

        for (var i = 0; i < a[field].length; i++) {
          if (!isNodesEquivalent(a[field][i], b[field][i])) {
            return false;
          }
        }

        continue;
      }

      if (typeof a[field] === "object" && (!visitorKeys || !visitorKeys.includes(field))) {
        for (var _i2 = 0, _Object$keys = Object.keys(a[field]); _i2 < _Object$keys.length; _i2++) {
          var key = _Object$keys[_i2];

          if (a[field][key] !== b[field][key]) {
            return false;
          }
        }

        continue;
      }

      if (!isNodesEquivalent(a[field], b[field])) {
        return false;
      }
    }

    return true;
  }

  function isReferenced(node, parent, grandparent) {
    switch (parent.type) {
      case "MemberExpression":
      case "JSXMemberExpression":
      case "OptionalMemberExpression":
        if (parent.property === node) {
          return !!parent.computed;
        }

        return parent.object === node;

      case "VariableDeclarator":
        return parent.init === node;

      case "ArrowFunctionExpression":
        return parent.body === node;

      case "ExportSpecifier":
        if (parent.source) {
          return false;
        }

        return parent.local === node;

      case "PrivateName":
        return false;

      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (parent.params.includes(node)) {
          return false;
        }

      case "ObjectProperty":
      case "ClassProperty":
      case "ClassPrivateProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }

        if (parent.value === node) {
          return !grandparent || grandparent.type !== "ObjectPattern";
        }

        return true;

      case "ClassDeclaration":
      case "ClassExpression":
        return parent.superClass === node;

      case "AssignmentExpression":
        return parent.right === node;

      case "AssignmentPattern":
        return parent.right === node;

      case "LabeledStatement":
        return false;

      case "CatchClause":
        return false;

      case "RestElement":
        return false;

      case "BreakStatement":
      case "ContinueStatement":
        return false;

      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;

      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;

      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;

      case "JSXAttribute":
        return false;

      case "ObjectPattern":
      case "ArrayPattern":
        return false;

      case "MetaProperty":
        return false;

      case "ObjectTypeProperty":
        return parent.key !== node;

      case "TSEnumMember":
        return parent.id !== node;

      case "TSPropertySignature":
        if (parent.key === node) {
          return !!parent.computed;
        }

        return true;
    }

    return true;
  }

  function isScope(node, parent) {
    if (isBlockStatement(node) && isFunction(parent, {
      body: node
    })) {
      return false;
    }

    if (isBlockStatement(node) && isCatchClause(parent, {
      body: node
    })) {
      return false;
    }

    if (isPattern(node) && isFunction(parent)) {
      return true;
    }

    return isScopable(node);
  }

  function isSpecifierDefault(specifier) {
    return isImportDefaultSpecifier(specifier) || isIdentifier(specifier.imported || specifier.exported, {
      name: "default"
    });
  }

  var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
  function isValidES3Identifier(name) {
    return isValidIdentifier(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
  }

  function isVar(node) {
    return isVariableDeclaration(node, {
      kind: "var"
    }) && !node[BLOCK_SCOPED_SYMBOL];
  }

  var react = {
    isReactComponent: isReactComponent,
    isCompatTag: isCompatTag,
    buildChildren: buildChildren
  };

  var t = /*#__PURE__*/Object.freeze({
    __proto__: null,
    react: react,
    assertNode: assertNode,
    createTypeAnnotationBasedOnTypeof: createTypeAnnotationBasedOnTypeof,
    createUnionTypeAnnotation: createUnionTypeAnnotation,
    cloneNode: cloneNode,
    clone: clone$1,
    cloneDeep: cloneDeep,
    cloneDeepWithoutLoc: cloneDeepWithoutLoc,
    cloneWithoutLoc: cloneWithoutLoc,
    addComment: addComment,
    addComments: addComments,
    inheritInnerComments: inheritInnerComments,
    inheritLeadingComments: inheritLeadingComments,
    inheritsComments: inheritsComments,
    inheritTrailingComments: inheritTrailingComments,
    removeComments: removeComments,
    ensureBlock: ensureBlock,
    toBindingIdentifierName: toBindingIdentifierName,
    toBlock: toBlock,
    toComputedKey: toComputedKey,
    toExpression: toExpression,
    toIdentifier: toIdentifier,
    toKeyAlias: toKeyAlias,
    toSequenceExpression: toSequenceExpression,
    toStatement: toStatement,
    valueToNode: valueToNode,
    appendToMemberExpression: appendToMemberExpression,
    inherits: inherits,
    prependToMemberExpression: prependToMemberExpression,
    removeProperties: removeProperties,
    removePropertiesDeep: removePropertiesDeep,
    removeTypeDuplicates: removeTypeDuplicates,
    getBindingIdentifiers: getBindingIdentifiers,
    getOuterBindingIdentifiers: getOuterBindingIdentifiers,
    traverse: traverse,
    traverseFast: traverseFast,
    shallowEqual: shallowEqual,
    is: is,
    isBinding: isBinding,
    isBlockScoped: isBlockScoped,
    isImmutable: isImmutable,
    isLet: isLet,
    isNode: isNode,
    isNodesEquivalent: isNodesEquivalent,
    isPlaceholderType: isPlaceholderType,
    isReferenced: isReferenced,
    isScope: isScope,
    isSpecifierDefault: isSpecifierDefault,
    isType: isType,
    isValidES3Identifier: isValidES3Identifier,
    isValidIdentifier: isValidIdentifier,
    isVar: isVar,
    matchesPattern: matchesPattern,
    validate: validate,
    buildMatchMemberExpression: buildMatchMemberExpression,
    assertArrayExpression: assertArrayExpression,
    assertAssignmentExpression: assertAssignmentExpression,
    assertBinaryExpression: assertBinaryExpression,
    assertInterpreterDirective: assertInterpreterDirective,
    assertDirective: assertDirective,
    assertDirectiveLiteral: assertDirectiveLiteral,
    assertBlockStatement: assertBlockStatement,
    assertBreakStatement: assertBreakStatement,
    assertCallExpression: assertCallExpression,
    assertCatchClause: assertCatchClause,
    assertConditionalExpression: assertConditionalExpression,
    assertContinueStatement: assertContinueStatement,
    assertDebuggerStatement: assertDebuggerStatement,
    assertDoWhileStatement: assertDoWhileStatement,
    assertEmptyStatement: assertEmptyStatement,
    assertExpressionStatement: assertExpressionStatement,
    assertFile: assertFile,
    assertForInStatement: assertForInStatement,
    assertForStatement: assertForStatement,
    assertFunctionDeclaration: assertFunctionDeclaration,
    assertFunctionExpression: assertFunctionExpression,
    assertIdentifier: assertIdentifier,
    assertIfStatement: assertIfStatement,
    assertLabeledStatement: assertLabeledStatement,
    assertStringLiteral: assertStringLiteral,
    assertNumericLiteral: assertNumericLiteral,
    assertNullLiteral: assertNullLiteral,
    assertBooleanLiteral: assertBooleanLiteral,
    assertRegExpLiteral: assertRegExpLiteral,
    assertLogicalExpression: assertLogicalExpression,
    assertMemberExpression: assertMemberExpression,
    assertNewExpression: assertNewExpression,
    assertProgram: assertProgram,
    assertObjectExpression: assertObjectExpression,
    assertObjectMethod: assertObjectMethod,
    assertObjectProperty: assertObjectProperty,
    assertRestElement: assertRestElement,
    assertReturnStatement: assertReturnStatement,
    assertSequenceExpression: assertSequenceExpression,
    assertParenthesizedExpression: assertParenthesizedExpression,
    assertSwitchCase: assertSwitchCase,
    assertSwitchStatement: assertSwitchStatement,
    assertThisExpression: assertThisExpression,
    assertThrowStatement: assertThrowStatement,
    assertTryStatement: assertTryStatement,
    assertUnaryExpression: assertUnaryExpression,
    assertUpdateExpression: assertUpdateExpression,
    assertVariableDeclaration: assertVariableDeclaration,
    assertVariableDeclarator: assertVariableDeclarator,
    assertWhileStatement: assertWhileStatement,
    assertWithStatement: assertWithStatement,
    assertAssignmentPattern: assertAssignmentPattern,
    assertArrayPattern: assertArrayPattern,
    assertArrowFunctionExpression: assertArrowFunctionExpression,
    assertClassBody: assertClassBody,
    assertClassExpression: assertClassExpression,
    assertClassDeclaration: assertClassDeclaration,
    assertExportAllDeclaration: assertExportAllDeclaration,
    assertExportDefaultDeclaration: assertExportDefaultDeclaration,
    assertExportNamedDeclaration: assertExportNamedDeclaration,
    assertExportSpecifier: assertExportSpecifier,
    assertForOfStatement: assertForOfStatement,
    assertImportDeclaration: assertImportDeclaration,
    assertImportDefaultSpecifier: assertImportDefaultSpecifier,
    assertImportNamespaceSpecifier: assertImportNamespaceSpecifier,
    assertImportSpecifier: assertImportSpecifier,
    assertMetaProperty: assertMetaProperty,
    assertClassMethod: assertClassMethod,
    assertObjectPattern: assertObjectPattern,
    assertSpreadElement: assertSpreadElement,
    assertSuper: assertSuper,
    assertTaggedTemplateExpression: assertTaggedTemplateExpression,
    assertTemplateElement: assertTemplateElement,
    assertTemplateLiteral: assertTemplateLiteral,
    assertYieldExpression: assertYieldExpression,
    assertAnyTypeAnnotation: assertAnyTypeAnnotation,
    assertArrayTypeAnnotation: assertArrayTypeAnnotation,
    assertBooleanTypeAnnotation: assertBooleanTypeAnnotation,
    assertBooleanLiteralTypeAnnotation: assertBooleanLiteralTypeAnnotation,
    assertNullLiteralTypeAnnotation: assertNullLiteralTypeAnnotation,
    assertClassImplements: assertClassImplements,
    assertDeclareClass: assertDeclareClass,
    assertDeclareFunction: assertDeclareFunction,
    assertDeclareInterface: assertDeclareInterface,
    assertDeclareModule: assertDeclareModule,
    assertDeclareModuleExports: assertDeclareModuleExports,
    assertDeclareTypeAlias: assertDeclareTypeAlias,
    assertDeclareOpaqueType: assertDeclareOpaqueType,
    assertDeclareVariable: assertDeclareVariable,
    assertDeclareExportDeclaration: assertDeclareExportDeclaration,
    assertDeclareExportAllDeclaration: assertDeclareExportAllDeclaration,
    assertDeclaredPredicate: assertDeclaredPredicate,
    assertExistsTypeAnnotation: assertExistsTypeAnnotation,
    assertFunctionTypeAnnotation: assertFunctionTypeAnnotation,
    assertFunctionTypeParam: assertFunctionTypeParam,
    assertGenericTypeAnnotation: assertGenericTypeAnnotation,
    assertInferredPredicate: assertInferredPredicate,
    assertInterfaceExtends: assertInterfaceExtends,
    assertInterfaceDeclaration: assertInterfaceDeclaration,
    assertInterfaceTypeAnnotation: assertInterfaceTypeAnnotation,
    assertIntersectionTypeAnnotation: assertIntersectionTypeAnnotation,
    assertMixedTypeAnnotation: assertMixedTypeAnnotation,
    assertEmptyTypeAnnotation: assertEmptyTypeAnnotation,
    assertNullableTypeAnnotation: assertNullableTypeAnnotation,
    assertNumberLiteralTypeAnnotation: assertNumberLiteralTypeAnnotation,
    assertNumberTypeAnnotation: assertNumberTypeAnnotation,
    assertObjectTypeAnnotation: assertObjectTypeAnnotation,
    assertObjectTypeInternalSlot: assertObjectTypeInternalSlot,
    assertObjectTypeCallProperty: assertObjectTypeCallProperty,
    assertObjectTypeIndexer: assertObjectTypeIndexer,
    assertObjectTypeProperty: assertObjectTypeProperty,
    assertObjectTypeSpreadProperty: assertObjectTypeSpreadProperty,
    assertOpaqueType: assertOpaqueType,
    assertQualifiedTypeIdentifier: assertQualifiedTypeIdentifier,
    assertStringLiteralTypeAnnotation: assertStringLiteralTypeAnnotation,
    assertStringTypeAnnotation: assertStringTypeAnnotation,
    assertSymbolTypeAnnotation: assertSymbolTypeAnnotation,
    assertThisTypeAnnotation: assertThisTypeAnnotation,
    assertTupleTypeAnnotation: assertTupleTypeAnnotation,
    assertTypeofTypeAnnotation: assertTypeofTypeAnnotation,
    assertTypeAlias: assertTypeAlias,
    assertTypeAnnotation: assertTypeAnnotation,
    assertTypeCastExpression: assertTypeCastExpression,
    assertTypeParameter: assertTypeParameter,
    assertTypeParameterDeclaration: assertTypeParameterDeclaration,
    assertTypeParameterInstantiation: assertTypeParameterInstantiation,
    assertUnionTypeAnnotation: assertUnionTypeAnnotation,
    assertVariance: assertVariance,
    assertVoidTypeAnnotation: assertVoidTypeAnnotation,
    assertEnumDeclaration: assertEnumDeclaration,
    assertEnumBooleanBody: assertEnumBooleanBody,
    assertEnumNumberBody: assertEnumNumberBody,
    assertEnumStringBody: assertEnumStringBody,
    assertEnumSymbolBody: assertEnumSymbolBody,
    assertEnumBooleanMember: assertEnumBooleanMember,
    assertEnumNumberMember: assertEnumNumberMember,
    assertEnumStringMember: assertEnumStringMember,
    assertEnumDefaultedMember: assertEnumDefaultedMember,
    assertJSXAttribute: assertJSXAttribute,
    assertJSXClosingElement: assertJSXClosingElement,
    assertJSXElement: assertJSXElement,
    assertJSXEmptyExpression: assertJSXEmptyExpression,
    assertJSXExpressionContainer: assertJSXExpressionContainer,
    assertJSXSpreadChild: assertJSXSpreadChild,
    assertJSXIdentifier: assertJSXIdentifier,
    assertJSXMemberExpression: assertJSXMemberExpression,
    assertJSXNamespacedName: assertJSXNamespacedName,
    assertJSXOpeningElement: assertJSXOpeningElement,
    assertJSXSpreadAttribute: assertJSXSpreadAttribute,
    assertJSXText: assertJSXText,
    assertJSXFragment: assertJSXFragment,
    assertJSXOpeningFragment: assertJSXOpeningFragment,
    assertJSXClosingFragment: assertJSXClosingFragment,
    assertNoop: assertNoop,
    assertPlaceholder: assertPlaceholder,
    assertV8IntrinsicIdentifier: assertV8IntrinsicIdentifier,
    assertArgumentPlaceholder: assertArgumentPlaceholder,
    assertAwaitExpression: assertAwaitExpression,
    assertBindExpression: assertBindExpression,
    assertClassProperty: assertClassProperty,
    assertOptionalMemberExpression: assertOptionalMemberExpression,
    assertPipelineTopicExpression: assertPipelineTopicExpression,
    assertPipelineBareFunction: assertPipelineBareFunction,
    assertPipelinePrimaryTopicReference: assertPipelinePrimaryTopicReference,
    assertOptionalCallExpression: assertOptionalCallExpression,
    assertClassPrivateProperty: assertClassPrivateProperty,
    assertClassPrivateMethod: assertClassPrivateMethod,
    assertImport: assertImport,
    assertDecorator: assertDecorator,
    assertDoExpression: assertDoExpression,
    assertExportDefaultSpecifier: assertExportDefaultSpecifier,
    assertExportNamespaceSpecifier: assertExportNamespaceSpecifier,
    assertPrivateName: assertPrivateName,
    assertBigIntLiteral: assertBigIntLiteral,
    assertRecordExpression: assertRecordExpression,
    assertTupleExpression: assertTupleExpression,
    assertTSParameterProperty: assertTSParameterProperty,
    assertTSDeclareFunction: assertTSDeclareFunction,
    assertTSDeclareMethod: assertTSDeclareMethod,
    assertTSQualifiedName: assertTSQualifiedName,
    assertTSCallSignatureDeclaration: assertTSCallSignatureDeclaration,
    assertTSConstructSignatureDeclaration: assertTSConstructSignatureDeclaration,
    assertTSPropertySignature: assertTSPropertySignature,
    assertTSMethodSignature: assertTSMethodSignature,
    assertTSIndexSignature: assertTSIndexSignature,
    assertTSAnyKeyword: assertTSAnyKeyword,
    assertTSBooleanKeyword: assertTSBooleanKeyword,
    assertTSBigIntKeyword: assertTSBigIntKeyword,
    assertTSNeverKeyword: assertTSNeverKeyword,
    assertTSNullKeyword: assertTSNullKeyword,
    assertTSNumberKeyword: assertTSNumberKeyword,
    assertTSObjectKeyword: assertTSObjectKeyword,
    assertTSStringKeyword: assertTSStringKeyword,
    assertTSSymbolKeyword: assertTSSymbolKeyword,
    assertTSUndefinedKeyword: assertTSUndefinedKeyword,
    assertTSUnknownKeyword: assertTSUnknownKeyword,
    assertTSVoidKeyword: assertTSVoidKeyword,
    assertTSThisType: assertTSThisType,
    assertTSFunctionType: assertTSFunctionType,
    assertTSConstructorType: assertTSConstructorType,
    assertTSTypeReference: assertTSTypeReference,
    assertTSTypePredicate: assertTSTypePredicate,
    assertTSTypeQuery: assertTSTypeQuery,
    assertTSTypeLiteral: assertTSTypeLiteral,
    assertTSArrayType: assertTSArrayType,
    assertTSTupleType: assertTSTupleType,
    assertTSOptionalType: assertTSOptionalType,
    assertTSRestType: assertTSRestType,
    assertTSUnionType: assertTSUnionType,
    assertTSIntersectionType: assertTSIntersectionType,
    assertTSConditionalType: assertTSConditionalType,
    assertTSInferType: assertTSInferType,
    assertTSParenthesizedType: assertTSParenthesizedType,
    assertTSTypeOperator: assertTSTypeOperator,
    assertTSIndexedAccessType: assertTSIndexedAccessType,
    assertTSMappedType: assertTSMappedType,
    assertTSLiteralType: assertTSLiteralType,
    assertTSExpressionWithTypeArguments: assertTSExpressionWithTypeArguments,
    assertTSInterfaceDeclaration: assertTSInterfaceDeclaration,
    assertTSInterfaceBody: assertTSInterfaceBody,
    assertTSTypeAliasDeclaration: assertTSTypeAliasDeclaration,
    assertTSAsExpression: assertTSAsExpression,
    assertTSTypeAssertion: assertTSTypeAssertion,
    assertTSEnumDeclaration: assertTSEnumDeclaration,
    assertTSEnumMember: assertTSEnumMember,
    assertTSModuleDeclaration: assertTSModuleDeclaration,
    assertTSModuleBlock: assertTSModuleBlock,
    assertTSImportType: assertTSImportType,
    assertTSImportEqualsDeclaration: assertTSImportEqualsDeclaration,
    assertTSExternalModuleReference: assertTSExternalModuleReference,
    assertTSNonNullExpression: assertTSNonNullExpression,
    assertTSExportAssignment: assertTSExportAssignment,
    assertTSNamespaceExportDeclaration: assertTSNamespaceExportDeclaration,
    assertTSTypeAnnotation: assertTSTypeAnnotation,
    assertTSTypeParameterInstantiation: assertTSTypeParameterInstantiation,
    assertTSTypeParameterDeclaration: assertTSTypeParameterDeclaration,
    assertTSTypeParameter: assertTSTypeParameter,
    assertExpression: assertExpression,
    assertBinary: assertBinary,
    assertScopable: assertScopable,
    assertBlockParent: assertBlockParent,
    assertBlock: assertBlock,
    assertStatement: assertStatement,
    assertTerminatorless: assertTerminatorless,
    assertCompletionStatement: assertCompletionStatement,
    assertConditional: assertConditional,
    assertLoop: assertLoop,
    assertWhile: assertWhile,
    assertExpressionWrapper: assertExpressionWrapper,
    assertFor: assertFor,
    assertForXStatement: assertForXStatement,
    assertFunction: assertFunction,
    assertFunctionParent: assertFunctionParent,
    assertPureish: assertPureish,
    assertDeclaration: assertDeclaration,
    assertPatternLike: assertPatternLike,
    assertLVal: assertLVal,
    assertTSEntityName: assertTSEntityName,
    assertLiteral: assertLiteral,
    assertImmutable: assertImmutable,
    assertUserWhitespacable: assertUserWhitespacable,
    assertMethod: assertMethod,
    assertObjectMember: assertObjectMember,
    assertProperty: assertProperty,
    assertUnaryLike: assertUnaryLike,
    assertPattern: assertPattern,
    assertClass: assertClass,
    assertModuleDeclaration: assertModuleDeclaration,
    assertExportDeclaration: assertExportDeclaration,
    assertModuleSpecifier: assertModuleSpecifier,
    assertFlow: assertFlow,
    assertFlowType: assertFlowType,
    assertFlowBaseAnnotation: assertFlowBaseAnnotation,
    assertFlowDeclaration: assertFlowDeclaration,
    assertFlowPredicate: assertFlowPredicate,
    assertEnumBody: assertEnumBody,
    assertEnumMember: assertEnumMember,
    assertJSX: assertJSX,
    assertPrivate: assertPrivate,
    assertTSTypeElement: assertTSTypeElement,
    assertTSType: assertTSType,
    assertNumberLiteral: assertNumberLiteral,
    assertRegexLiteral: assertRegexLiteral,
    assertRestProperty: assertRestProperty,
    assertSpreadProperty: assertSpreadProperty,
    ArrayExpression: ArrayExpression,
    arrayExpression: ArrayExpression,
    AssignmentExpression: AssignmentExpression,
    assignmentExpression: AssignmentExpression,
    BinaryExpression: BinaryExpression,
    binaryExpression: BinaryExpression,
    InterpreterDirective: InterpreterDirective,
    interpreterDirective: InterpreterDirective,
    Directive: Directive,
    directive: Directive,
    DirectiveLiteral: DirectiveLiteral,
    directiveLiteral: DirectiveLiteral,
    BlockStatement: BlockStatement,
    blockStatement: BlockStatement,
    BreakStatement: BreakStatement,
    breakStatement: BreakStatement,
    CallExpression: CallExpression,
    callExpression: CallExpression,
    CatchClause: CatchClause,
    catchClause: CatchClause,
    ConditionalExpression: ConditionalExpression,
    conditionalExpression: ConditionalExpression,
    ContinueStatement: ContinueStatement,
    continueStatement: ContinueStatement,
    DebuggerStatement: DebuggerStatement,
    debuggerStatement: DebuggerStatement,
    DoWhileStatement: DoWhileStatement,
    doWhileStatement: DoWhileStatement,
    EmptyStatement: EmptyStatement,
    emptyStatement: EmptyStatement,
    ExpressionStatement: ExpressionStatement,
    expressionStatement: ExpressionStatement,
    File: File,
    file: File,
    ForInStatement: ForInStatement,
    forInStatement: ForInStatement,
    ForStatement: ForStatement,
    forStatement: ForStatement,
    FunctionDeclaration: FunctionDeclaration,
    functionDeclaration: FunctionDeclaration,
    FunctionExpression: FunctionExpression,
    functionExpression: FunctionExpression,
    Identifier: Identifier,
    identifier: Identifier,
    IfStatement: IfStatement,
    ifStatement: IfStatement,
    LabeledStatement: LabeledStatement,
    labeledStatement: LabeledStatement,
    StringLiteral: StringLiteral,
    stringLiteral: StringLiteral,
    NumericLiteral: NumericLiteral,
    numericLiteral: NumericLiteral,
    NullLiteral: NullLiteral,
    nullLiteral: NullLiteral,
    BooleanLiteral: BooleanLiteral,
    booleanLiteral: BooleanLiteral,
    RegExpLiteral: RegExpLiteral,
    regExpLiteral: RegExpLiteral,
    LogicalExpression: LogicalExpression,
    logicalExpression: LogicalExpression,
    MemberExpression: MemberExpression,
    memberExpression: MemberExpression,
    NewExpression: NewExpression,
    newExpression: NewExpression,
    Program: Program,
    program: Program,
    ObjectExpression: ObjectExpression,
    objectExpression: ObjectExpression,
    ObjectMethod: ObjectMethod,
    objectMethod: ObjectMethod,
    ObjectProperty: ObjectProperty,
    objectProperty: ObjectProperty,
    RestElement: RestElement,
    restElement: RestElement,
    ReturnStatement: ReturnStatement,
    returnStatement: ReturnStatement,
    SequenceExpression: SequenceExpression,
    sequenceExpression: SequenceExpression,
    ParenthesizedExpression: ParenthesizedExpression,
    parenthesizedExpression: ParenthesizedExpression,
    SwitchCase: SwitchCase,
    switchCase: SwitchCase,
    SwitchStatement: SwitchStatement,
    switchStatement: SwitchStatement,
    ThisExpression: ThisExpression,
    thisExpression: ThisExpression,
    ThrowStatement: ThrowStatement,
    throwStatement: ThrowStatement,
    TryStatement: TryStatement,
    tryStatement: TryStatement,
    UnaryExpression: UnaryExpression,
    unaryExpression: UnaryExpression,
    UpdateExpression: UpdateExpression,
    updateExpression: UpdateExpression,
    VariableDeclaration: VariableDeclaration,
    variableDeclaration: VariableDeclaration,
    VariableDeclarator: VariableDeclarator,
    variableDeclarator: VariableDeclarator,
    WhileStatement: WhileStatement,
    whileStatement: WhileStatement,
    WithStatement: WithStatement,
    withStatement: WithStatement,
    AssignmentPattern: AssignmentPattern,
    assignmentPattern: AssignmentPattern,
    ArrayPattern: ArrayPattern,
    arrayPattern: ArrayPattern,
    ArrowFunctionExpression: ArrowFunctionExpression,
    arrowFunctionExpression: ArrowFunctionExpression,
    ClassBody: ClassBody,
    classBody: ClassBody,
    ClassExpression: ClassExpression,
    classExpression: ClassExpression,
    ClassDeclaration: ClassDeclaration,
    classDeclaration: ClassDeclaration,
    ExportAllDeclaration: ExportAllDeclaration,
    exportAllDeclaration: ExportAllDeclaration,
    ExportDefaultDeclaration: ExportDefaultDeclaration,
    exportDefaultDeclaration: ExportDefaultDeclaration,
    ExportNamedDeclaration: ExportNamedDeclaration,
    exportNamedDeclaration: ExportNamedDeclaration,
    ExportSpecifier: ExportSpecifier,
    exportSpecifier: ExportSpecifier,
    ForOfStatement: ForOfStatement,
    forOfStatement: ForOfStatement,
    ImportDeclaration: ImportDeclaration,
    importDeclaration: ImportDeclaration,
    ImportDefaultSpecifier: ImportDefaultSpecifier,
    importDefaultSpecifier: ImportDefaultSpecifier,
    ImportNamespaceSpecifier: ImportNamespaceSpecifier,
    importNamespaceSpecifier: ImportNamespaceSpecifier,
    ImportSpecifier: ImportSpecifier,
    importSpecifier: ImportSpecifier,
    MetaProperty: MetaProperty,
    metaProperty: MetaProperty,
    ClassMethod: ClassMethod,
    classMethod: ClassMethod,
    ObjectPattern: ObjectPattern,
    objectPattern: ObjectPattern,
    SpreadElement: SpreadElement,
    spreadElement: SpreadElement,
    Super: Super,
    'super': Super,
    TaggedTemplateExpression: TaggedTemplateExpression,
    taggedTemplateExpression: TaggedTemplateExpression,
    TemplateElement: TemplateElement,
    templateElement: TemplateElement,
    TemplateLiteral: TemplateLiteral,
    templateLiteral: TemplateLiteral,
    YieldExpression: YieldExpression,
    yieldExpression: YieldExpression,
    AnyTypeAnnotation: AnyTypeAnnotation,
    anyTypeAnnotation: AnyTypeAnnotation,
    ArrayTypeAnnotation: ArrayTypeAnnotation,
    arrayTypeAnnotation: ArrayTypeAnnotation,
    BooleanTypeAnnotation: BooleanTypeAnnotation,
    booleanTypeAnnotation: BooleanTypeAnnotation,
    BooleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation,
    booleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation,
    NullLiteralTypeAnnotation: NullLiteralTypeAnnotation,
    nullLiteralTypeAnnotation: NullLiteralTypeAnnotation,
    ClassImplements: ClassImplements,
    classImplements: ClassImplements,
    DeclareClass: DeclareClass,
    declareClass: DeclareClass,
    DeclareFunction: DeclareFunction,
    declareFunction: DeclareFunction,
    DeclareInterface: DeclareInterface,
    declareInterface: DeclareInterface,
    DeclareModule: DeclareModule,
    declareModule: DeclareModule,
    DeclareModuleExports: DeclareModuleExports,
    declareModuleExports: DeclareModuleExports,
    DeclareTypeAlias: DeclareTypeAlias,
    declareTypeAlias: DeclareTypeAlias,
    DeclareOpaqueType: DeclareOpaqueType,
    declareOpaqueType: DeclareOpaqueType,
    DeclareVariable: DeclareVariable,
    declareVariable: DeclareVariable,
    DeclareExportDeclaration: DeclareExportDeclaration,
    declareExportDeclaration: DeclareExportDeclaration,
    DeclareExportAllDeclaration: DeclareExportAllDeclaration,
    declareExportAllDeclaration: DeclareExportAllDeclaration,
    DeclaredPredicate: DeclaredPredicate,
    declaredPredicate: DeclaredPredicate,
    ExistsTypeAnnotation: ExistsTypeAnnotation,
    existsTypeAnnotation: ExistsTypeAnnotation,
    FunctionTypeAnnotation: FunctionTypeAnnotation,
    functionTypeAnnotation: FunctionTypeAnnotation,
    FunctionTypeParam: FunctionTypeParam,
    functionTypeParam: FunctionTypeParam,
    GenericTypeAnnotation: GenericTypeAnnotation,
    genericTypeAnnotation: GenericTypeAnnotation,
    InferredPredicate: InferredPredicate,
    inferredPredicate: InferredPredicate,
    InterfaceExtends: InterfaceExtends,
    interfaceExtends: InterfaceExtends,
    InterfaceDeclaration: InterfaceDeclaration,
    interfaceDeclaration: InterfaceDeclaration,
    InterfaceTypeAnnotation: InterfaceTypeAnnotation,
    interfaceTypeAnnotation: InterfaceTypeAnnotation,
    IntersectionTypeAnnotation: IntersectionTypeAnnotation,
    intersectionTypeAnnotation: IntersectionTypeAnnotation,
    MixedTypeAnnotation: MixedTypeAnnotation,
    mixedTypeAnnotation: MixedTypeAnnotation,
    EmptyTypeAnnotation: EmptyTypeAnnotation,
    emptyTypeAnnotation: EmptyTypeAnnotation,
    NullableTypeAnnotation: NullableTypeAnnotation,
    nullableTypeAnnotation: NullableTypeAnnotation,
    NumberLiteralTypeAnnotation: NumberLiteralTypeAnnotation,
    numberLiteralTypeAnnotation: NumberLiteralTypeAnnotation,
    NumberTypeAnnotation: NumberTypeAnnotation,
    numberTypeAnnotation: NumberTypeAnnotation,
    ObjectTypeAnnotation: ObjectTypeAnnotation,
    objectTypeAnnotation: ObjectTypeAnnotation,
    ObjectTypeInternalSlot: ObjectTypeInternalSlot,
    objectTypeInternalSlot: ObjectTypeInternalSlot,
    ObjectTypeCallProperty: ObjectTypeCallProperty,
    objectTypeCallProperty: ObjectTypeCallProperty,
    ObjectTypeIndexer: ObjectTypeIndexer,
    objectTypeIndexer: ObjectTypeIndexer,
    ObjectTypeProperty: ObjectTypeProperty,
    objectTypeProperty: ObjectTypeProperty,
    ObjectTypeSpreadProperty: ObjectTypeSpreadProperty,
    objectTypeSpreadProperty: ObjectTypeSpreadProperty,
    OpaqueType: OpaqueType,
    opaqueType: OpaqueType,
    QualifiedTypeIdentifier: QualifiedTypeIdentifier,
    qualifiedTypeIdentifier: QualifiedTypeIdentifier,
    StringLiteralTypeAnnotation: StringLiteralTypeAnnotation,
    stringLiteralTypeAnnotation: StringLiteralTypeAnnotation,
    StringTypeAnnotation: StringTypeAnnotation,
    stringTypeAnnotation: StringTypeAnnotation,
    SymbolTypeAnnotation: SymbolTypeAnnotation,
    symbolTypeAnnotation: SymbolTypeAnnotation,
    ThisTypeAnnotation: ThisTypeAnnotation,
    thisTypeAnnotation: ThisTypeAnnotation,
    TupleTypeAnnotation: TupleTypeAnnotation,
    tupleTypeAnnotation: TupleTypeAnnotation,
    TypeofTypeAnnotation: TypeofTypeAnnotation,
    typeofTypeAnnotation: TypeofTypeAnnotation,
    TypeAlias: TypeAlias,
    typeAlias: TypeAlias,
    TypeAnnotation: TypeAnnotation,
    typeAnnotation: TypeAnnotation,
    TypeCastExpression: TypeCastExpression,
    typeCastExpression: TypeCastExpression,
    TypeParameter: TypeParameter,
    typeParameter: TypeParameter,
    TypeParameterDeclaration: TypeParameterDeclaration,
    typeParameterDeclaration: TypeParameterDeclaration,
    TypeParameterInstantiation: TypeParameterInstantiation,
    typeParameterInstantiation: TypeParameterInstantiation,
    UnionTypeAnnotation: UnionTypeAnnotation,
    unionTypeAnnotation: UnionTypeAnnotation,
    Variance: Variance,
    variance: Variance,
    VoidTypeAnnotation: VoidTypeAnnotation,
    voidTypeAnnotation: VoidTypeAnnotation,
    EnumDeclaration: EnumDeclaration,
    enumDeclaration: EnumDeclaration,
    EnumBooleanBody: EnumBooleanBody,
    enumBooleanBody: EnumBooleanBody,
    EnumNumberBody: EnumNumberBody,
    enumNumberBody: EnumNumberBody,
    EnumStringBody: EnumStringBody,
    enumStringBody: EnumStringBody,
    EnumSymbolBody: EnumSymbolBody,
    enumSymbolBody: EnumSymbolBody,
    EnumBooleanMember: EnumBooleanMember,
    enumBooleanMember: EnumBooleanMember,
    EnumNumberMember: EnumNumberMember,
    enumNumberMember: EnumNumberMember,
    EnumStringMember: EnumStringMember,
    enumStringMember: EnumStringMember,
    EnumDefaultedMember: EnumDefaultedMember,
    enumDefaultedMember: EnumDefaultedMember,
    JSXAttribute: JSXAttribute,
    jsxAttribute: JSXAttribute,
    jSXAttribute: JSXAttribute,
    JSXClosingElement: JSXClosingElement,
    jsxClosingElement: JSXClosingElement,
    jSXClosingElement: JSXClosingElement,
    JSXElement: JSXElement,
    jsxElement: JSXElement,
    jSXElement: JSXElement,
    JSXEmptyExpression: JSXEmptyExpression,
    jsxEmptyExpression: JSXEmptyExpression,
    jSXEmptyExpression: JSXEmptyExpression,
    JSXExpressionContainer: JSXExpressionContainer,
    jsxExpressionContainer: JSXExpressionContainer,
    jSXExpressionContainer: JSXExpressionContainer,
    JSXSpreadChild: JSXSpreadChild,
    jsxSpreadChild: JSXSpreadChild,
    jSXSpreadChild: JSXSpreadChild,
    JSXIdentifier: JSXIdentifier,
    jsxIdentifier: JSXIdentifier,
    jSXIdentifier: JSXIdentifier,
    JSXMemberExpression: JSXMemberExpression,
    jsxMemberExpression: JSXMemberExpression,
    jSXMemberExpression: JSXMemberExpression,
    JSXNamespacedName: JSXNamespacedName,
    jsxNamespacedName: JSXNamespacedName,
    jSXNamespacedName: JSXNamespacedName,
    JSXOpeningElement: JSXOpeningElement,
    jsxOpeningElement: JSXOpeningElement,
    jSXOpeningElement: JSXOpeningElement,
    JSXSpreadAttribute: JSXSpreadAttribute,
    jsxSpreadAttribute: JSXSpreadAttribute,
    jSXSpreadAttribute: JSXSpreadAttribute,
    JSXText: JSXText,
    jsxText: JSXText,
    jSXText: JSXText,
    JSXFragment: JSXFragment,
    jsxFragment: JSXFragment,
    jSXFragment: JSXFragment,
    JSXOpeningFragment: JSXOpeningFragment,
    jsxOpeningFragment: JSXOpeningFragment,
    jSXOpeningFragment: JSXOpeningFragment,
    JSXClosingFragment: JSXClosingFragment,
    jsxClosingFragment: JSXClosingFragment,
    jSXClosingFragment: JSXClosingFragment,
    Noop: Noop,
    noop: Noop,
    Placeholder: Placeholder,
    placeholder: Placeholder,
    V8IntrinsicIdentifier: V8IntrinsicIdentifier,
    v8IntrinsicIdentifier: V8IntrinsicIdentifier,
    ArgumentPlaceholder: ArgumentPlaceholder,
    argumentPlaceholder: ArgumentPlaceholder,
    AwaitExpression: AwaitExpression,
    awaitExpression: AwaitExpression,
    BindExpression: BindExpression,
    bindExpression: BindExpression,
    ClassProperty: ClassProperty,
    classProperty: ClassProperty,
    OptionalMemberExpression: OptionalMemberExpression,
    optionalMemberExpression: OptionalMemberExpression,
    PipelineTopicExpression: PipelineTopicExpression,
    pipelineTopicExpression: PipelineTopicExpression,
    PipelineBareFunction: PipelineBareFunction,
    pipelineBareFunction: PipelineBareFunction,
    PipelinePrimaryTopicReference: PipelinePrimaryTopicReference,
    pipelinePrimaryTopicReference: PipelinePrimaryTopicReference,
    OptionalCallExpression: OptionalCallExpression,
    optionalCallExpression: OptionalCallExpression,
    ClassPrivateProperty: ClassPrivateProperty,
    classPrivateProperty: ClassPrivateProperty,
    ClassPrivateMethod: ClassPrivateMethod,
    classPrivateMethod: ClassPrivateMethod,
    Import: Import,
    'import': Import,
    Decorator: Decorator,
    decorator: Decorator,
    DoExpression: DoExpression,
    doExpression: DoExpression,
    ExportDefaultSpecifier: ExportDefaultSpecifier,
    exportDefaultSpecifier: ExportDefaultSpecifier,
    ExportNamespaceSpecifier: ExportNamespaceSpecifier,
    exportNamespaceSpecifier: ExportNamespaceSpecifier,
    PrivateName: PrivateName,
    privateName: PrivateName,
    BigIntLiteral: BigIntLiteral,
    bigIntLiteral: BigIntLiteral,
    RecordExpression: RecordExpression,
    recordExpression: RecordExpression,
    TupleExpression: TupleExpression,
    tupleExpression: TupleExpression,
    TSParameterProperty: TSParameterProperty,
    tsParameterProperty: TSParameterProperty,
    tSParameterProperty: TSParameterProperty,
    TSDeclareFunction: TSDeclareFunction,
    tsDeclareFunction: TSDeclareFunction,
    tSDeclareFunction: TSDeclareFunction,
    TSDeclareMethod: TSDeclareMethod,
    tsDeclareMethod: TSDeclareMethod,
    tSDeclareMethod: TSDeclareMethod,
    TSQualifiedName: TSQualifiedName,
    tsQualifiedName: TSQualifiedName,
    tSQualifiedName: TSQualifiedName,
    TSCallSignatureDeclaration: TSCallSignatureDeclaration,
    tsCallSignatureDeclaration: TSCallSignatureDeclaration,
    tSCallSignatureDeclaration: TSCallSignatureDeclaration,
    TSConstructSignatureDeclaration: TSConstructSignatureDeclaration,
    tsConstructSignatureDeclaration: TSConstructSignatureDeclaration,
    tSConstructSignatureDeclaration: TSConstructSignatureDeclaration,
    TSPropertySignature: TSPropertySignature,
    tsPropertySignature: TSPropertySignature,
    tSPropertySignature: TSPropertySignature,
    TSMethodSignature: TSMethodSignature,
    tsMethodSignature: TSMethodSignature,
    tSMethodSignature: TSMethodSignature,
    TSIndexSignature: TSIndexSignature,
    tsIndexSignature: TSIndexSignature,
    tSIndexSignature: TSIndexSignature,
    TSAnyKeyword: TSAnyKeyword,
    tsAnyKeyword: TSAnyKeyword,
    tSAnyKeyword: TSAnyKeyword,
    TSBooleanKeyword: TSBooleanKeyword,
    tsBooleanKeyword: TSBooleanKeyword,
    tSBooleanKeyword: TSBooleanKeyword,
    TSBigIntKeyword: TSBigIntKeyword,
    tsBigIntKeyword: TSBigIntKeyword,
    tSBigIntKeyword: TSBigIntKeyword,
    TSNeverKeyword: TSNeverKeyword,
    tsNeverKeyword: TSNeverKeyword,
    tSNeverKeyword: TSNeverKeyword,
    TSNullKeyword: TSNullKeyword,
    tsNullKeyword: TSNullKeyword,
    tSNullKeyword: TSNullKeyword,
    TSNumberKeyword: TSNumberKeyword,
    tsNumberKeyword: TSNumberKeyword,
    tSNumberKeyword: TSNumberKeyword,
    TSObjectKeyword: TSObjectKeyword,
    tsObjectKeyword: TSObjectKeyword,
    tSObjectKeyword: TSObjectKeyword,
    TSStringKeyword: TSStringKeyword,
    tsStringKeyword: TSStringKeyword,
    tSStringKeyword: TSStringKeyword,
    TSSymbolKeyword: TSSymbolKeyword,
    tsSymbolKeyword: TSSymbolKeyword,
    tSSymbolKeyword: TSSymbolKeyword,
    TSUndefinedKeyword: TSUndefinedKeyword,
    tsUndefinedKeyword: TSUndefinedKeyword,
    tSUndefinedKeyword: TSUndefinedKeyword,
    TSUnknownKeyword: TSUnknownKeyword,
    tsUnknownKeyword: TSUnknownKeyword,
    tSUnknownKeyword: TSUnknownKeyword,
    TSVoidKeyword: TSVoidKeyword,
    tsVoidKeyword: TSVoidKeyword,
    tSVoidKeyword: TSVoidKeyword,
    TSThisType: TSThisType,
    tsThisType: TSThisType,
    tSThisType: TSThisType,
    TSFunctionType: TSFunctionType,
    tsFunctionType: TSFunctionType,
    tSFunctionType: TSFunctionType,
    TSConstructorType: TSConstructorType,
    tsConstructorType: TSConstructorType,
    tSConstructorType: TSConstructorType,
    TSTypeReference: TSTypeReference,
    tsTypeReference: TSTypeReference,
    tSTypeReference: TSTypeReference,
    TSTypePredicate: TSTypePredicate,
    tsTypePredicate: TSTypePredicate,
    tSTypePredicate: TSTypePredicate,
    TSTypeQuery: TSTypeQuery,
    tsTypeQuery: TSTypeQuery,
    tSTypeQuery: TSTypeQuery,
    TSTypeLiteral: TSTypeLiteral,
    tsTypeLiteral: TSTypeLiteral,
    tSTypeLiteral: TSTypeLiteral,
    TSArrayType: TSArrayType,
    tsArrayType: TSArrayType,
    tSArrayType: TSArrayType,
    TSTupleType: TSTupleType,
    tsTupleType: TSTupleType,
    tSTupleType: TSTupleType,
    TSOptionalType: TSOptionalType,
    tsOptionalType: TSOptionalType,
    tSOptionalType: TSOptionalType,
    TSRestType: TSRestType,
    tsRestType: TSRestType,
    tSRestType: TSRestType,
    TSUnionType: TSUnionType,
    tsUnionType: TSUnionType,
    tSUnionType: TSUnionType,
    TSIntersectionType: TSIntersectionType,
    tsIntersectionType: TSIntersectionType,
    tSIntersectionType: TSIntersectionType,
    TSConditionalType: TSConditionalType,
    tsConditionalType: TSConditionalType,
    tSConditionalType: TSConditionalType,
    TSInferType: TSInferType,
    tsInferType: TSInferType,
    tSInferType: TSInferType,
    TSParenthesizedType: TSParenthesizedType,
    tsParenthesizedType: TSParenthesizedType,
    tSParenthesizedType: TSParenthesizedType,
    TSTypeOperator: TSTypeOperator,
    tsTypeOperator: TSTypeOperator,
    tSTypeOperator: TSTypeOperator,
    TSIndexedAccessType: TSIndexedAccessType,
    tsIndexedAccessType: TSIndexedAccessType,
    tSIndexedAccessType: TSIndexedAccessType,
    TSMappedType: TSMappedType,
    tsMappedType: TSMappedType,
    tSMappedType: TSMappedType,
    TSLiteralType: TSLiteralType,
    tsLiteralType: TSLiteralType,
    tSLiteralType: TSLiteralType,
    TSExpressionWithTypeArguments: TSExpressionWithTypeArguments,
    tsExpressionWithTypeArguments: TSExpressionWithTypeArguments,
    tSExpressionWithTypeArguments: TSExpressionWithTypeArguments,
    TSInterfaceDeclaration: TSInterfaceDeclaration,
    tsInterfaceDeclaration: TSInterfaceDeclaration,
    tSInterfaceDeclaration: TSInterfaceDeclaration,
    TSInterfaceBody: TSInterfaceBody,
    tsInterfaceBody: TSInterfaceBody,
    tSInterfaceBody: TSInterfaceBody,
    TSTypeAliasDeclaration: TSTypeAliasDeclaration,
    tsTypeAliasDeclaration: TSTypeAliasDeclaration,
    tSTypeAliasDeclaration: TSTypeAliasDeclaration,
    TSAsExpression: TSAsExpression,
    tsAsExpression: TSAsExpression,
    tSAsExpression: TSAsExpression,
    TSTypeAssertion: TSTypeAssertion,
    tsTypeAssertion: TSTypeAssertion,
    tSTypeAssertion: TSTypeAssertion,
    TSEnumDeclaration: TSEnumDeclaration,
    tsEnumDeclaration: TSEnumDeclaration,
    tSEnumDeclaration: TSEnumDeclaration,
    TSEnumMember: TSEnumMember,
    tsEnumMember: TSEnumMember,
    tSEnumMember: TSEnumMember,
    TSModuleDeclaration: TSModuleDeclaration,
    tsModuleDeclaration: TSModuleDeclaration,
    tSModuleDeclaration: TSModuleDeclaration,
    TSModuleBlock: TSModuleBlock,
    tsModuleBlock: TSModuleBlock,
    tSModuleBlock: TSModuleBlock,
    TSImportType: TSImportType,
    tsImportType: TSImportType,
    tSImportType: TSImportType,
    TSImportEqualsDeclaration: TSImportEqualsDeclaration,
    tsImportEqualsDeclaration: TSImportEqualsDeclaration,
    tSImportEqualsDeclaration: TSImportEqualsDeclaration,
    TSExternalModuleReference: TSExternalModuleReference,
    tsExternalModuleReference: TSExternalModuleReference,
    tSExternalModuleReference: TSExternalModuleReference,
    TSNonNullExpression: TSNonNullExpression,
    tsNonNullExpression: TSNonNullExpression,
    tSNonNullExpression: TSNonNullExpression,
    TSExportAssignment: TSExportAssignment,
    tsExportAssignment: TSExportAssignment,
    tSExportAssignment: TSExportAssignment,
    TSNamespaceExportDeclaration: TSNamespaceExportDeclaration,
    tsNamespaceExportDeclaration: TSNamespaceExportDeclaration,
    tSNamespaceExportDeclaration: TSNamespaceExportDeclaration,
    TSTypeAnnotation: TSTypeAnnotation,
    tsTypeAnnotation: TSTypeAnnotation,
    tSTypeAnnotation: TSTypeAnnotation,
    TSTypeParameterInstantiation: TSTypeParameterInstantiation,
    tsTypeParameterInstantiation: TSTypeParameterInstantiation,
    tSTypeParameterInstantiation: TSTypeParameterInstantiation,
    TSTypeParameterDeclaration: TSTypeParameterDeclaration,
    tsTypeParameterDeclaration: TSTypeParameterDeclaration,
    tSTypeParameterDeclaration: TSTypeParameterDeclaration,
    TSTypeParameter: TSTypeParameter,
    tsTypeParameter: TSTypeParameter,
    tSTypeParameter: TSTypeParameter,
    NumberLiteral: NumberLiteral,
    numberLiteral: NumberLiteral,
    RegexLiteral: RegexLiteral,
    regexLiteral: RegexLiteral,
    RestProperty: RestProperty,
    restProperty: RestProperty,
    SpreadProperty: SpreadProperty,
    spreadProperty: SpreadProperty,
    EXPRESSION_TYPES: EXPRESSION_TYPES,
    BINARY_TYPES: BINARY_TYPES,
    SCOPABLE_TYPES: SCOPABLE_TYPES,
    BLOCKPARENT_TYPES: BLOCKPARENT_TYPES,
    BLOCK_TYPES: BLOCK_TYPES,
    STATEMENT_TYPES: STATEMENT_TYPES,
    TERMINATORLESS_TYPES: TERMINATORLESS_TYPES,
    COMPLETIONSTATEMENT_TYPES: COMPLETIONSTATEMENT_TYPES,
    CONDITIONAL_TYPES: CONDITIONAL_TYPES,
    LOOP_TYPES: LOOP_TYPES,
    WHILE_TYPES: WHILE_TYPES,
    EXPRESSIONWRAPPER_TYPES: EXPRESSIONWRAPPER_TYPES,
    FOR_TYPES: FOR_TYPES,
    FORXSTATEMENT_TYPES: FORXSTATEMENT_TYPES,
    FUNCTION_TYPES: FUNCTION_TYPES,
    FUNCTIONPARENT_TYPES: FUNCTIONPARENT_TYPES,
    PUREISH_TYPES: PUREISH_TYPES,
    DECLARATION_TYPES: DECLARATION_TYPES,
    PATTERNLIKE_TYPES: PATTERNLIKE_TYPES,
    LVAL_TYPES: LVAL_TYPES,
    TSENTITYNAME_TYPES: TSENTITYNAME_TYPES,
    LITERAL_TYPES: LITERAL_TYPES,
    IMMUTABLE_TYPES: IMMUTABLE_TYPES,
    USERWHITESPACABLE_TYPES: USERWHITESPACABLE_TYPES,
    METHOD_TYPES: METHOD_TYPES,
    OBJECTMEMBER_TYPES: OBJECTMEMBER_TYPES,
    PROPERTY_TYPES: PROPERTY_TYPES,
    UNARYLIKE_TYPES: UNARYLIKE_TYPES,
    PATTERN_TYPES: PATTERN_TYPES,
    CLASS_TYPES: CLASS_TYPES,
    MODULEDECLARATION_TYPES: MODULEDECLARATION_TYPES,
    EXPORTDECLARATION_TYPES: EXPORTDECLARATION_TYPES,
    MODULESPECIFIER_TYPES: MODULESPECIFIER_TYPES,
    FLOW_TYPES: FLOW_TYPES,
    FLOWTYPE_TYPES: FLOWTYPE_TYPES,
    FLOWBASEANNOTATION_TYPES: FLOWBASEANNOTATION_TYPES,
    FLOWDECLARATION_TYPES: FLOWDECLARATION_TYPES,
    FLOWPREDICATE_TYPES: FLOWPREDICATE_TYPES,
    ENUMBODY_TYPES: ENUMBODY_TYPES,
    ENUMMEMBER_TYPES: ENUMMEMBER_TYPES,
    JSX_TYPES: JSX_TYPES,
    PRIVATE_TYPES: PRIVATE_TYPES,
    TSTYPEELEMENT_TYPES: TSTYPEELEMENT_TYPES,
    TSTYPE_TYPES: TSTYPE_TYPES,
    STATEMENT_OR_BLOCK_KEYS: STATEMENT_OR_BLOCK_KEYS,
    FLATTENABLE_KEYS: FLATTENABLE_KEYS,
    FOR_INIT_KEYS: FOR_INIT_KEYS,
    COMMENT_KEYS: COMMENT_KEYS,
    LOGICAL_OPERATORS: LOGICAL_OPERATORS,
    UPDATE_OPERATORS: UPDATE_OPERATORS,
    BOOLEAN_NUMBER_BINARY_OPERATORS: BOOLEAN_NUMBER_BINARY_OPERATORS,
    EQUALITY_BINARY_OPERATORS: EQUALITY_BINARY_OPERATORS,
    COMPARISON_BINARY_OPERATORS: COMPARISON_BINARY_OPERATORS,
    BOOLEAN_BINARY_OPERATORS: BOOLEAN_BINARY_OPERATORS,
    NUMBER_BINARY_OPERATORS: NUMBER_BINARY_OPERATORS,
    BINARY_OPERATORS: BINARY_OPERATORS,
    ASSIGNMENT_OPERATORS: ASSIGNMENT_OPERATORS,
    BOOLEAN_UNARY_OPERATORS: BOOLEAN_UNARY_OPERATORS,
    NUMBER_UNARY_OPERATORS: NUMBER_UNARY_OPERATORS,
    STRING_UNARY_OPERATORS: STRING_UNARY_OPERATORS,
    UNARY_OPERATORS: UNARY_OPERATORS,
    INHERIT_KEYS: INHERIT_KEYS,
    BLOCK_SCOPED_SYMBOL: BLOCK_SCOPED_SYMBOL,
    NOT_LOCAL_BINDING: NOT_LOCAL_BINDING,
    VISITOR_KEYS: VISITOR_KEYS,
    ALIAS_KEYS: ALIAS_KEYS,
    FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS,
    NODE_FIELDS: NODE_FIELDS,
    BUILDER_KEYS: BUILDER_KEYS,
    DEPRECATED_KEYS: DEPRECATED_KEYS,
    NODE_PARENT_VALIDATIONS: NODE_PARENT_VALIDATIONS,
    PLACEHOLDERS: PLACEHOLDERS,
    PLACEHOLDERS_ALIAS: PLACEHOLDERS_ALIAS,
    PLACEHOLDERS_FLIPPED_ALIAS: PLACEHOLDERS_FLIPPED_ALIAS,
    TYPES: TYPES,
    isArrayExpression: isArrayExpression,
    isAssignmentExpression: isAssignmentExpression,
    isBinaryExpression: isBinaryExpression,
    isInterpreterDirective: isInterpreterDirective,
    isDirective: isDirective,
    isDirectiveLiteral: isDirectiveLiteral,
    isBlockStatement: isBlockStatement,
    isBreakStatement: isBreakStatement,
    isCallExpression: isCallExpression,
    isCatchClause: isCatchClause,
    isConditionalExpression: isConditionalExpression,
    isContinueStatement: isContinueStatement,
    isDebuggerStatement: isDebuggerStatement,
    isDoWhileStatement: isDoWhileStatement,
    isEmptyStatement: isEmptyStatement,
    isExpressionStatement: isExpressionStatement,
    isFile: isFile,
    isForInStatement: isForInStatement,
    isForStatement: isForStatement,
    isFunctionDeclaration: isFunctionDeclaration,
    isFunctionExpression: isFunctionExpression,
    isIdentifier: isIdentifier,
    isIfStatement: isIfStatement,
    isLabeledStatement: isLabeledStatement,
    isStringLiteral: isStringLiteral,
    isNumericLiteral: isNumericLiteral,
    isNullLiteral: isNullLiteral,
    isBooleanLiteral: isBooleanLiteral,
    isRegExpLiteral: isRegExpLiteral,
    isLogicalExpression: isLogicalExpression,
    isMemberExpression: isMemberExpression,
    isNewExpression: isNewExpression,
    isProgram: isProgram,
    isObjectExpression: isObjectExpression,
    isObjectMethod: isObjectMethod,
    isObjectProperty: isObjectProperty,
    isRestElement: isRestElement,
    isReturnStatement: isReturnStatement,
    isSequenceExpression: isSequenceExpression,
    isParenthesizedExpression: isParenthesizedExpression,
    isSwitchCase: isSwitchCase,
    isSwitchStatement: isSwitchStatement,
    isThisExpression: isThisExpression,
    isThrowStatement: isThrowStatement,
    isTryStatement: isTryStatement,
    isUnaryExpression: isUnaryExpression,
    isUpdateExpression: isUpdateExpression,
    isVariableDeclaration: isVariableDeclaration,
    isVariableDeclarator: isVariableDeclarator,
    isWhileStatement: isWhileStatement,
    isWithStatement: isWithStatement,
    isAssignmentPattern: isAssignmentPattern,
    isArrayPattern: isArrayPattern,
    isArrowFunctionExpression: isArrowFunctionExpression,
    isClassBody: isClassBody,
    isClassExpression: isClassExpression,
    isClassDeclaration: isClassDeclaration,
    isExportAllDeclaration: isExportAllDeclaration,
    isExportDefaultDeclaration: isExportDefaultDeclaration,
    isExportNamedDeclaration: isExportNamedDeclaration,
    isExportSpecifier: isExportSpecifier,
    isForOfStatement: isForOfStatement,
    isImportDeclaration: isImportDeclaration,
    isImportDefaultSpecifier: isImportDefaultSpecifier,
    isImportNamespaceSpecifier: isImportNamespaceSpecifier,
    isImportSpecifier: isImportSpecifier,
    isMetaProperty: isMetaProperty,
    isClassMethod: isClassMethod,
    isObjectPattern: isObjectPattern,
    isSpreadElement: isSpreadElement,
    isSuper: isSuper,
    isTaggedTemplateExpression: isTaggedTemplateExpression,
    isTemplateElement: isTemplateElement,
    isTemplateLiteral: isTemplateLiteral,
    isYieldExpression: isYieldExpression,
    isAnyTypeAnnotation: isAnyTypeAnnotation,
    isArrayTypeAnnotation: isArrayTypeAnnotation,
    isBooleanTypeAnnotation: isBooleanTypeAnnotation,
    isBooleanLiteralTypeAnnotation: isBooleanLiteralTypeAnnotation,
    isNullLiteralTypeAnnotation: isNullLiteralTypeAnnotation,
    isClassImplements: isClassImplements,
    isDeclareClass: isDeclareClass,
    isDeclareFunction: isDeclareFunction,
    isDeclareInterface: isDeclareInterface,
    isDeclareModule: isDeclareModule,
    isDeclareModuleExports: isDeclareModuleExports,
    isDeclareTypeAlias: isDeclareTypeAlias,
    isDeclareOpaqueType: isDeclareOpaqueType,
    isDeclareVariable: isDeclareVariable,
    isDeclareExportDeclaration: isDeclareExportDeclaration,
    isDeclareExportAllDeclaration: isDeclareExportAllDeclaration,
    isDeclaredPredicate: isDeclaredPredicate,
    isExistsTypeAnnotation: isExistsTypeAnnotation,
    isFunctionTypeAnnotation: isFunctionTypeAnnotation,
    isFunctionTypeParam: isFunctionTypeParam,
    isGenericTypeAnnotation: isGenericTypeAnnotation,
    isInferredPredicate: isInferredPredicate,
    isInterfaceExtends: isInterfaceExtends,
    isInterfaceDeclaration: isInterfaceDeclaration,
    isInterfaceTypeAnnotation: isInterfaceTypeAnnotation,
    isIntersectionTypeAnnotation: isIntersectionTypeAnnotation,
    isMixedTypeAnnotation: isMixedTypeAnnotation,
    isEmptyTypeAnnotation: isEmptyTypeAnnotation,
    isNullableTypeAnnotation: isNullableTypeAnnotation,
    isNumberLiteralTypeAnnotation: isNumberLiteralTypeAnnotation,
    isNumberTypeAnnotation: isNumberTypeAnnotation,
    isObjectTypeAnnotation: isObjectTypeAnnotation,
    isObjectTypeInternalSlot: isObjectTypeInternalSlot,
    isObjectTypeCallProperty: isObjectTypeCallProperty,
    isObjectTypeIndexer: isObjectTypeIndexer,
    isObjectTypeProperty: isObjectTypeProperty,
    isObjectTypeSpreadProperty: isObjectTypeSpreadProperty,
    isOpaqueType: isOpaqueType,
    isQualifiedTypeIdentifier: isQualifiedTypeIdentifier,
    isStringLiteralTypeAnnotation: isStringLiteralTypeAnnotation,
    isStringTypeAnnotation: isStringTypeAnnotation,
    isSymbolTypeAnnotation: isSymbolTypeAnnotation,
    isThisTypeAnnotation: isThisTypeAnnotation,
    isTupleTypeAnnotation: isTupleTypeAnnotation,
    isTypeofTypeAnnotation: isTypeofTypeAnnotation,
    isTypeAlias: isTypeAlias,
    isTypeAnnotation: isTypeAnnotation,
    isTypeCastExpression: isTypeCastExpression,
    isTypeParameter: isTypeParameter,
    isTypeParameterDeclaration: isTypeParameterDeclaration,
    isTypeParameterInstantiation: isTypeParameterInstantiation,
    isUnionTypeAnnotation: isUnionTypeAnnotation,
    isVariance: isVariance,
    isVoidTypeAnnotation: isVoidTypeAnnotation,
    isEnumDeclaration: isEnumDeclaration,
    isEnumBooleanBody: isEnumBooleanBody,
    isEnumNumberBody: isEnumNumberBody,
    isEnumStringBody: isEnumStringBody,
    isEnumSymbolBody: isEnumSymbolBody,
    isEnumBooleanMember: isEnumBooleanMember,
    isEnumNumberMember: isEnumNumberMember,
    isEnumStringMember: isEnumStringMember,
    isEnumDefaultedMember: isEnumDefaultedMember,
    isJSXAttribute: isJSXAttribute,
    isJSXClosingElement: isJSXClosingElement,
    isJSXElement: isJSXElement,
    isJSXEmptyExpression: isJSXEmptyExpression,
    isJSXExpressionContainer: isJSXExpressionContainer,
    isJSXSpreadChild: isJSXSpreadChild,
    isJSXIdentifier: isJSXIdentifier,
    isJSXMemberExpression: isJSXMemberExpression,
    isJSXNamespacedName: isJSXNamespacedName,
    isJSXOpeningElement: isJSXOpeningElement,
    isJSXSpreadAttribute: isJSXSpreadAttribute,
    isJSXText: isJSXText,
    isJSXFragment: isJSXFragment,
    isJSXOpeningFragment: isJSXOpeningFragment,
    isJSXClosingFragment: isJSXClosingFragment,
    isNoop: isNoop,
    isPlaceholder: isPlaceholder,
    isV8IntrinsicIdentifier: isV8IntrinsicIdentifier,
    isArgumentPlaceholder: isArgumentPlaceholder,
    isAwaitExpression: isAwaitExpression,
    isBindExpression: isBindExpression,
    isClassProperty: isClassProperty,
    isOptionalMemberExpression: isOptionalMemberExpression,
    isPipelineTopicExpression: isPipelineTopicExpression,
    isPipelineBareFunction: isPipelineBareFunction,
    isPipelinePrimaryTopicReference: isPipelinePrimaryTopicReference,
    isOptionalCallExpression: isOptionalCallExpression,
    isClassPrivateProperty: isClassPrivateProperty,
    isClassPrivateMethod: isClassPrivateMethod,
    isImport: isImport,
    isDecorator: isDecorator,
    isDoExpression: isDoExpression,
    isExportDefaultSpecifier: isExportDefaultSpecifier,
    isExportNamespaceSpecifier: isExportNamespaceSpecifier,
    isPrivateName: isPrivateName,
    isBigIntLiteral: isBigIntLiteral,
    isRecordExpression: isRecordExpression,
    isTupleExpression: isTupleExpression,
    isTSParameterProperty: isTSParameterProperty,
    isTSDeclareFunction: isTSDeclareFunction,
    isTSDeclareMethod: isTSDeclareMethod,
    isTSQualifiedName: isTSQualifiedName,
    isTSCallSignatureDeclaration: isTSCallSignatureDeclaration,
    isTSConstructSignatureDeclaration: isTSConstructSignatureDeclaration,
    isTSPropertySignature: isTSPropertySignature,
    isTSMethodSignature: isTSMethodSignature,
    isTSIndexSignature: isTSIndexSignature,
    isTSAnyKeyword: isTSAnyKeyword,
    isTSBooleanKeyword: isTSBooleanKeyword,
    isTSBigIntKeyword: isTSBigIntKeyword,
    isTSNeverKeyword: isTSNeverKeyword,
    isTSNullKeyword: isTSNullKeyword,
    isTSNumberKeyword: isTSNumberKeyword,
    isTSObjectKeyword: isTSObjectKeyword,
    isTSStringKeyword: isTSStringKeyword,
    isTSSymbolKeyword: isTSSymbolKeyword,
    isTSUndefinedKeyword: isTSUndefinedKeyword,
    isTSUnknownKeyword: isTSUnknownKeyword,
    isTSVoidKeyword: isTSVoidKeyword,
    isTSThisType: isTSThisType,
    isTSFunctionType: isTSFunctionType,
    isTSConstructorType: isTSConstructorType,
    isTSTypeReference: isTSTypeReference,
    isTSTypePredicate: isTSTypePredicate,
    isTSTypeQuery: isTSTypeQuery,
    isTSTypeLiteral: isTSTypeLiteral,
    isTSArrayType: isTSArrayType,
    isTSTupleType: isTSTupleType,
    isTSOptionalType: isTSOptionalType,
    isTSRestType: isTSRestType,
    isTSUnionType: isTSUnionType,
    isTSIntersectionType: isTSIntersectionType,
    isTSConditionalType: isTSConditionalType,
    isTSInferType: isTSInferType,
    isTSParenthesizedType: isTSParenthesizedType,
    isTSTypeOperator: isTSTypeOperator,
    isTSIndexedAccessType: isTSIndexedAccessType,
    isTSMappedType: isTSMappedType,
    isTSLiteralType: isTSLiteralType,
    isTSExpressionWithTypeArguments: isTSExpressionWithTypeArguments,
    isTSInterfaceDeclaration: isTSInterfaceDeclaration,
    isTSInterfaceBody: isTSInterfaceBody,
    isTSTypeAliasDeclaration: isTSTypeAliasDeclaration,
    isTSAsExpression: isTSAsExpression,
    isTSTypeAssertion: isTSTypeAssertion,
    isTSEnumDeclaration: isTSEnumDeclaration,
    isTSEnumMember: isTSEnumMember,
    isTSModuleDeclaration: isTSModuleDeclaration,
    isTSModuleBlock: isTSModuleBlock,
    isTSImportType: isTSImportType,
    isTSImportEqualsDeclaration: isTSImportEqualsDeclaration,
    isTSExternalModuleReference: isTSExternalModuleReference,
    isTSNonNullExpression: isTSNonNullExpression,
    isTSExportAssignment: isTSExportAssignment,
    isTSNamespaceExportDeclaration: isTSNamespaceExportDeclaration,
    isTSTypeAnnotation: isTSTypeAnnotation,
    isTSTypeParameterInstantiation: isTSTypeParameterInstantiation,
    isTSTypeParameterDeclaration: isTSTypeParameterDeclaration,
    isTSTypeParameter: isTSTypeParameter,
    isExpression: isExpression,
    isBinary: isBinary,
    isScopable: isScopable,
    isBlockParent: isBlockParent,
    isBlock: isBlock,
    isStatement: isStatement,
    isTerminatorless: isTerminatorless,
    isCompletionStatement: isCompletionStatement,
    isConditional: isConditional,
    isLoop: isLoop,
    isWhile: isWhile,
    isExpressionWrapper: isExpressionWrapper,
    isFor: isFor,
    isForXStatement: isForXStatement,
    isFunction: isFunction,
    isFunctionParent: isFunctionParent,
    isPureish: isPureish,
    isDeclaration: isDeclaration,
    isPatternLike: isPatternLike,
    isLVal: isLVal,
    isTSEntityName: isTSEntityName,
    isLiteral: isLiteral,
    isUserWhitespacable: isUserWhitespacable,
    isMethod: isMethod,
    isObjectMember: isObjectMember,
    isProperty: isProperty,
    isUnaryLike: isUnaryLike,
    isPattern: isPattern,
    isClass: isClass,
    isModuleDeclaration: isModuleDeclaration,
    isExportDeclaration: isExportDeclaration,
    isModuleSpecifier: isModuleSpecifier,
    isFlow: isFlow,
    isFlowType: isFlowType,
    isFlowBaseAnnotation: isFlowBaseAnnotation,
    isFlowDeclaration: isFlowDeclaration,
    isFlowPredicate: isFlowPredicate,
    isEnumBody: isEnumBody,
    isEnumMember: isEnumMember,
    isJSX: isJSX,
    isPrivate: isPrivate,
    isTSTypeElement: isTSTypeElement,
    isTSType: isTSType,
    isNumberLiteral: isNumberLiteral,
    isRegexLiteral: isRegexLiteral,
    isRestProperty: isRestProperty,
    isSpreadProperty: isSpreadProperty
  });

  var ReferencedIdentifier = {
    types: ["Identifier", "JSXIdentifier"],
    checkPath: function checkPath(path, opts) {
      var node = path.node,
          parent = path.parent;

      if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
        if (isJSXIdentifier(node, opts)) {
          if (react.isCompatTag(node.name)) return false;
        } else {
          return false;
        }
      }

      return isReferenced(node, parent, path.parentPath.parent);
    }
  };
  var ReferencedMemberExpression = {
    types: ["MemberExpression"],
    checkPath: function checkPath(_ref) {
      var node = _ref.node,
          parent = _ref.parent;
      return isMemberExpression(node) && isReferenced(node, parent);
    }
  };
  var BindingIdentifier = {
    types: ["Identifier"],
    checkPath: function checkPath(path) {
      var node = path.node,
          parent = path.parent;
      var grandparent = path.parentPath.parent;
      return isIdentifier(node) && isBinding(node, parent, grandparent);
    }
  };
  var Statement = {
    types: ["Statement"],
    checkPath: function checkPath(_ref2) {
      var node = _ref2.node,
          parent = _ref2.parent;

      if (isStatement(node)) {
        if (isVariableDeclaration(node)) {
          if (isForXStatement(parent, {
            left: node
          })) return false;
          if (isForStatement(parent, {
            init: node
          })) return false;
        }

        return true;
      } else {
        return false;
      }
    }
  };
  var Expression = {
    types: ["Expression"],
    checkPath: function checkPath(path) {
      if (path.isIdentifier()) {
        return path.isReferencedIdentifier();
      } else {
        return isExpression(path.node);
      }
    }
  };
  var Scope = {
    types: ["Scopable", "Pattern"],
    checkPath: function checkPath(path) {
      return isScope(path.node, path.parent);
    }
  };
  var Referenced = {
    checkPath: function checkPath(path) {
      return isReferenced(path.node, path.parent);
    }
  };
  var BlockScoped = {
    checkPath: function checkPath(path) {
      return isBlockScoped(path.node);
    }
  };
  var Var = {
    types: ["VariableDeclaration"],
    checkPath: function checkPath(path) {
      return isVar(path.node);
    }
  };
  var User = {
    checkPath: function checkPath(path) {
      return path.node && !!path.node.loc;
    }
  };
  var Generated = {
    checkPath: function checkPath(path) {
      return !path.isUser();
    }
  };
  var Pure = {
    checkPath: function checkPath(path, opts) {
      return path.scope.isPure(path.node, opts);
    }
  };
  var Flow = {
    types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
    checkPath: function checkPath(_ref3) {
      var node = _ref3.node;

      if (isFlow(node)) {
        return true;
      } else if (isImportDeclaration(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else if (isExportDeclaration(node)) {
        return node.exportKind === "type";
      } else if (isImportSpecifier(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else {
        return false;
      }
    }
  };
  var RestProperty$1 = {
    types: ["RestElement"],
    checkPath: function checkPath(path) {
      return path.parentPath && path.parentPath.isObjectPattern();
    }
  };
  var SpreadProperty$1 = {
    types: ["RestElement"],
    checkPath: function checkPath(path) {
      return path.parentPath && path.parentPath.isObjectExpression();
    }
  };
  var ExistentialTypeParam = {
    types: ["ExistsTypeAnnotation"]
  };
  var NumericLiteralTypeAnnotation = {
    types: ["NumberLiteralTypeAnnotation"]
  };
  var ForAwaitStatement = {
    types: ["ForOfStatement"],
    checkPath: function checkPath(_ref4) {
      var node = _ref4.node;
      return node["await"] === true;
    }
  };

  var virtualTypes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ReferencedIdentifier: ReferencedIdentifier,
    ReferencedMemberExpression: ReferencedMemberExpression,
    BindingIdentifier: BindingIdentifier,
    Statement: Statement,
    Expression: Expression,
    Scope: Scope,
    Referenced: Referenced,
    BlockScoped: BlockScoped,
    Var: Var,
    User: User,
    Generated: Generated,
    Pure: Pure,
    Flow: Flow,
    RestProperty: RestProperty$1,
    SpreadProperty: SpreadProperty$1,
    ExistentialTypeParam: ExistentialTypeParam,
    NumericLiteralTypeAnnotation: NumericLiteralTypeAnnotation,
    ForAwaitStatement: ForAwaitStatement
  });

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;

  var ms = function (val, options) {
    options = options || {};
    var type = typeof val;

    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isFinite(val)) {
      return options["long"] ? fmtLong(val) : fmtShort(val);
    }

    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  function parse(str) {
    str = String(str);

    if (str.length > 100) {
      return;
    }

    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

    if (!match) {
      return;
    }

    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();

    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;

      case 'weeks':
      case 'week':
      case 'w':
        return n * w;

      case 'days':
      case 'day':
      case 'd':
        return n * d;

      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;

      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;

      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;

      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;

      default:
        return undefined;
    }
  }

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }

    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }

    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }

    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }

    return ms + 'ms';
  }

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }

    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }

    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }

    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }

    return ms + ' ms';
  }

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }

  function setup(env) {
    createDebug.debug = createDebug;
    createDebug["default"] = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = ms;
    Object.keys(env).forEach(function (key) {
      createDebug[key] = env[key];
    });
    createDebug.instances = [];
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};

    function selectColor(namespace) {
      var hash = 0;

      for (var i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }

      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }

    createDebug.selectColor = selectColor;

    function createDebug(namespace) {
      var prevTime;

      function debug() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (!debug.enabled) {
          return;
        }

        var self = debug;
        var curr = Number(new Date());
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);

        if (typeof args[0] !== 'string') {
          args.unshift('%O');
        }

        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          if (match === '%%') {
            return match;
          }

          index++;
          var formatter = createDebug.formatters[format];

          if (typeof formatter === 'function') {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }

          return match;
        });
        createDebug.formatArgs.call(self, args);
        var logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.enabled = createDebug.enabled(namespace);
      debug.useColors = createDebug.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      debug.extend = extend;

      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }

      createDebug.instances.push(debug);
      return debug;
    }

    function destroy() {
      var index = createDebug.instances.indexOf(this);

      if (index !== -1) {
        createDebug.instances.splice(index, 1);
        return true;
      }

      return false;
    }

    function extend(namespace, delimiter) {
      var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }

    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      var i;
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }

        namespaces = split[i].replace(/\*/g, '.*?');

        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }

      for (i = 0; i < createDebug.instances.length; i++) {
        var instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }

    function disable() {
      var namespaces = [].concat(createDebug.names.map(toNamespace), createDebug.skips.map(toNamespace).map(function (namespace) {
        return '-' + namespace;
      })).join(',');
      createDebug.enable('');
      return namespaces;
    }

    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }

      var i;
      var len;

      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }

      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }

      return false;
    }

    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
    }

    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }

      return val;
    }

    createDebug.enable(createDebug.load());
    return createDebug;
  }

  var common = setup;

  var browser$1 = createCommonjsModule(function (module, exports) {
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

  function useColors() {
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
      return true;
    }

    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }

    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }

  function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

    if (!this.useColors) {
      return;
    }

    var c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function (match) {
      if (match === '%%') {
        return;
      }

      index++;

      if (match === '%c') {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }

  function log() {
    var _console;

    return typeof console === 'object' && console.log && (_console = console).log.apply(_console, arguments);
  }

  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem('debug', namespaces);
      } else {
        exports.storage.removeItem('debug');
      }
    } catch (error) {}
  }

  function load() {
    var r;

    try {
      r = exports.storage.getItem('debug');
    } catch (error) {}

    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }

  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }

  module.exports = common(exports);
  var formatters = module.exports.formatters;

  formatters.j = function (v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return '[UnexpectedJSONParseError]: ' + error.message;
    }
  };
  });
  var browser_1 = browser$1.log;
  var browser_2 = browser$1.formatArgs;
  var browser_3 = browser$1.save;
  var browser_4 = browser$1.load;
  var browser_5 = browser$1.useColors;
  var browser_6 = browser$1.storage;
  var browser_7 = browser$1.colors;

  var stringTag$3 = '[object String]';

  function isString(value) {
    return typeof value == 'string' || !isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag$3;
  }

  var isString_1 = isString;

  var symbolTag$2 = '[object Symbol]';

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike_1(value) && _baseGetTag(value) == symbolTag$2;
  }

  var isSymbol_1 = isSymbol;

  var NAN = 0 / 0;
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;

  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol_1(value)) {
      return NAN;
    }

    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  var toNumber_1 = toNumber;

  var INFINITY$1 = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;

  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }

    value = toNumber_1(value);

    if (value === INFINITY$1 || value === -INFINITY$1) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }

    return value === value ? value : 0;
  }

  var toFinite_1 = toFinite;

  function toInteger(value) {
    var result = toFinite_1(value),
        remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }

  var toInteger_1 = toInteger;

  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  var _arrayMap = arrayMap;

  function baseValues(object, props) {
    return _arrayMap(props, function (key) {
      return object[key];
    });
  }

  var _baseValues = baseValues;

  function values(object) {
    return object == null ? [] : _baseValues(object, keys_1(object));
  }

  var values_1 = values;

  var nativeMax = Math.max;

  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike_1(collection) ? collection : values_1(collection);
    fromIndex = fromIndex && !guard ? toInteger_1(fromIndex) : 0;
    var length = collection.length;

    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }

    return isString_1(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && _baseIndexOf(collection, value, fromIndex) > -1;
  }

  var includes_1 = includes;

  var MAX_SAFE_INTEGER$2 = 9007199254740991;
  var nativeFloor = Math.floor;

  function baseRepeat(string, n) {
    var result = '';

    if (!string || n < 1 || n > MAX_SAFE_INTEGER$2) {
      return result;
    }

    do {
      if (n % 2) {
        result += string;
      }

      n = nativeFloor(n / 2);

      if (n) {
        string += string;
      }
    } while (n);

    return result;
  }

  var _baseRepeat = baseRepeat;

  function isIterateeCall(value, index, object) {
    if (!isObject_1(object)) {
      return false;
    }

    var type = typeof index;

    if (type == 'number' ? isArrayLike_1(object) && _isIndex(index, object.length) : type == 'string' && index in object) {
      return eq_1(object[index], value);
    }

    return false;
  }

  var _isIterateeCall = isIterateeCall;

  var INFINITY$2 = 1 / 0;
  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }

    if (isArray_1(value)) {
      return _arrayMap(value, baseToString) + '';
    }

    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
  }

  var _baseToString = baseToString;

  function toString(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString;

  function repeat(string, n, guard) {
    if (guard ? _isIterateeCall(string, n, guard) : n === undefined) {
      n = 1;
    } else {
      n = toInteger_1(n);
    }

    return _baseRepeat(toString_1(string), n);
  }

  var repeat_1 = repeat;

  var Binding = function () {
    function Binding(_ref) {
      var identifier = _ref.identifier,
          scope = _ref.scope,
          path = _ref.path,
          kind = _ref.kind;
      this.identifier = identifier;
      this.scope = scope;
      this.path = path;
      this.kind = kind;
      this.constantViolations = [];
      this.constant = true;
      this.referencePaths = [];
      this.referenced = false;
      this.references = 0;
      this.clearValue();
    }

    var _proto = Binding.prototype;

    _proto.deoptValue = function deoptValue() {
      this.clearValue();
      this.hasDeoptedValue = true;
    };

    _proto.setValue = function setValue(value) {
      if (this.hasDeoptedValue) return;
      this.hasValue = true;
      this.value = value;
    };

    _proto.clearValue = function clearValue() {
      this.hasDeoptedValue = false;
      this.hasValue = false;
      this.value = null;
    };

    _proto.reassign = function reassign(path) {
      this.constant = false;

      if (this.constantViolations.indexOf(path) !== -1) {
        return;
      }

      this.constantViolations.push(path);
    };

    _proto.reference = function reference(path) {
      if (this.referencePaths.indexOf(path) !== -1) {
        return;
      }

      this.referenced = true;
      this.references++;
      this.referencePaths.push(path);
    };

    _proto.dereference = function dereference() {
      this.references--;
      this.referenced = !!this.references;
    };

    return Binding;
  }();

  function splitExportDeclaration(exportDeclaration) {
    if (!exportDeclaration.isExportDeclaration()) {
      throw new Error("Only export declarations can be splitted.");
    }

    var isDefault = exportDeclaration.isExportDefaultDeclaration();
    var declaration = exportDeclaration.get("declaration");
    var isClassDeclaration = declaration.isClassDeclaration();

    if (isDefault) {
      var standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;
      var scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
      var id = declaration.node.id;
      var needBindingRegistration = false;

      if (!id) {
        needBindingRegistration = true;
        id = scope.generateUidIdentifier("default");

        if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {
          declaration.node.id = cloneNode(id);
        }
      }

      var updatedDeclaration = standaloneDeclaration ? declaration : VariableDeclaration("var", [VariableDeclarator(cloneNode(id), declaration.node)]);
      var updatedExportDeclaration = ExportNamedDeclaration(null, [ExportSpecifier(cloneNode(id), Identifier("default"))]);
      exportDeclaration.insertAfter(updatedExportDeclaration);
      exportDeclaration.replaceWith(updatedDeclaration);

      if (needBindingRegistration) {
        scope.registerDeclaration(exportDeclaration);
      }

      return exportDeclaration;
    }

    if (exportDeclaration.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }

    var bindingIdentifiers = declaration.getOuterBindingIdentifiers();
    var specifiers = Object.keys(bindingIdentifiers).map(function (name) {
      return ExportSpecifier(Identifier(name), Identifier(name));
    });
    var aliasDeclar = ExportNamedDeclaration(null, specifiers);
    exportDeclaration.insertAfter(aliasDeclar);
    exportDeclaration.replaceWith(declaration.node);
    return exportDeclaration;
  }

  var renameVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
      var node = _ref.node;

      if (node.name === state.oldName) {
        node.name = state.newName;
      }
    },
    Scope: function Scope(path, state) {
      if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
        path.skip();
      }
    },
    "AssignmentExpression|Declaration": function AssignmentExpressionDeclaration(path, state) {
      var ids = path.getOuterBindingIdentifiers();

      for (var name in ids) {
        if (name === state.oldName) ids[name].name = state.newName;
      }
    }
  };

  var Renamer = function () {
    function Renamer(binding, oldName, newName) {
      this.newName = newName;
      this.oldName = oldName;
      this.binding = binding;
    }

    var _proto = Renamer.prototype;

    _proto.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(parentDeclar) {
      var maybeExportDeclar = parentDeclar.parentPath;

      if (!maybeExportDeclar.isExportDeclaration()) {
        return;
      }

      if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get("declaration").node.id) {
        return;
      }

      splitExportDeclaration(maybeExportDeclar);
    };

    _proto.maybeConvertFromClassFunctionDeclaration = function maybeConvertFromClassFunctionDeclaration(path) {
      return;
    };

    _proto.maybeConvertFromClassFunctionExpression = function maybeConvertFromClassFunctionExpression(path) {
      return;
    };

    _proto.rename = function rename(block) {
      var binding = this.binding,
          oldName = this.oldName,
          newName = this.newName;
      var scope = binding.scope,
          path = binding.path;
      var parentDeclar = path.find(function (path) {
        return path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression();
      });

      if (parentDeclar) {
        var bindingIds = parentDeclar.getOuterBindingIdentifiers();

        if (bindingIds[oldName] === binding.identifier) {
          this.maybeConvertFromExportDeclaration(parentDeclar);
        }
      }

      scope.traverse(block || scope.block, renameVisitor, this);

      if (!block) {
        scope.removeOwnBinding(oldName);
        scope.bindings[newName] = binding;
        this.binding.identifier.name = newName;
      }

      if (binding.type === "hoisted") ;

      if (parentDeclar) {
        this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
        this.maybeConvertFromClassFunctionExpression(parentDeclar);
      }
    };

    return Renamer;
  }();

  function identity(value) {
    return value;
  }

  var identity_1 = identity;

  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }

  var _apply = apply;

  var nativeMax$1 = Math.max;

  function overRest(func, start, transform) {
    start = nativeMax$1(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax$1(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = transform(array);
      return _apply(func, this, otherArgs);
    };
  }

  var _overRest = overRest;

  function constant(value) {
    return function () {
      return value;
    };
  }

  var constant_1 = constant;

  var baseSetToString = !_defineProperty ? identity_1 : function (func, string) {
    return _defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant_1(string),
      'writable': true
    });
  };
  var _baseSetToString = baseSetToString;

  var HOT_COUNT = 800,
      HOT_SPAN = 16;
  var nativeNow = Date.now;

  function shortOut(func) {
    var count = 0,
        lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;

      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }

      return func.apply(undefined, arguments);
    };
  }

  var _shortOut = shortOut;

  var setToString = _shortOut(_baseSetToString);
  var _setToString = setToString;

  function baseRest(func, start) {
    return _setToString(_overRest(func, start, identity_1), func + '');
  }

  var _baseRest = baseRest;

  var objectProto$e = Object.prototype;
  var hasOwnProperty$b = objectProto$e.hasOwnProperty;
  var defaults = _baseRest(function (object, sources) {
    object = Object(object);
    var index = -1;
    var length = sources.length;
    var guard = length > 2 ? sources[2] : undefined;

    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
      length = 1;
    }

    while (++index < length) {
      var source = sources[index];
      var props = keysIn_1(source);
      var propsIndex = -1;
      var propsLength = props.length;

      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object[key];

        if (value === undefined || eq_1(value, objectProto$e[key]) && !hasOwnProperty$b.call(object, key)) {
          object[key] = source[key];
        }
      }
    }

    return object;
  });
  var defaults_1 = defaults;

  var builtin = {
    "Array": false,
    "ArrayBuffer": false,
    Atomics: false,
    BigInt: false,
    BigInt64Array: false,
    BigUint64Array: false,
    "Boolean": false,
    constructor: false,
    "DataView": false,
    "Date": false,
    "decodeURI": false,
    "decodeURIComponent": false,
    "encodeURI": false,
    "encodeURIComponent": false,
    "Error": false,
    "escape": false,
    "eval": false,
    "EvalError": false,
    "Float32Array": false,
    "Float64Array": false,
    "Function": false,
    globalThis: false,
    hasOwnProperty: false,
    "Infinity": false,
    "Int16Array": false,
    "Int32Array": false,
    "Int8Array": false,
    "isFinite": false,
    "isNaN": false,
    isPrototypeOf: false,
    "JSON": false,
    "Map": false,
    "Math": false,
    "NaN": false,
    "Number": false,
    "Object": false,
    "parseFloat": false,
    "parseInt": false,
    "Promise": false,
    propertyIsEnumerable: false,
    "Proxy": false,
    "RangeError": false,
    "ReferenceError": false,
    "Reflect": false,
    "RegExp": false,
    "Set": false,
    SharedArrayBuffer: false,
    "String": false,
    "Symbol": false,
    "SyntaxError": false,
    toLocaleString: false,
    toString: false,
    "TypeError": false,
    "Uint16Array": false,
    "Uint32Array": false,
    "Uint8Array": false,
    "Uint8ClampedArray": false,
    "undefined": false,
    "unescape": false,
    "URIError": false,
    valueOf: false,
    "WeakMap": false,
    "WeakSet": false
  };
  var es5 = {
    "Array": false,
    "Boolean": false,
    constructor: false,
    "Date": false,
    "decodeURI": false,
    "decodeURIComponent": false,
    "encodeURI": false,
    "encodeURIComponent": false,
    "Error": false,
    "escape": false,
    "eval": false,
    "EvalError": false,
    "Function": false,
    hasOwnProperty: false,
    "Infinity": false,
    "isFinite": false,
    "isNaN": false,
    isPrototypeOf: false,
    "JSON": false,
    "Math": false,
    "NaN": false,
    "Number": false,
    "Object": false,
    "parseFloat": false,
    "parseInt": false,
    propertyIsEnumerable: false,
    "RangeError": false,
    "ReferenceError": false,
    "RegExp": false,
    "String": false,
    "SyntaxError": false,
    toLocaleString: false,
    toString: false,
    "TypeError": false,
    "undefined": false,
    "unescape": false,
    "URIError": false,
    valueOf: false
  };
  var es2015 = {
    "Array": false,
    "ArrayBuffer": false,
    "Boolean": false,
    constructor: false,
    "DataView": false,
    "Date": false,
    "decodeURI": false,
    "decodeURIComponent": false,
    "encodeURI": false,
    "encodeURIComponent": false,
    "Error": false,
    "escape": false,
    "eval": false,
    "EvalError": false,
    "Float32Array": false,
    "Float64Array": false,
    "Function": false,
    hasOwnProperty: false,
    "Infinity": false,
    "Int16Array": false,
    "Int32Array": false,
    "Int8Array": false,
    "isFinite": false,
    "isNaN": false,
    isPrototypeOf: false,
    "JSON": false,
    "Map": false,
    "Math": false,
    "NaN": false,
    "Number": false,
    "Object": false,
    "parseFloat": false,
    "parseInt": false,
    "Promise": false,
    propertyIsEnumerable: false,
    "Proxy": false,
    "RangeError": false,
    "ReferenceError": false,
    "Reflect": false,
    "RegExp": false,
    "Set": false,
    "String": false,
    "Symbol": false,
    "SyntaxError": false,
    toLocaleString: false,
    toString: false,
    "TypeError": false,
    "Uint16Array": false,
    "Uint32Array": false,
    "Uint8Array": false,
    "Uint8ClampedArray": false,
    "undefined": false,
    "unescape": false,
    "URIError": false,
    valueOf: false,
    "WeakMap": false,
    "WeakSet": false
  };
  var es2017 = {
    "Array": false,
    "ArrayBuffer": false,
    Atomics: false,
    "Boolean": false,
    constructor: false,
    "DataView": false,
    "Date": false,
    "decodeURI": false,
    "decodeURIComponent": false,
    "encodeURI": false,
    "encodeURIComponent": false,
    "Error": false,
    "escape": false,
    "eval": false,
    "EvalError": false,
    "Float32Array": false,
    "Float64Array": false,
    "Function": false,
    hasOwnProperty: false,
    "Infinity": false,
    "Int16Array": false,
    "Int32Array": false,
    "Int8Array": false,
    "isFinite": false,
    "isNaN": false,
    isPrototypeOf: false,
    "JSON": false,
    "Map": false,
    "Math": false,
    "NaN": false,
    "Number": false,
    "Object": false,
    "parseFloat": false,
    "parseInt": false,
    "Promise": false,
    propertyIsEnumerable: false,
    "Proxy": false,
    "RangeError": false,
    "ReferenceError": false,
    "Reflect": false,
    "RegExp": false,
    "Set": false,
    SharedArrayBuffer: false,
    "String": false,
    "Symbol": false,
    "SyntaxError": false,
    toLocaleString: false,
    toString: false,
    "TypeError": false,
    "Uint16Array": false,
    "Uint32Array": false,
    "Uint8Array": false,
    "Uint8ClampedArray": false,
    "undefined": false,
    "unescape": false,
    "URIError": false,
    valueOf: false,
    "WeakMap": false,
    "WeakSet": false
  };
  var browser$2 = {
    AbortController: false,
    AbortSignal: false,
    addEventListener: false,
    alert: false,
    AnalyserNode: false,
    Animation: false,
    AnimationEffectReadOnly: false,
    AnimationEffectTiming: false,
    AnimationEffectTimingReadOnly: false,
    AnimationEvent: false,
    AnimationPlaybackEvent: false,
    AnimationTimeline: false,
    applicationCache: false,
    ApplicationCache: false,
    ApplicationCacheErrorEvent: false,
    atob: false,
    Attr: false,
    Audio: false,
    AudioBuffer: false,
    AudioBufferSourceNode: false,
    AudioContext: false,
    AudioDestinationNode: false,
    AudioListener: false,
    AudioNode: false,
    AudioParam: false,
    AudioProcessingEvent: false,
    AudioScheduledSourceNode: false,
    "AudioWorkletGlobalScope ": false,
    AudioWorkletNode: false,
    AudioWorkletProcessor: false,
    BarProp: false,
    BaseAudioContext: false,
    BatteryManager: false,
    BeforeUnloadEvent: false,
    BiquadFilterNode: false,
    Blob: false,
    BlobEvent: false,
    blur: false,
    BroadcastChannel: false,
    btoa: false,
    BudgetService: false,
    ByteLengthQueuingStrategy: false,
    Cache: false,
    caches: false,
    CacheStorage: false,
    cancelAnimationFrame: false,
    cancelIdleCallback: false,
    CanvasCaptureMediaStreamTrack: false,
    CanvasGradient: false,
    CanvasPattern: false,
    CanvasRenderingContext2D: false,
    ChannelMergerNode: false,
    ChannelSplitterNode: false,
    CharacterData: false,
    clearInterval: false,
    clearTimeout: false,
    clientInformation: false,
    ClipboardEvent: false,
    close: false,
    closed: false,
    CloseEvent: false,
    Comment: false,
    CompositionEvent: false,
    confirm: false,
    console: false,
    ConstantSourceNode: false,
    ConvolverNode: false,
    CountQueuingStrategy: false,
    createImageBitmap: false,
    Credential: false,
    CredentialsContainer: false,
    crypto: false,
    Crypto: false,
    CryptoKey: false,
    CSS: false,
    CSSConditionRule: false,
    CSSFontFaceRule: false,
    CSSGroupingRule: false,
    CSSImportRule: false,
    CSSKeyframeRule: false,
    CSSKeyframesRule: false,
    CSSMediaRule: false,
    CSSNamespaceRule: false,
    CSSPageRule: false,
    CSSRule: false,
    CSSRuleList: false,
    CSSStyleDeclaration: false,
    CSSStyleRule: false,
    CSSStyleSheet: false,
    CSSSupportsRule: false,
    CustomElementRegistry: false,
    customElements: false,
    CustomEvent: false,
    DataTransfer: false,
    DataTransferItem: false,
    DataTransferItemList: false,
    defaultstatus: false,
    defaultStatus: false,
    DelayNode: false,
    DeviceMotionEvent: false,
    DeviceOrientationEvent: false,
    devicePixelRatio: false,
    dispatchEvent: false,
    document: false,
    Document: false,
    DocumentFragment: false,
    DocumentType: false,
    DOMError: false,
    DOMException: false,
    DOMImplementation: false,
    DOMMatrix: false,
    DOMMatrixReadOnly: false,
    DOMParser: false,
    DOMPoint: false,
    DOMPointReadOnly: false,
    DOMQuad: false,
    DOMRect: false,
    DOMRectReadOnly: false,
    DOMStringList: false,
    DOMStringMap: false,
    DOMTokenList: false,
    DragEvent: false,
    DynamicsCompressorNode: false,
    Element: false,
    ErrorEvent: false,
    event: false,
    Event: false,
    EventSource: false,
    EventTarget: false,
    external: false,
    fetch: false,
    File: false,
    FileList: false,
    FileReader: false,
    find: false,
    focus: false,
    FocusEvent: false,
    FontFace: false,
    FontFaceSetLoadEvent: false,
    FormData: false,
    frameElement: false,
    frames: false,
    GainNode: false,
    Gamepad: false,
    GamepadButton: false,
    GamepadEvent: false,
    getComputedStyle: false,
    getSelection: false,
    HashChangeEvent: false,
    Headers: false,
    history: false,
    History: false,
    HTMLAllCollection: false,
    HTMLAnchorElement: false,
    HTMLAreaElement: false,
    HTMLAudioElement: false,
    HTMLBaseElement: false,
    HTMLBodyElement: false,
    HTMLBRElement: false,
    HTMLButtonElement: false,
    HTMLCanvasElement: false,
    HTMLCollection: false,
    HTMLContentElement: false,
    HTMLDataElement: false,
    HTMLDataListElement: false,
    HTMLDetailsElement: false,
    HTMLDialogElement: false,
    HTMLDirectoryElement: false,
    HTMLDivElement: false,
    HTMLDListElement: false,
    HTMLDocument: false,
    HTMLElement: false,
    HTMLEmbedElement: false,
    HTMLFieldSetElement: false,
    HTMLFontElement: false,
    HTMLFormControlsCollection: false,
    HTMLFormElement: false,
    HTMLFrameElement: false,
    HTMLFrameSetElement: false,
    HTMLHeadElement: false,
    HTMLHeadingElement: false,
    HTMLHRElement: false,
    HTMLHtmlElement: false,
    HTMLIFrameElement: false,
    HTMLImageElement: false,
    HTMLInputElement: false,
    HTMLLabelElement: false,
    HTMLLegendElement: false,
    HTMLLIElement: false,
    HTMLLinkElement: false,
    HTMLMapElement: false,
    HTMLMarqueeElement: false,
    HTMLMediaElement: false,
    HTMLMenuElement: false,
    HTMLMetaElement: false,
    HTMLMeterElement: false,
    HTMLModElement: false,
    HTMLObjectElement: false,
    HTMLOListElement: false,
    HTMLOptGroupElement: false,
    HTMLOptionElement: false,
    HTMLOptionsCollection: false,
    HTMLOutputElement: false,
    HTMLParagraphElement: false,
    HTMLParamElement: false,
    HTMLPictureElement: false,
    HTMLPreElement: false,
    HTMLProgressElement: false,
    HTMLQuoteElement: false,
    HTMLScriptElement: false,
    HTMLSelectElement: false,
    HTMLShadowElement: false,
    HTMLSlotElement: false,
    HTMLSourceElement: false,
    HTMLSpanElement: false,
    HTMLStyleElement: false,
    HTMLTableCaptionElement: false,
    HTMLTableCellElement: false,
    HTMLTableColElement: false,
    HTMLTableElement: false,
    HTMLTableRowElement: false,
    HTMLTableSectionElement: false,
    HTMLTemplateElement: false,
    HTMLTextAreaElement: false,
    HTMLTimeElement: false,
    HTMLTitleElement: false,
    HTMLTrackElement: false,
    HTMLUListElement: false,
    HTMLUnknownElement: false,
    HTMLVideoElement: false,
    IDBCursor: false,
    IDBCursorWithValue: false,
    IDBDatabase: false,
    IDBFactory: false,
    IDBIndex: false,
    IDBKeyRange: false,
    IDBObjectStore: false,
    IDBOpenDBRequest: false,
    IDBRequest: false,
    IDBTransaction: false,
    IDBVersionChangeEvent: false,
    IdleDeadline: false,
    IIRFilterNode: false,
    Image: false,
    ImageBitmap: false,
    ImageBitmapRenderingContext: false,
    ImageCapture: false,
    ImageData: false,
    indexedDB: false,
    innerHeight: false,
    innerWidth: false,
    InputEvent: false,
    IntersectionObserver: false,
    IntersectionObserverEntry: false,
    "Intl": false,
    isSecureContext: false,
    KeyboardEvent: false,
    KeyframeEffect: false,
    KeyframeEffectReadOnly: false,
    length: false,
    localStorage: false,
    location: true,
    Location: false,
    locationbar: false,
    matchMedia: false,
    MediaDeviceInfo: false,
    MediaDevices: false,
    MediaElementAudioSourceNode: false,
    MediaEncryptedEvent: false,
    MediaError: false,
    MediaKeyMessageEvent: false,
    MediaKeySession: false,
    MediaKeyStatusMap: false,
    MediaKeySystemAccess: false,
    MediaList: false,
    MediaQueryList: false,
    MediaQueryListEvent: false,
    MediaRecorder: false,
    MediaSettingsRange: false,
    MediaSource: false,
    MediaStream: false,
    MediaStreamAudioDestinationNode: false,
    MediaStreamAudioSourceNode: false,
    MediaStreamEvent: false,
    MediaStreamTrack: false,
    MediaStreamTrackEvent: false,
    menubar: false,
    MessageChannel: false,
    MessageEvent: false,
    MessagePort: false,
    MIDIAccess: false,
    MIDIConnectionEvent: false,
    MIDIInput: false,
    MIDIInputMap: false,
    MIDIMessageEvent: false,
    MIDIOutput: false,
    MIDIOutputMap: false,
    MIDIPort: false,
    MimeType: false,
    MimeTypeArray: false,
    MouseEvent: false,
    moveBy: false,
    moveTo: false,
    MutationEvent: false,
    MutationObserver: false,
    MutationRecord: false,
    name: false,
    NamedNodeMap: false,
    NavigationPreloadManager: false,
    navigator: false,
    Navigator: false,
    NetworkInformation: false,
    Node: false,
    NodeFilter: false,
    NodeIterator: false,
    NodeList: false,
    Notification: false,
    OfflineAudioCompletionEvent: false,
    OfflineAudioContext: false,
    offscreenBuffering: false,
    OffscreenCanvas: true,
    onabort: true,
    onafterprint: true,
    onanimationend: true,
    onanimationiteration: true,
    onanimationstart: true,
    onappinstalled: true,
    onauxclick: true,
    onbeforeinstallprompt: true,
    onbeforeprint: true,
    onbeforeunload: true,
    onblur: true,
    oncancel: true,
    oncanplay: true,
    oncanplaythrough: true,
    onchange: true,
    onclick: true,
    onclose: true,
    oncontextmenu: true,
    oncuechange: true,
    ondblclick: true,
    ondevicemotion: true,
    ondeviceorientation: true,
    ondeviceorientationabsolute: true,
    ondrag: true,
    ondragend: true,
    ondragenter: true,
    ondragleave: true,
    ondragover: true,
    ondragstart: true,
    ondrop: true,
    ondurationchange: true,
    onemptied: true,
    onended: true,
    onerror: true,
    onfocus: true,
    ongotpointercapture: true,
    onhashchange: true,
    oninput: true,
    oninvalid: true,
    onkeydown: true,
    onkeypress: true,
    onkeyup: true,
    onlanguagechange: true,
    onload: true,
    onloadeddata: true,
    onloadedmetadata: true,
    onloadstart: true,
    onlostpointercapture: true,
    onmessage: true,
    onmessageerror: true,
    onmousedown: true,
    onmouseenter: true,
    onmouseleave: true,
    onmousemove: true,
    onmouseout: true,
    onmouseover: true,
    onmouseup: true,
    onmousewheel: true,
    onoffline: true,
    ononline: true,
    onpagehide: true,
    onpageshow: true,
    onpause: true,
    onplay: true,
    onplaying: true,
    onpointercancel: true,
    onpointerdown: true,
    onpointerenter: true,
    onpointerleave: true,
    onpointermove: true,
    onpointerout: true,
    onpointerover: true,
    onpointerup: true,
    onpopstate: true,
    onprogress: true,
    onratechange: true,
    onrejectionhandled: true,
    onreset: true,
    onresize: true,
    onscroll: true,
    onsearch: true,
    onseeked: true,
    onseeking: true,
    onselect: true,
    onstalled: true,
    onstorage: true,
    onsubmit: true,
    onsuspend: true,
    ontimeupdate: true,
    ontoggle: true,
    ontransitionend: true,
    onunhandledrejection: true,
    onunload: true,
    onvolumechange: true,
    onwaiting: true,
    onwheel: true,
    open: false,
    openDatabase: false,
    opener: false,
    Option: false,
    origin: false,
    OscillatorNode: false,
    outerHeight: false,
    outerWidth: false,
    PageTransitionEvent: false,
    pageXOffset: false,
    pageYOffset: false,
    PannerNode: false,
    parent: false,
    Path2D: false,
    PaymentAddress: false,
    PaymentRequest: false,
    PaymentRequestUpdateEvent: false,
    PaymentResponse: false,
    performance: false,
    Performance: false,
    PerformanceEntry: false,
    PerformanceLongTaskTiming: false,
    PerformanceMark: false,
    PerformanceMeasure: false,
    PerformanceNavigation: false,
    PerformanceNavigationTiming: false,
    PerformanceObserver: false,
    PerformanceObserverEntryList: false,
    PerformancePaintTiming: false,
    PerformanceResourceTiming: false,
    PerformanceTiming: false,
    PeriodicWave: false,
    Permissions: false,
    PermissionStatus: false,
    personalbar: false,
    PhotoCapabilities: false,
    Plugin: false,
    PluginArray: false,
    PointerEvent: false,
    PopStateEvent: false,
    postMessage: false,
    Presentation: false,
    PresentationAvailability: false,
    PresentationConnection: false,
    PresentationConnectionAvailableEvent: false,
    PresentationConnectionCloseEvent: false,
    PresentationConnectionList: false,
    PresentationReceiver: false,
    PresentationRequest: false,
    print: false,
    ProcessingInstruction: false,
    ProgressEvent: false,
    PromiseRejectionEvent: false,
    prompt: false,
    PushManager: false,
    PushSubscription: false,
    PushSubscriptionOptions: false,
    queueMicrotask: false,
    RadioNodeList: false,
    Range: false,
    ReadableStream: false,
    registerProcessor: false,
    RemotePlayback: false,
    removeEventListener: false,
    Request: false,
    requestAnimationFrame: false,
    requestIdleCallback: false,
    resizeBy: false,
    ResizeObserver: false,
    ResizeObserverEntry: false,
    resizeTo: false,
    Response: false,
    RTCCertificate: false,
    RTCDataChannel: false,
    RTCDataChannelEvent: false,
    RTCDtlsTransport: false,
    RTCIceCandidate: false,
    RTCIceGatherer: false,
    RTCIceTransport: false,
    RTCPeerConnection: false,
    RTCPeerConnectionIceEvent: false,
    RTCRtpContributingSource: false,
    RTCRtpReceiver: false,
    RTCRtpSender: false,
    RTCSctpTransport: false,
    RTCSessionDescription: false,
    RTCStatsReport: false,
    RTCTrackEvent: false,
    screen: false,
    Screen: false,
    screenLeft: false,
    ScreenOrientation: false,
    screenTop: false,
    screenX: false,
    screenY: false,
    ScriptProcessorNode: false,
    scroll: false,
    scrollbars: false,
    scrollBy: false,
    scrollTo: false,
    scrollX: false,
    scrollY: false,
    SecurityPolicyViolationEvent: false,
    Selection: false,
    self: false,
    ServiceWorker: false,
    ServiceWorkerContainer: false,
    ServiceWorkerRegistration: false,
    sessionStorage: false,
    setInterval: false,
    setTimeout: false,
    ShadowRoot: false,
    SharedWorker: false,
    SourceBuffer: false,
    SourceBufferList: false,
    speechSynthesis: false,
    SpeechSynthesisEvent: false,
    SpeechSynthesisUtterance: false,
    StaticRange: false,
    status: false,
    statusbar: false,
    StereoPannerNode: false,
    stop: false,
    Storage: false,
    StorageEvent: false,
    StorageManager: false,
    styleMedia: false,
    StyleSheet: false,
    StyleSheetList: false,
    SubtleCrypto: false,
    SVGAElement: false,
    SVGAngle: false,
    SVGAnimatedAngle: false,
    SVGAnimatedBoolean: false,
    SVGAnimatedEnumeration: false,
    SVGAnimatedInteger: false,
    SVGAnimatedLength: false,
    SVGAnimatedLengthList: false,
    SVGAnimatedNumber: false,
    SVGAnimatedNumberList: false,
    SVGAnimatedPreserveAspectRatio: false,
    SVGAnimatedRect: false,
    SVGAnimatedString: false,
    SVGAnimatedTransformList: false,
    SVGAnimateElement: false,
    SVGAnimateMotionElement: false,
    SVGAnimateTransformElement: false,
    SVGAnimationElement: false,
    SVGCircleElement: false,
    SVGClipPathElement: false,
    SVGComponentTransferFunctionElement: false,
    SVGDefsElement: false,
    SVGDescElement: false,
    SVGDiscardElement: false,
    SVGElement: false,
    SVGEllipseElement: false,
    SVGFEBlendElement: false,
    SVGFEColorMatrixElement: false,
    SVGFEComponentTransferElement: false,
    SVGFECompositeElement: false,
    SVGFEConvolveMatrixElement: false,
    SVGFEDiffuseLightingElement: false,
    SVGFEDisplacementMapElement: false,
    SVGFEDistantLightElement: false,
    SVGFEDropShadowElement: false,
    SVGFEFloodElement: false,
    SVGFEFuncAElement: false,
    SVGFEFuncBElement: false,
    SVGFEFuncGElement: false,
    SVGFEFuncRElement: false,
    SVGFEGaussianBlurElement: false,
    SVGFEImageElement: false,
    SVGFEMergeElement: false,
    SVGFEMergeNodeElement: false,
    SVGFEMorphologyElement: false,
    SVGFEOffsetElement: false,
    SVGFEPointLightElement: false,
    SVGFESpecularLightingElement: false,
    SVGFESpotLightElement: false,
    SVGFETileElement: false,
    SVGFETurbulenceElement: false,
    SVGFilterElement: false,
    SVGForeignObjectElement: false,
    SVGGElement: false,
    SVGGeometryElement: false,
    SVGGradientElement: false,
    SVGGraphicsElement: false,
    SVGImageElement: false,
    SVGLength: false,
    SVGLengthList: false,
    SVGLinearGradientElement: false,
    SVGLineElement: false,
    SVGMarkerElement: false,
    SVGMaskElement: false,
    SVGMatrix: false,
    SVGMetadataElement: false,
    SVGMPathElement: false,
    SVGNumber: false,
    SVGNumberList: false,
    SVGPathElement: false,
    SVGPatternElement: false,
    SVGPoint: false,
    SVGPointList: false,
    SVGPolygonElement: false,
    SVGPolylineElement: false,
    SVGPreserveAspectRatio: false,
    SVGRadialGradientElement: false,
    SVGRect: false,
    SVGRectElement: false,
    SVGScriptElement: false,
    SVGSetElement: false,
    SVGStopElement: false,
    SVGStringList: false,
    SVGStyleElement: false,
    SVGSVGElement: false,
    SVGSwitchElement: false,
    SVGSymbolElement: false,
    SVGTextContentElement: false,
    SVGTextElement: false,
    SVGTextPathElement: false,
    SVGTextPositioningElement: false,
    SVGTitleElement: false,
    SVGTransform: false,
    SVGTransformList: false,
    SVGTSpanElement: false,
    SVGUnitTypes: false,
    SVGUseElement: false,
    SVGViewElement: false,
    TaskAttributionTiming: false,
    Text: false,
    TextDecoder: false,
    TextEncoder: false,
    TextEvent: false,
    TextMetrics: false,
    TextTrack: false,
    TextTrackCue: false,
    TextTrackCueList: false,
    TextTrackList: false,
    TimeRanges: false,
    toolbar: false,
    top: false,
    Touch: false,
    TouchEvent: false,
    TouchList: false,
    TrackEvent: false,
    TransitionEvent: false,
    TreeWalker: false,
    UIEvent: false,
    URL: false,
    URLSearchParams: false,
    ValidityState: false,
    visualViewport: false,
    VisualViewport: false,
    VTTCue: false,
    WaveShaperNode: false,
    WebAssembly: false,
    WebGL2RenderingContext: false,
    WebGLActiveInfo: false,
    WebGLBuffer: false,
    WebGLContextEvent: false,
    WebGLFramebuffer: false,
    WebGLProgram: false,
    WebGLQuery: false,
    WebGLRenderbuffer: false,
    WebGLRenderingContext: false,
    WebGLSampler: false,
    WebGLShader: false,
    WebGLShaderPrecisionFormat: false,
    WebGLSync: false,
    WebGLTexture: false,
    WebGLTransformFeedback: false,
    WebGLUniformLocation: false,
    WebGLVertexArrayObject: false,
    WebSocket: false,
    WheelEvent: false,
    window: false,
    Window: false,
    Worker: false,
    WritableStream: false,
    XMLDocument: false,
    XMLHttpRequest: false,
    XMLHttpRequestEventTarget: false,
    XMLHttpRequestUpload: false,
    XMLSerializer: false,
    XPathEvaluator: false,
    XPathExpression: false,
    XPathResult: false,
    XSLTProcessor: false
  };
  var worker = {
    addEventListener: false,
    applicationCache: false,
    atob: false,
    Blob: false,
    BroadcastChannel: false,
    btoa: false,
    Cache: false,
    caches: false,
    clearInterval: false,
    clearTimeout: false,
    close: true,
    console: false,
    fetch: false,
    FileReaderSync: false,
    FormData: false,
    Headers: false,
    IDBCursor: false,
    IDBCursorWithValue: false,
    IDBDatabase: false,
    IDBFactory: false,
    IDBIndex: false,
    IDBKeyRange: false,
    IDBObjectStore: false,
    IDBOpenDBRequest: false,
    IDBRequest: false,
    IDBTransaction: false,
    IDBVersionChangeEvent: false,
    ImageData: false,
    importScripts: true,
    indexedDB: false,
    location: false,
    MessageChannel: false,
    MessagePort: false,
    name: false,
    navigator: false,
    Notification: false,
    onclose: true,
    onconnect: true,
    onerror: true,
    onlanguagechange: true,
    onmessage: true,
    onoffline: true,
    ononline: true,
    onrejectionhandled: true,
    onunhandledrejection: true,
    performance: false,
    Performance: false,
    PerformanceEntry: false,
    PerformanceMark: false,
    PerformanceMeasure: false,
    PerformanceNavigation: false,
    PerformanceResourceTiming: false,
    PerformanceTiming: false,
    postMessage: true,
    "Promise": false,
    queueMicrotask: false,
    removeEventListener: false,
    Request: false,
    Response: false,
    self: true,
    ServiceWorkerRegistration: false,
    setInterval: false,
    setTimeout: false,
    TextDecoder: false,
    TextEncoder: false,
    URL: false,
    URLSearchParams: false,
    WebSocket: false,
    Worker: false,
    WorkerGlobalScope: false,
    XMLHttpRequest: false
  };
  var node = {
    __dirname: false,
    __filename: false,
    Buffer: false,
    clearImmediate: false,
    clearInterval: false,
    clearTimeout: false,
    console: false,
    exports: true,
    global: false,
    "Intl": false,
    module: false,
    process: false,
    queueMicrotask: false,
    require: false,
    setImmediate: false,
    setInterval: false,
    setTimeout: false,
    TextDecoder: false,
    TextEncoder: false,
    URL: false,
    URLSearchParams: false
  };
  var commonjs = {
    exports: true,
    global: false,
    module: false,
    require: false
  };
  var amd = {
    define: false,
    require: false
  };
  var mocha = {
    after: false,
    afterEach: false,
    before: false,
    beforeEach: false,
    context: false,
    describe: false,
    it: false,
    mocha: false,
    run: false,
    setup: false,
    specify: false,
    suite: false,
    suiteSetup: false,
    suiteTeardown: false,
    teardown: false,
    test: false,
    xcontext: false,
    xdescribe: false,
    xit: false,
    xspecify: false
  };
  var jasmine = {
    afterAll: false,
    afterEach: false,
    beforeAll: false,
    beforeEach: false,
    describe: false,
    expect: false,
    fail: false,
    fdescribe: false,
    fit: false,
    it: false,
    jasmine: false,
    pending: false,
    runs: false,
    spyOn: false,
    spyOnProperty: false,
    waits: false,
    waitsFor: false,
    xdescribe: false,
    xit: false
  };
  var jest = {
    afterAll: false,
    afterEach: false,
    beforeAll: false,
    beforeEach: false,
    describe: false,
    expect: false,
    fdescribe: false,
    fit: false,
    it: false,
    jest: false,
    pit: false,
    require: false,
    test: false,
    xdescribe: false,
    xit: false,
    xtest: false
  };
  var qunit = {
    asyncTest: false,
    deepEqual: false,
    equal: false,
    expect: false,
    module: false,
    notDeepEqual: false,
    notEqual: false,
    notOk: false,
    notPropEqual: false,
    notStrictEqual: false,
    ok: false,
    propEqual: false,
    QUnit: false,
    raises: false,
    start: false,
    stop: false,
    strictEqual: false,
    test: false,
    throws: false
  };
  var phantomjs = {
    console: true,
    exports: true,
    phantom: true,
    require: true,
    WebPage: true
  };
  var couch = {
    emit: false,
    exports: false,
    getRow: false,
    log: false,
    module: false,
    provides: false,
    require: false,
    respond: false,
    send: false,
    start: false,
    sum: false
  };
  var rhino = {
    defineClass: false,
    deserialize: false,
    gc: false,
    help: false,
    importClass: false,
    importPackage: false,
    java: false,
    load: false,
    loadClass: false,
    Packages: false,
    print: false,
    quit: false,
    readFile: false,
    readUrl: false,
    runCommand: false,
    seal: false,
    serialize: false,
    spawn: false,
    sync: false,
    toint32: false,
    version: false
  };
  var nashorn = {
    __DIR__: false,
    __FILE__: false,
    __LINE__: false,
    com: false,
    edu: false,
    exit: false,
    java: false,
    Java: false,
    javafx: false,
    JavaImporter: false,
    javax: false,
    JSAdapter: false,
    load: false,
    loadWithNewGlobal: false,
    org: false,
    Packages: false,
    print: false,
    quit: false
  };
  var wsh = {
    ActiveXObject: true,
    Enumerator: true,
    GetObject: true,
    ScriptEngine: true,
    ScriptEngineBuildVersion: true,
    ScriptEngineMajorVersion: true,
    ScriptEngineMinorVersion: true,
    VBArray: true,
    WScript: true,
    WSH: true,
    XDomainRequest: true
  };
  var jquery = {
    $: false,
    jQuery: false
  };
  var yui = {
    YAHOO: false,
    YAHOO_config: false,
    YUI: false,
    YUI_config: false
  };
  var shelljs = {
    cat: false,
    cd: false,
    chmod: false,
    config: false,
    cp: false,
    dirs: false,
    echo: false,
    env: false,
    error: false,
    exec: false,
    exit: false,
    find: false,
    grep: false,
    ln: false,
    ls: false,
    mkdir: false,
    mv: false,
    popd: false,
    pushd: false,
    pwd: false,
    rm: false,
    sed: false,
    set: false,
    target: false,
    tempdir: false,
    test: false,
    touch: false,
    which: false
  };
  var prototypejs = {
    $: false,
    $$: false,
    $A: false,
    $break: false,
    $continue: false,
    $F: false,
    $H: false,
    $R: false,
    $w: false,
    Abstract: false,
    Ajax: false,
    Autocompleter: false,
    Builder: false,
    Class: false,
    Control: false,
    Draggable: false,
    Draggables: false,
    Droppables: false,
    Effect: false,
    Element: false,
    Enumerable: false,
    Event: false,
    Field: false,
    Form: false,
    Hash: false,
    Insertion: false,
    ObjectRange: false,
    PeriodicalExecuter: false,
    Position: false,
    Prototype: false,
    Scriptaculous: false,
    Selector: false,
    Sortable: false,
    SortableObserver: false,
    Sound: false,
    Template: false,
    Toggle: false,
    Try: false
  };
  var meteor = {
    _: false,
    $: false,
    Accounts: false,
    AccountsClient: false,
    AccountsCommon: false,
    AccountsServer: false,
    App: false,
    Assets: false,
    Blaze: false,
    check: false,
    Cordova: false,
    DDP: false,
    DDPRateLimiter: false,
    DDPServer: false,
    Deps: false,
    EJSON: false,
    Email: false,
    HTTP: false,
    Log: false,
    Match: false,
    Meteor: false,
    Mongo: false,
    MongoInternals: false,
    Npm: false,
    Package: false,
    Plugin: false,
    process: false,
    Random: false,
    ReactiveDict: false,
    ReactiveVar: false,
    Router: false,
    ServiceConfiguration: false,
    Session: false,
    share: false,
    Spacebars: false,
    Template: false,
    Tinytest: false,
    Tracker: false,
    UI: false,
    Utils: false,
    WebApp: false,
    WebAppInternals: false
  };
  var mongo = {
    _isWindows: false,
    _rand: false,
    BulkWriteResult: false,
    cat: false,
    cd: false,
    connect: false,
    db: false,
    getHostName: false,
    getMemInfo: false,
    hostname: false,
    ISODate: false,
    listFiles: false,
    load: false,
    ls: false,
    md5sumFile: false,
    mkdir: false,
    Mongo: false,
    NumberInt: false,
    NumberLong: false,
    ObjectId: false,
    PlanCache: false,
    print: false,
    printjson: false,
    pwd: false,
    quit: false,
    removeFile: false,
    rs: false,
    sh: false,
    UUID: false,
    version: false,
    WriteResult: false
  };
  var applescript = {
    $: false,
    Application: false,
    Automation: false,
    console: false,
    delay: false,
    Library: false,
    ObjC: false,
    ObjectSpecifier: false,
    Path: false,
    Progress: false,
    Ref: false
  };
  var serviceworker = {
    addEventListener: false,
    applicationCache: false,
    atob: false,
    Blob: false,
    BroadcastChannel: false,
    btoa: false,
    Cache: false,
    caches: false,
    CacheStorage: false,
    clearInterval: false,
    clearTimeout: false,
    Client: false,
    clients: false,
    Clients: false,
    close: true,
    console: false,
    ExtendableEvent: false,
    ExtendableMessageEvent: false,
    fetch: false,
    FetchEvent: false,
    FileReaderSync: false,
    FormData: false,
    Headers: false,
    IDBCursor: false,
    IDBCursorWithValue: false,
    IDBDatabase: false,
    IDBFactory: false,
    IDBIndex: false,
    IDBKeyRange: false,
    IDBObjectStore: false,
    IDBOpenDBRequest: false,
    IDBRequest: false,
    IDBTransaction: false,
    IDBVersionChangeEvent: false,
    ImageData: false,
    importScripts: false,
    indexedDB: false,
    location: false,
    MessageChannel: false,
    MessagePort: false,
    name: false,
    navigator: false,
    Notification: false,
    onclose: true,
    onconnect: true,
    onerror: true,
    onfetch: true,
    oninstall: true,
    onlanguagechange: true,
    onmessage: true,
    onmessageerror: true,
    onnotificationclick: true,
    onnotificationclose: true,
    onoffline: true,
    ononline: true,
    onpush: true,
    onpushsubscriptionchange: true,
    onrejectionhandled: true,
    onsync: true,
    onunhandledrejection: true,
    performance: false,
    Performance: false,
    PerformanceEntry: false,
    PerformanceMark: false,
    PerformanceMeasure: false,
    PerformanceNavigation: false,
    PerformanceResourceTiming: false,
    PerformanceTiming: false,
    postMessage: true,
    "Promise": false,
    queueMicrotask: false,
    registration: false,
    removeEventListener: false,
    Request: false,
    Response: false,
    self: false,
    ServiceWorker: false,
    ServiceWorkerContainer: false,
    ServiceWorkerGlobalScope: false,
    ServiceWorkerMessageEvent: false,
    ServiceWorkerRegistration: false,
    setInterval: false,
    setTimeout: false,
    skipWaiting: false,
    TextDecoder: false,
    TextEncoder: false,
    URL: false,
    URLSearchParams: false,
    WebSocket: false,
    WindowClient: false,
    Worker: false,
    WorkerGlobalScope: false,
    XMLHttpRequest: false
  };
  var atomtest = {
    advanceClock: false,
    fakeClearInterval: false,
    fakeClearTimeout: false,
    fakeSetInterval: false,
    fakeSetTimeout: false,
    resetTimeouts: false,
    waitsForPromise: false
  };
  var embertest = {
    andThen: false,
    click: false,
    currentPath: false,
    currentRouteName: false,
    currentURL: false,
    fillIn: false,
    find: false,
    findAll: false,
    findWithAssert: false,
    keyEvent: false,
    pauseTest: false,
    resumeTest: false,
    triggerEvent: false,
    visit: false,
    wait: false
  };
  var protractor = {
    $: false,
    $$: false,
    browser: false,
    by: false,
    By: false,
    DartObject: false,
    element: false,
    protractor: false
  };
  var webextensions = {
    browser: false,
    chrome: false,
    opr: false
  };
  var greasemonkey = {
    cloneInto: false,
    createObjectIn: false,
    exportFunction: false,
    GM: false,
    GM_addStyle: false,
    GM_deleteValue: false,
    GM_getResourceText: false,
    GM_getResourceURL: false,
    GM_getValue: false,
    GM_info: false,
    GM_listValues: false,
    GM_log: false,
    GM_openInTab: false,
    GM_registerMenuCommand: false,
    GM_setClipboard: false,
    GM_setValue: false,
    GM_xmlhttpRequest: false,
    unsafeWindow: false
  };
  var devtools = {
    $: false,
    $_: false,
    $$: false,
    $0: false,
    $1: false,
    $2: false,
    $3: false,
    $4: false,
    $x: false,
    chrome: false,
    clear: false,
    copy: false,
    debug: false,
    dir: false,
    dirxml: false,
    getEventListeners: false,
    inspect: false,
    keys: false,
    monitor: false,
    monitorEvents: false,
    profile: false,
    profileEnd: false,
    queryObjects: false,
    table: false,
    undebug: false,
    unmonitor: false,
    unmonitorEvents: false,
    values: false
  };
  var globals = {
    builtin: builtin,
    es5: es5,
    es2015: es2015,
    es2017: es2017,
    browser: browser$2,
    worker: worker,
    node: node,
    commonjs: commonjs,
    amd: amd,
    mocha: mocha,
    jasmine: jasmine,
    jest: jest,
    qunit: qunit,
    phantomjs: phantomjs,
    couch: couch,
    rhino: rhino,
    nashorn: nashorn,
    wsh: wsh,
    jquery: jquery,
    yui: yui,
    shelljs: shelljs,
    prototypejs: prototypejs,
    meteor: meteor,
    mongo: mongo,
    applescript: applescript,
    serviceworker: serviceworker,
    atomtest: atomtest,
    embertest: embertest,
    protractor: protractor,
    "shared-node-browser": {
    clearInterval: false,
    clearTimeout: false,
    console: false,
    setInterval: false,
    setTimeout: false,
    URL: false,
    URLSearchParams: false
  },
    webextensions: webextensions,
    greasemonkey: greasemonkey,
    devtools: devtools
  };

  var globals$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    builtin: builtin,
    es5: es5,
    es2015: es2015,
    es2017: es2017,
    browser: browser$2,
    worker: worker,
    node: node,
    commonjs: commonjs,
    amd: amd,
    mocha: mocha,
    jasmine: jasmine,
    jest: jest,
    qunit: qunit,
    phantomjs: phantomjs,
    couch: couch,
    rhino: rhino,
    nashorn: nashorn,
    wsh: wsh,
    jquery: jquery,
    yui: yui,
    shelljs: shelljs,
    prototypejs: prototypejs,
    meteor: meteor,
    mongo: mongo,
    applescript: applescript,
    serviceworker: serviceworker,
    atomtest: atomtest,
    embertest: embertest,
    protractor: protractor,
    webextensions: webextensions,
    greasemonkey: greasemonkey,
    devtools: devtools,
    'default': globals
  });

  var require$$0 = getCjsExportFromNamespace(globals$1);

  var globals$2 = require$$0;

  var path = new WeakMap();
  var scope = new WeakMap();
  function clear() {
    clearPath();
    clearScope();
  }
  function clearPath() {
    path = new WeakMap();
  }
  function clearScope() {
    scope = new WeakMap();
  }

  var cache = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get path () { return path; },
    get scope () { return scope; },
    clear: clear,
    clearPath: clearPath,
    clearScope: clearScope
  });

  function gatherNodeParts(node, parts) {
    switch (node == null ? void 0 : node.type) {
      default:
        if (isModuleDeclaration(node)) {
          if (node.source) {
            gatherNodeParts(node.source, parts);
          } else if (node.specifiers && node.specifiers.length) {
            for (var _iterator = node.specifiers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var e = _ref;
              gatherNodeParts(e, parts);
            }
          } else if (node.declaration) {
            gatherNodeParts(node.declaration, parts);
          }
        } else if (isModuleSpecifier(node)) {
          gatherNodeParts(node.local, parts);
        } else if (isLiteral(node)) {
          parts.push(node.value);
        }

        break;

      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        gatherNodeParts(node.object, parts);
        gatherNodeParts(node.property, parts);
        break;

      case "Identifier":
      case "JSXIdentifier":
        parts.push(node.name);
        break;

      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        gatherNodeParts(node.callee, parts);
        break;

      case "ObjectExpression":
      case "ObjectPattern":
        for (var _iterator2 = node.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
          var _ref2;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
          }

          var _e = _ref2;
          gatherNodeParts(_e, parts);
        }

        break;

      case "SpreadElement":
      case "RestElement":
        gatherNodeParts(node.argument, parts);
        break;

      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        gatherNodeParts(node.key, parts);
        break;

      case "ThisExpression":
        parts.push("this");
        break;

      case "Super":
        parts.push("super");
        break;

      case "Import":
        parts.push("import");
        break;

      case "DoExpression":
        parts.push("do");
        break;

      case "YieldExpression":
        parts.push("yield");
        gatherNodeParts(node.argument, parts);
        break;

      case "AwaitExpression":
        parts.push("await");
        gatherNodeParts(node.argument, parts);
        break;

      case "AssignmentExpression":
        gatherNodeParts(node.left, parts);
        break;

      case "VariableDeclarator":
        gatherNodeParts(node.id, parts);
        break;

      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        gatherNodeParts(node.id, parts);
        break;

      case "PrivateName":
        gatherNodeParts(node.id, parts);
        break;

      case "ParenthesizedExpression":
        gatherNodeParts(node.expression, parts);
        break;

      case "UnaryExpression":
      case "UpdateExpression":
        gatherNodeParts(node.argument, parts);
        break;

      case "MetaProperty":
        gatherNodeParts(node.meta, parts);
        gatherNodeParts(node.property, parts);
        break;

      case "JSXElement":
        gatherNodeParts(node.openingElement, parts);
        break;

      case "JSXOpeningElement":
        parts.push(node.name);
        break;

      case "JSXFragment":
        gatherNodeParts(node.openingFragment, parts);
        break;

      case "JSXOpeningFragment":
        parts.push("Fragment");
        break;

      case "JSXNamespacedName":
        gatherNodeParts(node.namespace, parts);
        gatherNodeParts(node.name, parts);
        break;
    }
  }

  var collectorVisitor = {
    For: function For(path) {
      for (var _i3 = 0, _arr = FOR_INIT_KEYS; _i3 < _arr.length; _i3++) {
        var key = _arr[_i3];
        var declar = path.get(key);

        if (declar.isVar()) {
          var parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
          parentScope.registerBinding("var", declar);
        }
      }
    },
    Declaration: function Declaration(path) {
      if (path.isBlockScoped()) return;

      if (path.isExportDeclaration() && path.get("declaration").isDeclaration()) {
        return;
      }

      var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
      parent.registerDeclaration(path);
    },
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      state.references.push(path);
    },
    ForXStatement: function ForXStatement(path, state) {
      var left = path.get("left");

      if (left.isPattern() || left.isIdentifier()) {
        state.constantViolations.push(path);
      }
    },
    ExportDeclaration: {
      exit: function exit(path) {
        var node = path.node,
            scope = path.scope;
        var declar = node.declaration;

        if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
          var id = declar.id;
          if (!id) return;
          var binding = scope.getBinding(id.name);
          if (binding) binding.reference(path);
        } else if (isVariableDeclaration(declar)) {
          for (var _i4 = 0, _arr2 = declar.declarations; _i4 < _arr2.length; _i4++) {
            var decl = _arr2[_i4];

            for (var _i5 = 0, _Object$keys = Object.keys(getBindingIdentifiers(decl)); _i5 < _Object$keys.length; _i5++) {
              var name = _Object$keys[_i5];

              var _binding = scope.getBinding(name);

              if (_binding) _binding.reference(path);
            }
          }
        }
      }
    },
    LabeledStatement: function LabeledStatement(path) {
      path.scope.getProgramParent().addGlobal(path.node);
      path.scope.getBlockParent().registerDeclaration(path);
    },
    AssignmentExpression: function AssignmentExpression(path, state) {
      state.assignments.push(path);
    },
    UpdateExpression: function UpdateExpression(path, state) {
      state.constantViolations.push(path);
    },
    UnaryExpression: function UnaryExpression(path, state) {
      if (path.node.operator === "delete") {
        state.constantViolations.push(path);
      }
    },
    BlockScoped: function BlockScoped(path) {
      var scope = path.scope;
      if (scope.path === path) scope = scope.parent;
      var parent = scope.getBlockParent();
      parent.registerDeclaration(path);

      if (path.isClassDeclaration() && path.node.id) {
        var id = path.node.id;
        var name = id.name;
        path.scope.bindings[name] = path.scope.parent.getBinding(name);
      }
    },
    Block: function Block(path) {
      var paths = path.get("body");

      for (var _i6 = 0, _arr3 = paths; _i6 < _arr3.length; _i6++) {
        var bodyPath = _arr3[_i6];

        if (bodyPath.isFunctionDeclaration()) {
          path.scope.getBlockParent().registerDeclaration(bodyPath);
        }
      }
    }
  };
  var uid = 0;

  var Scope$1 = function () {
    function Scope(path) {
      var node = path.node;
      var cached = scope.get(node);

      if (cached && cached.path === path) {
        return cached;
      }

      scope.set(node, this);
      this.uid = uid++;
      this.block = node;
      this.path = path;
      this.labels = new Map();
    }

    var _proto = Scope.prototype;

    _proto.traverse = function traverse(node, opts, state) {
      traverse$1(node, opts, this, state, this.path);
    };

    _proto.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier(name) {
      var id = this.generateUidIdentifier(name);
      this.push({
        id: id
      });
      return cloneNode(id);
    };

    _proto.generateUidIdentifier = function generateUidIdentifier(name) {
      return Identifier(this.generateUid(name));
    };

    _proto.generateUid = function generateUid(name) {
      if (name === void 0) {
        name = "temp";
      }

      name = toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      var uid;
      var i = 0;

      do {
        uid = this._generateUid(name, i);
        i++;
      } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

      var program = this.getProgramParent();
      program.references[uid] = true;
      program.uids[uid] = true;
      return uid;
    };

    _proto._generateUid = function _generateUid(name, i) {
      var id = name;
      if (i > 1) id += i;
      return "_" + id;
    };

    _proto.generateUidBasedOnNode = function generateUidBasedOnNode(node, defaultName) {
      var parts = [];
      gatherNodeParts(node, parts);
      var id = parts.join("$");
      id = id.replace(/^_/, "") || defaultName || "ref";
      return this.generateUid(id.slice(0, 20));
    };

    _proto.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(node, defaultName) {
      return Identifier(this.generateUidBasedOnNode(node, defaultName));
    };

    _proto.isStatic = function isStatic(node) {
      if (isThisExpression(node) || isSuper(node)) {
        return true;
      }

      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);

        if (binding) {
          return binding.constant;
        } else {
          return this.hasBinding(node.name);
        }
      }

      return false;
    };

    _proto.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
      if (this.isStatic(node)) {
        return null;
      } else {
        var id = this.generateUidIdentifierBasedOnNode(node);

        if (!dontPush) {
          this.push({
            id: id
          });
          return cloneNode(id);
        }

        return id;
      }
    };

    _proto.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {
      if (kind === "param") return;
      if (local.kind === "local") return;
      var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const");

      if (duplicate) {
        throw this.hub.buildError(id, "Duplicate declaration \"" + name + "\"", TypeError);
      }
    };

    _proto.rename = function rename(oldName, newName, block) {
      var binding = this.getBinding(oldName);

      if (binding) {
        newName = newName || this.generateUidIdentifier(oldName).name;
        return new Renamer(binding, oldName, newName).rename(block);
      }
    };

    _proto._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
      if (map[oldName]) {
        map[newName] = value;
        map[oldName] = null;
      }
    };

    _proto.dump = function dump() {
      var sep = repeat_1("-", 60);
      console.log(sep);
      var scope = this;

      do {
        console.log("#", scope.block.type);

        for (var _i7 = 0, _Object$keys2 = Object.keys(scope.bindings); _i7 < _Object$keys2.length; _i7++) {
          var name = _Object$keys2[_i7];
          var binding = scope.bindings[name];
          console.log(" -", name, {
            constant: binding.constant,
            references: binding.references,
            violations: binding.constantViolations.length,
            kind: binding.kind
          });
        }
      } while (scope = scope.parent);

      console.log(sep);
    };

    _proto.toArray = function toArray(node, i) {
      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);

        if (binding && binding.constant && binding.path.isGenericType("Array")) {
          return node;
        }
      }

      if (isArrayExpression(node)) {
        return node;
      }

      if (isIdentifier(node, {
        name: "arguments"
      })) {
        return CallExpression(MemberExpression(MemberExpression(MemberExpression(Identifier("Array"), Identifier("prototype")), Identifier("slice")), Identifier("call")), [node]);
      }

      var helperName;
      var args = [node];

      if (i === true) {
        helperName = "toConsumableArray";
      } else if (i) {
        args.push(NumericLiteral(i));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }

      return CallExpression(this.hub.addHelper(helperName), args);
    };

    _proto.hasLabel = function hasLabel(name) {
      return !!this.getLabel(name);
    };

    _proto.getLabel = function getLabel(name) {
      return this.labels.get(name);
    };

    _proto.registerLabel = function registerLabel(path) {
      this.labels.set(path.node.label.name, path);
    };

    _proto.registerDeclaration = function registerDeclaration(path) {
      if (path.isLabeledStatement()) {
        this.registerLabel(path);
      } else if (path.isFunctionDeclaration()) {
        this.registerBinding("hoisted", path.get("id"), path);
      } else if (path.isVariableDeclaration()) {
        var declarations = path.get("declarations");

        for (var _i8 = 0, _arr4 = declarations; _i8 < _arr4.length; _i8++) {
          var declar = _arr4[_i8];
          this.registerBinding(path.node.kind, declar);
        }
      } else if (path.isClassDeclaration()) {
        this.registerBinding("let", path);
      } else if (path.isImportDeclaration()) {
        var specifiers = path.get("specifiers");

        for (var _i9 = 0, _arr5 = specifiers; _i9 < _arr5.length; _i9++) {
          var specifier = _arr5[_i9];
          this.registerBinding("module", specifier);
        }
      } else if (path.isExportDeclaration()) {
        var _declar = path.get("declaration");

        if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
          this.registerDeclaration(_declar);
        }
      } else {
        this.registerBinding("unknown", path);
      }
    };

    _proto.buildUndefinedNode = function buildUndefinedNode() {
      return UnaryExpression("void", NumericLiteral(0), true);
    };

    _proto.registerConstantViolation = function registerConstantViolation(path) {
      var ids = path.getBindingIdentifiers();

      for (var _i10 = 0, _Object$keys3 = Object.keys(ids); _i10 < _Object$keys3.length; _i10++) {
        var name = _Object$keys3[_i10];
        var binding = this.getBinding(name);
        if (binding) binding.reassign(path);
      }
    };

    _proto.registerBinding = function registerBinding(kind, path, bindingPath) {
      if (bindingPath === void 0) {
        bindingPath = path;
      }

      if (!kind) throw new ReferenceError("no `kind`");

      if (path.isVariableDeclaration()) {
        var declarators = path.get("declarations");

        for (var _iterator3 = declarators, _isArray3 = Array.isArray(_iterator3), _i11 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
          var _ref3;

          if (_isArray3) {
            if (_i11 >= _iterator3.length) break;
            _ref3 = _iterator3[_i11++];
          } else {
            _i11 = _iterator3.next();
            if (_i11.done) break;
            _ref3 = _i11.value;
          }

          var declar = _ref3;
          this.registerBinding(kind, declar);
        }

        return;
      }

      var parent = this.getProgramParent();
      var ids = path.getOuterBindingIdentifiers(true);

      for (var _i12 = 0, _Object$keys4 = Object.keys(ids); _i12 < _Object$keys4.length; _i12++) {
        var name = _Object$keys4[_i12];

        for (var _i13 = 0, _arr6 = ids[name]; _i13 < _arr6.length; _i13++) {
          var id = _arr6[_i13];
          var local = this.getOwnBinding(name);

          if (local) {
            if (local.identifier === id) continue;
            this.checkBlockScopedCollisions(local, kind, name, id);
          }

          parent.references[name] = true;

          if (local) {
            this.registerConstantViolation(bindingPath);
          } else {
            this.bindings[name] = new Binding({
              identifier: id,
              scope: this,
              path: bindingPath,
              kind: kind
            });
          }
        }
      }
    };

    _proto.addGlobal = function addGlobal(node) {
      this.globals[node.name] = node;
    };

    _proto.hasUid = function hasUid(name) {
      var scope = this;

      do {
        if (scope.uids[name]) return true;
      } while (scope = scope.parent);

      return false;
    };

    _proto.hasGlobal = function hasGlobal(name) {
      var scope = this;

      do {
        if (scope.globals[name]) return true;
      } while (scope = scope.parent);

      return false;
    };

    _proto.hasReference = function hasReference(name) {
      var scope = this;

      do {
        if (scope.references[name]) return true;
      } while (scope = scope.parent);

      return false;
    };

    _proto.isPure = function isPure(node, constantsOnly) {
      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);
        if (!binding) return false;
        if (constantsOnly) return binding.constant;
        return true;
      } else if (isClass(node)) {
        if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
          return false;
        }

        return this.isPure(node.body, constantsOnly);
      } else if (isClassBody(node)) {
        for (var _iterator4 = node.body, _isArray4 = Array.isArray(_iterator4), _i14 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
          var _ref4;

          if (_isArray4) {
            if (_i14 >= _iterator4.length) break;
            _ref4 = _iterator4[_i14++];
          } else {
            _i14 = _iterator4.next();
            if (_i14.done) break;
            _ref4 = _i14.value;
          }

          var method = _ref4;
          if (!this.isPure(method, constantsOnly)) return false;
        }

        return true;
      } else if (isBinary(node)) {
        return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
      } else if (isArrayExpression(node)) {
        for (var _i15 = 0, _arr7 = node.elements; _i15 < _arr7.length; _i15++) {
          var elem = _arr7[_i15];
          if (!this.isPure(elem, constantsOnly)) return false;
        }

        return true;
      } else if (isObjectExpression(node)) {
        for (var _i16 = 0, _arr8 = node.properties; _i16 < _arr8.length; _i16++) {
          var prop = _arr8[_i16];
          if (!this.isPure(prop, constantsOnly)) return false;
        }

        return true;
      } else if (isClassMethod(node)) {
        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
        if (node.kind === "get" || node.kind === "set") return false;
        return true;
      } else if (isProperty(node)) {
        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
        return this.isPure(node.value, constantsOnly);
      } else if (isUnaryExpression(node)) {
        return this.isPure(node.argument, constantsOnly);
      } else if (isTaggedTemplateExpression(node)) {
        return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
      } else if (isTemplateLiteral(node)) {
        for (var _i17 = 0, _arr9 = node.expressions; _i17 < _arr9.length; _i17++) {
          var expression = _arr9[_i17];
          if (!this.isPure(expression, constantsOnly)) return false;
        }

        return true;
      } else {
        return isPureish(node);
      }
    };

    _proto.setData = function setData(key, val) {
      return this.data[key] = val;
    };

    _proto.getData = function getData(key) {
      var scope = this;

      do {
        var data = scope.data[key];
        if (data != null) return data;
      } while (scope = scope.parent);
    };

    _proto.removeData = function removeData(key) {
      var scope = this;

      do {
        var data = scope.data[key];
        if (data != null) scope.data[key] = null;
      } while (scope = scope.parent);
    };

    _proto.init = function init() {
      if (!this.references) this.crawl();
    };

    _proto.crawl = function crawl() {
      var path = this.path;
      this.references = Object.create(null);
      this.bindings = Object.create(null);
      this.globals = Object.create(null);
      this.uids = Object.create(null);
      this.data = Object.create(null);

      if (path.isLoop()) {
        for (var _i18 = 0, _arr10 = FOR_INIT_KEYS; _i18 < _arr10.length; _i18++) {
          var key = _arr10[_i18];
          var node = path.get(key);
          if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);
        }
      }

      if (path.isFunctionExpression() && path.has("id")) {
        if (!path.get("id").node[NOT_LOCAL_BINDING]) {
          this.registerBinding("local", path.get("id"), path);
        }
      }

      if (path.isClassExpression() && path.has("id")) {
        if (!path.get("id").node[NOT_LOCAL_BINDING]) {
          this.registerBinding("local", path);
        }
      }

      if (path.isFunction()) {
        var params = path.get("params");

        for (var _iterator5 = params, _isArray5 = Array.isArray(_iterator5), _i19 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
          var _ref5;

          if (_isArray5) {
            if (_i19 >= _iterator5.length) break;
            _ref5 = _iterator5[_i19++];
          } else {
            _i19 = _iterator5.next();
            if (_i19.done) break;
            _ref5 = _i19.value;
          }

          var param = _ref5;
          this.registerBinding("param", param);
        }
      }

      if (path.isCatchClause()) {
        this.registerBinding("let", path);
      }

      var parent = this.getProgramParent();
      if (parent.crawling) return;
      var state = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      this.crawling = true;
      path.traverse(collectorVisitor, state);
      this.crawling = false;

      for (var _iterator6 = state.assignments, _isArray6 = Array.isArray(_iterator6), _i20 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
        var _ref6;

        if (_isArray6) {
          if (_i20 >= _iterator6.length) break;
          _ref6 = _iterator6[_i20++];
        } else {
          _i20 = _iterator6.next();
          if (_i20.done) break;
          _ref6 = _i20.value;
        }

        var _path = _ref6;

        var ids = _path.getBindingIdentifiers();

        var programParent = void 0;

        for (var _i23 = 0, _Object$keys5 = Object.keys(ids); _i23 < _Object$keys5.length; _i23++) {
          var name = _Object$keys5[_i23];
          if (_path.scope.getBinding(name)) continue;
          programParent = programParent || _path.scope.getProgramParent();
          programParent.addGlobal(ids[name]);
        }

        _path.scope.registerConstantViolation(_path);
      }

      for (var _iterator7 = state.references, _isArray7 = Array.isArray(_iterator7), _i21 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
        var _ref7;

        if (_isArray7) {
          if (_i21 >= _iterator7.length) break;
          _ref7 = _iterator7[_i21++];
        } else {
          _i21 = _iterator7.next();
          if (_i21.done) break;
          _ref7 = _i21.value;
        }

        var ref = _ref7;
        var binding = ref.scope.getBinding(ref.node.name);

        if (binding) {
          binding.reference(ref);
        } else {
          ref.scope.getProgramParent().addGlobal(ref.node);
        }
      }

      for (var _iterator8 = state.constantViolations, _isArray8 = Array.isArray(_iterator8), _i22 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
        var _ref8;

        if (_isArray8) {
          if (_i22 >= _iterator8.length) break;
          _ref8 = _iterator8[_i22++];
        } else {
          _i22 = _iterator8.next();
          if (_i22.done) break;
          _ref8 = _i22.value;
        }

        var _path2 = _ref8;

        _path2.scope.registerConstantViolation(_path2);
      }
    };

    _proto.push = function push(opts) {
      var path = this.path;

      if (!path.isBlockStatement() && !path.isProgram()) {
        path = this.getBlockParent().path;
      }

      if (path.isSwitchStatement()) {
        path = (this.getFunctionParent() || this.getProgramParent()).path;
      }

      if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
        path.ensureBlock();
        path = path.get("body");
      }

      var unique = opts.unique;
      var kind = opts.kind || "var";
      var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
      var dataKey = "declaration:" + kind + ":" + blockHoist;
      var declarPath = !unique && path.getData(dataKey);

      if (!declarPath) {
        var declar = VariableDeclaration(kind, []);
        declar._blockHoist = blockHoist;

        var _path$unshiftContaine = path.unshiftContainer("body", [declar]);

        declarPath = _path$unshiftContaine[0];
        if (!unique) path.setData(dataKey, declarPath);
      }

      var declarator = VariableDeclarator(opts.id, opts.init);
      declarPath.node.declarations.push(declarator);
      this.registerBinding(kind, declarPath.get("declarations").pop());
    };

    _proto.getProgramParent = function getProgramParent() {
      var scope = this;

      do {
        if (scope.path.isProgram()) {
          return scope;
        }
      } while (scope = scope.parent);

      throw new Error("Couldn't find a Program");
    };

    _proto.getFunctionParent = function getFunctionParent() {
      var scope = this;

      do {
        if (scope.path.isFunctionParent()) {
          return scope;
        }
      } while (scope = scope.parent);

      return null;
    };

    _proto.getBlockParent = function getBlockParent() {
      var scope = this;

      do {
        if (scope.path.isBlockParent()) {
          return scope;
        }
      } while (scope = scope.parent);

      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    };

    _proto.getAllBindings = function getAllBindings() {
      var ids = Object.create(null);
      var scope = this;

      do {
        defaults_1(ids, scope.bindings);
        scope = scope.parent;
      } while (scope);

      return ids;
    };

    _proto.getAllBindingsOfKind = function getAllBindingsOfKind() {
      var ids = Object.create(null);

      for (var _i24 = 0, _arr11 = arguments; _i24 < _arr11.length; _i24++) {
        var kind = _arr11[_i24];
        var scope = this;

        do {
          for (var _i25 = 0, _Object$keys6 = Object.keys(scope.bindings); _i25 < _Object$keys6.length; _i25++) {
            var name = _Object$keys6[_i25];
            var binding = scope.bindings[name];
            if (binding.kind === kind) ids[name] = binding;
          }

          scope = scope.parent;
        } while (scope);
      }

      return ids;
    };

    _proto.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
      return this.getBindingIdentifier(name) === node;
    };

    _proto.getBinding = function getBinding(name) {
      var scope = this;
      var previousPath;

      do {
        var binding = scope.getOwnBinding(name);

        if (binding) {
          if (previousPath && previousPath.isPattern() && previousPath.parentPath.isFunction() && binding.kind !== "param") ; else {
            return binding;
          }
        }

        previousPath = scope.path;
      } while (scope = scope.parent);
    };

    _proto.getOwnBinding = function getOwnBinding(name) {
      return this.bindings[name];
    };

    _proto.getBindingIdentifier = function getBindingIdentifier(name) {
      var info = this.getBinding(name);
      return info && info.identifier;
    };

    _proto.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
      var binding = this.bindings[name];
      return binding && binding.identifier;
    };

    _proto.hasOwnBinding = function hasOwnBinding(name) {
      return !!this.getOwnBinding(name);
    };

    _proto.hasBinding = function hasBinding(name, noGlobals) {
      if (!name) return false;
      if (this.hasOwnBinding(name)) return true;
      if (this.parentHasBinding(name, noGlobals)) return true;
      if (this.hasUid(name)) return true;
      if (!noGlobals && includes_1(Scope.globals, name)) return true;
      if (!noGlobals && includes_1(Scope.contextVariables, name)) return true;
      return false;
    };

    _proto.parentHasBinding = function parentHasBinding(name, noGlobals) {
      return this.parent && this.parent.hasBinding(name, noGlobals);
    };

    _proto.moveBindingTo = function moveBindingTo(name, scope) {
      var info = this.getBinding(name);

      if (info) {
        info.scope.removeOwnBinding(name);
        info.scope = scope;
        scope.bindings[name] = info;
      }
    };

    _proto.removeOwnBinding = function removeOwnBinding(name) {
      delete this.bindings[name];
    };

    _proto.removeBinding = function removeBinding(name) {
      var info = this.getBinding(name);

      if (info) {
        info.scope.removeOwnBinding(name);
      }

      var scope = this;

      do {
        if (scope.uids[name]) {
          scope.uids[name] = false;
        }
      } while (scope = scope.parent);
    };

    _createClass(Scope, [{
      key: "parent",
      get: function get() {
        var parent = this.path.findParent(function (p) {
          return p.isScope();
        });
        return parent && parent.scope;
      }
    }, {
      key: "parentBlock",
      get: function get() {
        return this.path.parent;
      }
    }, {
      key: "hub",
      get: function get() {
        return this.path.hub;
      }
    }]);

    return Scope;
  }();

  Scope$1.globals = Object.keys(globals$2.builtin);
  Scope$1.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  var encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }

    throw new TypeError("Must be between 0 and 63: " + number);
  };

  var decode = function (charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;

    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }

    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }

    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }

    if (charCode == plus) {
      return 62;
    }

    if (charCode == slash) {
      return 63;
    }

    return -1;
  };

  var base64 = {
    encode: encode,
    decode: decode
  };

  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }

  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }

  var encode$1 = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;

      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }

      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));

      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };

  var base64Vlq = {
    encode: encode$1,
    decode: decode$1
  };

  var util = createCommonjsModule(function (module, exports) {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }

  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);

    if (!match) {
      return null;
    }

    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }

  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';

    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }

    url += '//';

    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }

    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }

    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }

    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }

    return url;
  }

  exports.urlGenerate = urlGenerate;

  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);

    if (url) {
      if (!url.path) {
        return aPath;
      }

      path = url.path;
    }

    var isAbsolute = exports.isAbsolute(path);
    var parts = path.split(/\/+/);

    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];

      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }

    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }

    return path;
  }

  exports.normalize = normalize;

  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    if (aPath === "") {
      aPath = ".";
    }

    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);

    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }

      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }

    return joined;
  }

  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
  };

  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');
    var level = 0;

    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");

      if (index < 0) {
        return aPath;
      }

      aRoot = aRoot.slice(0, index);

      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    }

    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }

  exports.relative = relative;

  var supportsNullProto = function () {
    var obj = Object.create(null);
    return !('__proto__' in obj);
  }();

  function identity(s) {
    return s;
  }

  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return '$' + aStr;
    }

    return aStr;
  }

  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }

  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9) {
        return false;
      }

    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36) {
          return false;
        }
    }

    return true;
  }

  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByOriginalPositions = compareByOriginalPositions;

  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 === null) {
      return 1;
    }

    if (aStr2 === null) {
      return -1;
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }

  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
  }

  exports.parseSourceMapInput = parseSourceMapInput;

  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || '';

    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
        sourceRoot += '/';
      }

      sourceURL = sourceRoot + sourceURL;
    }

    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);

      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }

      if (parsed.path) {
        var index = parsed.path.lastIndexOf('/');

        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }

      sourceURL = join(urlGenerate(parsed), sourceURL);
    }

    return normalize(sourceURL);
  }

  exports.computeSourceURL = computeSourceURL;
  });
  var util_1 = util.getArg;
  var util_2 = util.urlParse;
  var util_3 = util.urlGenerate;
  var util_4 = util.normalize;
  var util_5 = util.join;
  var util_6 = util.isAbsolute;
  var util_7 = util.relative;
  var util_8 = util.toSetString;
  var util_9 = util.fromSetString;
  var util_10 = util.compareByOriginalPositions;
  var util_11 = util.compareByGeneratedPositionsDeflated;
  var util_12 = util.compareByGeneratedPositionsInflated;
  var util_13 = util.parseSourceMapInput;
  var util_14 = util.computeSourceURL;

  var has$1 = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";

  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }

  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();

    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }

    return set;
  };

  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };

  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has$1.call(this._set, sStr);
    var idx = this._array.length;

    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }

    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };

  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has$1.call(this._set, sStr);
    }
  };

  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);

      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);

      if (has$1.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }

    throw new Error('"' + aStr + '" is not in the set.');
  };

  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }

    throw new Error('No element indexed by ' + aIdx);
  };

  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  var ArraySet_1 = ArraySet;

  var arraySet = {
    ArraySet: ArraySet_1
  };

  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }

  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;

      this._array.push(aMapping);
    } else {
      this._sorted = false;

      this._array.push(aMapping);
    }
  };

  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);

      this._sorted = true;
    }

    return this._array;
  };

  var MappingList_1 = MappingList;

  var mappingList = {
    MappingList: MappingList_1
  };

  var ArraySet$1 = arraySet.ArraySet;

  var MappingList$1 = mappingList.MappingList;

  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }

    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet$1();
    this._names = new ArraySet$1();
    this._mappings = new MappingList$1();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;

        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;

      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);

      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);

      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;

    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }

      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];

      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;

    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
      }

      sourceFile = aSourceMapConsumer.file;
    }

    var sourceRoot = this._sourceRoot;

    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }

    var newSources = new ArraySet$1();
    var newNames = new ArraySet$1();

    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });

        if (original.source != null) {
          mapping.source = original.source;

          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }

          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }

          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;

          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;

      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;

      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);

    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }

        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }

        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
      throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();

    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;

        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }

          next += ',';
        }
      }

      next += base64Vlq.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64Vlq.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64Vlq.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64Vlq.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64Vlq.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }

      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }

      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };

  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };

    if (this._file != null) {
      map.file = this._file;
    }

    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }

    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

  var SourceMapGenerator_1 = SourceMapGenerator;

  var sourceMapGenerator = {
    SourceMapGenerator: SourceMapGenerator_1
  };

  var binarySearch = createCommonjsModule(function (module, exports) {
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;

  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);

    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }

      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }

      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }

  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

    if (index < 0) {
      return -1;
    }

    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }

      --index;
    }

    return index;
  };
  });
  var binarySearch_1 = binarySearch.GREATEST_LOWER_BOUND;
  var binarySearch_2 = binarySearch.LEAST_UPPER_BOUND;
  var binarySearch_3 = binarySearch.search;

  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }

  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  var quickSort_1 = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };

  var quickSort = {
    quickSort: quickSort_1
  };

  var ArraySet$2 = arraySet.ArraySet;



  var quickSort$1 = quickSort.quickSort;

  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  }

  SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };

  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    configurable: true,
    enumerable: true,
    get: function get() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    configurable: true,
    enumerable: true,
    get: function get() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;

  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;

    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;

      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;

      default:
        throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };
    needle.source = this._findSourceIndex(needle.source);

    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

  var SourceMapConsumer_1 = SourceMapConsumer;

  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }

    sources = sources.map(String).map(util.normalize).map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet$2.fromArray(names.map(String), true);
    this._sources = ArraySet$2.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function (s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
    var relativeSource = aSource;

    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }

    var i;

    for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }

    return -1;
  };

  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    var generatedMappings = aSourceMap._mappings.toArray().slice();

    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort$1(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };

  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function get() {
      return this._absoluteSources.slice();
    }
  });

  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ',') {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }

        str = aStr.slice(index, end);
        segment = cachedSegments[str];

        if (segment) {
          index += str.length;
        } else {
          segment = [];

          while (index < end) {
            base64Vlq.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);

        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort$1(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort$1(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }

    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      mapping.lastGeneratedColumn = Infinity;
    }
  };

  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);

        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }

        var name = util.getArg(mapping, 'name', null);

        if (name !== null) {
          name = this._names.at(name);
        }

        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }

    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
      return sc == null;
    });
  };

  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);

    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;

    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;

    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");

      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }

      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);

    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

  var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet$2();
    this._names = new ArraySet$2();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        throw new Error('Support for url field in sections not implemented.');
      }

      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }

      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
      };
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function get() {
      var sources = [];

      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }

      return sources;
    }
  });

  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

      if (cmp) {
        return cmp;
      }

      return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };

  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);

      if (content) {
        return content;
      }
    }

    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }

      var generatedPosition = section.consumer.generatedPositionFor(aArgs);

      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];

    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;

      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);

        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);

        this._sources.add(source);

        source = this._sources.indexOf(source);
        var name = null;

        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);

          this._names.add(name);

          name = this._names.indexOf(name);
        }

        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);

        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort$1(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort$1(this.__originalMappings, util.compareByOriginalPositions);
  };

  var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

  var sourceMapConsumer = {
    SourceMapConsumer: SourceMapConsumer_1,
    BasicSourceMapConsumer: BasicSourceMapConsumer_1,
    IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
  };

  var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;



  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";

  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode();
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;

    var shiftNextLine = function shiftNextLine() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    var lastGeneratedLine = 1,
        lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }

      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }

      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }

      lastMapping = mapping;
    }, this);

    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }

      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }

        node.setSourceContent(sourceFile, content);
      }
    });
    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };

  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }

    return this;
  };

  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }

    return this;
  };

  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;

    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];

      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== '') {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };

  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;

    if (len > 0) {
      newChildren = [];

      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }

      newChildren.push(this.children[i]);
      this.children = newChildren;
    }

    return this;
  };

  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];

    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push(''.replace(aPattern, aReplacement));
    }

    return this;
  };

  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);

    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator$1(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;

      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }

        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }

      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;

          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {
      code: generated.code,
      map: map
    };
  };

  var SourceNode_1 = SourceNode;

  var sourceNode = {
    SourceNode: SourceNode_1
  };

  var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
  var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;
  var SourceNode$1 = sourceNode.SourceNode;

  var sourceMap = {
    SourceMapGenerator: SourceMapGenerator$2,
    SourceMapConsumer: SourceMapConsumer$1,
    SourceNode: SourceNode$1
  };

  var SourceMap = function () {
    function SourceMap(opts, code) {
      this._cachedMap = null;
      this._code = code;
      this._opts = opts;
      this._rawMappings = [];
    }

    var _proto = SourceMap.prototype;

    _proto.get = function get() {
      if (!this._cachedMap) {
        var map = this._cachedMap = new sourceMap.SourceMapGenerator({
          sourceRoot: this._opts.sourceRoot
        });
        var code = this._code;

        if (typeof code === "string") {
          map.setSourceContent(this._opts.sourceFileName.replace(/\\/g, "/"), code);
        } else if (typeof code === "object") {
          Object.keys(code).forEach(function (sourceFileName) {
            map.setSourceContent(sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
          });
        }

        this._rawMappings.forEach(function (mapping) {
          return map.addMapping(mapping);
        }, map);
      }

      return this._cachedMap.toJSON();
    };

    _proto.getRawMappings = function getRawMappings() {
      return this._rawMappings.slice();
    };

    _proto.mark = function mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {
      if (this._lastGenLine !== generatedLine && line === null) return;

      if (!force && this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
        return;
      }

      this._cachedMap = null;
      this._lastGenLine = generatedLine;
      this._lastSourceLine = line;
      this._lastSourceColumn = column;

      this._rawMappings.push({
        name: identifierName || undefined,
        generated: {
          line: generatedLine,
          column: generatedColumn
        },
        source: line == null ? undefined : (filename || this._opts.sourceFileName).replace(/\\/g, "/"),
        original: line == null ? undefined : {
          line: line,
          column: column
        }
      });
    };

    return SourceMap;
  }();

  function isInteger(value) {
    return typeof value == 'number' && value == toInteger_1(value);
  }

  var isInteger_1 = isInteger;

  var SPACES_RE = /^[ \t]+$/;

  var Buffer = function () {
    function Buffer(map) {
      this._map = null;
      this._buf = [];
      this._last = "";
      this._queue = [];
      this._position = {
        line: 1,
        column: 0
      };
      this._sourcePosition = {
        identifierName: null,
        line: null,
        column: null,
        filename: null
      };
      this._disallowedPop = null;
      this._map = map;
    }

    var _proto = Buffer.prototype;

    _proto.get = function get() {
      this._flush();

      var map = this._map;
      var result = {
        code: this._buf.join("").trimRight(),
        map: null,
        rawMappings: map && map.getRawMappings()
      };

      if (map) {
        Object.defineProperty(result, "map", {
          configurable: true,
          enumerable: true,
          get: function get() {
            return this.map = map.get();
          },
          set: function set(value) {
            Object.defineProperty(this, "map", {
              value: value,
              writable: true
            });
          }
        });
      }

      return result;
    };

    _proto.append = function append(str) {
      this._flush();

      var _this$_sourcePosition = this._sourcePosition,
          line = _this$_sourcePosition.line,
          column = _this$_sourcePosition.column,
          filename = _this$_sourcePosition.filename,
          identifierName = _this$_sourcePosition.identifierName,
          force = _this$_sourcePosition.force;

      this._append(str, line, column, identifierName, filename, force);
    };

    _proto.queue = function queue(str) {
      if (str === "\n") {
        while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
          this._queue.shift();
        }
      }

      var _this$_sourcePosition2 = this._sourcePosition,
          line = _this$_sourcePosition2.line,
          column = _this$_sourcePosition2.column,
          filename = _this$_sourcePosition2.filename,
          identifierName = _this$_sourcePosition2.identifierName,
          force = _this$_sourcePosition2.force;

      this._queue.unshift([str, line, column, identifierName, filename, force]);
    };

    _proto._flush = function _flush() {
      var item;

      while (item = this._queue.pop()) {
        this._append.apply(this, item);
      }
    };

    _proto._append = function _append(str, line, column, identifierName, filename, force) {
      if (this._map && str[0] !== "\n") {
        this._map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);
      }

      this._buf.push(str);

      this._last = str[str.length - 1];

      for (var i = 0; i < str.length; i++) {
        if (str[i] === "\n") {
          this._position.line++;
          this._position.column = 0;
        } else {
          this._position.column++;
        }
      }
    };

    _proto.removeTrailingNewline = function removeTrailingNewline() {
      if (this._queue.length > 0 && this._queue[0][0] === "\n") {
        this._queue.shift();
      }
    };

    _proto.removeLastSemicolon = function removeLastSemicolon() {
      if (this._queue.length > 0 && this._queue[0][0] === ";") {
        this._queue.shift();
      }
    };

    _proto.endsWith = function endsWith(suffix) {
      if (suffix.length === 1) {
        var last;

        if (this._queue.length > 0) {
          var str = this._queue[0][0];
          last = str[str.length - 1];
        } else {
          last = this._last;
        }

        return last === suffix;
      }

      var end = this._last + this._queue.reduce(function (acc, item) {
        return item[0] + acc;
      }, "");

      if (suffix.length <= end.length) {
        return end.slice(-suffix.length) === suffix;
      }

      return false;
    };

    _proto.hasContent = function hasContent() {
      return this._queue.length > 0 || !!this._last;
    };

    _proto.exactSource = function exactSource(loc, cb) {
      this.source("start", loc, true);
      cb();
      this.source("end", loc);

      this._disallowPop("start", loc);
    };

    _proto.source = function source(prop, loc, force) {
      if (prop && !loc) return;

      this._normalizePosition(prop, loc, this._sourcePosition, force);
    };

    _proto.withSource = function withSource(prop, loc, cb) {
      if (!this._map) return cb();
      var originalLine = this._sourcePosition.line;
      var originalColumn = this._sourcePosition.column;
      var originalFilename = this._sourcePosition.filename;
      var originalIdentifierName = this._sourcePosition.identifierName;
      this.source(prop, loc);
      cb();

      if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {
        this._sourcePosition.line = originalLine;
        this._sourcePosition.column = originalColumn;
        this._sourcePosition.filename = originalFilename;
        this._sourcePosition.identifierName = originalIdentifierName;
        this._sourcePosition.force = false;
        this._disallowedPop = null;
      }
    };

    _proto._disallowPop = function _disallowPop(prop, loc) {
      if (prop && !loc) return;
      this._disallowedPop = this._normalizePosition(prop, loc);
    };

    _proto._normalizePosition = function _normalizePosition(prop, loc, targetObj, force) {
      var pos = loc ? loc[prop] : null;

      if (targetObj === undefined) {
        targetObj = {
          identifierName: null,
          line: null,
          column: null,
          filename: null,
          force: false
        };
      }

      var origLine = targetObj.line;
      var origColumn = targetObj.column;
      var origFilename = targetObj.filename;
      targetObj.identifierName = prop === "start" && loc && loc.identifierName || null;
      targetObj.line = pos ? pos.line : null;
      targetObj.column = pos ? pos.column : null;
      targetObj.filename = loc && loc.filename || null;

      if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {
        targetObj.force = force;
      }

      return targetObj;
    };

    _proto.getCurrentColumn = function getCurrentColumn() {
      var extra = this._queue.reduce(function (acc, item) {
        return item[0] + acc;
      }, "");

      var lastIndex = extra.lastIndexOf("\n");
      return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
    };

    _proto.getCurrentLine = function getCurrentLine() {
      var extra = this._queue.reduce(function (acc, item) {
        return item[0] + acc;
      }, "");

      var count = 0;

      for (var i = 0; i < extra.length; i++) {
        if (extra[i] === "\n") count++;
      }

      return this._position.line + count;
    };

    return Buffer;
  }();

  function crawl(node, state) {
    if (state === void 0) {
      state = {};
    }

    if (isMemberExpression(node)) {
      crawl(node.object, state);
      if (node.computed) crawl(node.property, state);
    } else if (isBinary(node) || isAssignmentExpression(node)) {
      crawl(node.left, state);
      crawl(node.right, state);
    } else if (isCallExpression(node)) {
      state.hasCall = true;
      crawl(node.callee, state);
    } else if (isFunction(node)) {
      state.hasFunction = true;
    } else if (isIdentifier(node)) {
      state.hasHelper = state.hasHelper || isHelper(node.callee);
    }

    return state;
  }

  function isHelper(node) {
    if (isMemberExpression(node)) {
      return isHelper(node.object) || isHelper(node.property);
    } else if (isIdentifier(node)) {
      return node.name === "require" || node.name[0] === "_";
    } else if (isCallExpression(node)) {
      return isHelper(node.callee);
    } else if (isBinary(node) || isAssignmentExpression(node)) {
      return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
    } else {
      return false;
    }
  }

  function isType$1(node) {
    return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
  }

  var nodes = {
    AssignmentExpression: function AssignmentExpression(node) {
      var state = crawl(node.right);

      if (state.hasCall && state.hasHelper || state.hasFunction) {
        return {
          before: state.hasFunction,
          after: true
        };
      }
    },
    SwitchCase: function SwitchCase(node, parent) {
      return {
        before: node.consequent.length || parent.cases[0] === node,
        after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
      };
    },
    LogicalExpression: function LogicalExpression(node) {
      if (isFunction(node.left) || isFunction(node.right)) {
        return {
          after: true
        };
      }
    },
    Literal: function Literal(node) {
      if (node.value === "use strict") {
        return {
          after: true
        };
      }
    },
    CallExpression: function CallExpression(node) {
      if (isFunction(node.callee) || isHelper(node)) {
        return {
          before: true,
          after: true
        };
      }
    },
    VariableDeclaration: function VariableDeclaration(node) {
      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        var enabled = isHelper(declar.id) && !isType$1(declar.init);

        if (!enabled) {
          var state = crawl(declar.init);
          enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
        }

        if (enabled) {
          return {
            before: true,
            after: true
          };
        }
      }
    },
    IfStatement: function IfStatement(node) {
      if (isBlockStatement(node.consequent)) {
        return {
          before: true,
          after: true
        };
      }
    }
  };

  nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
    if (parent.properties[0] === node) {
      return {
        before: true
      };
    }
  };

  nodes.ObjectTypeCallProperty = function (node, parent) {
    if (parent.callProperties[0] === node && (!parent.properties || !parent.properties.length)) {
      return {
        before: true
      };
    }
  };

  nodes.ObjectTypeIndexer = function (node, parent) {
    if (parent.indexers[0] === node && (!parent.properties || !parent.properties.length) && (!parent.callProperties || !parent.callProperties.length)) {
      return {
        before: true
      };
    }
  };

  nodes.ObjectTypeInternalSlot = function (node, parent) {
    if (parent.internalSlots[0] === node && (!parent.properties || !parent.properties.length) && (!parent.callProperties || !parent.callProperties.length) && (!parent.indexers || !parent.indexers.length)) {
      return {
        before: true
      };
    }
  };

  var list = {
    VariableDeclaration: function VariableDeclaration(node) {
      return node.declarations.map(function (decl) {
        return decl.init;
      });
    },
    ArrayExpression: function ArrayExpression(node) {
      return node.elements;
    },
    ObjectExpression: function ObjectExpression(node) {
      return node.properties;
    }
  };
  [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function (_ref) {
    var type = _ref[0],
        amounts = _ref[1];

    if (typeof amounts === "boolean") {
      amounts = {
        after: amounts,
        before: amounts
      };
    }

    [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
      nodes[type] = function () {
        return amounts;
      };
    });
  });

  var PRECEDENCE = {
    "||": 0,
    "??": 0,
    "&&": 1,
    "|": 2,
    "^": 3,
    "&": 4,
    "==": 5,
    "===": 5,
    "!=": 5,
    "!==": 5,
    "<": 6,
    ">": 6,
    "<=": 6,
    ">=": 6,
    "in": 6,
    "instanceof": 6,
    ">>": 7,
    "<<": 7,
    ">>>": 7,
    "+": 8,
    "-": 8,
    "*": 9,
    "/": 9,
    "%": 9,
    "**": 10
  };

  var isClassExtendsClause = function isClassExtendsClause(node, parent) {
    return (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node;
  };

  function NullableTypeAnnotation$1(node, parent) {
    return isArrayTypeAnnotation(parent);
  }
  function FunctionTypeAnnotation$1(node, parent, printStack) {
    return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);
  }
  function UpdateExpression$1(node, parent) {
    return isMemberExpression(parent, {
      object: node
    }) || isOptionalMemberExpression(parent, {
      object: node
    }) || isCallExpression(parent, {
      callee: node
    }) || isOptionalCallExpression(parent, {
      callee: node
    }) || isNewExpression(parent, {
      callee: node
    }) || isClassExtendsClause(node, parent);
  }
  function ObjectExpression$1(node, parent, printStack) {
    return isFirstInStatement(printStack, {
      considerArrow: true
    });
  }
  function DoExpression$1(node, parent, printStack) {
    return isFirstInStatement(printStack);
  }
  function Binary(node, parent) {
    if (node.operator === "**" && isBinaryExpression(parent, {
      operator: "**"
    })) {
      return parent.left === node;
    }

    if (isClassExtendsClause(node, parent)) {
      return true;
    }

    if ((isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isUnaryLike(parent) || (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || isAwaitExpression(parent)) {
      return true;
    }

    if (isBinary(parent)) {
      var parentOp = parent.operator;
      var parentPos = PRECEDENCE[parentOp];
      var nodeOp = node.operator;
      var nodePos = PRECEDENCE[nodeOp];

      if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {
        return true;
      }
    }
  }
  function UnionTypeAnnotation$1(node, parent) {
    return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);
  }
  function TSAsExpression$1() {
    return true;
  }
  function TSTypeAssertion$1() {
    return true;
  }
  function TSUnionType$1(node, parent) {
    return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);
  }
  function TSInferType$1(node, parent) {
    return isTSArrayType(parent) || isTSOptionalType(parent);
  }
  function BinaryExpression$1(node, parent) {
    return node.operator === "in" && (isVariableDeclarator(parent) || isFor(parent));
  }
  function SequenceExpression$1(node, parent) {
    if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {
      return false;
    }

    return true;
  }
  function YieldExpression$1(node, parent) {
    return isBinary(parent) || isUnaryLike(parent) || isCallExpression(parent) || isOptionalCallExpression(parent) || isMemberExpression(parent) || isOptionalMemberExpression(parent) || isNewExpression(parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
  }
  function ClassExpression$1(node, parent, printStack) {
    return isFirstInStatement(printStack, {
      considerDefaultExports: true
    });
  }
  function UnaryLike(node, parent) {
    return (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isBinaryExpression(parent, {
      operator: "**",
      left: node
    }) || isClassExtendsClause(node, parent);
  }
  function FunctionExpression$1(node, parent, printStack) {
    return isFirstInStatement(printStack, {
      considerDefaultExports: true
    });
  }
  function ArrowFunctionExpression$1(node, parent) {
    return isExportDeclaration(parent) || ConditionalExpression$1(node, parent);
  }
  function ConditionalExpression$1(node, parent) {
    if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {
      test: node
    }) || isAwaitExpression(parent) || isOptionalMemberExpression(parent, {
      object: node
    }) || isOptionalCallExpression(parent, {
      callee: node
    }) || isTaggedTemplateExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {
      return true;
    }

    return UnaryLike(node, parent);
  }
  function OptionalMemberExpression$1(node, parent) {
    return isCallExpression(parent, {
      callee: node
    }) || isMemberExpression(parent, {
      object: node
    });
  }
  function OptionalCallExpression$1(node, parent) {
    return isCallExpression(parent, {
      callee: node
    }) || isMemberExpression(parent, {
      object: node
    });
  }
  function AssignmentExpression$1(node, parent, printStack) {
    if (isObjectPattern(node.left)) {
      return true;
    } else {
      return ConditionalExpression$1(node, parent);
    }
  }
  function LogicalExpression$1(node, parent) {
    switch (node.operator) {
      case "||":
        if (!isLogicalExpression(parent)) return false;
        return parent.operator === "??" || parent.operator === "&&";

      case "&&":
        return isLogicalExpression(parent, {
          operator: "??"
        });

      case "??":
        return isLogicalExpression(parent) && parent.operator !== "??";
    }
  }

  function isFirstInStatement(printStack, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$considerArrow = _ref.considerArrow,
        considerArrow = _ref$considerArrow === void 0 ? false : _ref$considerArrow,
        _ref$considerDefaultE = _ref.considerDefaultExports,
        considerDefaultExports = _ref$considerDefaultE === void 0 ? false : _ref$considerDefaultE;

    var i = printStack.length - 1;
    var node = printStack[i];
    i--;
    var parent = printStack[i];

    while (i > 0) {
      if (isExpressionStatement(parent, {
        expression: node
      }) || isTaggedTemplateExpression(parent) || considerDefaultExports && isExportDefaultDeclaration(parent, {
        declaration: node
      }) || considerArrow && isArrowFunctionExpression(parent, {
        body: node
      })) {
        return true;
      }

      if ((isCallExpression(parent) || isOptionalCallExpression(parent)) && parent.callee === node || isSequenceExpression(parent) && parent.expressions[0] === node || (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || isConditional(parent, {
        test: node
      }) || isBinary(parent, {
        left: node
      }) || isAssignmentExpression(parent, {
        left: node
      })) {
        node = parent;
        i--;
        parent = printStack[i];
      } else {
        return false;
      }
    }

    return false;
  }

  var parens = /*#__PURE__*/Object.freeze({
    __proto__: null,
    NullableTypeAnnotation: NullableTypeAnnotation$1,
    FunctionTypeAnnotation: FunctionTypeAnnotation$1,
    UpdateExpression: UpdateExpression$1,
    ObjectExpression: ObjectExpression$1,
    DoExpression: DoExpression$1,
    Binary: Binary,
    UnionTypeAnnotation: UnionTypeAnnotation$1,
    IntersectionTypeAnnotation: UnionTypeAnnotation$1,
    TSAsExpression: TSAsExpression$1,
    TSTypeAssertion: TSTypeAssertion$1,
    TSUnionType: TSUnionType$1,
    TSIntersectionType: TSUnionType$1,
    TSInferType: TSInferType$1,
    BinaryExpression: BinaryExpression$1,
    SequenceExpression: SequenceExpression$1,
    YieldExpression: YieldExpression$1,
    AwaitExpression: YieldExpression$1,
    ClassExpression: ClassExpression$1,
    UnaryLike: UnaryLike,
    FunctionExpression: FunctionExpression$1,
    ArrowFunctionExpression: ArrowFunctionExpression$1,
    ConditionalExpression: ConditionalExpression$1,
    OptionalMemberExpression: OptionalMemberExpression$1,
    OptionalCallExpression: OptionalCallExpression$1,
    AssignmentExpression: AssignmentExpression$1,
    LogicalExpression: LogicalExpression$1
  });

  function expandAliases(obj) {
    var newObj = {};

    function add(type, func) {
      var fn = newObj[type];
      newObj[type] = fn ? function (node, parent, stack) {
        var result = fn(node, parent, stack);
        return result == null ? func(node, parent, stack) : result;
      } : func;
    }

    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
      var type = _Object$keys[_i];
      var aliases = FLIPPED_ALIAS_KEYS[type];

      if (aliases) {
        for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i2 >= _iterator.length) break;
            _ref = _iterator[_i2++];
          } else {
            _i2 = _iterator.next();
            if (_i2.done) break;
            _ref = _i2.value;
          }

          var alias = _ref;
          add(alias, obj[type]);
        }
      } else {
        add(type, obj[type]);
      }
    }

    return newObj;
  }

  var expandedParens = expandAliases(parens);
  var expandedWhitespaceNodes = expandAliases(nodes);
  var expandedWhitespaceList = expandAliases(list);

  function find(obj, node, parent, printStack) {
    var fn = obj[node.type];
    return fn ? fn(node, parent, printStack) : null;
  }

  function isOrHasCallExpression(node) {
    if (isCallExpression(node)) {
      return true;
    }

    return isMemberExpression(node) && isOrHasCallExpression(node.object);
  }

  function needsWhitespace(node, parent, type) {
    if (!node) return 0;

    if (isExpressionStatement(node)) {
      node = node.expression;
    }

    var linesInfo = find(expandedWhitespaceNodes, node, parent);

    if (!linesInfo) {
      var items = find(expandedWhitespaceList, node, parent);

      if (items) {
        for (var i = 0; i < items.length; i++) {
          linesInfo = needsWhitespace(items[i], node, type);
          if (linesInfo) break;
        }
      }
    }

    if (typeof linesInfo === "object" && linesInfo !== null) {
      return linesInfo[type] || 0;
    }

    return 0;
  }
  function needsWhitespaceBefore(node, parent) {
    return needsWhitespace(node, parent, "before");
  }
  function needsWhitespaceAfter(node, parent) {
    return needsWhitespace(node, parent, "after");
  }
  function needsParens(node, parent, printStack) {
    if (!parent) return false;

    if (isNewExpression(parent) && parent.callee === node) {
      if (isOrHasCallExpression(node)) return true;
    }

    return find(expandedParens, node, parent, printStack);
  }

  function TaggedTemplateExpression$1(node) {
    this.print(node.tag, node);
    this.print(node.typeParameters, node);
    this.print(node.quasi, node);
  }
  function TemplateElement$1(node, parent) {
    var isFirst = parent.quasis[0] === node;
    var isLast = parent.quasis[parent.quasis.length - 1] === node;
    var value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
    this.token(value);
  }
  function TemplateLiteral$1(node) {
    var quasis = node.quasis;

    for (var i = 0; i < quasis.length; i++) {
      this.print(quasis[i], node);

      if (i + 1 < quasis.length) {
        this.print(node.expressions[i], node);
      }
    }
  }

  function UnaryExpression$1(node) {
    if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw") {
      this.word(node.operator);
      this.space();
    } else {
      this.token(node.operator);
    }

    this.print(node.argument, node);
  }
  function DoExpression$2(node) {
    this.word("do");
    this.space();
    this.print(node.body, node);
  }
  function ParenthesizedExpression$1(node) {
    this.token("(");
    this.print(node.expression, node);
    this.token(")");
  }
  function UpdateExpression$2(node) {
    if (node.prefix) {
      this.token(node.operator);
      this.print(node.argument, node);
    } else {
      this.startTerminatorless(true);
      this.print(node.argument, node);
      this.endTerminatorless();
      this.token(node.operator);
    }
  }
  function ConditionalExpression$2(node) {
    this.print(node.test, node);
    this.space();
    this.token("?");
    this.space();
    this.print(node.consequent, node);
    this.space();
    this.token(":");
    this.space();
    this.print(node.alternate, node);
  }
  function NewExpression$1(node, parent) {
    this.word("new");
    this.space();
    this.print(node.callee, node);

    if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
      callee: node
    }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
      return;
    }

    this.print(node.typeArguments, node);
    this.print(node.typeParameters, node);

    if (node.optional) {
      this.token("?.");
    }

    this.token("(");
    this.printList(node.arguments, node);
    this.token(")");
  }
  function SequenceExpression$2(node) {
    this.printList(node.expressions, node);
  }
  function ThisExpression$1() {
    this.word("this");
  }
  function Super$1() {
    this.word("super");
  }
  function Decorator$1(node) {
    this.token("@");
    this.print(node.expression, node);
    this.newline();
  }
  function OptionalMemberExpression$2(node) {
    this.print(node.object, node);

    if (!node.computed && isMemberExpression(node.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }

    var computed = node.computed;

    if (isLiteral(node.property) && typeof node.property.value === "number") {
      computed = true;
    }

    if (node.optional) {
      this.token("?.");
    }

    if (computed) {
      this.token("[");
      this.print(node.property, node);
      this.token("]");
    } else {
      if (!node.optional) {
        this.token(".");
      }

      this.print(node.property, node);
    }
  }
  function OptionalCallExpression$2(node) {
    this.print(node.callee, node);
    this.print(node.typeArguments, node);
    this.print(node.typeParameters, node);

    if (node.optional) {
      this.token("?.");
    }

    this.token("(");
    this.printList(node.arguments, node);
    this.token(")");
  }
  function CallExpression$1(node) {
    this.print(node.callee, node);
    this.print(node.typeArguments, node);
    this.print(node.typeParameters, node);
    this.token("(");
    this.printList(node.arguments, node);
    this.token(")");
  }
  function Import$1() {
    this.word("import");
  }

  function buildYieldAwait(keyword) {
    return function (node) {
      this.word(keyword);

      if (node.delegate) {
        this.token("*");
      }

      if (node.argument) {
        this.space();
        var terminatorState = this.startTerminatorless();
        this.print(node.argument, node);
        this.endTerminatorless(terminatorState);
      }
    };
  }

  var YieldExpression$2 = buildYieldAwait("yield");
  var AwaitExpression$1 = buildYieldAwait("await");
  function EmptyStatement$1() {
    this.semicolon(true);
  }
  function ExpressionStatement$1(node) {
    this.print(node.expression, node);
    this.semicolon();
  }
  function AssignmentPattern$1(node) {
    this.print(node.left, node);
    if (node.left.optional) this.token("?");
    this.print(node.left.typeAnnotation, node);
    this.space();
    this.token("=");
    this.space();
    this.print(node.right, node);
  }
  function AssignmentExpression$2(node, parent) {
    var parens = this.inForStatementInitCounter && node.operator === "in" && !needsParens(node, parent);

    if (parens) {
      this.token("(");
    }

    this.print(node.left, node);
    this.space();

    if (node.operator === "in" || node.operator === "instanceof") {
      this.word(node.operator);
    } else {
      this.token(node.operator);
    }

    this.space();
    this.print(node.right, node);

    if (parens) {
      this.token(")");
    }
  }
  function BindExpression$1(node) {
    this.print(node.object, node);
    this.token("::");
    this.print(node.callee, node);
  }
  function MemberExpression$1(node) {
    this.print(node.object, node);

    if (!node.computed && isMemberExpression(node.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }

    var computed = node.computed;

    if (isLiteral(node.property) && typeof node.property.value === "number") {
      computed = true;
    }

    if (computed) {
      this.token("[");
      this.print(node.property, node);
      this.token("]");
    } else {
      this.token(".");
      this.print(node.property, node);
    }
  }
  function MetaProperty$1(node) {
    this.print(node.meta, node);
    this.token(".");
    this.print(node.property, node);
  }
  function PrivateName$1(node) {
    this.token("#");
    this.print(node.id, node);
  }
  function V8IntrinsicIdentifier$1(node) {
    this.token("%");
    this.word(node.name);
  }

  function WithStatement$1(node) {
    this.word("with");
    this.space();
    this.token("(");
    this.print(node.object, node);
    this.token(")");
    this.printBlock(node);
  }
  function IfStatement$1(node) {
    this.word("if");
    this.space();
    this.token("(");
    this.print(node.test, node);
    this.token(")");
    this.space();
    var needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));

    if (needsBlock) {
      this.token("{");
      this.newline();
      this.indent();
    }

    this.printAndIndentOnComments(node.consequent, node);

    if (needsBlock) {
      this.dedent();
      this.newline();
      this.token("}");
    }

    if (node.alternate) {
      if (this.endsWith("}")) this.space();
      this.word("else");
      this.space();
      this.printAndIndentOnComments(node.alternate, node);
    }
  }

  function getLastStatement(statement) {
    if (!isStatement(statement.body)) return statement;
    return getLastStatement(statement.body);
  }

  function ForStatement$1(node) {
    this.word("for");
    this.space();
    this.token("(");
    this.inForStatementInitCounter++;
    this.print(node.init, node);
    this.inForStatementInitCounter--;
    this.token(";");

    if (node.test) {
      this.space();
      this.print(node.test, node);
    }

    this.token(";");

    if (node.update) {
      this.space();
      this.print(node.update, node);
    }

    this.token(")");
    this.printBlock(node);
  }
  function WhileStatement$1(node) {
    this.word("while");
    this.space();
    this.token("(");
    this.print(node.test, node);
    this.token(")");
    this.printBlock(node);
  }

  var buildForXStatement = function buildForXStatement(op) {
    return function (node) {
      this.word("for");
      this.space();

      if (op === "of" && node["await"]) {
        this.word("await");
        this.space();
      }

      this.token("(");
      this.print(node.left, node);
      this.space();
      this.word(op);
      this.space();
      this.print(node.right, node);
      this.token(")");
      this.printBlock(node);
    };
  };

  var ForInStatement$1 = buildForXStatement("in");
  var ForOfStatement$1 = buildForXStatement("of");
  function DoWhileStatement$1(node) {
    this.word("do");
    this.space();
    this.print(node.body, node);
    this.space();
    this.word("while");
    this.space();
    this.token("(");
    this.print(node.test, node);
    this.token(")");
    this.semicolon();
  }

  function buildLabelStatement(prefix, key) {
    if (key === void 0) {
      key = "label";
    }

    return function (node) {
      this.word(prefix);
      var label = node[key];

      if (label) {
        this.space();
        var isLabel = key == "label";
        var terminatorState = this.startTerminatorless(isLabel);
        this.print(label, node);
        this.endTerminatorless(terminatorState);
      }

      this.semicolon();
    };
  }

  var ContinueStatement$1 = buildLabelStatement("continue");
  var ReturnStatement$1 = buildLabelStatement("return", "argument");
  var BreakStatement$1 = buildLabelStatement("break");
  var ThrowStatement$1 = buildLabelStatement("throw", "argument");
  function LabeledStatement$1(node) {
    this.print(node.label, node);
    this.token(":");
    this.space();
    this.print(node.body, node);
  }
  function TryStatement$1(node) {
    this.word("try");
    this.space();
    this.print(node.block, node);
    this.space();

    if (node.handlers) {
      this.print(node.handlers[0], node);
    } else {
      this.print(node.handler, node);
    }

    if (node.finalizer) {
      this.space();
      this.word("finally");
      this.space();
      this.print(node.finalizer, node);
    }
  }
  function CatchClause$1(node) {
    this.word("catch");
    this.space();

    if (node.param) {
      this.token("(");
      this.print(node.param, node);
      this.token(")");
      this.space();
    }

    this.print(node.body, node);
  }
  function SwitchStatement$1(node) {
    this.word("switch");
    this.space();
    this.token("(");
    this.print(node.discriminant, node);
    this.token(")");
    this.space();
    this.token("{");
    this.printSequence(node.cases, node, {
      indent: true,
      addNewlines: function addNewlines(leading, cas) {
        if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
      }
    });
    this.token("}");
  }
  function SwitchCase$1(node) {
    if (node.test) {
      this.word("case");
      this.space();
      this.print(node.test, node);
      this.token(":");
    } else {
      this.word("default");
      this.token(":");
    }

    if (node.consequent.length) {
      this.newline();
      this.printSequence(node.consequent, node, {
        indent: true
      });
    }
  }
  function DebuggerStatement$1() {
    this.word("debugger");
    this.semicolon();
  }

  function variableDeclarationIndent() {
    this.token(",");
    this.newline();
    if (this.endsWith("\n")) for (var i = 0; i < 4; i++) {
      this.space(true);
    }
  }

  function constDeclarationIndent() {
    this.token(",");
    this.newline();
    if (this.endsWith("\n")) for (var i = 0; i < 6; i++) {
      this.space(true);
    }
  }

  function VariableDeclaration$1(node, parent) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }

    this.word(node.kind);
    this.space();
    var hasInits = false;

    if (!isFor(parent)) {
      for (var _i = 0, _arr = node.declarations; _i < _arr.length; _i++) {
        var declar = _arr[_i];

        if (declar.init) {
          hasInits = true;
        }
      }
    }

    var separator;

    if (hasInits) {
      separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;
    }

    this.printList(node.declarations, node, {
      separator: separator
    });

    if (isFor(parent)) {
      if (parent.left === node || parent.init === node) return;
    }

    this.semicolon();
  }
  function VariableDeclarator$1(node) {
    this.print(node.id, node);
    if (node.definite) this.token("!");
    this.print(node.id.typeAnnotation, node);

    if (node.init) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.init, node);
    }
  }

  function ClassDeclaration$1(node, parent) {
    if (!this.format.decoratorsBeforeExport || !isExportDefaultDeclaration(parent) && !isExportNamedDeclaration(parent)) {
      this.printJoin(node.decorators, node);
    }

    if (node.declare) {
      this.word("declare");
      this.space();
    }

    if (node["abstract"]) {
      this.word("abstract");
      this.space();
    }

    this.word("class");

    if (node.id) {
      this.space();
      this.print(node.id, node);
    }

    this.print(node.typeParameters, node);

    if (node.superClass) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.superClass, node);
      this.print(node.superTypeParameters, node);
    }

    if (node["implements"]) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node["implements"], node);
    }

    this.space();
    this.print(node.body, node);
  }
  function ClassBody$1(node) {
    this.token("{");
    this.printInnerComments(node);

    if (node.body.length === 0) {
      this.token("}");
    } else {
      this.newline();
      this.indent();
      this.printSequence(node.body, node);
      this.dedent();
      if (!this.endsWith("\n")) this.newline();
      this.rightBrace();
    }
  }
  function ClassProperty$1(node) {
    this.printJoin(node.decorators, node);
    this.tsPrintClassMemberModifiers(node, true);

    if (node.computed) {
      this.token("[");
      this.print(node.key, node);
      this.token("]");
    } else {
      this._variance(node);

      this.print(node.key, node);
    }

    if (node.optional) {
      this.token("?");
    }

    if (node.definite) {
      this.token("!");
    }

    this.print(node.typeAnnotation, node);

    if (node.value) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.value, node);
    }

    this.semicolon();
  }
  function ClassPrivateProperty$1(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this.print(node.key, node);
    this.print(node.typeAnnotation, node);

    if (node.value) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.value, node);
    }

    this.semicolon();
  }
  function ClassMethod$1(node) {
    this._classMethodHead(node);

    this.space();
    this.print(node.body, node);
  }
  function ClassPrivateMethod$1(node) {
    this._classMethodHead(node);

    this.space();
    this.print(node.body, node);
  }
  function _classMethodHead(node) {
    this.printJoin(node.decorators, node);
    this.tsPrintClassMemberModifiers(node, false);

    this._methodHead(node);
  }

  function _params(node) {
    this.print(node.typeParameters, node);
    this.token("(");

    this._parameters(node.params, node);

    this.token(")");
    this.print(node.returnType, node);
  }
  function _parameters(parameters, parent) {
    for (var i = 0; i < parameters.length; i++) {
      this._param(parameters[i], parent);

      if (i < parameters.length - 1) {
        this.token(",");
        this.space();
      }
    }
  }
  function _param(parameter, parent) {
    this.printJoin(parameter.decorators, parameter);
    this.print(parameter, parent);
    if (parameter.optional) this.token("?");
    this.print(parameter.typeAnnotation, parameter);
  }
  function _methodHead(node) {
    var kind = node.kind;
    var key = node.key;

    if (kind === "get" || kind === "set") {
      this.word(kind);
      this.space();
    }

    if (node.async) {
      this.word("async");
      this.space();
    }

    if (kind === "method" || kind === "init") {
      if (node.generator) {
        this.token("*");
      }
    }

    if (node.computed) {
      this.token("[");
      this.print(key, node);
      this.token("]");
    } else {
      this.print(key, node);
    }

    if (node.optional) {
      this.token("?");
    }

    this._params(node);
  }
  function _predicate(node) {
    if (node.predicate) {
      if (!node.returnType) {
        this.token(":");
      }

      this.space();
      this.print(node.predicate, node);
    }
  }
  function _functionHead(node) {
    if (node.async) {
      this.word("async");
      this.space();
    }

    this.word("function");
    if (node.generator) this.token("*");
    this.space();

    if (node.id) {
      this.print(node.id, node);
    }

    this._params(node);

    this._predicate(node);
  }
  function FunctionExpression$2(node) {
    this._functionHead(node);

    this.space();
    this.print(node.body, node);
  }
  function ArrowFunctionExpression$2(node) {
    if (node.async) {
      this.word("async");
      this.space();
    }

    var firstParam = node.params[0];

    if (node.params.length === 1 && isIdentifier(firstParam) && !hasTypes(node, firstParam)) {
      if (this.format.retainLines && node.loc && node.body.loc && node.loc.start.line < node.body.loc.start.line) {
        this.token("(");

        if (firstParam.loc && firstParam.loc.start.line > node.loc.start.line) {
          this.indent();
          this.print(firstParam, node);
          this.dedent();

          this._catchUp("start", node.body.loc);
        } else {
          this.print(firstParam, node);
        }

        this.token(")");
      } else {
        this.print(firstParam, node);
      }
    } else {
      this._params(node);
    }

    this._predicate(node);

    this.space();
    this.token("=>");
    this.space();
    this.print(node.body, node);
  }

  function hasTypes(node, param) {
    return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;
  }

  function ImportSpecifier$1(node) {
    if (node.importKind === "type" || node.importKind === "typeof") {
      this.word(node.importKind);
      this.space();
    }

    this.print(node.imported, node);

    if (node.local && node.local.name !== node.imported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.local, node);
    }
  }
  function ImportDefaultSpecifier$1(node) {
    this.print(node.local, node);
  }
  function ExportDefaultSpecifier$1(node) {
    this.print(node.exported, node);
  }
  function ExportSpecifier$1(node) {
    this.print(node.local, node);

    if (node.exported && node.local.name !== node.exported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported, node);
    }
  }
  function ExportNamespaceSpecifier$1(node) {
    this.token("*");
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported, node);
  }
  function ExportAllDeclaration$1(node) {
    this.word("export");
    this.space();

    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }

    this.token("*");
    this.space();
    this.word("from");
    this.space();
    this.print(node.source, node);
    this.semicolon();
  }
  function ExportNamedDeclaration$1(node) {
    if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
      this.printJoin(node.declaration.decorators, node);
    }

    this.word("export");
    this.space();
    ExportDeclaration.apply(this, arguments);
  }
  function ExportDefaultDeclaration$1(node) {
    if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
      this.printJoin(node.declaration.decorators, node);
    }

    this.word("export");
    this.space();
    this.word("default");
    this.space();
    ExportDeclaration.apply(this, arguments);
  }

  function ExportDeclaration(node) {
    if (node.declaration) {
      var declar = node.declaration;
      this.print(declar, node);
      if (!isStatement(declar)) this.semicolon();
    } else {
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }

      var specifiers = node.specifiers.slice(0);
      var hasSpecial = false;

      for (;;) {
        var first = specifiers[0];

        if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
          hasSpecial = true;
          this.print(specifiers.shift(), node);

          if (specifiers.length) {
            this.token(",");
            this.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length || !specifiers.length && !hasSpecial) {
        this.token("{");

        if (specifiers.length) {
          this.space();
          this.printList(specifiers, node);
          this.space();
        }

        this.token("}");
      }

      if (node.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node.source, node);
      }

      this.semicolon();
    }
  }

  function ImportDeclaration$1(node) {
    this.word("import");
    this.space();

    if (node.importKind === "type" || node.importKind === "typeof") {
      this.word(node.importKind);
      this.space();
    }

    var specifiers = node.specifiers.slice(0);

    if (specifiers && specifiers.length) {
      for (;;) {
        var first = specifiers[0];

        if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
          this.print(specifiers.shift(), node);

          if (specifiers.length) {
            this.token(",");
            this.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length) {
        this.token("{");
        this.space();
        this.printList(specifiers, node);
        this.space();
        this.token("}");
      }

      this.space();
      this.word("from");
      this.space();
    }

    this.print(node.source, node);
    this.semicolon();
  }
  function ImportNamespaceSpecifier$1(node) {
    this.token("*");
    this.space();
    this.word("as");
    this.space();
    this.print(node.local, node);
  }

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;

  function init() {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray(b64) {
    if (!inited) {
      init();
    }

    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
    arr = new Arr(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 0xFF;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    if (!inited) {
      init();
    }

    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = '';
    var parts = [];
    var maxChunkLength = 16383;

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }

    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 0x3F];
      output += lookup[tmp << 2 & 0x3F];
      output += '=';
    }

    parts.push(output);
    return parts.join('');
  }

  function read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;

    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;

    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }

    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  function write(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);

      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }

      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }

      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;

    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString$1 = {}.toString;
  var isArray$1 = Array.isArray || function (arr) {
    return toString$1.call(arr) == '[object Array]';
  };

  var INSPECT_MAX_BYTES = 50;
  Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

  var _kMaxLength = kMaxLength();

  function kMaxLength() {
    return Buffer$1.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }

  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length');
    }

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer$1.prototype;
    } else {
      if (that === null) {
        that = new Buffer$1(length);
      }

      that.length = length;
    }

    return that;
  }

  function Buffer$1(arg, encodingOrOffset, length) {
    if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
      return new Buffer$1(arg, encodingOrOffset, length);
    }

    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error('If encoding is specified then the first argument must be a string');
      }

      return allocUnsafe(this, arg);
    }

    return from(this, arg, encodingOrOffset, length);
  }
  Buffer$1.poolSize = 8192;

  Buffer$1._augment = function (arr) {
    arr.__proto__ = Buffer$1.prototype;
    return arr;
  };

  function from(that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number');
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset);
    }

    return fromObject(that, value);
  }

  Buffer$1.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length);
  };

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    Buffer$1.prototype.__proto__ = Uint8Array.prototype;
    Buffer$1.__proto__ = Uint8Array;
  }

  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }

  function alloc(that, size, fill, encoding) {
    assertSize(size);

    if (size <= 0) {
      return createBuffer(that, size);
    }

    if (fill !== undefined) {
      return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
    }

    return createBuffer(that, size);
  }

  Buffer$1.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding);
  };

  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

    if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }

    return that;
  }

  Buffer$1.allocUnsafe = function (size) {
    return allocUnsafe(null, size);
  };

  Buffer$1.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size);
  };

  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer$1.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);

    if (actual !== length) {
      that = that.slice(0, actual);
    }

    return that;
  }

  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);

    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }

    return that;
  }

  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength;

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds');
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds');
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      that = array;
      that.__proto__ = Buffer$1.prototype;
    } else {
      that = fromArrayLike(that, array);
    }

    return that;
  }

  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that;
      }

      obj.copy(that, 0, 0, len);
      return that;
    }

    if (obj) {
      if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0);
        }

        return fromArrayLike(that, obj);
      }

      if (obj.type === 'Buffer' && isArray$1(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
  }

  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }

    return length | 0;
  }

  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }

    return Buffer$1.alloc(+length);
  }
  Buffer$1.isBuffer = isBuffer;

  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }

  Buffer$1.compare = function compare(a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }

    if (a === b) return 0;
    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer$1.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;

      default:
        return false;
    }
  };

  Buffer$1.concat = function concat(list, length) {
    if (!isArray$1(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return Buffer$1.alloc(0);
    }

    var i;

    if (length === undefined) {
      length = 0;

      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer$1.allocUnsafe(length);
    var pos = 0;

    for (i = 0; i < list.length; ++i) {
      var buf = list[i];

      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      buf.copy(buffer, pos);
      pos += buf.length;
    }

    return buffer;
  };

  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }

    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0;
    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;

        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length;

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;

        case 'hex':
          return len >>> 1;

        case 'base64':
          return base64ToBytes(string).length;

        default:
          if (loweredCase) return utf8ToBytes(string).length;
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer$1.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false;

    if (start === undefined || start < 0) {
      start = 0;
    }

    if (start > this.length) {
      return '';
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return '';
    }

    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return '';
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer$1.prototype._isBuffer = true;

  function swap$1(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer$1.prototype.swap16 = function swap16() {
    var len = this.length;

    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }

    for (var i = 0; i < len; i += 2) {
      swap$1(this, i, i + 1);
    }

    return this;
  };

  Buffer$1.prototype.swap32 = function swap32() {
    var len = this.length;

    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }

    for (var i = 0; i < len; i += 4) {
      swap$1(this, i, i + 3);
      swap$1(this, i + 1, i + 2);
    }

    return this;
  };

  Buffer$1.prototype.swap64 = function swap64() {
    var len = this.length;

    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }

    for (var i = 0; i < len; i += 8) {
      swap$1(this, i, i + 7);
      swap$1(this, i + 1, i + 6);
      swap$1(this, i + 2, i + 5);
      swap$1(this, i + 3, i + 4);
    }

    return this;
  };

  Buffer$1.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer$1.prototype.equals = function equals(b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer$1.compare(this, b) === 0;
  };

  Buffer$1.prototype.inspect = function inspect() {
    var str = '';
    var max = INSPECT_MAX_BYTES;

    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }

    return '<Buffer ' + str + '>';
  };

  Buffer$1.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer');
    }

    if (start === undefined) {
      start = 0;
    }

    if (end === undefined) {
      end = target ? target.length : 0;
    }

    if (thisStart === undefined) {
      thisStart = 0;
    }

    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }

    if (thisStart >= thisEnd) {
      return -1;
    }

    if (start >= end) {
      return 1;
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0) return -1;

    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }

    byteOffset = +byteOffset;

    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }

    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

    if (byteOffset >= buffer.length) {
      if (dir) return -1;else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;else return -1;
    }

    if (typeof val === 'string') {
      val = Buffer$1.from(val, encoding);
    }

    if (internalIsBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }

      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xFF;

      if (Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }

      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }

    throw new TypeError('val must be string, number or Buffer');
  }

  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();

      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }

        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }

    var i;

    if (dir) {
      var foundIndex = -1;

      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

      for (i = byteOffset; i >= 0; i--) {
        var found = true;

        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }

        if (found) return i;
      }
    }

    return -1;
  }

  Buffer$1.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };

  Buffer$1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };

  Buffer$1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;

    if (!length) {
      length = remaining;
    } else {
      length = Number(length);

      if (length > remaining) {
        length = remaining;
      }
    }

    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

    if (length > strLen / 2) {
      length = strLen / 2;
    }

    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }

    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }

  Buffer$1.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;

      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';
    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
          return asciiWrite(this, string, offset, length);

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length);

        case 'base64':
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer$1.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf);
    } else {
      return fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;

    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }

            break;

          case 2:
            secondByte = buf[i + 1];

            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }

        }
      }

      if (codePoint === null) {
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  }

  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;

    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }

    var res = '';
    var i = 0;

    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }

    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }

    return ret;
  }

  function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }

    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';

    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }

    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';

    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }

    return res;
  }

  Buffer$1.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;
    var newBuf;

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer$1.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer$1(sliceLen, undefined);

      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf;
  };

  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer$1.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer$1.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;

    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer$1.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer$1.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer$1.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer$1.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer$1.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer$1.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer$1.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];

    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer$1.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer$1.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer$1.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer$1.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer$1.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer$1.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4);
  };

  Buffer$1.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4);
  };

  Buffer$1.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8);
  };

  Buffer$1.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }

  Buffer$1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer$1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer$1.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;

    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer$1.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }

    return offset + 2;
  };

  Buffer$1.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }

    return offset + 2;
  };

  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;

    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
    }
  }

  Buffer$1.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }

    return offset + 4;
  };

  Buffer$1.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }

    return offset + 4;
  };

  Buffer$1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer$1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer$1.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer$1.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }

    return offset + 2;
  };

  Buffer$1.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }

    return offset + 2;
  };

  Buffer$1.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }

    return offset + 4;
  };

  Buffer$1.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }

    return offset + 4;
  };

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }

    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer$1.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer$1.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }

    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer$1.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer$1.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };

  Buffer$1.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;

    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }

    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    if (end > this.length) end = this.length;

    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    }

    return len;
  };

  Buffer$1.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }

      if (val.length === 1) {
        var code = val.charCodeAt(0);

        if (code < 256) {
          val = code;
        }
      }

      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }

      if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;

    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$1(val, encoding).toString());
      var len = bytes.length;

      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  };

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    if (str.length < 2) return '';

    while (str.length % 4 !== 0) {
      str = str + '=';
    }

    return str;
  }

  function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }

  function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (!leadSurrogate) {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }

          leadSurrogate = codePoint;
          continue;
        }

        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }

        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }

    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }

    return i;
  }

  function isnan(val) {
    return val !== val;
  }

  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }

  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
  }

  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
  }

  var bufferEs6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
    kMaxLength: _kMaxLength,
    Buffer: Buffer$1,
    SlowBuffer: SlowBuffer,
    isBuffer: isBuffer
  });

  var object = {};
  var hasOwnProperty$c = object.hasOwnProperty;

  var forOwn = function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty$c.call(object, key)) {
        callback(key, object[key]);
      }
    }
  };

  var extend = function extend(destination, source) {
    if (!source) {
      return destination;
    }

    forOwn(source, function (key, value) {
      destination[key] = value;
    });
    return destination;
  };

  var forEach = function forEach(array, callback) {
    var length = array.length;
    var index = -1;

    while (++index < length) {
      callback(array[index]);
    }
  };

  var toString$2 = object.toString;
  var isArray$2 = Array.isArray;
  var isBuffer$1 = isBuffer;

  var isObject$1 = function isObject(value) {
    return toString$2.call(value) == '[object Object]';
  };

  var isString$1 = function isString(value) {
    return typeof value == 'string' || toString$2.call(value) == '[object String]';
  };

  var isNumber = function isNumber(value) {
    return typeof value == 'number' || toString$2.call(value) == '[object Number]';
  };

  var isFunction$2 = function isFunction(value) {
    return typeof value == 'function';
  };

  var isMap$1 = function isMap(value) {
    return toString$2.call(value) == '[object Map]';
  };

  var isSet$1 = function isSet(value) {
    return toString$2.call(value) == '[object Set]';
  };

  var singleEscapes = {
    '"': '\\"',
    '\'': '\\\'',
    '\\': '\\\\',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t'
  };
  var regexSingleEscape = /["'\\\b\f\n\r\t]/;
  var regexDigit = /[0-9]/;
  var regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;

  var jsesc = function jsesc(argument, options) {
    var increaseIndentation = function increaseIndentation() {
      oldIndent = indent;
      ++options.indentLevel;
      indent = options.indent.repeat(options.indentLevel);
    };

    var defaults = {
      'escapeEverything': false,
      'minimal': false,
      'isScriptContext': false,
      'quotes': 'single',
      'wrap': false,
      'es6': false,
      'json': false,
      'compact': true,
      'lowercaseHex': false,
      'numbers': 'decimal',
      'indent': '\t',
      'indentLevel': 0,
      '__inline1__': false,
      '__inline2__': false
    };
    var json = options && options.json;

    if (json) {
      defaults.quotes = 'double';
      defaults.wrap = true;
    }

    options = extend(defaults, options);

    if (options.quotes != 'single' && options.quotes != 'double' && options.quotes != 'backtick') {
      options.quotes = 'single';
    }

    var quote = options.quotes == 'double' ? '"' : options.quotes == 'backtick' ? '`' : '\'';
    var compact = options.compact;
    var lowercaseHex = options.lowercaseHex;
    var indent = options.indent.repeat(options.indentLevel);
    var oldIndent = '';
    var inline1 = options.__inline1__;
    var inline2 = options.__inline2__;
    var newLine = compact ? '' : '\n';
    var result;
    var isEmpty = true;
    var useBinNumbers = options.numbers == 'binary';
    var useOctNumbers = options.numbers == 'octal';
    var useDecNumbers = options.numbers == 'decimal';
    var useHexNumbers = options.numbers == 'hexadecimal';

    if (json && argument && isFunction$2(argument.toJSON)) {
      argument = argument.toJSON();
    }

    if (!isString$1(argument)) {
      if (isMap$1(argument)) {
        if (argument.size == 0) {
          return 'new Map()';
        }

        if (!compact) {
          options.__inline1__ = true;
          options.__inline2__ = false;
        }

        return 'new Map(' + jsesc(Array.from(argument), options) + ')';
      }

      if (isSet$1(argument)) {
        if (argument.size == 0) {
          return 'new Set()';
        }

        return 'new Set(' + jsesc(Array.from(argument), options) + ')';
      }

      if (isBuffer$1(argument)) {
        if (argument.length == 0) {
          return 'Buffer.from([])';
        }

        return 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';
      }

      if (isArray$2(argument)) {
        result = [];
        options.wrap = true;

        if (inline1) {
          options.__inline1__ = false;
          options.__inline2__ = true;
        }

        if (!inline2) {
          increaseIndentation();
        }

        forEach(argument, function (value) {
          isEmpty = false;

          if (inline2) {
            options.__inline2__ = false;
          }

          result.push((compact || inline2 ? '' : indent) + jsesc(value, options));
        });

        if (isEmpty) {
          return '[]';
        }

        if (inline2) {
          return '[' + result.join(', ') + ']';
        }

        return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';
      } else if (isNumber(argument)) {
        if (json) {
          return JSON.stringify(argument);
        }

        if (useDecNumbers) {
          return String(argument);
        }

        if (useHexNumbers) {
          var hexadecimal = argument.toString(16);

          if (!lowercaseHex) {
            hexadecimal = hexadecimal.toUpperCase();
          }

          return '0x' + hexadecimal;
        }

        if (useBinNumbers) {
          return '0b' + argument.toString(2);
        }

        if (useOctNumbers) {
          return '0o' + argument.toString(8);
        }
      } else if (!isObject$1(argument)) {
        if (json) {
          return JSON.stringify(argument) || 'null';
        }

        return String(argument);
      } else {
        result = [];
        options.wrap = true;
        increaseIndentation();
        forOwn(argument, function (key, value) {
          isEmpty = false;
          result.push((compact ? '' : indent) + jsesc(key, options) + ':' + (compact ? '' : ' ') + jsesc(value, options));
        });

        if (isEmpty) {
          return '{}';
        }

        return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';
      }
    }

    var string = argument;
    var index = -1;
    var length = string.length;
    result = '';

    while (++index < length) {
      var character = string.charAt(index);

      if (options.es6) {
        var first = string.charCodeAt(index);

        if (first >= 0xD800 && first <= 0xDBFF && length > index + 1) {
            var second = string.charCodeAt(index + 1);

            if (second >= 0xDC00 && second <= 0xDFFF) {
              var codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;

              var _hexadecimal2 = codePoint.toString(16);

              if (!lowercaseHex) {
                _hexadecimal2 = _hexadecimal2.toUpperCase();
              }

              result += "\\u{" + _hexadecimal2 + '}';
              ++index;
              continue;
            }
          }
      }

      if (!options.escapeEverything) {
        if (regexWhitelist.test(character)) {
          result += character;
          continue;
        }

        if (character == '"') {
          result += quote == character ? '\\"' : character;
          continue;
        }

        if (character == '`') {
          result += quote == character ? '\\`' : character;
          continue;
        }

        if (character == '\'') {
          result += quote == character ? '\\\'' : character;
          continue;
        }
      }

      if (character == '\0' && !json && !regexDigit.test(string.charAt(index + 1))) {
        result += '\\0';
        continue;
      }

      if (regexSingleEscape.test(character)) {
        result += singleEscapes[character];
        continue;
      }

      var charCode = character.charCodeAt(0);

      if (options.minimal && charCode != 0x2028 && charCode != 0x2029) {
        result += character;
        continue;
      }

      var _hexadecimal = charCode.toString(16);

      if (!lowercaseHex) {
        _hexadecimal = _hexadecimal.toUpperCase();
      }

      var longhand = _hexadecimal.length > 2 || json;

      var escaped = '\\' + (longhand ? 'u' : 'x') + ('0000' + _hexadecimal).slice(longhand ? -4 : -2);

      result += escaped;
      continue;
    }

    if (options.wrap) {
      result = quote + result + quote;
    }

    if (quote == '`') {
      result = result.replace(/\$\{/g, '\\\$\{');
    }

    if (options.isScriptContext) {
      return result.replace(/<\/(script|style)/gi, '<\\/$1').replace(/<!--/g, json ? "\\u003C!--" : '\\x3C!--');
    }

    return result;
  };

  jsesc.version = '2.5.2';
  var jsesc_1 = jsesc;

  function Identifier$1(node) {
    var _this = this;

    this.exactSource(node.loc, function () {
      _this.word(node.name);
    });
  }
  function ArgumentPlaceholder$1() {
    this.token("?");
  }
  function RestElement$1(node) {
    this.token("...");
    this.print(node.argument, node);
  }
  function ObjectExpression$2(node) {
    var props = node.properties;
    this.token("{");
    this.printInnerComments(node);

    if (props.length) {
      this.space();
      this.printList(props, node, {
        indent: true,
        statement: true
      });
      this.space();
    }

    this.token("}");
  }
  function ObjectMethod$1(node) {
    this.printJoin(node.decorators, node);

    this._methodHead(node);

    this.space();
    this.print(node.body, node);
  }
  function ObjectProperty$1(node) {
    this.printJoin(node.decorators, node);

    if (node.computed) {
      this.token("[");
      this.print(node.key, node);
      this.token("]");
    } else {
      if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
        this.print(node.value, node);
        return;
      }

      this.print(node.key, node);

      if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {
        return;
      }
    }

    this.token(":");
    this.space();
    this.print(node.value, node);
  }
  function ArrayExpression$1(node) {
    var elems = node.elements;
    var len = elems.length;
    this.token("[");
    this.printInnerComments(node);

    for (var i = 0; i < elems.length; i++) {
      var elem = elems[i];

      if (elem) {
        if (i > 0) this.space();
        this.print(elem, node);
        if (i < len - 1) this.token(",");
      } else {
        this.token(",");
      }
    }

    this.token("]");
  }
  function RecordExpression$1(node) {
    var props = node.properties;
    var startToken;
    var endToken;

    if (this.format.recordAndTupleSyntaxType === "bar") {
      startToken = "{|";
      endToken = "|}";
    } else if (this.format.recordAndTupleSyntaxType === "hash") {
      startToken = "#{";
      endToken = "}";
    } else {
      throw new Error("The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (" + JSON.stringify(this.format.recordAndTupleSyntaxType) + " received).");
    }

    this.token(startToken);
    this.printInnerComments(node);

    if (props.length) {
      this.space();
      this.printList(props, node, {
        indent: true,
        statement: true
      });
      this.space();
    }

    this.token(endToken);
  }
  function TupleExpression$1(node) {
    var elems = node.elements;
    var len = elems.length;
    var startToken;
    var endToken;

    if (this.format.recordAndTupleSyntaxType === "bar") {
      startToken = "[|";
      endToken = "|]";
    } else if (this.format.recordAndTupleSyntaxType === "hash") {
      startToken = "#[";
      endToken = "]";
    } else {
      throw new Error(this.format.recordAndTupleSyntaxType + " is not a valid recordAndTuple syntax type");
    }

    this.token(startToken);
    this.printInnerComments(node);

    for (var i = 0; i < elems.length; i++) {
      var elem = elems[i];

      if (elem) {
        if (i > 0) this.space();
        this.print(elem, node);
        if (i < len - 1) this.token(",");
      }
    }

    this.token(endToken);
  }
  function RegExpLiteral$1(node) {
    this.word("/" + node.pattern + "/" + node.flags);
  }
  function BooleanLiteral$1(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteral$1() {
    this.word("null");
  }
  function NumericLiteral$1(node) {
    var raw = this.getPossibleRaw(node);
    var opts = this.format.jsescOption;
    var value = node.value + "";

    if (opts.numbers) {
      this.number(jsesc_1(node.value, opts));
    } else if (raw == null) {
      this.number(value);
    } else if (this.format.minified) {
      this.number(raw.length < value.length ? raw : value);
    } else {
      this.number(raw);
    }
  }
  function StringLiteral$1(node) {
    var raw = this.getPossibleRaw(node);

    if (!this.format.minified && raw != null) {
      this.token(raw);
      return;
    }

    var opts = this.format.jsescOption;

    if (this.format.jsonCompatibleStrings) {
      opts.json = true;
    }

    var val = jsesc_1(node.value, opts);
    return this.token(val);
  }
  function BigIntLiteral$1(node) {
    var raw = this.getPossibleRaw(node);

    if (!this.format.minified && raw != null) {
      this.token(raw);
      return;
    }

    this.token(node.value);
  }
  function PipelineTopicExpression$1(node) {
    this.print(node.expression, node);
  }
  function PipelineBareFunction$1(node) {
    this.print(node.callee, node);
  }
  function PipelinePrimaryTopicReference$1() {
    this.token("#");
  }

  function AnyTypeAnnotation$1() {
    this.word("any");
  }
  function ArrayTypeAnnotation$1(node) {
    this.print(node.elementType, node);
    this.token("[");
    this.token("]");
  }
  function BooleanTypeAnnotation$1() {
    this.word("boolean");
  }
  function BooleanLiteralTypeAnnotation$1(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteralTypeAnnotation$1() {
    this.word("null");
  }
  function DeclareClass$1(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.word("class");
    this.space();

    this._interfaceish(node);
  }
  function DeclareFunction$1(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.word("function");
    this.space();
    this.print(node.id, node);
    this.print(node.id.typeAnnotation.typeAnnotation, node);

    if (node.predicate) {
      this.space();
      this.print(node.predicate, node);
    }

    this.semicolon();
  }
  function InferredPredicate$1() {
    this.token("%");
    this.word("checks");
  }
  function DeclaredPredicate$1(node) {
    this.token("%");
    this.word("checks");
    this.token("(");
    this.print(node.value, node);
    this.token(")");
  }
  function DeclareInterface$1(node) {
    this.word("declare");
    this.space();
    this.InterfaceDeclaration(node);
  }
  function DeclareModule$1(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.space();
    this.print(node.id, node);
    this.space();
    this.print(node.body, node);
  }
  function DeclareModuleExports$1(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.token(".");
    this.word("exports");
    this.print(node.typeAnnotation, node);
  }
  function DeclareTypeAlias$1(node) {
    this.word("declare");
    this.space();
    this.TypeAlias(node);
  }
  function DeclareOpaqueType$1(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.OpaqueType(node);
  }
  function DeclareVariable$1(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.word("var");
    this.space();
    this.print(node.id, node);
    this.print(node.id.typeAnnotation, node);
    this.semicolon();
  }
  function DeclareExportDeclaration$1(node) {
    this.word("declare");
    this.space();
    this.word("export");
    this.space();

    if (node["default"]) {
      this.word("default");
      this.space();
    }

    FlowExportDeclaration.apply(this, arguments);
  }
  function DeclareExportAllDeclaration$1() {
    this.word("declare");
    this.space();
    ExportAllDeclaration$1.apply(this, arguments);
  }
  function EnumDeclaration$1(node) {
    var id = node.id,
        body = node.body;
    this.word("enum");
    this.space();
    this.print(id, node);
    this.print(body, node);
  }

  function enumExplicitType(context, name, hasExplicitType) {
    if (hasExplicitType) {
      context.space();
      context.word("of");
      context.space();
      context.word(name);
    }

    context.space();
  }

  function enumBody(context, node) {
    var members = node.members;
    context.token("{");
    context.indent();
    context.newline();

    for (var _iterator = members, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var member = _ref;
      context.print(member, node);
      context.newline();
    }

    context.dedent();
    context.token("}");
  }

  function EnumBooleanBody$1(node) {
    var explicitType = node.explicitType;
    enumExplicitType(this, "boolean", explicitType);
    enumBody(this, node);
  }
  function EnumNumberBody$1(node) {
    var explicitType = node.explicitType;
    enumExplicitType(this, "number", explicitType);
    enumBody(this, node);
  }
  function EnumStringBody$1(node) {
    var explicitType = node.explicitType;
    enumExplicitType(this, "string", explicitType);
    enumBody(this, node);
  }
  function EnumSymbolBody$1(node) {
    enumExplicitType(this, "symbol", true);
    enumBody(this, node);
  }
  function EnumDefaultedMember$1(node) {
    var id = node.id;
    this.print(id, node);
    this.token(",");
  }

  function enumInitializedMember(context, node) {
    var id = node.id,
        init = node.init;
    context.print(id, node);
    context.space();
    context.token("=");
    context.space();
    context.print(init, node);
    context.token(",");
  }

  function EnumBooleanMember$1(node) {
    enumInitializedMember(this, node);
  }
  function EnumNumberMember$1(node) {
    enumInitializedMember(this, node);
  }
  function EnumStringMember$1(node) {
    enumInitializedMember(this, node);
  }

  function FlowExportDeclaration(node) {
    if (node.declaration) {
      var declar = node.declaration;
      this.print(declar, node);
      if (!isStatement(declar)) this.semicolon();
    } else {
      this.token("{");

      if (node.specifiers.length) {
        this.space();
        this.printList(node.specifiers, node);
        this.space();
      }

      this.token("}");

      if (node.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node.source, node);
      }

      this.semicolon();
    }
  }

  function ExistsTypeAnnotation$1() {
    this.token("*");
  }
  function FunctionTypeAnnotation$2(node, parent) {
    this.print(node.typeParameters, node);
    this.token("(");
    this.printList(node.params, node);

    if (node.rest) {
      if (node.params.length) {
        this.token(",");
        this.space();
      }

      this.token("...");
      this.print(node.rest, node);
    }

    this.token(")");

    if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method) {
      this.token(":");
    } else {
      this.space();
      this.token("=>");
    }

    this.space();
    this.print(node.returnType, node);
  }
  function FunctionTypeParam$1(node) {
    this.print(node.name, node);
    if (node.optional) this.token("?");

    if (node.name) {
      this.token(":");
      this.space();
    }

    this.print(node.typeAnnotation, node);
  }
  function InterfaceExtends$1(node) {
    this.print(node.id, node);
    this.print(node.typeParameters, node);
  }
  function _interfaceish(node) {
    this.print(node.id, node);
    this.print(node.typeParameters, node);

    if (node["extends"].length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node["extends"], node);
    }

    if (node.mixins && node.mixins.length) {
      this.space();
      this.word("mixins");
      this.space();
      this.printList(node.mixins, node);
    }

    if (node["implements"] && node["implements"].length) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node["implements"], node);
    }

    this.space();
    this.print(node.body, node);
  }
  function _variance(node) {
    if (node.variance) {
      if (node.variance.kind === "plus") {
        this.token("+");
      } else if (node.variance.kind === "minus") {
        this.token("-");
      }
    }
  }
  function InterfaceDeclaration$1(node) {
    this.word("interface");
    this.space();

    this._interfaceish(node);
  }

  function andSeparator() {
    this.space();
    this.token("&");
    this.space();
  }

  function InterfaceTypeAnnotation$1(node) {
    this.word("interface");

    if (node["extends"] && node["extends"].length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node["extends"], node);
    }

    this.space();
    this.print(node.body, node);
  }
  function IntersectionTypeAnnotation$1(node) {
    this.printJoin(node.types, node, {
      separator: andSeparator
    });
  }
  function MixedTypeAnnotation$1() {
    this.word("mixed");
  }
  function EmptyTypeAnnotation$1() {
    this.word("empty");
  }
  function NullableTypeAnnotation$2(node) {
    this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function NumberTypeAnnotation$1() {
    this.word("number");
  }
  function StringTypeAnnotation$1() {
    this.word("string");
  }
  function ThisTypeAnnotation$1() {
    this.word("this");
  }
  function TupleTypeAnnotation$1(node) {
    this.token("[");
    this.printList(node.types, node);
    this.token("]");
  }
  function TypeofTypeAnnotation$1(node) {
    this.word("typeof");
    this.space();
    this.print(node.argument, node);
  }
  function TypeAlias$1(node) {
    this.word("type");
    this.space();
    this.print(node.id, node);
    this.print(node.typeParameters, node);
    this.space();
    this.token("=");
    this.space();
    this.print(node.right, node);
    this.semicolon();
  }
  function TypeAnnotation$1(node) {
    this.token(":");
    this.space();
    if (node.optional) this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function TypeParameterInstantiation$1(node) {
    this.token("<");
    this.printList(node.params, node, {});
    this.token(">");
  }
  function TypeParameter$1(node) {
    this._variance(node);

    this.word(node.name);

    if (node.bound) {
      this.print(node.bound, node);
    }

    if (node["default"]) {
      this.space();
      this.token("=");
      this.space();
      this.print(node["default"], node);
    }
  }
  function OpaqueType$1(node) {
    this.word("opaque");
    this.space();
    this.word("type");
    this.space();
    this.print(node.id, node);
    this.print(node.typeParameters, node);

    if (node.supertype) {
      this.token(":");
      this.space();
      this.print(node.supertype, node);
    }

    if (node.impltype) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.impltype, node);
    }

    this.semicolon();
  }
  function ObjectTypeAnnotation$1(node) {
    var _this = this;

    if (node.exact) {
      this.token("{|");
    } else {
      this.token("{");
    }

    var props = node.properties.concat(node.callProperties || [], node.indexers || [], node.internalSlots || []);

    if (props.length) {
      this.space();
      this.printJoin(props, node, {
        addNewlines: function addNewlines(leading) {
          if (leading && !props[0]) return 1;
        },
        indent: true,
        statement: true,
        iterator: function iterator() {
          if (props.length !== 1 || node.inexact) {
            _this.token(",");

            _this.space();
          }
        }
      });
      this.space();
    }

    if (node.inexact) {
      this.indent();
      this.token("...");

      if (props.length) {
        this.newline();
      }

      this.dedent();
    }

    if (node.exact) {
      this.token("|}");
    } else {
      this.token("}");
    }
  }
  function ObjectTypeInternalSlot$1(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this.token("[");
    this.token("[");
    this.print(node.id, node);
    this.token("]");
    this.token("]");
    if (node.optional) this.token("?");

    if (!node.method) {
      this.token(":");
      this.space();
    }

    this.print(node.value, node);
  }
  function ObjectTypeCallProperty$1(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this.print(node.value, node);
  }
  function ObjectTypeIndexer$1(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this._variance(node);

    this.token("[");

    if (node.id) {
      this.print(node.id, node);
      this.token(":");
      this.space();
    }

    this.print(node.key, node);
    this.token("]");
    this.token(":");
    this.space();
    this.print(node.value, node);
  }
  function ObjectTypeProperty$1(node) {
    if (node.proto) {
      this.word("proto");
      this.space();
    }

    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this._variance(node);

    this.print(node.key, node);
    if (node.optional) this.token("?");

    if (!node.method) {
      this.token(":");
      this.space();
    }

    this.print(node.value, node);
  }
  function ObjectTypeSpreadProperty$1(node) {
    this.token("...");
    this.print(node.argument, node);
  }
  function QualifiedTypeIdentifier$1(node) {
    this.print(node.qualification, node);
    this.token(".");
    this.print(node.id, node);
  }
  function SymbolTypeAnnotation$1() {
    this.word("symbol");
  }

  function orSeparator() {
    this.space();
    this.token("|");
    this.space();
  }

  function UnionTypeAnnotation$2(node) {
    this.printJoin(node.types, node, {
      separator: orSeparator
    });
  }
  function TypeCastExpression$1(node) {
    this.token("(");
    this.print(node.expression, node);
    this.print(node.typeAnnotation, node);
    this.token(")");
  }
  function Variance$1(node) {
    if (node.kind === "plus") {
      this.token("+");
    } else {
      this.token("-");
    }
  }
  function VoidTypeAnnotation$1() {
    this.word("void");
  }

  function File$1(node) {
    if (node.program) {
      this.print(node.program.interpreter, node);
    }

    this.print(node.program, node);
  }
  function Program$1(node) {
    this.printInnerComments(node, false);
    this.printSequence(node.directives, node);
    if (node.directives && node.directives.length) this.newline();
    this.printSequence(node.body, node);
  }
  function BlockStatement$1(node) {
    this.token("{");
    this.printInnerComments(node);
    var hasDirectives = node.directives && node.directives.length;

    if (node.body.length || hasDirectives) {
      this.newline();
      this.printSequence(node.directives, node, {
        indent: true
      });
      if (hasDirectives) this.newline();
      this.printSequence(node.body, node, {
        indent: true
      });
      this.removeTrailingNewline();
      this.source("end", node.loc);
      if (!this.endsWith("\n")) this.newline();
      this.rightBrace();
    } else {
      this.source("end", node.loc);
      this.token("}");
    }
  }
  function Noop$1() {}
  function Directive$1(node) {
    this.print(node.value, node);
    this.semicolon();
  }
  var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
  var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
  function DirectiveLiteral$1(node) {
    var raw = this.getPossibleRaw(node);

    if (raw != null) {
      this.token(raw);
      return;
    }

    var value = node.value;

    if (!unescapedDoubleQuoteRE.test(value)) {
      this.token("\"" + value + "\"");
    } else if (!unescapedSingleQuoteRE.test(value)) {
      this.token("'" + value + "'");
    } else {
      throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
    }
  }
  function InterpreterDirective$1(node) {
    this.token("#!" + node.value + "\n");
  }
  function Placeholder$1(node) {
    this.token("%%");
    this.print(node.name);
    this.token("%%");

    if (node.expectedNode === "Statement") {
      this.semicolon();
    }
  }

  function JSXAttribute$1(node) {
    this.print(node.name, node);

    if (node.value) {
      this.token("=");
      this.print(node.value, node);
    }
  }
  function JSXIdentifier$1(node) {
    this.word(node.name);
  }
  function JSXNamespacedName$1(node) {
    this.print(node.namespace, node);
    this.token(":");
    this.print(node.name, node);
  }
  function JSXMemberExpression$1(node) {
    this.print(node.object, node);
    this.token(".");
    this.print(node.property, node);
  }
  function JSXSpreadAttribute$1(node) {
    this.token("{");
    this.token("...");
    this.print(node.argument, node);
    this.token("}");
  }
  function JSXExpressionContainer$1(node) {
    this.token("{");
    this.print(node.expression, node);
    this.token("}");
  }
  function JSXSpreadChild$1(node) {
    this.token("{");
    this.token("...");
    this.print(node.expression, node);
    this.token("}");
  }
  function JSXText$1(node) {
    var raw = this.getPossibleRaw(node);

    if (raw != null) {
      this.token(raw);
    } else {
      this.token(node.value);
    }
  }
  function JSXElement$1(node) {
    var open = node.openingElement;
    this.print(open, node);
    if (open.selfClosing) return;
    this.indent();

    for (var _i = 0, _arr = node.children; _i < _arr.length; _i++) {
      var child = _arr[_i];
      this.print(child, node);
    }

    this.dedent();
    this.print(node.closingElement, node);
  }

  function spaceSeparator() {
    this.space();
  }

  function JSXOpeningElement$1(node) {
    this.token("<");
    this.print(node.name, node);
    this.print(node.typeParameters, node);

    if (node.attributes.length > 0) {
      this.space();
      this.printJoin(node.attributes, node, {
        separator: spaceSeparator
      });
    }

    if (node.selfClosing) {
      this.space();
      this.token("/>");
    } else {
      this.token(">");
    }
  }
  function JSXClosingElement$1(node) {
    this.token("</");
    this.print(node.name, node);
    this.token(">");
  }
  function JSXEmptyExpression$1(node) {
    this.printInnerComments(node);
  }
  function JSXFragment$1(node) {
    this.print(node.openingFragment, node);
    this.indent();

    for (var _i2 = 0, _arr2 = node.children; _i2 < _arr2.length; _i2++) {
      var child = _arr2[_i2];
      this.print(child, node);
    }

    this.dedent();
    this.print(node.closingFragment, node);
  }
  function JSXOpeningFragment$1() {
    this.token("<");
    this.token(">");
  }
  function JSXClosingFragment$1() {
    this.token("</");
    this.token(">");
  }

  function TSTypeAnnotation$1(node) {
    this.token(":");
    this.space();
    if (node.optional) this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function TSTypeParameterInstantiation$1(node) {
    this.token("<");
    this.printList(node.params, node, {});
    this.token(">");
  }
  function TSTypeParameter$1(node) {
    this.word(node.name);

    if (node.constraint) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.constraint, node);
    }

    if (node["default"]) {
      this.space();
      this.token("=");
      this.space();
      this.print(node["default"], node);
    }
  }
  function TSParameterProperty$1(node) {
    if (node.accessibility) {
      this.word(node.accessibility);
      this.space();
    }

    if (node.readonly) {
      this.word("readonly");
      this.space();
    }

    this._param(node.parameter);
  }
  function TSDeclareFunction$1(node) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }

    this._functionHead(node);

    this.token(";");
  }
  function TSDeclareMethod$1(node) {
    this._classMethodHead(node);

    this.token(";");
  }
  function TSQualifiedName$1(node) {
    this.print(node.left, node);
    this.token(".");
    this.print(node.right, node);
  }
  function TSCallSignatureDeclaration$1(node) {
    this.tsPrintSignatureDeclarationBase(node);
    this.token(";");
  }
  function TSConstructSignatureDeclaration$1(node) {
    this.word("new");
    this.space();
    this.tsPrintSignatureDeclarationBase(node);
    this.token(";");
  }
  function TSPropertySignature$1(node) {
    var readonly = node.readonly,
        initializer = node.initializer;

    if (readonly) {
      this.word("readonly");
      this.space();
    }

    this.tsPrintPropertyOrMethodName(node);
    this.print(node.typeAnnotation, node);

    if (initializer) {
      this.space();
      this.token("=");
      this.space();
      this.print(initializer, node);
    }

    this.token(";");
  }
  function tsPrintPropertyOrMethodName(node) {
    if (node.computed) {
      this.token("[");
    }

    this.print(node.key, node);

    if (node.computed) {
      this.token("]");
    }

    if (node.optional) {
      this.token("?");
    }
  }
  function TSMethodSignature$1(node) {
    this.tsPrintPropertyOrMethodName(node);
    this.tsPrintSignatureDeclarationBase(node);
    this.token(";");
  }
  function TSIndexSignature$1(node) {
    var readonly = node.readonly;

    if (readonly) {
      this.word("readonly");
      this.space();
    }

    this.token("[");

    this._parameters(node.parameters, node);

    this.token("]");
    this.print(node.typeAnnotation, node);
    this.token(";");
  }
  function TSAnyKeyword$1() {
    this.word("any");
  }
  function TSBigIntKeyword$1() {
    this.word("bigint");
  }
  function TSUnknownKeyword$1() {
    this.word("unknown");
  }
  function TSNumberKeyword$1() {
    this.word("number");
  }
  function TSObjectKeyword$1() {
    this.word("object");
  }
  function TSBooleanKeyword$1() {
    this.word("boolean");
  }
  function TSStringKeyword$1() {
    this.word("string");
  }
  function TSSymbolKeyword$1() {
    this.word("symbol");
  }
  function TSVoidKeyword$1() {
    this.word("void");
  }
  function TSUndefinedKeyword$1() {
    this.word("undefined");
  }
  function TSNullKeyword$1() {
    this.word("null");
  }
  function TSNeverKeyword$1() {
    this.word("never");
  }
  function TSThisType$1() {
    this.word("this");
  }
  function TSFunctionType$1(node) {
    this.tsPrintFunctionOrConstructorType(node);
  }
  function TSConstructorType$1(node) {
    this.word("new");
    this.space();
    this.tsPrintFunctionOrConstructorType(node);
  }
  function tsPrintFunctionOrConstructorType(node) {
    var typeParameters = node.typeParameters,
        parameters = node.parameters;
    this.print(typeParameters, node);
    this.token("(");

    this._parameters(parameters, node);

    this.token(")");
    this.space();
    this.token("=>");
    this.space();
    this.print(node.typeAnnotation.typeAnnotation, node);
  }
  function TSTypeReference$1(node) {
    this.print(node.typeName, node);
    this.print(node.typeParameters, node);
  }
  function TSTypePredicate$1(node) {
    if (node.asserts) {
      this.word("asserts");
      this.space();
    }

    this.print(node.parameterName);

    if (node.typeAnnotation) {
      this.space();
      this.word("is");
      this.space();
      this.print(node.typeAnnotation.typeAnnotation);
    }
  }
  function TSTypeQuery$1(node) {
    this.word("typeof");
    this.space();
    this.print(node.exprName);
  }
  function TSTypeLiteral$1(node) {
    this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
  }
  function tsPrintTypeLiteralOrInterfaceBody(members, node) {
    this.tsPrintBraced(members, node);
  }
  function tsPrintBraced(members, node) {
    this.token("{");

    if (members.length) {
      this.indent();
      this.newline();

      for (var _iterator = members, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var member = _ref;
        this.print(member, node);
        this.newline();
      }

      this.dedent();
      this.rightBrace();
    } else {
      this.token("}");
    }
  }
  function TSArrayType$1(node) {
    this.print(node.elementType, node);
    this.token("[]");
  }
  function TSTupleType$1(node) {
    this.token("[");
    this.printList(node.elementTypes, node);
    this.token("]");
  }
  function TSOptionalType$1(node) {
    this.print(node.typeAnnotation, node);
    this.token("?");
  }
  function TSRestType$1(node) {
    this.token("...");
    this.print(node.typeAnnotation, node);
  }
  function TSUnionType$2(node) {
    this.tsPrintUnionOrIntersectionType(node, "|");
  }
  function TSIntersectionType$1(node) {
    this.tsPrintUnionOrIntersectionType(node, "&");
  }
  function tsPrintUnionOrIntersectionType(node, sep) {
    this.printJoin(node.types, node, {
      separator: function separator() {
        this.space();
        this.token(sep);
        this.space();
      }
    });
  }
  function TSConditionalType$1(node) {
    this.print(node.checkType);
    this.space();
    this.word("extends");
    this.space();
    this.print(node.extendsType);
    this.space();
    this.token("?");
    this.space();
    this.print(node.trueType);
    this.space();
    this.token(":");
    this.space();
    this.print(node.falseType);
  }
  function TSInferType$2(node) {
    this.token("infer");
    this.space();
    this.print(node.typeParameter);
  }
  function TSParenthesizedType$1(node) {
    this.token("(");
    this.print(node.typeAnnotation, node);
    this.token(")");
  }
  function TSTypeOperator$1(node) {
    this.token(node.operator);
    this.space();
    this.print(node.typeAnnotation, node);
  }
  function TSIndexedAccessType$1(node) {
    this.print(node.objectType, node);
    this.token("[");
    this.print(node.indexType, node);
    this.token("]");
  }
  function TSMappedType$1(node) {
    var readonly = node.readonly,
        typeParameter = node.typeParameter,
        optional = node.optional;
    this.token("{");
    this.space();

    if (readonly) {
      tokenIfPlusMinus(this, readonly);
      this.word("readonly");
      this.space();
    }

    this.token("[");
    this.word(typeParameter.name);
    this.space();
    this.word("in");
    this.space();
    this.print(typeParameter.constraint, typeParameter);
    this.token("]");

    if (optional) {
      tokenIfPlusMinus(this, optional);
      this.token("?");
    }

    this.token(":");
    this.space();
    this.print(node.typeAnnotation, node);
    this.space();
    this.token("}");
  }

  function tokenIfPlusMinus(self, tok) {
    if (tok !== true) {
      self.token(tok);
    }
  }

  function TSLiteralType$1(node) {
    this.print(node.literal, node);
  }
  function TSExpressionWithTypeArguments$1(node) {
    this.print(node.expression, node);
    this.print(node.typeParameters, node);
  }
  function TSInterfaceDeclaration$1(node) {
    var declare = node.declare,
        id = node.id,
        typeParameters = node.typeParameters,
        extendz = node["extends"],
        body = node.body;

    if (declare) {
      this.word("declare");
      this.space();
    }

    this.word("interface");
    this.space();
    this.print(id, node);
    this.print(typeParameters, node);

    if (extendz) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(extendz, node);
    }

    this.space();
    this.print(body, node);
  }
  function TSInterfaceBody$1(node) {
    this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
  }
  function TSTypeAliasDeclaration$1(node) {
    var declare = node.declare,
        id = node.id,
        typeParameters = node.typeParameters,
        typeAnnotation = node.typeAnnotation;

    if (declare) {
      this.word("declare");
      this.space();
    }

    this.word("type");
    this.space();
    this.print(id, node);
    this.print(typeParameters, node);
    this.space();
    this.token("=");
    this.space();
    this.print(typeAnnotation, node);
    this.token(";");
  }
  function TSAsExpression$2(node) {
    var expression = node.expression,
        typeAnnotation = node.typeAnnotation;
    this.print(expression, node);
    this.space();
    this.word("as");
    this.space();
    this.print(typeAnnotation, node);
  }
  function TSTypeAssertion$2(node) {
    var typeAnnotation = node.typeAnnotation,
        expression = node.expression;
    this.token("<");
    this.print(typeAnnotation, node);
    this.token(">");
    this.space();
    this.print(expression, node);
  }
  function TSEnumDeclaration$1(node) {
    var declare = node.declare,
        isConst = node["const"],
        id = node.id,
        members = node.members;

    if (declare) {
      this.word("declare");
      this.space();
    }

    if (isConst) {
      this.word("const");
      this.space();
    }

    this.word("enum");
    this.space();
    this.print(id, node);
    this.space();
    this.tsPrintBraced(members, node);
  }
  function TSEnumMember$1(node) {
    var id = node.id,
        initializer = node.initializer;
    this.print(id, node);

    if (initializer) {
      this.space();
      this.token("=");
      this.space();
      this.print(initializer, node);
    }

    this.token(",");
  }
  function TSModuleDeclaration$1(node) {
    var declare = node.declare,
        id = node.id;

    if (declare) {
      this.word("declare");
      this.space();
    }

    if (!node.global) {
      this.word(id.type === "Identifier" ? "namespace" : "module");
      this.space();
    }

    this.print(id, node);

    if (!node.body) {
      this.token(";");
      return;
    }

    var body = node.body;

    while (body.type === "TSModuleDeclaration") {
      this.token(".");
      this.print(body.id, body);
      body = body.body;
    }

    this.space();
    this.print(body, node);
  }
  function TSModuleBlock$1(node) {
    this.tsPrintBraced(node.body, node);
  }
  function TSImportType$1(node) {
    var argument = node.argument,
        qualifier = node.qualifier,
        typeParameters = node.typeParameters;
    this.word("import");
    this.token("(");
    this.print(argument, node);
    this.token(")");

    if (qualifier) {
      this.token(".");
      this.print(qualifier, node);
    }

    if (typeParameters) {
      this.print(typeParameters, node);
    }
  }
  function TSImportEqualsDeclaration$1(node) {
    var isExport = node.isExport,
        id = node.id,
        moduleReference = node.moduleReference;

    if (isExport) {
      this.word("export");
      this.space();
    }

    this.word("import");
    this.space();
    this.print(id, node);
    this.space();
    this.token("=");
    this.space();
    this.print(moduleReference, node);
    this.token(";");
  }
  function TSExternalModuleReference$1(node) {
    this.token("require(");
    this.print(node.expression, node);
    this.token(")");
  }
  function TSNonNullExpression$1(node) {
    this.print(node.expression, node);
    this.token("!");
  }
  function TSExportAssignment$1(node) {
    this.word("export");
    this.space();
    this.token("=");
    this.space();
    this.print(node.expression, node);
    this.token(";");
  }
  function TSNamespaceExportDeclaration$1(node) {
    this.word("export");
    this.space();
    this.word("as");
    this.space();
    this.word("namespace");
    this.space();
    this.print(node.id, node);
  }
  function tsPrintSignatureDeclarationBase(node) {
    var typeParameters = node.typeParameters,
        parameters = node.parameters;
    this.print(typeParameters, node);
    this.token("(");

    this._parameters(parameters, node);

    this.token(")");
    this.print(node.typeAnnotation, node);
  }
  function tsPrintClassMemberModifiers(node, isField) {
    if (isField && node.declare) {
      this.word("declare");
      this.space();
    }

    if (node.accessibility) {
      this.word(node.accessibility);
      this.space();
    }

    if (node["static"]) {
      this.word("static");
      this.space();
    }

    if (node["abstract"]) {
      this.word("abstract");
      this.space();
    }

    if (isField && node.readonly) {
      this.word("readonly");
      this.space();
    }
  }



  var generatorFunctions = /*#__PURE__*/Object.freeze({
    __proto__: null,
    TaggedTemplateExpression: TaggedTemplateExpression$1,
    TemplateElement: TemplateElement$1,
    TemplateLiteral: TemplateLiteral$1,
    UnaryExpression: UnaryExpression$1,
    DoExpression: DoExpression$2,
    ParenthesizedExpression: ParenthesizedExpression$1,
    UpdateExpression: UpdateExpression$2,
    ConditionalExpression: ConditionalExpression$2,
    NewExpression: NewExpression$1,
    SequenceExpression: SequenceExpression$2,
    ThisExpression: ThisExpression$1,
    Super: Super$1,
    Decorator: Decorator$1,
    OptionalMemberExpression: OptionalMemberExpression$2,
    OptionalCallExpression: OptionalCallExpression$2,
    CallExpression: CallExpression$1,
    Import: Import$1,
    YieldExpression: YieldExpression$2,
    AwaitExpression: AwaitExpression$1,
    EmptyStatement: EmptyStatement$1,
    ExpressionStatement: ExpressionStatement$1,
    AssignmentPattern: AssignmentPattern$1,
    AssignmentExpression: AssignmentExpression$2,
    BindExpression: BindExpression$1,
    BinaryExpression: AssignmentExpression$2,
    LogicalExpression: AssignmentExpression$2,
    MemberExpression: MemberExpression$1,
    MetaProperty: MetaProperty$1,
    PrivateName: PrivateName$1,
    V8IntrinsicIdentifier: V8IntrinsicIdentifier$1,
    WithStatement: WithStatement$1,
    IfStatement: IfStatement$1,
    ForStatement: ForStatement$1,
    WhileStatement: WhileStatement$1,
    ForInStatement: ForInStatement$1,
    ForOfStatement: ForOfStatement$1,
    DoWhileStatement: DoWhileStatement$1,
    ContinueStatement: ContinueStatement$1,
    ReturnStatement: ReturnStatement$1,
    BreakStatement: BreakStatement$1,
    ThrowStatement: ThrowStatement$1,
    LabeledStatement: LabeledStatement$1,
    TryStatement: TryStatement$1,
    CatchClause: CatchClause$1,
    SwitchStatement: SwitchStatement$1,
    SwitchCase: SwitchCase$1,
    DebuggerStatement: DebuggerStatement$1,
    VariableDeclaration: VariableDeclaration$1,
    VariableDeclarator: VariableDeclarator$1,
    ClassDeclaration: ClassDeclaration$1,
    ClassExpression: ClassDeclaration$1,
    ClassBody: ClassBody$1,
    ClassProperty: ClassProperty$1,
    ClassPrivateProperty: ClassPrivateProperty$1,
    ClassMethod: ClassMethod$1,
    ClassPrivateMethod: ClassPrivateMethod$1,
    _classMethodHead: _classMethodHead,
    _params: _params,
    _parameters: _parameters,
    _param: _param,
    _methodHead: _methodHead,
    _predicate: _predicate,
    _functionHead: _functionHead,
    FunctionExpression: FunctionExpression$2,
    FunctionDeclaration: FunctionExpression$2,
    ArrowFunctionExpression: ArrowFunctionExpression$2,
    ImportSpecifier: ImportSpecifier$1,
    ImportDefaultSpecifier: ImportDefaultSpecifier$1,
    ExportDefaultSpecifier: ExportDefaultSpecifier$1,
    ExportSpecifier: ExportSpecifier$1,
    ExportNamespaceSpecifier: ExportNamespaceSpecifier$1,
    ExportAllDeclaration: ExportAllDeclaration$1,
    ExportNamedDeclaration: ExportNamedDeclaration$1,
    ExportDefaultDeclaration: ExportDefaultDeclaration$1,
    ImportDeclaration: ImportDeclaration$1,
    ImportNamespaceSpecifier: ImportNamespaceSpecifier$1,
    Identifier: Identifier$1,
    ArgumentPlaceholder: ArgumentPlaceholder$1,
    RestElement: RestElement$1,
    SpreadElement: RestElement$1,
    ObjectExpression: ObjectExpression$2,
    ObjectPattern: ObjectExpression$2,
    ObjectMethod: ObjectMethod$1,
    ObjectProperty: ObjectProperty$1,
    ArrayExpression: ArrayExpression$1,
    ArrayPattern: ArrayExpression$1,
    RecordExpression: RecordExpression$1,
    TupleExpression: TupleExpression$1,
    RegExpLiteral: RegExpLiteral$1,
    BooleanLiteral: BooleanLiteral$1,
    NullLiteral: NullLiteral$1,
    NumericLiteral: NumericLiteral$1,
    StringLiteral: StringLiteral$1,
    BigIntLiteral: BigIntLiteral$1,
    PipelineTopicExpression: PipelineTopicExpression$1,
    PipelineBareFunction: PipelineBareFunction$1,
    PipelinePrimaryTopicReference: PipelinePrimaryTopicReference$1,
    AnyTypeAnnotation: AnyTypeAnnotation$1,
    ArrayTypeAnnotation: ArrayTypeAnnotation$1,
    BooleanTypeAnnotation: BooleanTypeAnnotation$1,
    BooleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation$1,
    NullLiteralTypeAnnotation: NullLiteralTypeAnnotation$1,
    DeclareClass: DeclareClass$1,
    DeclareFunction: DeclareFunction$1,
    InferredPredicate: InferredPredicate$1,
    DeclaredPredicate: DeclaredPredicate$1,
    DeclareInterface: DeclareInterface$1,
    DeclareModule: DeclareModule$1,
    DeclareModuleExports: DeclareModuleExports$1,
    DeclareTypeAlias: DeclareTypeAlias$1,
    DeclareOpaqueType: DeclareOpaqueType$1,
    DeclareVariable: DeclareVariable$1,
    DeclareExportDeclaration: DeclareExportDeclaration$1,
    DeclareExportAllDeclaration: DeclareExportAllDeclaration$1,
    EnumDeclaration: EnumDeclaration$1,
    EnumBooleanBody: EnumBooleanBody$1,
    EnumNumberBody: EnumNumberBody$1,
    EnumStringBody: EnumStringBody$1,
    EnumSymbolBody: EnumSymbolBody$1,
    EnumDefaultedMember: EnumDefaultedMember$1,
    EnumBooleanMember: EnumBooleanMember$1,
    EnumNumberMember: EnumNumberMember$1,
    EnumStringMember: EnumStringMember$1,
    ExistsTypeAnnotation: ExistsTypeAnnotation$1,
    FunctionTypeAnnotation: FunctionTypeAnnotation$2,
    FunctionTypeParam: FunctionTypeParam$1,
    InterfaceExtends: InterfaceExtends$1,
    ClassImplements: InterfaceExtends$1,
    GenericTypeAnnotation: InterfaceExtends$1,
    _interfaceish: _interfaceish,
    _variance: _variance,
    InterfaceDeclaration: InterfaceDeclaration$1,
    InterfaceTypeAnnotation: InterfaceTypeAnnotation$1,
    IntersectionTypeAnnotation: IntersectionTypeAnnotation$1,
    MixedTypeAnnotation: MixedTypeAnnotation$1,
    EmptyTypeAnnotation: EmptyTypeAnnotation$1,
    NullableTypeAnnotation: NullableTypeAnnotation$2,
    NumberTypeAnnotation: NumberTypeAnnotation$1,
    StringTypeAnnotation: StringTypeAnnotation$1,
    ThisTypeAnnotation: ThisTypeAnnotation$1,
    TupleTypeAnnotation: TupleTypeAnnotation$1,
    TypeofTypeAnnotation: TypeofTypeAnnotation$1,
    TypeAlias: TypeAlias$1,
    TypeAnnotation: TypeAnnotation$1,
    TypeParameterInstantiation: TypeParameterInstantiation$1,
    TypeParameterDeclaration: TypeParameterInstantiation$1,
    TypeParameter: TypeParameter$1,
    OpaqueType: OpaqueType$1,
    ObjectTypeAnnotation: ObjectTypeAnnotation$1,
    ObjectTypeInternalSlot: ObjectTypeInternalSlot$1,
    ObjectTypeCallProperty: ObjectTypeCallProperty$1,
    ObjectTypeIndexer: ObjectTypeIndexer$1,
    ObjectTypeProperty: ObjectTypeProperty$1,
    ObjectTypeSpreadProperty: ObjectTypeSpreadProperty$1,
    QualifiedTypeIdentifier: QualifiedTypeIdentifier$1,
    SymbolTypeAnnotation: SymbolTypeAnnotation$1,
    UnionTypeAnnotation: UnionTypeAnnotation$2,
    TypeCastExpression: TypeCastExpression$1,
    Variance: Variance$1,
    VoidTypeAnnotation: VoidTypeAnnotation$1,
    NumberLiteralTypeAnnotation: NumericLiteral$1,
    StringLiteralTypeAnnotation: StringLiteral$1,
    File: File$1,
    Program: Program$1,
    BlockStatement: BlockStatement$1,
    Noop: Noop$1,
    Directive: Directive$1,
    DirectiveLiteral: DirectiveLiteral$1,
    InterpreterDirective: InterpreterDirective$1,
    Placeholder: Placeholder$1,
    JSXAttribute: JSXAttribute$1,
    JSXIdentifier: JSXIdentifier$1,
    JSXNamespacedName: JSXNamespacedName$1,
    JSXMemberExpression: JSXMemberExpression$1,
    JSXSpreadAttribute: JSXSpreadAttribute$1,
    JSXExpressionContainer: JSXExpressionContainer$1,
    JSXSpreadChild: JSXSpreadChild$1,
    JSXText: JSXText$1,
    JSXElement: JSXElement$1,
    JSXOpeningElement: JSXOpeningElement$1,
    JSXClosingElement: JSXClosingElement$1,
    JSXEmptyExpression: JSXEmptyExpression$1,
    JSXFragment: JSXFragment$1,
    JSXOpeningFragment: JSXOpeningFragment$1,
    JSXClosingFragment: JSXClosingFragment$1,
    TSTypeAnnotation: TSTypeAnnotation$1,
    TSTypeParameterInstantiation: TSTypeParameterInstantiation$1,
    TSTypeParameterDeclaration: TSTypeParameterInstantiation$1,
    TSTypeParameter: TSTypeParameter$1,
    TSParameterProperty: TSParameterProperty$1,
    TSDeclareFunction: TSDeclareFunction$1,
    TSDeclareMethod: TSDeclareMethod$1,
    TSQualifiedName: TSQualifiedName$1,
    TSCallSignatureDeclaration: TSCallSignatureDeclaration$1,
    TSConstructSignatureDeclaration: TSConstructSignatureDeclaration$1,
    TSPropertySignature: TSPropertySignature$1,
    tsPrintPropertyOrMethodName: tsPrintPropertyOrMethodName,
    TSMethodSignature: TSMethodSignature$1,
    TSIndexSignature: TSIndexSignature$1,
    TSAnyKeyword: TSAnyKeyword$1,
    TSBigIntKeyword: TSBigIntKeyword$1,
    TSUnknownKeyword: TSUnknownKeyword$1,
    TSNumberKeyword: TSNumberKeyword$1,
    TSObjectKeyword: TSObjectKeyword$1,
    TSBooleanKeyword: TSBooleanKeyword$1,
    TSStringKeyword: TSStringKeyword$1,
    TSSymbolKeyword: TSSymbolKeyword$1,
    TSVoidKeyword: TSVoidKeyword$1,
    TSUndefinedKeyword: TSUndefinedKeyword$1,
    TSNullKeyword: TSNullKeyword$1,
    TSNeverKeyword: TSNeverKeyword$1,
    TSThisType: TSThisType$1,
    TSFunctionType: TSFunctionType$1,
    TSConstructorType: TSConstructorType$1,
    tsPrintFunctionOrConstructorType: tsPrintFunctionOrConstructorType,
    TSTypeReference: TSTypeReference$1,
    TSTypePredicate: TSTypePredicate$1,
    TSTypeQuery: TSTypeQuery$1,
    TSTypeLiteral: TSTypeLiteral$1,
    tsPrintTypeLiteralOrInterfaceBody: tsPrintTypeLiteralOrInterfaceBody,
    tsPrintBraced: tsPrintBraced,
    TSArrayType: TSArrayType$1,
    TSTupleType: TSTupleType$1,
    TSOptionalType: TSOptionalType$1,
    TSRestType: TSRestType$1,
    TSUnionType: TSUnionType$2,
    TSIntersectionType: TSIntersectionType$1,
    tsPrintUnionOrIntersectionType: tsPrintUnionOrIntersectionType,
    TSConditionalType: TSConditionalType$1,
    TSInferType: TSInferType$2,
    TSParenthesizedType: TSParenthesizedType$1,
    TSTypeOperator: TSTypeOperator$1,
    TSIndexedAccessType: TSIndexedAccessType$1,
    TSMappedType: TSMappedType$1,
    TSLiteralType: TSLiteralType$1,
    TSExpressionWithTypeArguments: TSExpressionWithTypeArguments$1,
    TSInterfaceDeclaration: TSInterfaceDeclaration$1,
    TSInterfaceBody: TSInterfaceBody$1,
    TSTypeAliasDeclaration: TSTypeAliasDeclaration$1,
    TSAsExpression: TSAsExpression$2,
    TSTypeAssertion: TSTypeAssertion$2,
    TSEnumDeclaration: TSEnumDeclaration$1,
    TSEnumMember: TSEnumMember$1,
    TSModuleDeclaration: TSModuleDeclaration$1,
    TSModuleBlock: TSModuleBlock$1,
    TSImportType: TSImportType$1,
    TSImportEqualsDeclaration: TSImportEqualsDeclaration$1,
    TSExternalModuleReference: TSExternalModuleReference$1,
    TSNonNullExpression: TSNonNullExpression$1,
    TSExportAssignment: TSExportAssignment$1,
    TSNamespaceExportDeclaration: TSNamespaceExportDeclaration$1,
    tsPrintSignatureDeclarationBase: tsPrintSignatureDeclarationBase,
    tsPrintClassMemberModifiers: tsPrintClassMemberModifiers
  });

  var SCIENTIFIC_NOTATION = /e/i;
  var ZERO_DECIMAL_INTEGER = /\.0+$/;
  var NON_DECIMAL_LITERAL = /^0[box]/;
  var PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;

  var Printer = function () {
    function Printer(format, map) {
      this.inForStatementInitCounter = 0;
      this._printStack = [];
      this._indent = 0;
      this._insideAux = false;
      this._printedCommentStarts = {};
      this._parenPushNewlineState = null;
      this._noLineTerminator = false;
      this._printAuxAfterOnNextUserNode = false;
      this._printedComments = new WeakSet();
      this._endsWithInteger = false;
      this._endsWithWord = false;
      this.format = format || {};
      this._buf = new Buffer(map);
    }

    var _proto = Printer.prototype;

    _proto.generate = function generate(ast) {
      this.print(ast);

      this._maybeAddAuxComment();

      return this._buf.get();
    };

    _proto.indent = function indent() {
      if (this.format.compact || this.format.concise) return;
      this._indent++;
    };

    _proto.dedent = function dedent() {
      if (this.format.compact || this.format.concise) return;
      this._indent--;
    };

    _proto.semicolon = function semicolon(force) {
      if (force === void 0) {
        force = false;
      }

      this._maybeAddAuxComment();

      this._append(";", !force);
    };

    _proto.rightBrace = function rightBrace() {
      if (this.format.minified) {
        this._buf.removeLastSemicolon();
      }

      this.token("}");
    };

    _proto.space = function space(force) {
      if (force === void 0) {
        force = false;
      }

      if (this.format.compact) return;

      if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) {
        this._space();
      }
    };

    _proto.word = function word(str) {
      if (this._endsWithWord || this.endsWith("/") && str.indexOf("/") === 0) {
        this._space();
      }

      this._maybeAddAuxComment();

      this._append(str);

      this._endsWithWord = true;
    };

    _proto.number = function number(str) {
      this.word(str);
      this._endsWithInteger = isInteger_1(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";
    };

    _proto.token = function token(str) {
      if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {
        this._space();
      }

      this._maybeAddAuxComment();

      this._append(str);
    };

    _proto.newline = function newline(i) {
      if (this.format.retainLines || this.format.compact) return;

      if (this.format.concise) {
        this.space();
        return;
      }

      if (this.endsWith("\n\n")) return;
      if (typeof i !== "number") i = 1;
      i = Math.min(2, i);
      if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
      if (i <= 0) return;

      for (var j = 0; j < i; j++) {
        this._newline();
      }
    };

    _proto.endsWith = function endsWith(str) {
      return this._buf.endsWith(str);
    };

    _proto.removeTrailingNewline = function removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    };

    _proto.exactSource = function exactSource(loc, cb) {
      this._catchUp("start", loc);

      this._buf.exactSource(loc, cb);
    };

    _proto.source = function source(prop, loc) {
      this._catchUp(prop, loc);

      this._buf.source(prop, loc);
    };

    _proto.withSource = function withSource(prop, loc, cb) {
      this._catchUp(prop, loc);

      this._buf.withSource(prop, loc, cb);
    };

    _proto._space = function _space() {
      this._append(" ", true);
    };

    _proto._newline = function _newline() {
      this._append("\n", true);
    };

    _proto._append = function _append(str, queue) {
      if (queue === void 0) {
        queue = false;
      }

      this._maybeAddParen(str);

      this._maybeIndent(str);

      if (queue) this._buf.queue(str);else this._buf.append(str);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    };

    _proto._maybeIndent = function _maybeIndent(str) {
      if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
        this._buf.queue(this._getIndent());
      }
    };

    _proto._maybeAddParen = function _maybeAddParen(str) {
      var parenPushNewlineState = this._parenPushNewlineState;
      if (!parenPushNewlineState) return;
      var i;

      for (i = 0; i < str.length && str[i] === " "; i++) {
        continue;
      }

      if (i === str.length) {
        return;
      }

      var cha = str[i];

      if (cha !== "\n") {
        if (cha !== "/" || i + 1 === str.length) {
          this._parenPushNewlineState = null;
          return;
        }

        var chaPost = str[i + 1];

        if (chaPost === "*") {
          if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {
            return;
          }
        } else if (chaPost !== "/") {
          this._parenPushNewlineState = null;
          return;
        }
      }

      this.token("(");
      this.indent();
      parenPushNewlineState.printed = true;
    };

    _proto._catchUp = function _catchUp(prop, loc) {
      if (!this.format.retainLines) return;
      var pos = loc ? loc[prop] : null;

      if (pos && pos.line !== null) {
        var count = pos.line - this._buf.getCurrentLine();

        for (var i = 0; i < count; i++) {
          this._newline();
        }
      }
    };

    _proto._getIndent = function _getIndent() {
      return repeat_1(this.format.indent.style, this._indent);
    };

    _proto.startTerminatorless = function startTerminatorless(isLabel) {
      if (isLabel === void 0) {
        isLabel = false;
      }

      if (isLabel) {
        this._noLineTerminator = true;
        return null;
      } else {
        return this._parenPushNewlineState = {
          printed: false
        };
      }
    };

    _proto.endTerminatorless = function endTerminatorless(state) {
      this._noLineTerminator = false;

      if (state && state.printed) {
        this.dedent();
        this.newline();
        this.token(")");
      }
    };

    _proto.print = function print(node, parent) {
      var _this = this;

      if (!node) return;
      var oldConcise = this.format.concise;

      if (node._compact) {
        this.format.concise = true;
      }

      var printMethod = this[node.type];

      if (!printMethod) {
        throw new ReferenceError("unknown node of type " + JSON.stringify(node.type) + " with constructor " + JSON.stringify(node && node.constructor.name));
      }

      this._printStack.push(node);

      var oldInAux = this._insideAux;
      this._insideAux = !node.loc;

      this._maybeAddAuxComment(this._insideAux && !oldInAux);

      var needsParens$1 = needsParens(node, parent, this._printStack);

      if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
        needsParens$1 = true;
      }

      if (needsParens$1) this.token("(");

      this._printLeadingComments(node);

      var loc = isProgram(node) || isFile(node) ? null : node.loc;
      this.withSource("start", loc, function () {
        printMethod.call(_this, node, parent);
      });

      this._printTrailingComments(node);

      if (needsParens$1) this.token(")");

      this._printStack.pop();

      this.format.concise = oldConcise;
      this._insideAux = oldInAux;
    };

    _proto._maybeAddAuxComment = function _maybeAddAuxComment(enteredPositionlessNode) {
      if (enteredPositionlessNode) this._printAuxBeforeComment();
      if (!this._insideAux) this._printAuxAfterComment();
    };

    _proto._printAuxBeforeComment = function _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = true;
      var comment = this.format.auxiliaryCommentBefore;

      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        });
      }
    };

    _proto._printAuxAfterComment = function _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = false;
      var comment = this.format.auxiliaryCommentAfter;

      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        });
      }
    };

    _proto.getPossibleRaw = function getPossibleRaw(node) {
      var extra = node.extra;

      if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
        return extra.raw;
      }
    };

    _proto.printJoin = function printJoin(nodes, parent, opts) {
      if (opts === void 0) {
        opts = {};
      }

      if (!nodes || !nodes.length) return;
      if (opts.indent) this.indent();
      var newlineOpts = {
        addNewlines: opts.addNewlines
      };

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (!node) continue;
        if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
        this.print(node, parent);

        if (opts.iterator) {
          opts.iterator(node, i);
        }

        if (opts.separator && i < nodes.length - 1) {
          opts.separator.call(this);
        }

        if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
      }

      if (opts.indent) this.dedent();
    };

    _proto.printAndIndentOnComments = function printAndIndentOnComments(node, parent) {
      var indent = node.leadingComments && node.leadingComments.length > 0;
      if (indent) this.indent();
      this.print(node, parent);
      if (indent) this.dedent();
    };

    _proto.printBlock = function printBlock(parent) {
      var node = parent.body;

      if (!isEmptyStatement(node)) {
        this.space();
      }

      this.print(node, parent);
    };

    _proto._printTrailingComments = function _printTrailingComments(node) {
      this._printComments(this._getComments(false, node));
    };

    _proto._printLeadingComments = function _printLeadingComments(node) {
      this._printComments(this._getComments(true, node), true);
    };

    _proto.printInnerComments = function printInnerComments(node, indent) {
      if (indent === void 0) {
        indent = true;
      }

      if (!node.innerComments || !node.innerComments.length) return;
      if (indent) this.indent();

      this._printComments(node.innerComments);

      if (indent) this.dedent();
    };

    _proto.printSequence = function printSequence(nodes, parent, opts) {
      if (opts === void 0) {
        opts = {};
      }

      opts.statement = true;
      return this.printJoin(nodes, parent, opts);
    };

    _proto.printList = function printList(items, parent, opts) {
      if (opts === void 0) {
        opts = {};
      }

      if (opts.separator == null) {
        opts.separator = commaSeparator;
      }

      return this.printJoin(items, parent, opts);
    };

    _proto._printNewline = function _printNewline(leading, node, parent, opts) {
      if (this.format.retainLines || this.format.compact) return;

      if (this.format.concise) {
        this.space();
        return;
      }

      var lines = 0;

      if (this._buf.hasContent()) {
        if (!leading) lines++;
        if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
        var needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;
        if (needs(node, parent)) lines++;
      }

      this.newline(lines);
    };

    _proto._getComments = function _getComments(leading, node) {
      return node && (leading ? node.leadingComments : node.trailingComments) || [];
    };

    _proto._printComment = function _printComment(comment, skipNewLines) {
      var _this2 = this;

      if (!this.format.shouldPrintComment(comment.value)) return;
      if (comment.ignore) return;
      if (this._printedComments.has(comment)) return;

      this._printedComments.add(comment);

      if (comment.start != null) {
        if (this._printedCommentStarts[comment.start]) return;
        this._printedCommentStarts[comment.start] = true;
      }

      var isBlockComment = comment.type === "CommentBlock";
      var printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;
      if (printNewLines && this._buf.hasContent()) this.newline(1);
      if (!this.endsWith("[") && !this.endsWith("{")) this.space();
      var val = !isBlockComment && !this._noLineTerminator ? "//" + comment.value + "\n" : "/*" + comment.value + "*/";

      if (isBlockComment && this.format.indent.adjustMultilineComment) {
        var offset = comment.loc && comment.loc.start.column;

        if (offset) {
          var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
          val = val.replace(newlineRegex, "\n");
        }

        var indentSize = Math.max(this._getIndent().length, this._buf.getCurrentColumn());
        val = val.replace(/\n(?!$)/g, "\n" + repeat_1(" ", indentSize));
      }

      if (this.endsWith("/")) this._space();
      this.withSource("start", comment.loc, function () {
        _this2._append(val);
      });
      if (printNewLines) this.newline(1);
    };

    _proto._printComments = function _printComments(comments, inlinePureAnnotation) {
      if (!comments || !comments.length) return;

      if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {
        this._printComment(comments[0], this._buf.hasContent() && !this.endsWith("\n"));
      } else {
        for (var _iterator = comments, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var _comment = _ref;

          this._printComment(_comment);
        }
      }
    };

    return Printer;
  }();
  Object.assign(Printer.prototype, generatorFunctions);

  function commaSeparator() {
    this.token(",");
    this.space();
  }

  var Generator = function (_Printer) {
    _inheritsLoose(Generator, _Printer);

    function Generator(ast, opts, code) {
      var _this;

      if (opts === void 0) {
        opts = {};
      }

      var format = normalizeOptions(code, opts);
      var map = opts.sourceMaps ? new SourceMap(opts, code) : null;
      _this = _Printer.call(this, format, map) || this;
      _this.ast = ast;
      return _this;
    }

    var _proto = Generator.prototype;

    _proto.generate = function generate() {
      return _Printer.prototype.generate.call(this, this.ast);
    };

    return Generator;
  }(Printer);

  function normalizeOptions(code, opts) {
    var format = {
      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
      shouldPrintComment: opts.shouldPrintComment,
      retainLines: opts.retainLines,
      retainFunctionParens: opts.retainFunctionParens,
      comments: opts.comments == null || opts.comments,
      compact: opts.compact,
      minified: opts.minified,
      concise: opts.concise,
      jsonCompatibleStrings: opts.jsonCompatibleStrings,
      indent: {
        adjustMultilineComment: true,
        style: "  ",
        base: 0
      },
      decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
      jsescOption: Object.assign({
        quotes: "double",
        wrap: true
      }, opts.jsescOption),
      recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType
    };

    if (format.minified) {
      format.compact = true;

      format.shouldPrintComment = format.shouldPrintComment || function () {
        return format.comments;
      };
    } else {
      format.shouldPrintComment = format.shouldPrintComment || function (value) {
        return format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0;
      };
    }

    if (format.compact === "auto") {
      format.compact = code.length > 500000;

      if (format.compact) {
        console.error("[BABEL] Note: The code generator has deoptimised the styling of " + (opts.filename + " as it exceeds the max of " + "500KB" + "."));
      }
    }

    if (format.compact) {
      format.indent.adjustMultilineComment = false;
    }

    return format;
  }
  function generateCode (ast, opts, code) {
    var gen = new Generator(ast, opts, code);
    return gen.generate();
  }

  function findParent(callback) {
    var path = this;

    while (path = path.parentPath) {
      if (callback(path)) return path;
    }

    return null;
  }
  function find$1(callback) {
    var path = this;

    do {
      if (callback(path)) return path;
    } while (path = path.parentPath);

    return null;
  }
  function getFunctionParent() {
    return this.findParent(function (p) {
      return p.isFunction();
    });
  }
  function getStatementParent() {
    var path = this;

    do {
      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
        break;
      } else {
        path = path.parentPath;
      }
    } while (path);

    if (path && (path.isProgram() || path.isFile())) {
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    }

    return path;
  }
  function getEarliestCommonAncestorFrom(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
      var earliest;
      var keys = VISITOR_KEYS[deepest.type];

      for (var _i = 0, _arr = ancestries; _i < _arr.length; _i++) {
        var ancestry = _arr[_i];
        var path = ancestry[i + 1];

        if (!earliest) {
          earliest = path;
          continue;
        }

        if (path.listKey && earliest.listKey === path.listKey) {
          if (path.key < earliest.key) {
            earliest = path;
            continue;
          }
        }

        var earliestKeyIndex = keys.indexOf(earliest.parentKey);
        var currentKeyIndex = keys.indexOf(path.parentKey);

        if (earliestKeyIndex > currentKeyIndex) {
          earliest = path;
        }
      }

      return earliest;
    });
  }
  function getDeepestCommonAncestorFrom(paths, filter) {
    var _this = this;

    if (!paths.length) {
      return this;
    }

    if (paths.length === 1) {
      return paths[0];
    }

    var minDepth = Infinity;
    var lastCommonIndex, lastCommon;
    var ancestries = paths.map(function (path) {
      var ancestry = [];

      do {
        ancestry.unshift(path);
      } while ((path = path.parentPath) && path !== _this);

      if (ancestry.length < minDepth) {
        minDepth = ancestry.length;
      }

      return ancestry;
    });
    var first = ancestries[0];

    depthLoop: for (var i = 0; i < minDepth; i++) {
      var shouldMatch = first[i];

      for (var _i2 = 0, _arr2 = ancestries; _i2 < _arr2.length; _i2++) {
        var ancestry = _arr2[_i2];

        if (ancestry[i] !== shouldMatch) {
          break depthLoop;
        }
      }

      lastCommonIndex = i;
      lastCommon = shouldMatch;
    }

    if (lastCommon) {
      if (filter) {
        return filter(lastCommon, lastCommonIndex, ancestries);
      } else {
        return lastCommon;
      }
    } else {
      throw new Error("Couldn't find intersection");
    }
  }
  function getAncestry() {
    var path = this;
    var paths = [];

    do {
      paths.push(path);
    } while (path = path.parentPath);

    return paths;
  }
  function isAncestor(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
  }
  function isDescendant(maybeAncestor) {
    return !!this.findParent(function (parent) {
      return parent === maybeAncestor;
    });
  }
  function inType() {
    var path = this;

    while (path) {
      for (var _i3 = 0, _arr3 = arguments; _i3 < _arr3.length; _i3++) {
        var type = _arr3[_i3];
        if (path.node.type === type) return true;
      }

      path = path.parentPath;
    }

    return false;
  }

  var NodePath_ancestry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    findParent: findParent,
    find: find$1,
    getFunctionParent: getFunctionParent,
    getStatementParent: getStatementParent,
    getEarliestCommonAncestorFrom: getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: getDeepestCommonAncestorFrom,
    getAncestry: getAncestry,
    isAncestor: isAncestor,
    isDescendant: isDescendant,
    inType: inType
  });

  function infererReference (node) {
    if (!this.isReferenced()) return;
    var binding = this.scope.getBinding(node.name);

    if (binding) {
      if (binding.identifier.typeAnnotation) {
        return binding.identifier.typeAnnotation;
      } else {
        return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
      }
    }

    if (node.name === "undefined") {
      return VoidTypeAnnotation();
    } else if (node.name === "NaN" || node.name === "Infinity") {
      return NumberTypeAnnotation();
    } else if (node.name === "arguments") ;
  }

  function getTypeAnnotationBindingConstantViolations(binding, path, name) {
    var types = [];
    var functionConstantViolations = [];
    var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
    var testType = getConditionalAnnotation(binding, path, name);

    if (testType) {
      var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
      constantViolations = constantViolations.filter(function (path) {
        return testConstantViolations.indexOf(path) < 0;
      });
      types.push(testType.typeAnnotation);
    }

    if (constantViolations.length) {
      constantViolations = constantViolations.concat(functionConstantViolations);

      for (var _i = 0, _arr = constantViolations; _i < _arr.length; _i++) {
        var violation = _arr[_i];
        types.push(violation.getTypeAnnotation());
      }
    }

    if (types.length) {
      return createUnionTypeAnnotation(types);
    }
  }

  function getConstantViolationsBefore(binding, path, functions) {
    var violations = binding.constantViolations.slice();
    violations.unshift(binding.path);
    return violations.filter(function (violation) {
      violation = violation.resolve();

      var status = violation._guessExecutionStatusRelativeTo(path);

      if (functions && status === "unknown") functions.push(violation);
      return status === "before";
    });
  }

  function inferAnnotationFromBinaryExpression(name, path) {
    var operator = path.node.operator;
    var right = path.get("right").resolve();
    var left = path.get("left").resolve();
    var target;

    if (left.isIdentifier({
      name: name
    })) {
      target = right;
    } else if (right.isIdentifier({
      name: name
    })) {
      target = left;
    }

    if (target) {
      if (operator === "===") {
        return target.getTypeAnnotation();
      }

      if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return NumberTypeAnnotation();
      }

      return;
    }

    if (operator !== "===" && operator !== "==") return;
    var typeofPath;
    var typePath;

    if (left.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = left;
      typePath = right;
    } else if (right.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = right;
      typePath = left;
    }

    if (!typeofPath) return;
    if (!typeofPath.get("argument").isIdentifier({
      name: name
    })) return;
    typePath = typePath.resolve();
    if (!typePath.isLiteral()) return;
    var typeValue = typePath.node.value;
    if (typeof typeValue !== "string") return;
    return createTypeAnnotationBasedOnTypeof(typeValue);
  }

  function getParentConditionalPath(binding, path, name) {
    var parentPath;

    while (parentPath = path.parentPath) {
      if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
        if (path.key === "test") {
          return;
        }

        return parentPath;
      }

      if (parentPath.isFunction()) {
        if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
      }

      path = parentPath;
    }
  }

  function getConditionalAnnotation(binding, path, name) {
    var ifStatement = getParentConditionalPath(binding, path, name);
    if (!ifStatement) return;
    var test = ifStatement.get("test");
    var paths = [test];
    var types = [];

    for (var i = 0; i < paths.length; i++) {
      var _path = paths[i];

      if (_path.isLogicalExpression()) {
        if (_path.node.operator === "&&") {
          paths.push(_path.get("left"));
          paths.push(_path.get("right"));
        }
      } else if (_path.isBinaryExpression()) {
        var type = inferAnnotationFromBinaryExpression(name, _path);
        if (type) types.push(type);
      }
    }

    if (types.length) {
      return {
        typeAnnotation: createUnionTypeAnnotation(types),
        ifStatement: ifStatement
      };
    }

    return getConditionalAnnotation(ifStatement, name);
  }

  function VariableDeclarator$2() {
    var id = this.get("id");
    if (!id.isIdentifier()) return;
    var init = this.get("init");
    var type = init.getTypeAnnotation();

    if (type && type.type === "AnyTypeAnnotation") {
      if (init.isCallExpression() && init.get("callee").isIdentifier({
        name: "Array"
      }) && !init.scope.hasBinding("Array", true)) {
        type = ArrayExpression$2();
      }
    }

    return type;
  }
  function TypeCastExpression$2(node) {
    return node.typeAnnotation;
  }
  TypeCastExpression$2.validParent = true;
  function NewExpression$2(node) {
    if (this.get("callee").isIdentifier()) {
      return GenericTypeAnnotation(node.callee);
    }
  }
  function TemplateLiteral$2() {
    return StringTypeAnnotation();
  }
  function UnaryExpression$2(node) {
    var operator = node.operator;

    if (operator === "void") {
      return VoidTypeAnnotation();
    } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return NumberTypeAnnotation();
    } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return StringTypeAnnotation();
    } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return BooleanTypeAnnotation();
    }
  }
  function BinaryExpression$2(node) {
    var operator = node.operator;

    if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return NumberTypeAnnotation();
    } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return BooleanTypeAnnotation();
    } else if (operator === "+") {
      var right = this.get("right");
      var left = this.get("left");

      if (left.isBaseType("number") && right.isBaseType("number")) {
        return NumberTypeAnnotation();
      } else if (left.isBaseType("string") || right.isBaseType("string")) {
        return StringTypeAnnotation();
      }

      return UnionTypeAnnotation([StringTypeAnnotation(), NumberTypeAnnotation()]);
    }
  }
  function LogicalExpression$2() {
    return createUnionTypeAnnotation([this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()]);
  }
  function ConditionalExpression$3() {
    return createUnionTypeAnnotation([this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()]);
  }
  function SequenceExpression$3() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  function ParenthesizedExpression$2() {
    return this.get("expression").getTypeAnnotation();
  }
  function AssignmentExpression$3() {
    return this.get("right").getTypeAnnotation();
  }
  function UpdateExpression$3(node) {
    var operator = node.operator;

    if (operator === "++" || operator === "--") {
      return NumberTypeAnnotation();
    }
  }
  function StringLiteral$2() {
    return StringTypeAnnotation();
  }
  function NumericLiteral$2() {
    return NumberTypeAnnotation();
  }
  function BooleanLiteral$2() {
    return BooleanTypeAnnotation();
  }
  function NullLiteral$2() {
    return NullLiteralTypeAnnotation();
  }
  function RegExpLiteral$2() {
    return GenericTypeAnnotation(Identifier("RegExp"));
  }
  function ObjectExpression$3() {
    return GenericTypeAnnotation(Identifier("Object"));
  }
  function ArrayExpression$2() {
    return GenericTypeAnnotation(Identifier("Array"));
  }
  function RestElement$2() {
    return ArrayExpression$2();
  }
  RestElement$2.validParent = true;

  function Func() {
    return GenericTypeAnnotation(Identifier("Function"));
  }
  var isArrayFrom = buildMatchMemberExpression("Array.from");
  var isObjectKeys = buildMatchMemberExpression("Object.keys");
  var isObjectValues = buildMatchMemberExpression("Object.values");
  var isObjectEntries = buildMatchMemberExpression("Object.entries");
  function CallExpression$2() {
    var callee = this.node.callee;

    if (isObjectKeys(callee)) {
      return ArrayTypeAnnotation(StringTypeAnnotation());
    } else if (isArrayFrom(callee) || isObjectValues(callee)) {
      return ArrayTypeAnnotation(AnyTypeAnnotation());
    } else if (isObjectEntries(callee)) {
      return ArrayTypeAnnotation(TupleTypeAnnotation([StringTypeAnnotation(), AnyTypeAnnotation()]));
    }

    return resolveCall(this.get("callee"));
  }
  function TaggedTemplateExpression$2() {
    return resolveCall(this.get("tag"));
  }

  function resolveCall(callee) {
    callee = callee.resolve();

    if (callee.isFunction()) {
      if (callee.is("async")) {
        if (callee.is("generator")) {
          return GenericTypeAnnotation(Identifier("AsyncIterator"));
        } else {
          return GenericTypeAnnotation(Identifier("Promise"));
        }
      } else {
        if (callee.node.returnType) {
          return callee.node.returnType;
        }
      }
    }
  }

  var inferers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    VariableDeclarator: VariableDeclarator$2,
    TypeCastExpression: TypeCastExpression$2,
    NewExpression: NewExpression$2,
    TemplateLiteral: TemplateLiteral$2,
    UnaryExpression: UnaryExpression$2,
    BinaryExpression: BinaryExpression$2,
    LogicalExpression: LogicalExpression$2,
    ConditionalExpression: ConditionalExpression$3,
    SequenceExpression: SequenceExpression$3,
    ParenthesizedExpression: ParenthesizedExpression$2,
    AssignmentExpression: AssignmentExpression$3,
    UpdateExpression: UpdateExpression$3,
    StringLiteral: StringLiteral$2,
    NumericLiteral: NumericLiteral$2,
    BooleanLiteral: BooleanLiteral$2,
    NullLiteral: NullLiteral$2,
    RegExpLiteral: RegExpLiteral$2,
    ObjectExpression: ObjectExpression$3,
    ArrayExpression: ArrayExpression$2,
    RestElement: RestElement$2,
    FunctionExpression: Func,
    ArrowFunctionExpression: Func,
    FunctionDeclaration: Func,
    ClassExpression: Func,
    ClassDeclaration: Func,
    CallExpression: CallExpression$2,
    TaggedTemplateExpression: TaggedTemplateExpression$2,
    Identifier: infererReference
  });

  function getTypeAnnotation() {
    if (this.typeAnnotation) return this.typeAnnotation;
    var type = this._getTypeAnnotation() || AnyTypeAnnotation();
    if (isTypeAnnotation(type)) type = type.typeAnnotation;
    return this.typeAnnotation = type;
  }
  function _getTypeAnnotation() {
    var node = this.node;

    if (!node) {
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        var declar = this.parentPath.parentPath;
        var declarParent = declar.parentPath;

        if (declar.key === "left" && declarParent.isForInStatement()) {
          return StringTypeAnnotation();
        }

        if (declar.key === "left" && declarParent.isForOfStatement()) {
          return AnyTypeAnnotation();
        }

        return VoidTypeAnnotation();
      } else {
        return;
      }
    }

    if (node.typeAnnotation) {
      return node.typeAnnotation;
    }

    var inferer = inferers[node.type];

    if (inferer) {
      return inferer.call(this, node);
    }

    inferer = inferers[this.parentPath.type];

    if (inferer && inferer.validParent) {
      return this.parentPath.getTypeAnnotation();
    }
  }
  function isBaseType(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
  }

  function _isBaseType(baseName, type, soft) {
    if (baseName === "string") {
      return isStringTypeAnnotation(type);
    } else if (baseName === "number") {
      return isNumberTypeAnnotation(type);
    } else if (baseName === "boolean") {
      return isBooleanTypeAnnotation(type);
    } else if (baseName === "any") {
      return isAnyTypeAnnotation(type);
    } else if (baseName === "mixed") {
      return isMixedTypeAnnotation(type);
    } else if (baseName === "empty") {
      return isEmptyTypeAnnotation(type);
    } else if (baseName === "void") {
      return isVoidTypeAnnotation(type);
    } else {
      if (soft) {
        return false;
      } else {
        throw new Error("Unknown base type " + baseName);
      }
    }
  }

  function couldBeBaseType(name) {
    var type = this.getTypeAnnotation();
    if (isAnyTypeAnnotation(type)) return true;

    if (isUnionTypeAnnotation(type)) {
      for (var _i = 0, _arr = type.types; _i < _arr.length; _i++) {
        var type2 = _arr[_i];

        if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
          return true;
        }
      }

      return false;
    } else {
      return _isBaseType(name, type, true);
    }
  }
  function baseTypeStrictlyMatches(right) {
    var left = this.getTypeAnnotation();
    right = right.getTypeAnnotation();

    if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
      return right.type === left.type;
    }
  }
  function isGenericType(genericName) {
    var type = this.getTypeAnnotation();
    return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
      name: genericName
    });
  }

  var NodePath_inference = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getTypeAnnotation: getTypeAnnotation,
    _getTypeAnnotation: _getTypeAnnotation,
    isBaseType: isBaseType,
    couldBeBaseType: couldBeBaseType,
    baseTypeStrictlyMatches: baseTypeStrictlyMatches,
    isGenericType: isGenericType
  });

  var jsTokens = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

  exports.matchToToken = function (match) {
    var token = {
      type: "invalid",
      value: match[0],
      closed: undefined
    };
    if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = "comment";else if (match[6]) token.type = "comment", token.closed = !!match[7];else if (match[8]) token.type = "regex";else if (match[9]) token.type = "number";else if (match[10]) token.type = "name";else if (match[11]) token.type = "punctuator";else if (match[12]) token.type = "whitespace";
    return token;
  };
  });

  var jsTokens$1 = unwrapExports(jsTokens);
  var jsTokens_1 = jsTokens.matchToToken;

  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

  var escapeStringRegexp = function (str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string');
    }

    return str.replace(matchOperatorsRe, '\\$&');
  };

  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };

  var conversions = createCommonjsModule(function (module) {
  var reverseKeywords = {};

  for (var key in colorName) {
    if (colorName.hasOwnProperty(key)) {
      reverseKeywords[colorName[key]] = key;
    }
  }

  var convert = module.exports = {
    rgb: {
      channels: 3,
      labels: 'rgb'
    },
    hsl: {
      channels: 3,
      labels: 'hsl'
    },
    hsv: {
      channels: 3,
      labels: 'hsv'
    },
    hwb: {
      channels: 3,
      labels: 'hwb'
    },
    cmyk: {
      channels: 4,
      labels: 'cmyk'
    },
    xyz: {
      channels: 3,
      labels: 'xyz'
    },
    lab: {
      channels: 3,
      labels: 'lab'
    },
    lch: {
      channels: 3,
      labels: 'lch'
    },
    hex: {
      channels: 1,
      labels: ['hex']
    },
    keyword: {
      channels: 1,
      labels: ['keyword']
    },
    ansi16: {
      channels: 1,
      labels: ['ansi16']
    },
    ansi256: {
      channels: 1,
      labels: ['ansi256']
    },
    hcg: {
      channels: 3,
      labels: ['h', 'c', 'g']
    },
    apple: {
      channels: 3,
      labels: ['r16', 'g16', 'b16']
    },
    gray: {
      channels: 1,
      labels: ['gray']
    }
  };

  for (var model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!('channels' in convert[model])) {
        throw new Error('missing channels property: ' + model);
      }

      if (!('labels' in convert[model])) {
        throw new Error('missing channel labels property: ' + model);
      }

      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error('channel and label counts mismatch: ' + model);
      }

      var channels = convert[model].channels;
      var labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], 'channels', {
        value: channels
      });
      Object.defineProperty(convert[model], 'labels', {
        value: labels
      });
    }
  }

  convert.rgb.hsl = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    var s;
    var l;

    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }

    h = Math.min(h * 60, 360);

    if (h < 0) {
      h += 360;
    }

    l = (min + max) / 2;

    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }

    return [h, s * 100, l * 100];
  };

  convert.rgb.hsv = function (rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);

    var diffc = function diffc(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };

    if (diff === 0) {
      h = s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);

      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }

      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }

    return [h * 360, s * 100, v * 100];
  };

  convert.rgb.hwb = function (rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };

  convert.rgb.cmyk = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };

  function comparativeDistance(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  }

  convert.rgb.keyword = function (rgb) {
    var reversed = reverseKeywords[rgb];

    if (reversed) {
      return reversed;
    }

    var currentClosestDistance = Infinity;
    var currentClosestKeyword;

    for (var keyword in colorName) {
      if (colorName.hasOwnProperty(keyword)) {
        var value = colorName[keyword];
        var distance = comparativeDistance(rgb, value);

        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }

    return currentClosestKeyword;
  };

  convert.keyword.rgb = function (keyword) {
    return colorName[keyword];
  };

  convert.rgb.xyz = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };

  convert.rgb.lab = function (rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };

  convert.hsl.rgb = function (hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;

    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }

    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }

    t1 = 2 * l - t2;
    rgb = [0, 0, 0];

    for (var i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);

      if (t3 < 0) {
        t3++;
      }

      if (t3 > 1) {
        t3--;
      }

      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }

      rgb[i] = val * 255;
    }

    return rgb;
  };

  convert.hsl.hsv = function (hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };

  convert.hsv.rgb = function (hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;

    switch (hi) {
      case 0:
        return [v, t, p];

      case 1:
        return [q, v, p];

      case 2:
        return [p, v, t];

      case 3:
        return [p, q, v];

      case 4:
        return [t, p, v];

      case 5:
        return [v, p, q];
    }
  };

  convert.hsv.hsl = function (hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };

  convert.hwb.rgb = function (hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n;

    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }

    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;

    if ((i & 0x01) !== 0) {
      f = 1 - f;
    }

    n = wh + f * (v - wh);
    var r;
    var g;
    var b;

    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;

      case 1:
        r = n;
        g = v;
        b = wh;
        break;

      case 2:
        r = wh;
        g = v;
        b = n;
        break;

      case 3:
        r = wh;
        g = n;
        b = v;
        break;

      case 4:
        r = n;
        g = wh;
        b = v;
        break;

      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }

    return [r * 255, g * 255, b * 255];
  };

  convert.cmyk.rgb = function (cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };

  convert.xyz.rgb = function (xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };

  convert.xyz.lab = function (xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };

  convert.lab.xyz = function (lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };

  convert.lab.lch = function (lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h;
    var c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;

    if (h < 0) {
      h += 360;
    }

    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };

  convert.lch.lab = function (lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var a;
    var b;
    var hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };

  convert.rgb.ansi16 = function (args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
    value = Math.round(value / 50);

    if (value === 0) {
      return 30;
    }

    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

    if (value === 2) {
      ansi += 60;
    }

    return ansi;
  };

  convert.hsv.ansi16 = function (args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };

  convert.rgb.ansi256 = function (args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];

    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }

      if (r > 248) {
        return 231;
      }

      return Math.round((r - 8) / 247 * 24) + 232;
    }

    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };

  convert.ansi16.rgb = function (args) {
    var color = args % 10;

    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }

      color = color / 10.5 * 255;
      return [color, color, color];
    }

    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };

  convert.ansi256.rgb = function (args) {
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }

    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };

  convert.rgb.hex = function (args) {
    var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    var string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert.hex.rgb = function (args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

    if (!match) {
      return [0, 0, 0];
    }

    var colorString = match[0];

    if (match[0].length === 3) {
      colorString = colorString.split('').map(function (_char) {
        return _char + _char;
      }).join('');
    }

    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 0xFF;
    var g = integer >> 8 & 0xFF;
    var b = integer & 0xFF;
    return [r, g, b];
  };

  convert.rgb.hcg = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale;
    var hue;

    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }

    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }

    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };

  convert.hsl.hcg = function (hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;

    if (l < 0.5) {
      c = 2.0 * s * l;
    } else {
      c = 2.0 * s * (1.0 - l);
    }

    if (c < 1.0) {
      f = (l - 0.5 * c) / (1.0 - c);
    }

    return [hsl[0], c * 100, f * 100];
  };

  convert.hsv.hcg = function (hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;

    if (c < 1.0) {
      f = (v - c) / (1 - c);
    }

    return [hsv[0], c * 100, f * 100];
  };

  convert.hcg.rgb = function (hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;

    if (c === 0.0) {
      return [g * 255, g * 255, g * 255];
    }

    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;

    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;

      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;

      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;

      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;

      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;

      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }

    mg = (1.0 - c) * g;
    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
  };

  convert.hcg.hsv = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1.0 - c);
    var f = 0;

    if (v > 0.0) {
      f = c / v;
    }

    return [hcg[0], f * 100, v * 100];
  };

  convert.hcg.hsl = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1.0 - c) + 0.5 * c;
    var s = 0;

    if (l > 0.0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1.0) {
      s = c / (2 * (1 - l));
    }

    return [hcg[0], s * 100, l * 100];
  };

  convert.hcg.hwb = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1.0 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };

  convert.hwb.hcg = function (hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;

    if (c < 1) {
      g = (v - c) / (1 - c);
    }

    return [hwb[0], c * 100, g * 100];
  };

  convert.apple.rgb = function (apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };

  convert.rgb.apple = function (rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };

  convert.gray.rgb = function (args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };

  convert.gray.hsl = convert.gray.hsv = function (args) {
    return [0, 0, args[0]];
  };

  convert.gray.hwb = function (gray) {
    return [0, 100, gray[0]];
  };

  convert.gray.cmyk = function (gray) {
    return [0, 0, 0, gray[0]];
  };

  convert.gray.lab = function (gray) {
    return [gray[0], 0, 0];
  };

  convert.gray.hex = function (gray) {
    var val = Math.round(gray[0] / 100 * 255) & 0xFF;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert.rgb.gray = function (rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
  });
  var conversions_1 = conversions.rgb;
  var conversions_2 = conversions.hsl;
  var conversions_3 = conversions.hsv;
  var conversions_4 = conversions.hwb;
  var conversions_5 = conversions.cmyk;
  var conversions_6 = conversions.xyz;
  var conversions_7 = conversions.lab;
  var conversions_8 = conversions.lch;
  var conversions_9 = conversions.hex;
  var conversions_10 = conversions.keyword;
  var conversions_11 = conversions.ansi16;
  var conversions_12 = conversions.ansi256;
  var conversions_13 = conversions.hcg;
  var conversions_14 = conversions.apple;
  var conversions_15 = conversions.gray;

  function buildGraph() {
    var graph = {};
    var models = Object.keys(conversions);

    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }

    return graph;
  }

  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;

    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);

      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];

        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }

    return graph;
  }

  function link(from, to) {
    return function (args) {
      return to(from(args));
    };
  }

  function wrapConversion(toModel, graph) {
    var path = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;

    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }

    fn.conversion = path;
    return fn;
  }

  var route = function (fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);

    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];

      if (node.parent === null) {
        continue;
      }

      conversion[toModel] = wrapConversion(toModel, graph);
    }

    return conversion;
  };

  var convert = {};
  var models = Object.keys(conversions);

  function wrapRaw(fn) {
    var wrappedFn = function wrappedFn(args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      return fn(args);
    };

    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  function wrapRounded(fn) {
    var wrappedFn = function wrappedFn(args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      var result = fn(args);

      if (typeof result === 'object') {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }

      return result;
    };

    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  models.forEach(function (fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {
      value: conversions[fromModel].channels
    });
    Object.defineProperty(convert[fromModel], 'labels', {
      value: conversions[fromModel].labels
    });
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function (toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  var colorConvert = convert;

  var ansiStyles = createCommonjsModule(function (module) {



  var wrapAnsi16 = function wrapAnsi16(fn, offset) {
    return function () {
      var code = fn.apply(colorConvert, arguments);
      return "\x1B[" + (code + offset) + "m";
    };
  };

  var wrapAnsi256 = function wrapAnsi256(fn, offset) {
    return function () {
      var code = fn.apply(colorConvert, arguments);
      return "\x1B[" + (38 + offset) + ";5;" + code + "m";
    };
  };

  var wrapAnsi16m = function wrapAnsi16m(fn, offset) {
    return function () {
      var rgb = fn.apply(colorConvert, arguments);
      return "\x1B[" + (38 + offset) + ";2;" + rgb[0] + ";" + rgb[1] + ";" + rgb[2] + "m";
    };
  };

  function assembleStyles() {
    var codes = new Map();
    var styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.grey = styles.color.gray;

    for (var _i = 0, _Object$keys = Object.keys(styles); _i < _Object$keys.length; _i++) {
      var groupName = _Object$keys[_i];
      var group = styles[groupName];

      for (var _i3 = 0, _Object$keys3 = Object.keys(group); _i3 < _Object$keys3.length; _i3++) {
        var styleName = _Object$keys3[_i3];
        var style = group[styleName];
        styles[styleName] = {
          open: "\x1B[" + style[0] + "m",
          close: "\x1B[" + style[1] + "m"
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }

      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false
      });
    }

    var ansi2ansi = function ansi2ansi(n) {
      return n;
    };

    var rgb2rgb = function rgb2rgb(r, g, b) {
      return [r, g, b];
    };

    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };

    for (var _i2 = 0, _Object$keys2 = Object.keys(colorConvert); _i2 < _Object$keys2.length; _i2++) {
      var key = _Object$keys2[_i2];

      if (typeof colorConvert[key] !== 'object') {
        continue;
      }

      var suite = colorConvert[key];

      if (key === 'ansi16') {
        key = 'ansi';
      }

      if ('ansi16' in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }

      if ('ansi256' in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }

      if ('rgb' in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }

    return styles;
  }

  Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles
  });
  });

  var browser$3 = {
    stdout: false,
    stderr: false
  };

  var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([['n', '\n'], ['r', '\r'], ['t', '\t'], ['b', '\b'], ['f', '\f'], ['v', '\v'], ['0', '\0'], ['\\', '\\'], ['e', "\x1B"], ['a', "\x07"]]);

  function unescape(c) {
    if (c[0] === 'u' && c.length === 5 || c[0] === 'x' && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }

    return ESCAPES.get(c) || c;
  }

  function parseArguments(name, args) {
    var results = [];
    var chunks = args.trim().split(/\s*,\s*/g);
    var matches;

    for (var _iterator = chunks, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var chunk = _ref;

      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, function (m, escape, chr) {
          return escape ? unescape(escape) : chr;
        }));
      } else {
        throw new Error("Invalid Chalk template style argument: " + chunk + " (in style '" + name + "')");
      }
    }

    return results;
  }

  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    var results = [];
    var matches;

    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      var name = matches[1];

      if (matches[2]) {
        var args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }

    return results;
  }

  function buildStyle(chalk, styles) {
    var enabled = {};

    for (var _iterator2 = styles, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var layer = _ref2;

      for (var _iterator3 = layer.styles, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i4 >= _iterator3.length) break;
          _ref3 = _iterator3[_i4++];
        } else {
          _i4 = _iterator3.next();
          if (_i4.done) break;
          _ref3 = _i4.value;
        }

        var style = _ref3;
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }

    var current = chalk;

    for (var _i3 = 0, _Object$keys = Object.keys(enabled); _i3 < _Object$keys.length; _i3++) {
      var styleName = _Object$keys[_i3];

      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error("Unknown Chalk style: " + styleName);
        }

        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }

    return current;
  }

  var templates = function (chalk, tmp) {
    var styles = [];
    var chunks = [];
    var chunk = [];
    tmp.replace(TEMPLATE_REGEX, function (m, escapeChar, inverse, style, close, chr) {
      if (escapeChar) {
        chunk.push(unescape(escapeChar));
      } else if (style) {
        var str = chunk.join('');
        chunk = [];
        chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
        styles.push({
          inverse: inverse,
          styles: parseStyle(style)
        });
      } else if (close) {
        if (styles.length === 0) {
          throw new Error('Found extraneous } in Chalk template literal');
        }

        chunks.push(buildStyle(chalk, styles)(chunk.join('')));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(''));

    if (styles.length > 0) {
      var errMsg = "Chalk template literal is missing " + styles.length + " closing bracket" + (styles.length === 1 ? '' : 's') + " (`}`)";
      throw new Error(errMsg);
    }

    return chunks.join('');
  };

  var chalk = createCommonjsModule(function (module) {





  var stdoutColor = browser$3.stdout;



  var isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');
  var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
  var skipModels = new Set(['gray']);
  var styles = Object.create(null);

  function applyOptions(obj, options) {
    options = options || {};
    var scLevel =  0;
    obj.level = options.level === undefined ? scLevel : options.level;
    obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
  }

  function Chalk(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      var chalk = {};
      applyOptions(chalk, options);

      chalk.template = function () {
        var args = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk.template].concat(args));
      };

      Object.setPrototypeOf(chalk, Chalk.prototype);
      Object.setPrototypeOf(chalk.template, chalk);
      chalk.template.constructor = Chalk;
      return chalk.template;
    }

    applyOptions(this, options);
  }

  if (isSimpleWindowsTerm) {
    ansiStyles.blue.open = "\x1B[94m";
  }

  var _loop = function _loop() {
    var key = _Object$keys[_i];
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    styles[key] = {
      get: function get() {
        var codes = ansiStyles[key];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }
    };
  };

  for (var _i = 0, _Object$keys = Object.keys(ansiStyles); _i < _Object$keys.length; _i++) {
    _loop();
  }

  styles.visible = {
    get: function get() {
      return build.call(this, this._styles || [], true, 'visible');
    }
  };
  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');

  var _loop2 = function _loop2() {
    var model = _Object$keys2[_i2];

    if (skipModels.has(model)) {
      return "continue";
    }

    styles[model] = {
      get: function get() {
        var level = this.level;
        return function () {
          var open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
          var codes = {
            open: open,
            close: ansiStyles.color.close,
            closeRe: ansiStyles.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  };

  for (var _i2 = 0, _Object$keys2 = Object.keys(ansiStyles.color.ansi); _i2 < _Object$keys2.length; _i2++) {
    var _ret = _loop2();

    if (_ret === "continue") continue;
  }

  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');

  var _loop3 = function _loop3() {
    var model = _Object$keys3[_i3];

    if (skipModels.has(model)) {
      return "continue";
    }

    var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get: function get() {
        var level = this.level;
        return function () {
          var open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
          var codes = {
            open: open,
            close: ansiStyles.bgColor.close,
            closeRe: ansiStyles.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  };

  for (var _i3 = 0, _Object$keys3 = Object.keys(ansiStyles.bgColor.ansi); _i3 < _Object$keys3.length; _i3++) {
    var _ret2 = _loop3();

    if (_ret2 === "continue") continue;
  }

  var proto = Object.defineProperties(function () {}, styles);

  function build(_styles, _empty, key) {
    var builder = function builder() {
      return applyStyle.apply(builder, arguments);
    };

    builder._styles = _styles;
    builder._empty = _empty;
    var self = this;
    Object.defineProperty(builder, 'level', {
      enumerable: true,
      get: function get() {
        return self.level;
      },
      set: function set(level) {
        self.level = level;
      }
    });
    Object.defineProperty(builder, 'enabled', {
      enumerable: true,
      get: function get() {
        return self.enabled;
      },
      set: function set(enabled) {
        self.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';
    builder.__proto__ = proto;
    return builder;
  }

  function applyStyle() {
    var args = arguments;
    var argsLen = args.length;
    var str = String(arguments[0]);

    if (argsLen === 0) {
      return '';
    }

    if (argsLen > 1) {
      for (var a = 1; a < argsLen; a++) {
        str += ' ' + args[a];
      }
    }

    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? '' : str;
    }

    var originalDim = ansiStyles.dim.open;

    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles.dim.open = '';
    }

    for (var _iterator = this._styles.slice().reverse(), _isArray = Array.isArray(_iterator), _i4 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i4 >= _iterator.length) break;
        _ref = _iterator[_i4++];
      } else {
        _i4 = _iterator.next();
        if (_i4.done) break;
        _ref = _i4.value;
      }

      var code = _ref;
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, code.close + "$&" + code.open);
    }

    ansiStyles.dim.open = originalDim;
    return str;
  }

  function chalkTag(chalk, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(' ');
    }

    var args = [].slice.call(arguments, 2);
    var parts = [strings.raw[0]];

    for (var i = 1; i < strings.length; i++) {
      parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
      parts.push(String(strings.raw[i]));
    }

    return templates(chalk, parts.join(''));
  }

  Object.defineProperties(Chalk.prototype, styles);
  module.exports = Chalk();
  module.exports.supportsColor = stdoutColor;
  module.exports["default"] = module.exports;
  });
  var chalk_1 = chalk.supportsColor;

  function getDefs(chalk) {
    return {
      keyword: chalk.cyan,
      capitalized: chalk.yellow,
      jsx_tag: chalk.yellow,
      punctuator: chalk.yellow,
      number: chalk.magenta,
      string: chalk.green,
      regex: chalk.magenta,
      comment: chalk.grey,
      invalid: chalk.white.bgRed.bold
    };
  }

  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  var JSX_TAG = /^[a-z][\w-]*$/i;
  var BRACKET = /^[()[\]{}]$/;

  function getTokenType(match) {
    var _match$slice = match.slice(-2),
        offset = _match$slice[0],
        text = _match$slice[1];

    var token = jsTokens_1(match);

    if (token.type === "name") {
      if (isKeyword(token.value) || isReservedWord(token.value)) {
        return "keyword";
      }

      if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
        return "jsx_tag";
      }

      if (token.value[0] !== token.value[0].toLowerCase()) {
        return "capitalized";
      }
    }

    if (token.type === "punctuator" && BRACKET.test(token.value)) {
      return "bracket";
    }

    if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
      return "punctuator";
    }

    return token.type;
  }

  function highlightTokens(defs, text) {
    return text.replace(jsTokens$1, function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var type = getTokenType(args);
      var colorize = defs[type];

      if (colorize) {
        return args[0].split(NEWLINE).map(function (str) {
          return colorize(str);
        }).join("\n");
      } else {
        return args[0];
      }
    });
  }

  function shouldHighlight(options) {
    return chalk.supportsColor || options.forceColor;
  }
  function getChalk(options) {
    var chalk$1 = chalk;

    if (options.forceColor) {
      chalk$1 = new chalk.constructor({
        enabled: true,
        level: 1
      });
    }

    return chalk$1;
  }
  function highlight(code, options) {
    if (options === void 0) {
      options = {};
    }

    if (shouldHighlight(options)) {
      var chalk = getChalk(options);
      var defs = getDefs(chalk);
      return highlightTokens(defs, code);
    } else {
      return code;
    }
  }

  function getDefs$1(chalk) {
    return {
      gutter: chalk.grey,
      marker: chalk.red.bold,
      message: chalk.red.bold
    };
  }

  var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;

  function getMarkerLines(loc, source, opts) {
    var startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    var endLoc = Object.assign({}, startLoc, {}, loc.end);

    var _ref = opts || {},
        _ref$linesAbove = _ref.linesAbove,
        linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,
        _ref$linesBelow = _ref.linesBelow,
        linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;

    var startLine = startLoc.line;
    var startColumn = startLoc.column;
    var endLine = endLoc.line;
    var endColumn = endLoc.column;
    var start = Math.max(startLine - (linesAbove + 1), 0);
    var end = Math.min(source.length, endLine + linesBelow);

    if (startLine === -1) {
      start = 0;
    }

    if (endLine === -1) {
      end = source.length;
    }

    var lineDiff = endLine - startLine;
    var markerLines = {};

    if (lineDiff) {
      for (var i = 0; i <= lineDiff; i++) {
        var lineNumber = i + startLine;

        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          var sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          var _sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, _sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }

    return {
      start: start,
      end: end,
      markerLines: markerLines
    };
  }

  function codeFrameColumns(rawLines, loc, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var highlighted = (opts.highlightCode || opts.forceColor) && shouldHighlight(opts);
    var chalk = getChalk(opts);
    var defs = getDefs$1(chalk);

    var maybeHighlight = function maybeHighlight(chalkFn, string) {
      return highlighted ? chalkFn(string) : string;
    };

    var lines = rawLines.split(NEWLINE$1);

    var _getMarkerLines = getMarkerLines(loc, lines, opts),
        start = _getMarkerLines.start,
        end = _getMarkerLines.end,
        markerLines = _getMarkerLines.markerLines;

    var hasColumns = loc.start && typeof loc.start.column === "number";
    var numberMaxWidth = String(end).length;
    var highlightedLines = highlighted ? highlight(rawLines, opts) : rawLines;
    var frame = highlightedLines.split(NEWLINE$1).slice(start, end).map(function (line, index) {
      var number = start + 1 + index;
      var paddedNumber = (" " + number).slice(-numberMaxWidth);
      var gutter = " " + paddedNumber + " | ";
      var hasMarker = markerLines[number];
      var lastMarkerLine = !markerLines[number + 1];

      if (hasMarker) {
        var markerLine = "";

        if (Array.isArray(hasMarker)) {
          var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          var numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");

          if (lastMarkerLine && opts.message) {
            markerLine += " " + maybeHighlight(defs.message, opts.message);
          }
        }

        return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine].join("");
      } else {
        return " " + maybeHighlight(defs.gutter, gutter) + line;
      }
    }).join("\n");

    if (opts.message && !hasColumns) {
      frame = "" + " ".repeat(numberMaxWidth + 1) + opts.message + "\n" + frame;
    }

    if (highlighted) {
      return chalk.reset(frame);
    } else {
      return frame;
    }
  }

  var beforeExpr = true;
  var startsExpr = true;
  var isLoop$1 = true;
  var isAssign = true;
  var prefix = true;
  var postfix = true;
  var TokenType = function TokenType(label, conf) {
    if (conf === void 0) {
      conf = {};
    }

    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.rightAssociative = !!conf.rightAssociative;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop != null ? conf.binop : null;
    this.updateContext = null;
  };
  var keywords$1 = new Map();

  function createKeyword(name, options) {
    if (options === void 0) {
      options = {};
    }

    options.keyword = name;
    var token = new TokenType(name, options);
    keywords$1.set(name, token);
    return token;
  }

  function createBinop(name, binop) {
    return new TokenType(name, {
      beforeExpr: beforeExpr,
      binop: binop
    });
  }

  var types = {
    num: new TokenType("num", {
      startsExpr: startsExpr
    }),
    bigint: new TokenType("bigint", {
      startsExpr: startsExpr
    }),
    regexp: new TokenType("regexp", {
      startsExpr: startsExpr
    }),
    string: new TokenType("string", {
      startsExpr: startsExpr
    }),
    name: new TokenType("name", {
      startsExpr: startsExpr
    }),
    eof: new TokenType("eof"),
    bracketL: new TokenType("[", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    bracketHashL: new TokenType("#[", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    bracketBarL: new TokenType("[|", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    bracketR: new TokenType("]"),
    bracketBarR: new TokenType("|]"),
    braceL: new TokenType("{", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    braceBarL: new TokenType("{|", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    braceHashL: new TokenType("#{", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    braceR: new TokenType("}"),
    braceBarR: new TokenType("|}"),
    parenL: new TokenType("(", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", {
      beforeExpr: beforeExpr
    }),
    semi: new TokenType(";", {
      beforeExpr: beforeExpr
    }),
    colon: new TokenType(":", {
      beforeExpr: beforeExpr
    }),
    doubleColon: new TokenType("::", {
      beforeExpr: beforeExpr
    }),
    dot: new TokenType("."),
    question: new TokenType("?", {
      beforeExpr: beforeExpr
    }),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", {
      beforeExpr: beforeExpr
    }),
    template: new TokenType("template"),
    ellipsis: new TokenType("...", {
      beforeExpr: beforeExpr
    }),
    backQuote: new TokenType("`", {
      startsExpr: startsExpr
    }),
    dollarBraceL: new TokenType("${", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    at: new TokenType("@"),
    hash: new TokenType("#", {
      startsExpr: startsExpr
    }),
    interpreterDirective: new TokenType("#!..."),
    eq: new TokenType("=", {
      beforeExpr: beforeExpr,
      isAssign: isAssign
    }),
    assign: new TokenType("_=", {
      beforeExpr: beforeExpr,
      isAssign: isAssign
    }),
    incDec: new TokenType("++/--", {
      prefix: prefix,
      postfix: postfix,
      startsExpr: startsExpr
    }),
    bang: new TokenType("!", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    tilde: new TokenType("~", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr: beforeExpr,
      binop: 9,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    modulo: new TokenType("%", {
      beforeExpr: beforeExpr,
      binop: 10,
      startsExpr: startsExpr
    }),
    star: createBinop("*", 10),
    slash: createBinop("/", 10),
    exponent: new TokenType("**", {
      beforeExpr: beforeExpr,
      binop: 11,
      rightAssociative: true
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr: beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr: beforeExpr
    }),
    _do: createKeyword("do", {
      isLoop: isLoop$1,
      beforeExpr: beforeExpr
    }),
    _else: createKeyword("else", {
      beforeExpr: beforeExpr
    }),
    _finally: createKeyword("finally"),
    _for: createKeyword("for", {
      isLoop: isLoop$1
    }),
    _function: createKeyword("function", {
      startsExpr: startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr: beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _while: createKeyword("while", {
      isLoop: isLoop$1
    }),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    _this: createKeyword("this", {
      startsExpr: startsExpr
    }),
    _super: createKeyword("super", {
      startsExpr: startsExpr
    }),
    _class: createKeyword("class", {
      startsExpr: startsExpr
    }),
    _extends: createKeyword("extends", {
      beforeExpr: beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr: startsExpr
    }),
    _null: createKeyword("null", {
      startsExpr: startsExpr
    }),
    _true: createKeyword("true", {
      startsExpr: startsExpr
    }),
    _false: createKeyword("false", {
      startsExpr: startsExpr
    }),
    _in: createKeyword("in", {
      beforeExpr: beforeExpr,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr: beforeExpr,
      binop: 7
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _void: createKeyword("void", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _delete: createKeyword("delete", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    })
  };

  var SCOPE_OTHER = 0,
      SCOPE_PROGRAM = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_ARROW = 4,
      SCOPE_SIMPLE_CATCH = 8,
      SCOPE_SUPER = 16,
      SCOPE_DIRECT_SUPER = 32,
      SCOPE_CLASS = 64,
      SCOPE_TS_MODULE = 128,
      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
  var BIND_KIND_VALUE = 1,
      BIND_KIND_TYPE = 2,
      BIND_SCOPE_VAR = 4,
      BIND_SCOPE_LEXICAL = 8,
      BIND_SCOPE_FUNCTION = 16,
      BIND_FLAGS_NONE = 64,
      BIND_FLAGS_CLASS = 128,
      BIND_FLAGS_TS_ENUM = 256,
      BIND_FLAGS_TS_CONST_ENUM = 512,
      BIND_FLAGS_TS_EXPORT_ONLY = 1024;
  var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
  var CLASS_ELEMENT_FLAG_STATIC = 4,
      CLASS_ELEMENT_KIND_GETTER = 2,
      CLASS_ELEMENT_KIND_SETTER = 1,
      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
  var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
      CLASS_ELEMENT_OTHER = 0;

  var lineBreak = /\r\n?|[\n\u2028\u2029]/;
  var lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code) {
    switch (code) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;

      default:
        return false;
    }
  }
  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  function isWhitespace(code) {
    switch (code) {
      case 0x0009:
      case 0x000b:
      case 0x000c:
      case 32:
      case 160:
      case 5760:
      case 0x2000:
      case 0x2001:
      case 0x2002:
      case 0x2003:
      case 0x2004:
      case 0x2005:
      case 0x2006:
      case 0x2007:
      case 0x2008:
      case 0x2009:
      case 0x200a:
      case 0x202f:
      case 0x205f:
      case 0x3000:
      case 0xfeff:
        return true;

      default:
        return false;
    }
  }

  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };
  var SourceLocation = function SourceLocation(start, end) {
    this.start = start;
    this.end = end;
  };
  function getLineInfo(input, offset) {
    var line = 1;
    var lineStart = 0;
    var match;
    lineBreakG.lastIndex = 0;

    while ((match = lineBreakG.exec(input)) && match.index < offset) {
      line++;
      lineStart = lineBreakG.lastIndex;
    }

    return new Position(line, offset - lineStart);
  }

  var BaseParser = function () {
    function BaseParser() {
      this.sawUnambiguousESM = false;
      this.ambiguousScriptDifferentAst = false;
    }

    var _proto = BaseParser.prototype;

    _proto.hasPlugin = function hasPlugin(name) {
      return this.plugins.has(name);
    };

    _proto.getPluginOption = function getPluginOption(plugin, name) {
      if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
    };

    return BaseParser;
  }();

  function last(stack) {
    return stack[stack.length - 1];
  }

  var CommentsParser = function (_BaseParser) {
    _inheritsLoose(CommentsParser, _BaseParser);

    function CommentsParser() {
      return _BaseParser.apply(this, arguments) || this;
    }

    var _proto = CommentsParser.prototype;

    _proto.addComment = function addComment(comment) {
      if (this.filename) comment.loc.filename = this.filename;
      this.state.trailingComments.push(comment);
      this.state.leadingComments.push(comment);
    };

    _proto.adjustCommentsAfterTrailingComma = function adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {
      if (this.state.leadingComments.length === 0) {
        return;
      }

      var lastElement = null;
      var i = elements.length;

      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }

      if (lastElement === null) {
        return;
      }

      for (var j = 0; j < this.state.leadingComments.length; j++) {
        if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
          this.state.leadingComments.splice(j, 1);
          j--;
        }
      }

      var newTrailingComments = [];

      for (var _i = 0; _i < this.state.leadingComments.length; _i++) {
        var leadingComment = this.state.leadingComments[_i];

        if (leadingComment.end < node.end) {
          newTrailingComments.push(leadingComment);

          if (!takeAllComments) {
            this.state.leadingComments.splice(_i, 1);
            _i--;
          }
        } else {
          if (node.trailingComments === undefined) {
            node.trailingComments = [];
          }

          node.trailingComments.push(leadingComment);
        }
      }

      if (takeAllComments) this.state.leadingComments = [];

      if (newTrailingComments.length > 0) {
        lastElement.trailingComments = newTrailingComments;
      } else if (lastElement.trailingComments !== undefined) {
        lastElement.trailingComments = [];
      }
    };

    _proto.processComment = function processComment(node) {
      if (node.type === "Program" && node.body.length > 0) return;
      var stack = this.state.commentStack;
      var firstChild, lastChild, trailingComments, i, j;

      if (this.state.trailingComments.length > 0) {
        if (this.state.trailingComments[0].start >= node.end) {
          trailingComments = this.state.trailingComments;
          this.state.trailingComments = [];
        } else {
          this.state.trailingComments.length = 0;
        }
      } else if (stack.length > 0) {
        var lastInStack = last(stack);

        if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
          trailingComments = lastInStack.trailingComments;
          delete lastInStack.trailingComments;
        }
      }

      if (stack.length > 0 && last(stack).start >= node.start) {
        firstChild = stack.pop();
      }

      while (stack.length > 0 && last(stack).start >= node.start) {
        lastChild = stack.pop();
      }

      if (!lastChild && firstChild) lastChild = firstChild;

      if (firstChild) {
        switch (node.type) {
          case "ObjectExpression":
            this.adjustCommentsAfterTrailingComma(node, node.properties);
            break;

          case "ObjectPattern":
            this.adjustCommentsAfterTrailingComma(node, node.properties, true);
            break;

          case "CallExpression":
            this.adjustCommentsAfterTrailingComma(node, node.arguments);
            break;

          case "ArrayExpression":
            this.adjustCommentsAfterTrailingComma(node, node.elements);
            break;

          case "ArrayPattern":
            this.adjustCommentsAfterTrailingComma(node, node.elements, true);
            break;
        }
      } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && node.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && node.type !== "ExportSpecifier")) {
        this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode]);
      }

      if (lastChild) {
        if (lastChild.leadingComments) {
          if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {
            node.leadingComments = lastChild.leadingComments;
            delete lastChild.leadingComments;
          } else {
            for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
              if (lastChild.leadingComments[i].end <= node.start) {
                node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                break;
              }
            }
          }
        }
      } else if (this.state.leadingComments.length > 0) {
        if (last(this.state.leadingComments).end <= node.start) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }
          }

          if (this.state.leadingComments.length > 0) {
            node.leadingComments = this.state.leadingComments;
            this.state.leadingComments = [];
          }
        } else {
          for (i = 0; i < this.state.leadingComments.length; i++) {
            if (this.state.leadingComments[i].end > node.start) {
              break;
            }
          }

          var leadingComments = this.state.leadingComments.slice(0, i);

          if (leadingComments.length) {
            node.leadingComments = leadingComments;
          }

          trailingComments = this.state.leadingComments.slice(i);

          if (trailingComments.length === 0) {
            trailingComments = null;
          }
        }
      }

      this.state.commentPreviousNode = node;

      if (trailingComments) {
        if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
          node.innerComments = trailingComments;
        } else {
          node.trailingComments = trailingComments;
        }
      }

      stack.push(node);
    };

    return CommentsParser;
  }(BaseParser);

  var Errors = Object.freeze({
    ArgumentsDisallowedInInitializer: "'arguments' is not allowed in class field initializer",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function",
    AwaitExpressionFormalParameter: "await is not allowed in async function parameters",
    AwaitNotInAsyncFunction: "Can not use keyword 'await' outside an async function",
    BadGetterArity: "getter must not have any formal parameters",
    BadSetterArity: "setter must have exactly one formal parameter",
    BadSetterRestParameter: "setter function argument must not be a rest parameter",
    ConstructorClassField: "Classes may not have a field named 'constructor'",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'",
    ConstructorIsAccessor: "Class constructor may not be an accessor",
    ConstructorIsAsync: "Constructor can't be an async function",
    ConstructorIsGenerator: "Constructor can't be a generator",
    DeclarationMissingInitializer: "%0 require an initialization value",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon",
    DeletePrivateField: "Deleting a private field is not allowed",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
    DuplicateProto: "Redefinition of __proto__ property",
    DuplicateRegExpFlags: "Duplicate regular expression flag",
    ElementAfterRest: "Rest element must be last element",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape",
    ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block",
    IllegalBreakContinue: "Unsyntactic %0",
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
    IllegalReturn: "'return' outside of function",
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments",
    ImportCallArity: "import() requires exactly one argument",
    ImportCallArityLtOne: "Dynamic imports require a parameter: import('a.js')",
    ImportCallNotNewExpression: "Cannot use new with import(...)",
    ImportCallSpreadArgument: "... is not allowed in import()",
    ImportMetaOutsideModule: "import.meta may appear only with 'sourceType: \"module\"'",
    ImportOutsideModule: "'import' and 'export' may appear only with 'sourceType: \"module\"'",
    InvalidCodePoint: "Code point out of bounds",
    InvalidDigit: "Expected number in radix %0",
    InvalidEscapeSequence: "Bad character escape sequence",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template",
    InvalidEscapedReservedWord: "Escape sequence in keyword %0",
    InvalidIdentifier: "Invalid identifier %0",
    InvalidLhs: "Invalid left-hand side in %0",
    InvalidLhsBinding: "Binding invalid left-hand side in %0",
    InvalidNumber: "Invalid number",
    InvalidOrUnexpectedToken: "Unexpected character '%0'",
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern",
    InvalidPrivateFieldResolution: "Private name #%0 is not defined",
    InvalidPropertyBindingPattern: "Binding member expression",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument",
    LabelRedeclaration: "Label '%0' is already declared",
    LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
    MalformedRegExpFlags: "Invalid regular expression flag",
    MissingClassName: "A class name is required",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators",
    ModuleExportUndefined: "Export '%0' is not defined",
    MultipleDefaultsInSwitch: "Multiple default clauses",
    NewlineAfterThrow: "Illegal newline after throw",
    NoCatchOrFinally: "Missing catch or finally clause",
    NumberIdentifier: "Identifier directly after number",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences",
    ObsoleteAwaitStar: "await* has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "constructors in/after an Optional Chain are not allowed",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain",
    ParamDupe: "Argument name clash",
    PatternHasAccessor: "Object pattern can't contain getter or setter",
    PatternHasMethod: "Object pattern can't contain methods",
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding",
    PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
    PrivateNameRedeclaration: "Duplicate private name #%0",
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
    RestTrailingComma: "Unexpected trailing comma after rest element",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement",
    StaticPrototype: "Classes may not have static property named prototype",
    StrictDelete: "Deleting local variable in strict mode",
    StrictEvalArguments: "Assigning to '%0' in strict mode",
    StrictEvalArgumentsBinding: "Binding '%0' in strict mode",
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode",
    StrictWith: "'with' in strict mode",
    SuperNotAllowed: "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super",
    TrailingDecorator: "Decorators must be attached to a class element",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level",
    UnexpectedKeyword: "Unexpected keyword '%0'",
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context",
    UnexpectedNewTarget: "new.target can only be used in functions",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits",
    UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
    UnexpectedReservedWord: "Unexpected reserved word '%0'",
    UnexpectedSuper: "super is only allowed in object methods and classes",
    UnexpectedToken: "Unexpected token '%'",
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "import can only be used in import() or import.meta",
    UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1",
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties",
    UnsupportedSuper: "super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])",
    UnterminatedComment: "Unterminated comment",
    UnterminatedRegExp: "Unterminated regular expression",
    UnterminatedString: "Unterminated string constant",
    UnterminatedTemplate: "Unterminated template",
    VarRedeclaration: "Identifier '%0' has already been declared",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator",
    YieldInParameter: "yield is not allowed in generator parameters",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0"
  });

  var LocationParser = function (_CommentsParser) {
    _inheritsLoose(LocationParser, _CommentsParser);

    function LocationParser() {
      return _CommentsParser.apply(this, arguments) || this;
    }

    var _proto = LocationParser.prototype;

    _proto.getLocationForPosition = function getLocationForPosition(pos) {
      var loc;
      if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);
      return loc;
    };

    _proto.raise = function raise(pos, errorTemplate) {
      for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        params[_key - 2] = arguments[_key];
      }

      return this.raiseWithData.apply(this, [pos, undefined, errorTemplate].concat(params));
    };

    _proto.raiseWithData = function raiseWithData(pos, data, errorTemplate) {
      for (var _len2 = arguments.length, params = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        params[_key2 - 3] = arguments[_key2];
      }

      var loc = this.getLocationForPosition(pos);
      var message = errorTemplate.replace(/%(\d+)/g, function (_, i) {
        return params[i];
      }) + (" (" + loc.line + ":" + loc.column + ")");
      return this._raise(Object.assign({
        loc: loc,
        pos: pos
      }, data), message);
    };

    _proto._raise = function _raise(errorContext, message) {
      var err = new SyntaxError(message);
      Object.assign(err, errorContext);

      if (this.options.errorRecovery) {
        if (!this.isLookahead) this.state.errors.push(err);
        return err;
      } else {
        throw err;
      }
    };

    return LocationParser;
  }(CommentsParser);

  function isSimpleProperty(node) {
    return node != null && node.type === "Property" && node.kind === "init" && node.method === false;
  }

  var estree = (function (superClass) {
    return function (_superClass) {
      _inheritsLoose(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.estreeParseRegExpLiteral = function estreeParseRegExpLiteral(_ref) {
        var pattern = _ref.pattern,
            flags = _ref.flags;
        var regex = null;

        try {
          regex = new RegExp(pattern, flags);
        } catch (e) {}

        var node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern: pattern,
          flags: flags
        };
        return node;
      };

      _proto.estreeParseBigIntLiteral = function estreeParseBigIntLiteral(value) {
        var bigInt = typeof BigInt !== "undefined" ? BigInt(value) : null;
        var node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      };

      _proto.estreeParseLiteral = function estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      };

      _proto.directiveToStmt = function directiveToStmt(directive) {
        var directiveLiteral = directive.value;
        var stmt = this.startNodeAt(directive.start, directive.loc.start);
        var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
        expression.value = directiveLiteral.value;
        expression.raw = directiveLiteral.extra.raw;
        stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
        stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
        return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
      };

      _proto.initFunction = function initFunction(node, isAsync) {
        _superClass.prototype.initFunction.call(this, node, isAsync);

        node.expression = false;
      };

      _proto.checkDeclaration = function checkDeclaration(node) {
        if (isSimpleProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          _superClass.prototype.checkDeclaration.call(this, node);
        }
      };

      _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
        var prop = method;
        var paramCount = prop.kind === "get" ? 0 : 1;
        var start = prop.start;

        if (prop.value.params.length !== paramCount) {
          if (method.kind === "get") {
            this.raise(start, Errors.BadGetterArity);
          } else {
            this.raise(start, Errors.BadSetterArity);
          }
        } else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
          this.raise(start, Errors.BadSetterRestParameter);
        }
      };

      _proto.checkLVal = function checkLVal(expr, bindingType, checkClashes, contextDescription, disallowLetBinding) {
        var _this = this;

        if (bindingType === void 0) {
          bindingType = BIND_NONE;
        }

        switch (expr.type) {
          case "ObjectPattern":
            expr.properties.forEach(function (prop) {
              _this.checkLVal(prop.type === "Property" ? prop.value : prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
            });
            break;

          default:
            _superClass.prototype.checkLVal.call(this, expr, bindingType, checkClashes, contextDescription, disallowLetBinding);

        }
      };

      _proto.checkDuplicatedProto = function checkDuplicatedProto(prop, protoRef, refExpressionErrors) {
        if (prop.type === "SpreadElement" || prop.computed || prop.method || prop.shorthand) {
          return;
        }

        var key = prop.key;
        var name = key.type === "Identifier" ? key.name : String(key.value);

        if (name === "__proto__" && prop.kind === "init") {
          if (protoRef.used) {
            if (refExpressionErrors && refExpressionErrors.doubleProto === -1) {
              refExpressionErrors.doubleProto = key.start;
            } else {
              this.raise(key.start, Errors.DuplicateProto);
            }
          }

          protoRef.used = true;
        }
      };

      _proto.isValidDirective = function isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);
      };

      _proto.stmtToDirective = function stmtToDirective(stmt) {
        var directive = _superClass.prototype.stmtToDirective.call(this, stmt);

        var value = stmt.expression.value;
        directive.value.value = value;
        return directive;
      };

      _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end) {
        var _this2 = this;

        _superClass.prototype.parseBlockBody.call(this, node, allowDirectives, topLevel, end);

        var directiveStatements = node.directives.map(function (d) {
          return _this2.directiveToStmt(d);
        });
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      };

      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);

        if (method.typeParameters) {
          method.value.typeParameters = method.typeParameters;
          delete method.typeParameters;
        }

        classBody.body.push(method);
      };

      _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
        switch (this.state.type) {
          case types.num:
          case types.string:
            return this.estreeParseLiteral(this.state.value);

          case types.regexp:
            return this.estreeParseRegExpLiteral(this.state.value);

          case types.bigint:
            return this.estreeParseBigIntLiteral(this.state.value);

          case types._null:
            return this.estreeParseLiteral(null);

          case types._true:
            return this.estreeParseLiteral(true);

          case types._false:
            return this.estreeParseLiteral(false);

          default:
            return _superClass.prototype.parseExprAtom.call(this, refExpressionErrors);
        }
      };

      _proto.parseLiteral = function parseLiteral(value, type, startPos, startLoc) {
        var node = _superClass.prototype.parseLiteral.call(this, value, type, startPos, startLoc);

        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      };

      _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }

        _superClass.prototype.parseFunctionBody.call(this, node, allowExpression, isMethod);

        node.expression = node.body.type !== "BlockStatement";
      };

      _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        if (inClassScope === void 0) {
          inClassScope = false;
        }

        var funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = _superClass.prototype.parseMethod.call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node.value = funcNode;
        type = type === "ClassMethod" ? "MethodDefinition" : type;
        return this.finishNode(node, type);
      };

      _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
        var node = _superClass.prototype.parseObjectMethod.call(this, prop, isGenerator, isAsync, isPattern, containsEsc);

        if (node) {
          node.type = "Property";
          if (node.kind === "method") node.kind = "init";
          node.shorthand = false;
        }

        return node;
      };

      _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
        var node = _superClass.prototype.parseObjectProperty.call(this, prop, startPos, startLoc, isPattern, refExpressionErrors);

        if (node) {
          node.kind = "init";
          node.type = "Property";
        }

        return node;
      };

      _proto.toAssignable = function toAssignable(node) {
        if (isSimpleProperty(node)) {
          this.toAssignable(node.value);
          return node;
        }

        return _superClass.prototype.toAssignable.call(this, node);
      };

      _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isLast) {
        if (prop.kind === "get" || prop.kind === "set") {
          throw this.raise(prop.key.start, Errors.PatternHasAccessor);
        } else if (prop.method) {
          throw this.raise(prop.key.start, Errors.PatternHasMethod);
        } else {
          _superClass.prototype.toAssignableObjectExpressionProp.call(this, prop, isLast);
        }
      };

      _proto.finishCallExpression = function finishCallExpression(node, optional) {
        _superClass.prototype.finishCallExpression.call(this, node, optional);

        if (node.callee.type === "Import") {
          node.type = "ImportExpression";
          node.source = node.arguments[0];
          delete node.arguments;
          delete node.callee;
        }

        return node;
      };

      _proto.toReferencedListDeep = function toReferencedListDeep(exprList, isParenthesizedExpr) {
        if (!exprList) {
          return;
        }

        _superClass.prototype.toReferencedListDeep.call(this, exprList, isParenthesizedExpr);
      };

      _proto.parseExport = function parseExport(node) {
        _superClass.prototype.parseExport.call(this, node);

        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;

          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              node.type = "ExportAllDeclaration";
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }

            break;
        }

        return node;
      };

      return _class;
    }(superClass);
  });

  var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
  };
  var types$1 = {
    braceStatement: new TokContext("{", false),
    braceExpression: new TokContext("{", true),
    templateQuasi: new TokContext("${", false),
    parenStatement: new TokContext("(", false),
    parenExpression: new TokContext("(", true),
    template: new TokContext("`", true, true, function (p) {
      return p.readTmplToken();
    }),
    functionExpression: new TokContext("function", true),
    functionStatement: new TokContext("function", false)
  };

  types.parenR.updateContext = types.braceR.updateContext = function () {
    if (this.state.context.length === 1) {
      this.state.exprAllowed = true;
      return;
    }

    var out = this.state.context.pop();

    if (out === types$1.braceStatement && this.curContext().token === "function") {
      out = this.state.context.pop();
    }

    this.state.exprAllowed = !out.isExpr;
  };

  types.name.updateContext = function (prevType) {
    var allowed = false;

    if (prevType !== types.dot) {
      if (this.state.value === "of" && !this.state.exprAllowed || this.state.value === "yield" && this.prodParam.hasYield) {
        allowed = true;
      }
    }

    this.state.exprAllowed = allowed;

    if (this.state.isIterator) {
      this.state.isIterator = false;
    }
  };

  types.braceL.updateContext = function (prevType) {
    this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
    this.state.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function () {
    this.state.context.push(types$1.templateQuasi);
    this.state.exprAllowed = true;
  };

  types.parenL.updateContext = function (prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
    this.state.exprAllowed = true;
  };

  types.incDec.updateContext = function () {};

  types._function.updateContext = types._class.updateContext = function (prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
      this.state.context.push(types$1.functionExpression);
    } else {
      this.state.context.push(types$1.functionStatement);
    }

    this.state.exprAllowed = false;
  };

  types.backQuote.updateContext = function () {
    if (this.curContext() === types$1.template) {
      this.state.context.pop();
    } else {
      this.state.context.push(types$1.template);
    }

    this.state.exprAllowed = false;
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;
  function isIteratorStart(current, next) {
    return current === 64 && next === 64;
  }

  var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
  var FlowErrors = Object.freeze({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module",
    AssignReservedType: "Cannot overwrite reserved type %0",
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement",
    EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
    EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
    EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
    EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
    EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
    EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
    EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
    EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
    EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions",
    InexactVariance: "Explicit inexact syntax cannot have variance",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment",
    OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
    SpreadVariance: "Spread properties cannot have variance",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object",
    UnexpectedReservedType: "Unexpected reserved type %0",
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint"',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration",
    UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead",
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module",
    UnterminatedFlowComment: "Unterminated flow-comment"
  });

  function isEsModuleType(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
  }

  function hasTypeImportKind(node) {
    return node.importKind === "type" || node.importKind === "typeof";
  }

  function isMaybeDefaultImport(state) {
    return (state.type === types.name || !!state.type.keyword) && state.value !== "from";
  }

  var exportSuggestions = {
    "const": "declare export var",
    "let": "declare export var",
    type: "export type",
    "interface": "export interface"
  };

  function partition(list, test) {
    var list1 = [];
    var list2 = [];

    for (var i = 0; i < list.length; i++) {
      (test(list[i], i, list) ? list1 : list2).push(list[i]);
    }

    return [list1, list2];
  }

  var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  var flow = (function (superClass) {
    return function (_superClass) {
      _inheritsLoose(_class, _superClass);

      function _class(options, input) {
        var _this;

        _this = _superClass.call(this, options, input) || this;
        _this.flowPragma = undefined;
        return _this;
      }

      var _proto = _class.prototype;

      _proto.shouldParseTypes = function shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      };

      _proto.shouldParseEnums = function shouldParseEnums() {
        return !!this.getPluginOption("flow", "enums");
      };

      _proto.finishToken = function finishToken(type, val) {
        if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {
          if (this.flowPragma === undefined) {
            this.flowPragma = null;
          }
        }

        return _superClass.prototype.finishToken.call(this, type, val);
      };

      _proto.addComment = function addComment(comment) {
        if (this.flowPragma === undefined) {
          var matches = FLOW_PRAGMA_REGEX.exec(comment.value);

          if (!matches) ; else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }

        return _superClass.prototype.addComment.call(this, comment);
      };

      _proto.flowParseTypeInitialiser = function flowParseTypeInitialiser(tok) {
        var oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || types.colon);
        var type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      };

      _proto.flowParsePredicate = function flowParsePredicate() {
        var node = this.startNode();
        var moduloLoc = this.state.startLoc;
        var moduloPos = this.state.start;
        this.expect(types.modulo);
        var checksLoc = this.state.startLoc;
        this.expectContextual("checks");

        if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
          this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
        }

        if (this.eat(types.parenL)) {
          node.value = this.parseExpression();
          this.expect(types.parenR);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      };

      _proto.flowParseTypeAndPredicateInitialiser = function flowParseTypeAndPredicateInitialiser() {
        var oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(types.colon);
        var type = null;
        var predicate = null;

        if (this.match(types.modulo)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;

          if (this.match(types.modulo)) {
            predicate = this.flowParsePredicate();
          }
        }

        return [type, predicate];
      };

      _proto.flowParseDeclareClass = function flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      };

      _proto.flowParseDeclareFunction = function flowParseDeclareFunction(node) {
        this.next();
        var id = node.id = this.parseIdentifier();
        var typeNode = this.startNode();
        var typeContainer = this.startNode();

        if (this.isRelational("<")) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }

        this.expect(types.parenL);
        var tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        this.expect(types.parenR);

        var _this$flowParseTypeAn = this.flowParseTypeAndPredicateInitialiser();

        typeNode.returnType = _this$flowParseTypeAn[0];
        node.predicate = _this$flowParseTypeAn[1];
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        return this.finishNode(node, "DeclareFunction");
      };

      _proto.flowParseDeclare = function flowParseDeclare(node, insideModule) {
        if (this.match(types._class)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(types._function)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(types._var)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual("module")) {
          if (this.match(types.dot)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
            }

            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual("type")) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual("opaque")) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual("interface")) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(types._export)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          throw this.unexpected();
        }
      };

      _proto.flowParseDeclareVariable = function flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      };

      _proto.flowParseDeclareModule = function flowParseDeclareModule(node) {
        var _this2 = this;

        this.scope.enter(SCOPE_OTHER);

        if (this.match(types.string)) {
          node.id = this.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }

        var bodyNode = node.body = this.startNode();
        var body = bodyNode.body = [];
        this.expect(types.braceL);

        while (!this.match(types.braceR)) {
          var _bodyNode = this.startNode();

          if (this.match(types._import)) {
            this.next();

            if (!this.isContextual("type") && !this.match(types._typeof)) {
              this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
            }

            this.parseImport(_bodyNode);
          } else {
            this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule);
            _bodyNode = this.flowParseDeclare(_bodyNode, true);
          }

          body.push(_bodyNode);
        }

        this.scope.exit();
        this.expect(types.braceR);
        this.finishNode(bodyNode, "BlockStatement");
        var kind = null;
        var hasModuleExport = false;
        body.forEach(function (bodyElement) {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              _this2.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
            }

            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              _this2.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
            }

            if (kind === "ES") {
              _this2.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
            }

            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      };

      _proto.flowParseDeclareExportDeclaration = function flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(types._export);

        if (this.eat(types._default)) {
          if (this.match(types._function) || this.match(types._class)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }

          node["default"] = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(types._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
            var label = this.state.value;
            var suggestion = exportSuggestions[label];
            throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
          }

          if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual("opaque")) {
              node.declaration = this.flowParseDeclare(this.startNode());
              node["default"] = false;
              return this.finishNode(node, "DeclareExportDeclaration");
            } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
              node = this.parseExport(node);

              if (node.type === "ExportNamedDeclaration") {
                node.type = "ExportDeclaration";
                node["default"] = false;
                delete node.exportKind;
              }

              node.type = "Declare" + node.type;
              return node;
            }
        }

        throw this.unexpected();
      };

      _proto.flowParseDeclareModuleExports = function flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual("exports");
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      };

      _proto.flowParseDeclareTypeAlias = function flowParseDeclareTypeAlias(node) {
        this.next();
        this.flowParseTypeAlias(node);
        node.type = "DeclareTypeAlias";
        return node;
      };

      _proto.flowParseDeclareOpaqueType = function flowParseDeclareOpaqueType(node) {
        this.next();
        this.flowParseOpaqueType(node, true);
        node.type = "DeclareOpaqueType";
        return node;
      };

      _proto.flowParseDeclareInterface = function flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "DeclareInterface");
      };

      _proto.flowParseInterfaceish = function flowParseInterfaceish(node, isClass) {
        if (isClass === void 0) {
          isClass = false;
        }

        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node["extends"] = [];
        node["implements"] = [];
        node.mixins = [];

        if (this.eat(types._extends)) {
          do {
            node["extends"].push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(types.comma));
        }

        if (this.isContextual("mixins")) {
          this.next();

          do {
            node.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }

        if (this.isContextual("implements")) {
          this.next();

          do {
            node["implements"].push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }

        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      };

      _proto.flowParseInterfaceExtends = function flowParseInterfaceExtends() {
        var node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }

        return this.finishNode(node, "InterfaceExtends");
      };

      _proto.flowParseInterface = function flowParseInterface(node) {
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "InterfaceDeclaration");
      };

      _proto.checkNotUnderscore = function checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
        }
      };

      _proto.checkReservedType = function checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word)) return;
        this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
      };

      _proto.flowParseRestrictedIdentifier = function flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.start, declaration);
        return this.parseIdentifier(liberal);
      };

      _proto.flowParseTypeAlias = function flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node.right = this.flowParseTypeInitialiser(types.eq);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      };

      _proto.flowParseOpaqueType = function flowParseOpaqueType(node, declare) {
        this.expectContextual("type");
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node.supertype = null;

        if (this.match(types.colon)) {
          node.supertype = this.flowParseTypeInitialiser(types.colon);
        }

        node.impltype = null;

        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(types.eq);
        }

        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      };

      _proto.flowParseTypeParameter = function flowParseTypeParameter(requireDefault) {
        if (requireDefault === void 0) {
          requireDefault = false;
        }

        var nodeStart = this.state.start;
        var node = this.startNode();
        var variance = this.flowParseVariance();
        var ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;

        if (this.match(types.eq)) {
          this.eat(types.eq);
          node["default"] = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
          }
        }

        return this.finishNode(node, "TypeParameter");
      };

      _proto.flowParseTypeParameterDeclaration = function flowParseTypeParameterDeclaration() {
        var oldInType = this.state.inType;
        var node = this.startNode();
        node.params = [];
        this.state.inType = true;

        if (this.isRelational("<") || this.match(types.jsxTagStart)) {
          this.next();
        } else {
          this.unexpected();
        }

        var defaultRequired = false;

        do {
          var typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);

          if (typeParameter["default"]) {
            defaultRequired = true;
          }

          if (!this.isRelational(">")) {
            this.expect(types.comma);
          }
        } while (!this.isRelational(">"));

        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      };

      _proto.flowParseTypeParameterInstantiation = function flowParseTypeParameterInstantiation() {
        var node = this.startNode();
        var oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expectRelational("<");
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = false;

        while (!this.isRelational(">")) {
          node.params.push(this.flowParseType());

          if (!this.isRelational(">")) {
            this.expect(types.comma);
          }
        }

        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      };

      _proto.flowParseTypeParameterInstantiationCallOrNew = function flowParseTypeParameterInstantiationCallOrNew() {
        var node = this.startNode();
        var oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expectRelational("<");

        while (!this.isRelational(">")) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());

          if (!this.isRelational(">")) {
            this.expect(types.comma);
          }
        }

        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      };

      _proto.flowParseInterfaceType = function flowParseInterfaceType() {
        var node = this.startNode();
        this.expectContextual("interface");
        node["extends"] = [];

        if (this.eat(types._extends)) {
          do {
            node["extends"].push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }

        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      };

      _proto.flowParseObjectPropertyKey = function flowParseObjectPropertyKey() {
        return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
      };

      _proto.flowParseObjectTypeIndexer = function flowParseObjectTypeIndexer(node, isStatic, variance) {
        node["static"] = isStatic;

        if (this.lookahead().type === types.colon) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }

        this.expect(types.bracketR);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      };

      _proto.flowParseObjectTypeInternalSlot = function flowParseObjectTypeInternalSlot(node, isStatic) {
        node["static"] = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(types.bracketR);
        this.expect(types.bracketR);

        if (this.isRelational("<") || this.match(types.parenL)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
        } else {
          node.method = false;

          if (this.eat(types.question)) {
            node.optional = true;
          }

          node.value = this.flowParseTypeInitialiser();
        }

        return this.finishNode(node, "ObjectTypeInternalSlot");
      };

      _proto.flowParseObjectTypeMethodish = function flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        this.expect(types.parenL);

        while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
          node.params.push(this.flowParseFunctionTypeParam());

          if (!this.match(types.parenR)) {
            this.expect(types.comma);
          }
        }

        if (this.eat(types.ellipsis)) {
          node.rest = this.flowParseFunctionTypeParam();
        }

        this.expect(types.parenR);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      };

      _proto.flowParseObjectTypeCallProperty = function flowParseObjectTypeCallProperty(node, isStatic) {
        var valueNode = this.startNode();
        node["static"] = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      };

      _proto.flowParseObjectType = function flowParseObjectType(_ref) {
        var allowStatic = _ref.allowStatic,
            allowExact = _ref.allowExact,
            allowSpread = _ref.allowSpread,
            allowProto = _ref.allowProto,
            allowInexact = _ref.allowInexact;
        var oldInType = this.state.inType;
        this.state.inType = true;
        var nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        var endDelim;
        var exact;
        var inexact = false;

        if (allowExact && this.match(types.braceBarL)) {
          this.expect(types.braceBarL);
          endDelim = types.braceBarR;
          exact = true;
        } else {
          this.expect(types.braceL);
          endDelim = types.braceR;
          exact = false;
        }

        nodeStart.exact = exact;

        while (!this.match(endDelim)) {
          var isStatic = false;
          var protoStart = null;
          var inexactStart = null;
          var node = this.startNode();

          if (allowProto && this.isContextual("proto")) {
            var lookahead = this.lookahead();

            if (lookahead.type !== types.colon && lookahead.type !== types.question) {
              this.next();
              protoStart = this.state.start;
              allowStatic = false;
            }
          }

          if (allowStatic && this.isContextual("static")) {
            var _lookahead = this.lookahead();

            if (_lookahead.type !== types.colon && _lookahead.type !== types.question) {
              this.next();
              isStatic = true;
            }
          }

          var variance = this.flowParseVariance();

          if (this.eat(types.bracketL)) {
            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (this.eat(types.bracketL)) {
              if (variance) {
                this.unexpected(variance.start);
              }

              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(types.parenL) || this.isRelational("<")) {
            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.unexpected(variance.start);
            }

            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            var kind = "init";

            if (this.isContextual("get") || this.isContextual("set")) {
              var _lookahead2 = this.lookahead();

              if (_lookahead2.type === types.name || _lookahead2.type === types.string || _lookahead2.type === types.num) {
                kind = this.state.value;
                this.next();
              }
            }

            var propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);

            if (propOrInexact === null) {
              inexact = true;
              inexactStart = this.state.lastTokStart;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }

          this.flowObjectTypeSemicolon();

          if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {
            this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
          }
        }

        this.expect(endDelim);

        if (allowSpread) {
          nodeStart.inexact = inexact;
        }

        var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      };

      _proto.flowParseObjectTypeProperty = function flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
        if (this.eat(types.ellipsis)) {
          var isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);

          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
            } else if (!allowInexact) {
              this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
            }

            if (variance) {
              this.raise(variance.start, FlowErrors.InexactVariance);
            }

            return null;
          }

          if (!allowSpread) {
            this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
          }

          if (protoStart != null) {
            this.unexpected(protoStart);
          }

          if (variance) {
            this.raise(variance.start, FlowErrors.SpreadVariance);
          }

          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node["static"] = isStatic;
          node.proto = protoStart != null;
          node.kind = kind;
          var optional = false;

          if (this.isRelational("<") || this.match(types.parenL)) {
            node.method = true;

            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.unexpected(variance.start);
            }

            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
          } else {
            if (kind !== "init") this.unexpected();
            node.method = false;

            if (this.eat(types.question)) {
              optional = true;
            }

            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }

          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      };

      _proto.flowCheckGetterSetterParams = function flowCheckGetterSetterParams(property) {
        var paramCount = property.kind === "get" ? 0 : 1;
        var start = property.start;
        var length = property.value.params.length + (property.value.rest ? 1 : 0);

        if (length !== paramCount) {
          if (property.kind === "get") {
            this.raise(start, Errors.BadGetterArity);
          } else {
            this.raise(start, Errors.BadSetterArity);
          }
        }

        if (property.kind === "set" && property.value.rest) {
          this.raise(start, Errors.BadSetterRestParameter);
        }
      };

      _proto.flowObjectTypeSemicolon = function flowObjectTypeSemicolon() {
        if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
          this.unexpected();
        }
      };

      _proto.flowParseQualifiedTypeIdentifier = function flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
        startPos = startPos || this.state.start;
        startLoc = startLoc || this.state.startLoc;
        var node = id || this.flowParseRestrictedIdentifier(true);

        while (this.eat(types.dot)) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }

        return node;
      };

      _proto.flowParseGenericType = function flowParseGenericType(startPos, startLoc, id) {
        var node = this.startNodeAt(startPos, startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }

        return this.finishNode(node, "GenericTypeAnnotation");
      };

      _proto.flowParseTypeofType = function flowParseTypeofType() {
        var node = this.startNode();
        this.expect(types._typeof);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      };

      _proto.flowParseTupleType = function flowParseTupleType() {
        var node = this.startNode();
        node.types = [];
        this.expect(types.bracketL);

        while (this.state.pos < this.length && !this.match(types.bracketR)) {
          node.types.push(this.flowParseType());
          if (this.match(types.bracketR)) break;
          this.expect(types.comma);
        }

        this.expect(types.bracketR);
        return this.finishNode(node, "TupleTypeAnnotation");
      };

      _proto.flowParseFunctionTypeParam = function flowParseFunctionTypeParam() {
        var name = null;
        var optional = false;
        var typeAnnotation = null;
        var node = this.startNode();
        var lh = this.lookahead();

        if (lh.type === types.colon || lh.type === types.question) {
          name = this.parseIdentifier();

          if (this.eat(types.question)) {
            optional = true;
          }

          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }

        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      };

      _proto.reinterpretTypeAsFunctionTypeParam = function reinterpretTypeAsFunctionTypeParam(type) {
        var node = this.startNodeAt(type.start, type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      };

      _proto.flowParseFunctionTypeParams = function flowParseFunctionTypeParams(params) {
        if (params === void 0) {
          params = [];
        }

        var rest = null;

        while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
          params.push(this.flowParseFunctionTypeParam());

          if (!this.match(types.parenR)) {
            this.expect(types.comma);
          }
        }

        if (this.eat(types.ellipsis)) {
          rest = this.flowParseFunctionTypeParam();
        }

        return {
          params: params,
          rest: rest
        };
      };

      _proto.flowIdentToTypeAnnotation = function flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");

          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");

          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");

          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");

          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");

          case "string":
            return this.finishNode(node, "StringTypeAnnotation");

          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");

          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startPos, startLoc, id);
        }
      };

      _proto.flowParsePrimaryType = function flowParsePrimaryType() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var node = this.startNode();
        var tmp;
        var type;
        var isGroupedType = false;
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;

        switch (this.state.type) {
          case types.name:
            if (this.isContextual("interface")) {
              return this.flowParseInterfaceType();
            }

            return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

          case types.braceL:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });

          case types.braceBarL:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });

          case types.bracketL:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;

          case types.relational:
            if (this.state.value === "<") {
              node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(types.parenL);
              tmp = this.flowParseFunctionTypeParams();
              node.params = tmp.params;
              node.rest = tmp.rest;
              this.expect(types.parenR);
              this.expect(types.arrow);
              node.returnType = this.flowParseType();
              return this.finishNode(node, "FunctionTypeAnnotation");
            }

            break;

          case types.parenL:
            this.next();

            if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
              if (this.match(types.name)) {
                var token = this.lookahead().type;
                isGroupedType = token !== types.question && token !== types.colon;
              } else {
                isGroupedType = true;
              }
            }

            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;

              if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
                this.expect(types.parenR);
                return type;
              } else {
                this.eat(types.comma);
              }
            }

            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }

            node.params = tmp.params;
            node.rest = tmp.rest;
            this.expect(types.parenR);
            this.expect(types.arrow);
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");

          case types.string:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

          case types._true:
          case types._false:
            node.value = this.match(types._true);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");

          case types.plusMin:
            if (this.state.value === "-") {
              this.next();

              if (this.match(types.num)) {
                return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node.start, node.loc.start);
              }

              if (this.match(types.bigint)) {
                return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", node.start, node.loc.start);
              }

              throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
            }

            throw this.unexpected();

          case types.num:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

          case types.bigint:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

          case types._void:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");

          case types._null:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");

          case types._this:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");

          case types.star:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");

          default:
            if (this.state.type.keyword === "typeof") {
              return this.flowParseTypeofType();
            } else if (this.state.type.keyword) {
              var label = this.state.type.label;
              this.next();
              return _superClass.prototype.createIdentifier.call(this, node, label);
            }

        }

        throw this.unexpected();
      };

      _proto.flowParsePostfixType = function flowParsePostfixType() {
        var startPos = this.state.start,
            startLoc = this.state.startLoc;
        var type = this.flowParsePrimaryType();

        while (this.match(types.bracketL) && !this.canInsertSemicolon()) {
          var node = this.startNodeAt(startPos, startLoc);
          node.elementType = type;
          this.expect(types.bracketL);
          this.expect(types.bracketR);
          type = this.finishNode(node, "ArrayTypeAnnotation");
        }

        return type;
      };

      _proto.flowParsePrefixType = function flowParsePrefixType() {
        var node = this.startNode();

        if (this.eat(types.question)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      };

      _proto.flowParseAnonFunctionWithoutParens = function flowParseAnonFunctionWithoutParens() {
        var param = this.flowParsePrefixType();

        if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
          var node = this.startNodeAt(param.start, param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }

        return param;
      };

      _proto.flowParseIntersectionType = function flowParseIntersectionType() {
        var node = this.startNode();
        this.eat(types.bitwiseAND);
        var type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];

        while (this.eat(types.bitwiseAND)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }

        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      };

      _proto.flowParseUnionType = function flowParseUnionType() {
        var node = this.startNode();
        this.eat(types.bitwiseOR);
        var type = this.flowParseIntersectionType();
        node.types = [type];

        while (this.eat(types.bitwiseOR)) {
          node.types.push(this.flowParseIntersectionType());
        }

        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      };

      _proto.flowParseType = function flowParseType() {
        var oldInType = this.state.inType;
        this.state.inType = true;
        var type = this.flowParseUnionType();
        this.state.inType = oldInType;
        this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;
        return type;
      };

      _proto.flowParseTypeOrImplicitInstantiation = function flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === types.name && this.state.value === "_") {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var node = this.parseIdentifier();
          return this.flowParseGenericType(startPos, startLoc, node);
        } else {
          return this.flowParseType();
        }
      };

      _proto.flowParseTypeAnnotation = function flowParseTypeAnnotation() {
        var node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      };

      _proto.flowParseTypeAnnotatableIdentifier = function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

        if (this.match(types.colon)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }

        return ident;
      };

      _proto.typeCastToParameter = function typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
        return node.expression;
      };

      _proto.flowParseVariance = function flowParseVariance() {
        var variance = null;

        if (this.match(types.plusMin)) {
          variance = this.startNode();

          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }

          this.next();
          this.finishNode(variance, "Variance");
        }

        return variance;
      };

      _proto.parseFunctionBody = function parseFunctionBody(node, allowExpressionBody, isMethod) {
        var _this3 = this;

        if (isMethod === void 0) {
          isMethod = false;
        }

        if (allowExpressionBody) {
          return this.forwardNoArrowParamsConversionAt(node, function () {
            return _superClass.prototype.parseFunctionBody.call(_this3, node, true, isMethod);
          });
        }

        return _superClass.prototype.parseFunctionBody.call(this, node, false, isMethod);
      };

      _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }

        if (this.match(types.colon)) {
          var typeNode = this.startNode();

          var _this$flowParseTypeAn2 = this.flowParseTypeAndPredicateInitialiser();

          typeNode.typeAnnotation = _this$flowParseTypeAn2[0];
          node.predicate = _this$flowParseTypeAn2[1];
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }

        _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, isMethod);
      };

      _proto.parseStatement = function parseStatement(context, topLevel) {
        if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
          var node = this.startNode();
          this.next();
          return this.flowParseInterface(node);
        } else if (this.shouldParseEnums() && this.isContextual("enum")) {
          var _node = this.startNode();

          this.next();
          return this.flowParseEnumDeclaration(_node);
        } else {
          var stmt = _superClass.prototype.parseStatement.call(this, context, topLevel);

          if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
            this.flowPragma = null;
          }

          return stmt;
        }
      };

      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {
              return this.flowParseDeclare(node);
            }
          } else if (this.match(types.name)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }

        return _superClass.prototype.parseExpressionStatement.call(this, node, expr);
      };

      _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
        return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || _superClass.prototype.shouldParseExportDeclaration.call(this);
      };

      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
        if (this.match(types.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
          return false;
        }

        return _superClass.prototype.isExportDefaultSpecifier.call(this);
      };

      _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual("enum")) {
          var node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }

        return _superClass.prototype.parseExportDefaultExpression.call(this);
      };

      _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
        var _this4 = this;

        if (!this.match(types.question)) return expr;

        if (refNeedsArrowPos) {
          var result = this.tryParse(function () {
            return _superClass.prototype.parseConditional.call(_this4, expr, noIn, startPos, startLoc);
          });

          if (!result.node) {
            refNeedsArrowPos.start = result.error.pos || this.state.start;
            return expr;
          }

          if (result.error) this.state = result.failState;
          return result.node;
        }

        this.expect(types.question);
        var state = this.state.clone();
        var originalNoArrowAt = this.state.noArrowAt;
        var node = this.startNodeAt(startPos, startLoc);

        var _this$tryParseConditi = this.tryParseConditionalConsequent(),
            consequent = _this$tryParseConditi.consequent,
            failed = _this$tryParseConditi.failed;

        var _this$getArrowLikeExp = this.getArrowLikeExpressions(consequent),
            valid = _this$getArrowLikeExp[0],
            invalid = _this$getArrowLikeExp[1];

        if (failed || invalid.length > 0) {
          var noArrowAt = [].concat(originalNoArrowAt);

          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;

            for (var i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }

            var _this$tryParseConditi2 = this.tryParseConditionalConsequent();

            consequent = _this$tryParseConditi2.consequent;
            failed = _this$tryParseConditi2.failed;

            var _this$getArrowLikeExp2 = this.getArrowLikeExpressions(consequent);

            valid = _this$getArrowLikeExp2[0];
            invalid = _this$getArrowLikeExp2[1];
          }

          if (failed && valid.length > 1) {
            this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
          }

          if (failed && valid.length === 1) {
            this.state = state;
            this.state.noArrowAt = noArrowAt.concat(valid[0].start);

            var _this$tryParseConditi3 = this.tryParseConditionalConsequent();

            consequent = _this$tryParseConditi3.consequent;
            failed = _this$tryParseConditi3.failed;
          }
        }

        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(types.colon);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {
          return _this4.parseMaybeAssign(noIn, undefined, undefined, undefined);
        });
        return this.finishNode(node, "ConditionalExpression");
      };

      _proto.tryParseConditionalConsequent = function tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        var consequent = this.parseMaybeAssign();
        var failed = !this.match(types.colon);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent: consequent,
          failed: failed
        };
      };

      _proto.getArrowLikeExpressions = function getArrowLikeExpressions(node, disallowInvalid) {
        var _this5 = this;

        var stack = [node];
        var arrows = [];

        while (stack.length !== 0) {
          var _node2 = stack.pop();

          if (_node2.type === "ArrowFunctionExpression") {
            if (_node2.typeParameters || !_node2.returnType) {
              this.finishArrowValidation(_node2);
            } else {
              arrows.push(_node2);
            }

            stack.push(_node2.body);
          } else if (_node2.type === "ConditionalExpression") {
            stack.push(_node2.consequent);
            stack.push(_node2.alternate);
          }
        }

        if (disallowInvalid) {
          arrows.forEach(function (node) {
            return _this5.finishArrowValidation(node);
          });
          return [arrows, []];
        }

        return partition(arrows, function (node) {
          return node.params.every(function (param) {
            return _this5.isAssignable(param, true);
          });
        });
      };

      _proto.finishArrowValidation = function finishArrowValidation(node) {
        var _node$extra;

        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma);
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);

        _superClass.prototype.checkParams.call(this, node, false, true);

        this.scope.exit();
      };

      _proto.forwardNoArrowParamsConversionAt = function forwardNoArrowParamsConversionAt(node, parse) {
        var result;

        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse();
        }

        return result;
      };

      _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
        node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);

        if (this.eat(types.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }

        if (this.match(types.colon)) {
          var typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }

        return node;
      };

      _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }

        _superClass.prototype.assertModuleNodeAllowed.call(this, node);
      };

      _proto.parseExport = function parseExport(node) {
        var decl = _superClass.prototype.parseExport.call(this, node);

        if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
          decl.exportKind = decl.exportKind || "value";
        }

        return decl;
      };

      _proto.parseExportDeclaration = function parseExportDeclaration(node) {
        if (this.isContextual("type")) {
          node.exportKind = "type";
          var declarationNode = this.startNode();
          this.next();

          if (this.match(types.braceL)) {
            node.specifiers = this.parseExportSpecifiers();
            this.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual("opaque")) {
          node.exportKind = "type";

          var _declarationNode = this.startNode();

          this.next();
          return this.flowParseOpaqueType(_declarationNode, false);
        } else if (this.isContextual("interface")) {
          node.exportKind = "type";

          var _declarationNode2 = this.startNode();

          this.next();
          return this.flowParseInterface(_declarationNode2);
        } else if (this.shouldParseEnums() && this.isContextual("enum")) {
          node.exportKind = "value";

          var _declarationNode3 = this.startNode();

          this.next();
          return this.flowParseEnumDeclaration(_declarationNode3);
        } else {
          return _superClass.prototype.parseExportDeclaration.call(this, node);
        }
      };

      _proto.eatExportStar = function eatExportStar(node) {
        if (_superClass.prototype.eatExportStar.apply(this, arguments)) return true;

        if (this.isContextual("type") && this.lookahead().type === types.star) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }

        return false;
      };

      _proto.maybeParseExportNamespaceSpecifier = function maybeParseExportNamespaceSpecifier(node) {
        var pos = this.state.start;

        var hasNamespace = _superClass.prototype.maybeParseExportNamespaceSpecifier.call(this, node);

        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(pos);
        }

        return hasNamespace;
      };

      _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
        _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      };

      _proto.parseClassMember = function parseClassMember(classBody, member, state, constructorAllowsSuper) {
        var pos = this.state.start;

        if (this.isContextual("declare")) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }

          member.declare = true;
        }

        _superClass.prototype.parseClassMember.call(this, classBody, member, state, constructorAllowsSuper);

        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty") {
            this.raise(pos, FlowErrors.DeclareClassElement);
          } else if (member.value) {
            this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
          }
        }
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 123 && next === 124) {
          return this.finishOp(types.braceBarL, 2);
        } else if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(types.relational, 1);
        } else if (isIteratorStart(code, next)) {
          this.state.isIterator = true;
          return _superClass.prototype.readWord.call(this);
        } else {
          return _superClass.prototype.getTokenFromCode.call(this, code);
        }
      };

      _proto.isAssignable = function isAssignable(node, isBinding) {
        var _this6 = this;

        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
            return true;

          case "ObjectExpression":
            {
              var last = node.properties.length - 1;
              return node.properties.every(function (prop, i) {
                return prop.type !== "ObjectMethod" && (i === last || prop.type === "SpreadElement") && _this6.isAssignable(prop);
              });
            }

          case "ObjectProperty":
            return this.isAssignable(node.value);

          case "SpreadElement":
            return this.isAssignable(node.argument);

          case "ArrayExpression":
            return node.elements.every(function (element) {
              return _this6.isAssignable(element);
            });

          case "AssignmentExpression":
            return node.operator === "=";

          case "ParenthesizedExpression":
          case "TypeCastExpression":
            return this.isAssignable(node.expression);

          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;

          default:
            return false;
        }
      };

      _proto.toAssignable = function toAssignable(node) {
        if (node.type === "TypeCastExpression") {
          return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node));
        } else {
          return _superClass.prototype.toAssignable.call(this, node);
        }
      };

      _proto.toAssignableList = function toAssignableList(exprList, trailingCommaPos) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];

          if (expr && expr.type === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }

        return _superClass.prototype.toAssignableList.call(this, exprList, trailingCommaPos);
      };

      _proto.toReferencedList = function toReferencedList(exprList, isParenthesizedExpr) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];

          if (expr && expr.type === "TypeCastExpression" && (!expr.extra || !expr.extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
          }
        }

        return exprList;
      };

      _proto.checkLVal = function checkLVal(expr, bindingType, checkClashes, contextDescription) {
        if (bindingType === void 0) {
          bindingType = BIND_NONE;
        }

        if (expr.type !== "TypeCastExpression") {
          return _superClass.prototype.checkLVal.call(this, expr, bindingType, checkClashes, contextDescription);
        }
      };

      _proto.parseClassProperty = function parseClassProperty(node) {
        if (this.match(types.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }

        return _superClass.prototype.parseClassProperty.call(this, node);
      };

      _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
        if (this.match(types.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }

        return _superClass.prototype.parseClassPrivateProperty.call(this, node);
      };

      _proto.isClassMethod = function isClassMethod() {
        return this.isRelational("<") || _superClass.prototype.isClassMethod.call(this);
      };

      _proto.isClassProperty = function isClassProperty() {
        return this.match(types.colon) || _superClass.prototype.isClassProperty.call(this);
      };

      _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
        return !this.match(types.colon) && _superClass.prototype.isNonstaticConstructor.call(this, method);
      };

      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.start);
        }

        delete method.variance;

        if (this.isRelational("<")) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      };

      _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.start);
        }

        delete method.variance;

        if (this.isRelational("<")) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
      };

      _proto.parseClassSuper = function parseClassSuper(node) {
        _superClass.prototype.parseClassSuper.call(this, node);

        if (node.superClass && this.isRelational("<")) {
          node.superTypeParameters = this.flowParseTypeParameterInstantiation();
        }

        if (this.isContextual("implements")) {
          this.next();
          var implemented = node["implements"] = [];

          do {
            var _node3 = this.startNode();

            _node3.id = this.flowParseRestrictedIdentifier(true);

            if (this.isRelational("<")) {
              _node3.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              _node3.typeParameters = null;
            }

            implemented.push(this.finishNode(_node3, "ClassImplements"));
          } while (this.eat(types.comma));
        }
      };

      _proto.parsePropertyName = function parsePropertyName(node, isPrivateNameAllowed) {
        var variance = this.flowParseVariance();

        var key = _superClass.prototype.parsePropertyName.call(this, node, isPrivateNameAllowed);

        node.variance = variance;
        return key;
      };

      _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc) {
        if (prop.variance) {
          this.unexpected(prop.variance.start);
        }

        delete prop.variance;
        var typeParameters;

        if (this.isRelational("<")) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(types.parenL)) this.unexpected();
        }

        _superClass.prototype.parseObjPropValue.call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc);

        if (typeParameters) {
          (prop.value || prop).typeParameters = typeParameters;
        }
      };

      _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
        if (this.eat(types.question)) {
          if (param.type !== "Identifier") {
            this.raise(param.start, FlowErrors.OptionalBindingPattern);
          }

          param.optional = true;
        }

        if (this.match(types.colon)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        }

        this.resetEndLocation(param);
        return param;
      };

      _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {
        var node = _superClass.prototype.parseMaybeDefault.call(this, startPos, startLoc, left);

        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
        }

        return node;
      };

      _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {
        if (!hasTypeImportKind(node)) {
          return _superClass.prototype.shouldParseDefaultImport.call(this, node);
        }

        return isMaybeDefaultImport(this.state);
      };

      _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);
        node.specifiers.push(this.finishNode(specifier, type));
      };

      _proto.maybeParseDefaultImportSpecifier = function maybeParseDefaultImportSpecifier(node) {
        node.importKind = "value";
        var kind = null;

        if (this.match(types._typeof)) {
          kind = "typeof";
        } else if (this.isContextual("type")) {
          kind = "type";
        }

        if (kind) {
          var lh = this.lookahead();

          if (kind === "type" && lh.type === types.star) {
            this.unexpected(lh.start);
          }

          if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {
            this.next();
            node.importKind = kind;
          }
        }

        return _superClass.prototype.maybeParseDefaultImportSpecifier.call(this, node);
      };

      _proto.parseImportSpecifier = function parseImportSpecifier(node) {
        var specifier = this.startNode();
        var firstIdentLoc = this.state.start;
        var firstIdent = this.parseIdentifier(true);
        var specifierTypeKind = null;

        if (firstIdent.name === "type") {
          specifierTypeKind = "type";
        } else if (firstIdent.name === "typeof") {
          specifierTypeKind = "typeof";
        }

        var isBinding = false;

        if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
          var as_ident = this.parseIdentifier(true);

          if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = as_ident.__clone();
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
          specifier.imported = this.parseIdentifier(true);
          specifier.importKind = specifierTypeKind;

          if (this.eatContextual("as")) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = specifier.imported.__clone();
          }
        } else {
          isBinding = true;
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = specifier.imported.__clone();
        }

        var nodeIsTypeImport = hasTypeImportKind(node);
        var specifierIsTypeImport = hasTypeImportKind(specifier);

        if (nodeIsTypeImport && specifierIsTypeImport) {
          this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport);
        }

        if (nodeIsTypeImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.start, true);
        }

        if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.start, true, true);
        }

        this.checkLVal(specifier.local, BIND_LEXICAL, undefined, "import specifier");
        node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
      };

      _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
        var kind = node.kind;

        if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);
      };

      _proto.parseVarId = function parseVarId(decl, kind) {
        _superClass.prototype.parseVarId.call(this, decl, kind);

        if (this.match(types.colon)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      };

      _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types.colon)) {
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }

        return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
      };

      _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
        return this.match(types.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);
      };

      _proto.parseMaybeAssign = function parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
        var _this7 = this;

        var state = null;
        var jsx;

        if (this.hasPlugin("jsx") && (this.match(types.jsxTagStart) || this.isRelational("<"))) {
          state = this.state.clone();
          jsx = this.tryParse(function () {
            return _superClass.prototype.parseMaybeAssign.call(_this7, noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos);
          }, state);
          if (!jsx.error) return jsx.node;
          var context = this.state.context;

          if (context[context.length - 1] === types$1.j_oTag) {
            context.length -= 2;
          } else if (context[context.length - 1] === types$1.j_expr) {
            context.length -= 1;
          }
        }

        if (jsx && jsx.error || this.isRelational("<")) {
          state = state || this.state.clone();
          var typeParameters;
          var arrow = this.tryParse(function () {
            typeParameters = _this7.flowParseTypeParameterDeclaration();

            var arrowExpression = _this7.forwardNoArrowParamsConversionAt(typeParameters, function () {
              return _superClass.prototype.parseMaybeAssign.call(_this7, noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos);
            });

            arrowExpression.typeParameters = typeParameters;

            _this7.resetStartLocationFromNode(arrowExpression, typeParameters);

            return arrowExpression;
          }, state);
          var arrowExpression = arrow.node && arrow.node.type === "ArrowFunctionExpression" ? arrow.node : null;
          if (!arrow.error && arrowExpression) return arrowExpression;

          if (jsx && jsx.node) {
            this.state = jsx.failState;
            return jsx.node;
          }

          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }

          if (jsx && jsx.thrown) throw jsx.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
        }

        return _superClass.prototype.parseMaybeAssign.call(this, noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos);
      };

      _proto.parseArrow = function parseArrow(node) {
        var _this8 = this;

        if (this.match(types.colon)) {
          var result = this.tryParse(function () {
            var oldNoAnonFunctionType = _this8.state.noAnonFunctionType;
            _this8.state.noAnonFunctionType = true;

            var typeNode = _this8.startNode();

            var _this8$flowParseTypeA = _this8.flowParseTypeAndPredicateInitialiser();

            typeNode.typeAnnotation = _this8$flowParseTypeA[0];
            node.predicate = _this8$flowParseTypeA[1];
            _this8.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (_this8.canInsertSemicolon()) _this8.unexpected();
            if (!_this8.match(types.arrow)) _this8.unexpected();
            return typeNode;
          });
          if (result.thrown) return null;
          if (result.error) this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }

        return _superClass.prototype.parseArrow.call(this, node);
      };

      _proto.shouldParseArrow = function shouldParseArrow() {
        return this.match(types.colon) || _superClass.prototype.shouldParseArrow.call(this);
      };

      _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          node.params = params;
        } else {
          _superClass.prototype.setArrowFunctionParameters.call(this, node, params);
        }
      };

      _proto.checkParams = function checkParams(node, allowDuplicates, isArrowFunction) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          return;
        }

        return _superClass.prototype.checkParams.apply(this, arguments);
      };

      _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
        return _superClass.prototype.parseParenAndDistinguishExpression.call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
      };

      _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {
        var _this9 = this;

        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
          this.next();
          var node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.arguments = this.parseCallExpressionArguments(types.parenR, false);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
          var state = this.state.clone();
          var arrow = this.tryParse(function (abort) {
            return _this9.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort();
          }, state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          var result = this.tryParse(function () {
            return _superClass.prototype.parseSubscripts.call(_this9, base, startPos, startLoc, noCalls);
          }, state);
          if (result.node && !result.error) return result.node;

          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }

          if (result.node) {
            this.state = result.failState;
            return result.node;
          }

          throw arrow.error || result.error;
        }

        return _superClass.prototype.parseSubscripts.call(this, base, startPos, startLoc, noCalls);
      };

      _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
        var _this10 = this;

        if (this.match(types.questionDot) && this.isLookaheadRelational("<")) {
          subscriptState.optionalChainMember = true;

          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }

          this.next();
          var node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiation();
          this.expect(types.parenL);
          node.arguments = this.parseCallExpressionArguments(types.parenR, false);
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
          var _node4 = this.startNodeAt(startPos, startLoc);

          _node4.callee = base;
          var result = this.tryParse(function () {
            _node4.typeArguments = _this10.flowParseTypeParameterInstantiationCallOrNew();

            _this10.expect(types.parenL);

            _node4.arguments = _this10.parseCallExpressionArguments(types.parenR, false);
            if (subscriptState.optionalChainMember) _node4.optional = false;
            return _this10.finishCallExpression(_node4, subscriptState.optionalChainMember);
          });

          if (result.node) {
            if (result.error) this.state = result.failState;
            return result.node;
          }
        }

        return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, subscriptState);
      };

      _proto.parseNewArguments = function parseNewArguments(node) {
        var _this11 = this;

        var targs = null;

        if (this.shouldParseTypes() && this.isRelational("<")) {
          targs = this.tryParse(function () {
            return _this11.flowParseTypeParameterInstantiationCallOrNew();
          }).node;
        }

        node.typeArguments = targs;

        _superClass.prototype.parseNewArguments.call(this, node);
      };

      _proto.parseAsyncArrowWithTypeParameters = function parseAsyncArrowWithTypeParameters(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);
        this.parseFunctionParams(node);
        if (!this.parseArrow(node)) return;
        return this.parseArrowExpression(node, undefined, true);
      };

      _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }

        _superClass.prototype.readToken_mult_modulo.call(this, code);
      };

      _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 124 && next === 125) {
          this.finishOp(types.braceBarR, 2);
          return;
        }

        _superClass.prototype.readToken_pipe_amp.call(this, code);
      };

      _proto.parseTopLevel = function parseTopLevel(file, program) {
        var fileNode = _superClass.prototype.parseTopLevel.call(this, file, program);

        if (this.state.hasFlowComment) {
          this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
        }

        return fileNode;
      };

      _proto.skipBlockComment = function skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            this.unexpected(null, FlowErrors.NestedFlowComment);
          }

          this.hasFlowCommentCompletion();
          this.state.pos += this.skipFlowComment();
          this.state.hasFlowComment = true;
          return;
        }

        if (this.state.hasFlowComment) {
          var end = this.input.indexOf("*-/", this.state.pos += 2);

          if (end === -1) {
            throw this.raise(this.state.pos - 2, Errors.UnterminatedComment);
          }

          this.state.pos = end + 3;
          return;
        }

        _superClass.prototype.skipBlockComment.call(this);
      };

      _proto.skipFlowComment = function skipFlowComment() {
        var pos = this.state.pos;
        var shiftToFirstNonWhiteSpace = 2;

        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }

        var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }

        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }

        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }

        return false;
      };

      _proto.hasFlowCommentCompletion = function hasFlowCommentCompletion() {
        var end = this.input.indexOf("*/", this.state.pos);

        if (end === -1) {
          throw this.raise(this.state.pos, Errors.UnterminatedComment);
        }
      };

      _proto.flowEnumErrorBooleanMemberNotInitialized = function flowEnumErrorBooleanMemberNotInitialized(pos, _ref2) {
        var enumName = _ref2.enumName,
            memberName = _ref2.memberName;
        this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
      };

      _proto.flowEnumErrorInvalidMemberName = function flowEnumErrorInvalidMemberName(pos, _ref3) {
        var enumName = _ref3.enumName,
            memberName = _ref3.memberName;
        var suggestion = memberName[0].toUpperCase() + memberName.slice(1);
        this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
      };

      _proto.flowEnumErrorDuplicateMemberName = function flowEnumErrorDuplicateMemberName(pos, _ref4) {
        var enumName = _ref4.enumName,
            memberName = _ref4.memberName;
        this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
      };

      _proto.flowEnumErrorInconsistentMemberValues = function flowEnumErrorInconsistentMemberValues(pos, _ref5) {
        var enumName = _ref5.enumName;
        this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
      };

      _proto.flowEnumErrorInvalidExplicitType = function flowEnumErrorInvalidExplicitType(pos, _ref6) {
        var enumName = _ref6.enumName,
            suppliedType = _ref6.suppliedType;
        return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
      };

      _proto.flowEnumErrorInvalidMemberInitializer = function flowEnumErrorInvalidMemberInitializer(pos, _ref7) {
        var enumName = _ref7.enumName,
            explicitType = _ref7.explicitType,
            memberName = _ref7.memberName;
        var message = null;

        switch (explicitType) {
          case "boolean":
          case "number":
          case "string":
            message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
            break;

          case "symbol":
            message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
            break;

          default:
            message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
        }

        return this.raise(pos, message, enumName, memberName, explicitType);
      };

      _proto.flowEnumErrorNumberMemberNotInitialized = function flowEnumErrorNumberMemberNotInitialized(pos, _ref8) {
        var enumName = _ref8.enumName,
            memberName = _ref8.memberName;
        this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
      };

      _proto.flowEnumErrorStringMemberInconsistentlyInitailized = function flowEnumErrorStringMemberInconsistentlyInitailized(pos, _ref9) {
        var enumName = _ref9.enumName;
        this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
      };

      _proto.flowEnumMemberInit = function flowEnumMemberInit() {
        var _this12 = this;

        var startPos = this.state.start;

        var endOfInit = function endOfInit() {
          return _this12.match(types.comma) || _this12.match(types.braceR);
        };

        switch (this.state.type) {
          case types.num:
            {
              var literal = this.parseLiteral(this.state.value, "NumericLiteral");

              if (endOfInit()) {
                return {
                  type: "number",
                  pos: literal.start,
                  value: literal
                };
              }

              return {
                type: "invalid",
                pos: startPos
              };
            }

          case types.string:
            {
              var _literal = this.parseLiteral(this.state.value, "StringLiteral");

              if (endOfInit()) {
                return {
                  type: "string",
                  pos: _literal.start,
                  value: _literal
                };
              }

              return {
                type: "invalid",
                pos: startPos
              };
            }

          case types._true:
          case types._false:
            {
              var _literal2 = this.parseBooleanLiteral();

              if (endOfInit()) {
                return {
                  type: "boolean",
                  pos: _literal2.start,
                  value: _literal2
                };
              }

              return {
                type: "invalid",
                pos: startPos
              };
            }

          default:
            return {
              type: "invalid",
              pos: startPos
            };
        }
      };

      _proto.flowEnumMemberRaw = function flowEnumMemberRaw() {
        var pos = this.state.start;
        var id = this.parseIdentifier(true);
        var init = this.eat(types.eq) ? this.flowEnumMemberInit() : {
          type: "none",
          pos: pos
        };
        return {
          id: id,
          init: init
        };
      };

      _proto.flowEnumCheckExplicitTypeMismatch = function flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
        var explicitType = context.explicitType;

        if (explicitType === null) {
          return;
        }

        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(pos, context);
        }
      };

      _proto.flowEnumMembers = function flowEnumMembers(_ref10) {
        var enumName = _ref10.enumName,
            explicitType = _ref10.explicitType;
        var seenNames = new Set();
        var members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };

        while (!this.match(types.braceR)) {
          var memberNode = this.startNode();

          var _this$flowEnumMemberR = this.flowEnumMemberRaw(),
              id = _this$flowEnumMemberR.id,
              init = _this$flowEnumMemberR.init;

          var memberName = id.name;

          if (memberName === "") {
            continue;
          }

          if (/^[a-z]/.test(memberName)) {
            this.flowEnumErrorInvalidMemberName(id.start, {
              enumName: enumName,
              memberName: memberName
            });
          }

          if (seenNames.has(memberName)) {
            this.flowEnumErrorDuplicateMemberName(id.start, {
              enumName: enumName,
              memberName: memberName
            });
          }

          seenNames.add(memberName);
          var context = {
            enumName: enumName,
            explicitType: explicitType,
            memberName: memberName
          };
          memberNode.id = id;

          switch (init.type) {
            case "boolean":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
                memberNode.init = init.value;
                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                break;
              }

            case "number":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
                memberNode.init = init.value;
                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                break;
              }

            case "string":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
                memberNode.init = init.value;
                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                break;
              }

            case "invalid":
              {
                throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
              }

            case "none":
              {
                switch (explicitType) {
                  case "boolean":
                    this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                    break;

                  case "number":
                    this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                    break;

                  default:
                    members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                }
              }
          }

          if (!this.match(types.braceR)) {
            this.expect(types.comma);
          }
        }

        return members;
      };

      _proto.flowEnumStringMembers = function flowEnumStringMembers(initializedMembers, defaultedMembers, _ref11) {
        var enumName = _ref11.enumName;

        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (var _i2 = 0; _i2 < initializedMembers.length; _i2++) {
            var member = initializedMembers[_i2];
            this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
              enumName: enumName
            });
          }

          return defaultedMembers;
        } else {
          for (var _i4 = 0; _i4 < defaultedMembers.length; _i4++) {
            var _member = defaultedMembers[_i4];
            this.flowEnumErrorStringMemberInconsistentlyInitailized(_member.start, {
              enumName: enumName
            });
          }

          return initializedMembers;
        }
      };

      _proto.flowEnumParseExplicitType = function flowEnumParseExplicitType(_ref12) {
        var enumName = _ref12.enumName;

        if (this.eatContextual("of")) {
          if (!this.match(types.name)) {
            throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
              enumName: enumName,
              suppliedType: null
            });
          }

          var value = this.state.value;
          this.next();

          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.flowEnumErrorInvalidExplicitType(this.state.start, {
              enumName: enumName,
              suppliedType: value
            });
          }

          return value;
        }

        return null;
      };

      _proto.flowEnumBody = function flowEnumBody(node, _ref13) {
        var _this13 = this;

        var enumName = _ref13.enumName,
            nameLoc = _ref13.nameLoc;
        var explicitType = this.flowEnumParseExplicitType({
          enumName: enumName
        });
        this.expect(types.braceL);
        var members = this.flowEnumMembers({
          enumName: enumName,
          explicitType: explicitType
        });

        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(types.braceR);
            return this.finishNode(node, "EnumBooleanBody");

          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(types.braceR);
            return this.finishNode(node, "EnumNumberBody");

          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName: enumName
            });
            this.expect(types.braceR);
            return this.finishNode(node, "EnumStringBody");

          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(types.braceR);
            return this.finishNode(node, "EnumSymbolBody");

          default:
            {
              var empty = function empty() {
                node.members = [];

                _this13.expect(types.braceR);

                return _this13.finishNode(node, "EnumStringBody");
              };

              node.explicitType = false;
              var boolsLen = members.booleanMembers.length;
              var numsLen = members.numberMembers.length;
              var strsLen = members.stringMembers.length;
              var defaultedLen = members.defaultedMembers.length;

              if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                return empty();
              } else if (!boolsLen && !numsLen) {
                node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                  enumName: enumName
                });
                this.expect(types.braceR);
                return this.finishNode(node, "EnumStringBody");
              } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                for (var _i6 = 0, _members$defaultedMem2 = members.defaultedMembers; _i6 < _members$defaultedMem2.length; _i6++) {
                  var member = _members$defaultedMem2[_i6];
                  this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                    enumName: enumName,
                    memberName: member.id.name
                  });
                }

                node.members = members.booleanMembers;
                this.expect(types.braceR);
                return this.finishNode(node, "EnumBooleanBody");
              } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                for (var _i8 = 0, _members$defaultedMem4 = members.defaultedMembers; _i8 < _members$defaultedMem4.length; _i8++) {
                  var _member2 = _members$defaultedMem4[_i8];
                  this.flowEnumErrorNumberMemberNotInitialized(_member2.start, {
                    enumName: enumName,
                    memberName: _member2.id.name
                  });
                }

                node.members = members.numberMembers;
                this.expect(types.braceR);
                return this.finishNode(node, "EnumNumberBody");
              } else {
                this.flowEnumErrorInconsistentMemberValues(nameLoc, {
                  enumName: enumName
                });
                return empty();
              }
            }
        }
      };

      _proto.flowParseEnumDeclaration = function flowParseEnumDeclaration(node) {
        var id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), {
          enumName: id.name,
          nameLoc: id.start
        });
        return this.finishNode(node, "EnumDeclaration");
      };

      return _class;
    }(superClass);
  });

  var entities = {
    quot: "\"",
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    "int": "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  };

  var HEX_NUMBER = /^[\da-fA-F]+$/;
  var DECIMAL_NUMBER = /^\d+$/;
  var JsxErrors = Object.freeze({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression",
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>",
    MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>",
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text",
    UnterminatedJsxContent: "Unterminated JSX contents",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  types$1.j_oTag = new TokContext("<tag", false);
  types$1.j_cTag = new TokContext("</tag", false);
  types$1.j_expr = new TokContext("<tag>...</tag>", true, true);
  types.jsxName = new TokenType("jsxName");
  types.jsxText = new TokenType("jsxText", {
    beforeExpr: true
  });
  types.jsxTagStart = new TokenType("jsxTagStart", {
    startsExpr: true
  });
  types.jsxTagEnd = new TokenType("jsxTagEnd");

  types.jsxTagStart.updateContext = function () {
    this.state.context.push(types$1.j_expr);
    this.state.context.push(types$1.j_oTag);
    this.state.exprAllowed = false;
  };

  types.jsxTagEnd.updateContext = function (prevType) {
    var out = this.state.context.pop();

    if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
      this.state.context.pop();
      this.state.exprAllowed = this.curContext() === types$1.j_expr;
    } else {
      this.state.exprAllowed = true;
    }
  };

  function isFragment(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
  }

  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }

    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ":" + object.name.name;
    }

    if (object.type === "JSXMemberExpression") {
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }

    throw new Error("Node had unexpected type: " + object.type);
  }

  var jsx = (function (superClass) {
    return function (_superClass) {
      _inheritsLoose(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.jsxReadToken = function jsxReadToken() {
        var out = "";
        var chunkStart = this.state.pos;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
          }

          var ch = this.input.charCodeAt(this.state.pos);

          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.exprAllowed) {
                  ++this.state.pos;
                  return this.finishToken(types.jsxTagStart);
                }

                return _superClass.prototype.getTokenFromCode.call(this, ch);
              }

              out += this.input.slice(chunkStart, this.state.pos);
              return this.finishToken(types.jsxText, out);

            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;

            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }

          }
        }
      };

      _proto.jsxReadNewLine = function jsxReadNewLine(normalizeCRLF) {
        var ch = this.input.charCodeAt(this.state.pos);
        var out;
        ++this.state.pos;

        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }

        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      };

      _proto.jsxReadString = function jsxReadString(quote) {
        var out = "";
        var chunkStart = ++this.state.pos;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, Errors.UnterminatedString);
          }

          var ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;

          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }

        out += this.input.slice(chunkStart, this.state.pos++);
        return this.finishToken(types.string, out);
      };

      _proto.jsxReadEntity = function jsxReadEntity() {
        var str = "";
        var count = 0;
        var entity;
        var ch = this.input[this.state.pos];
        var startPos = ++this.state.pos;

        while (this.state.pos < this.length && count++ < 10) {
          ch = this.input[this.state.pos++];

          if (ch === ";") {
            if (str[0] === "#") {
              if (str[1] === "x") {
                str = str.substr(2);

                if (HEX_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 16));
                }
              } else {
                str = str.substr(1);

                if (DECIMAL_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 10));
                }
              }
            } else {
              entity = entities[str];
            }

            break;
          }

          str += ch;
        }

        if (!entity) {
          this.state.pos = startPos;
          return "&";
        }

        return entity;
      };

      _proto.jsxReadWord = function jsxReadWord() {
        var ch;
        var start = this.state.pos;

        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);

        return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
      };

      _proto.jsxParseIdentifier = function jsxParseIdentifier() {
        var node = this.startNode();

        if (this.match(types.jsxName)) {
          node.name = this.state.value;
        } else if (this.state.type.keyword) {
          node.name = this.state.type.keyword;
        } else {
          this.unexpected();
        }

        this.next();
        return this.finishNode(node, "JSXIdentifier");
      };

      _proto.jsxParseNamespacedName = function jsxParseNamespacedName() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var name = this.jsxParseIdentifier();
        if (!this.eat(types.colon)) return name;
        var node = this.startNodeAt(startPos, startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      };

      _proto.jsxParseElementName = function jsxParseElementName() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var node = this.jsxParseNamespacedName();

        if (node.type === "JSXNamespacedName") {
          return node;
        }

        while (this.eat(types.dot)) {
          var newNode = this.startNodeAt(startPos, startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }

        return node;
      };

      _proto.jsxParseAttributeValue = function jsxParseAttributeValue() {
        var node;

        switch (this.state.type) {
          case types.braceL:
            node = this.startNode();
            this.next();
            node = this.jsxParseExpressionContainer(node);

            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(node.start, JsxErrors.AttributeIsEmpty);
            }

            return node;

          case types.jsxTagStart:
          case types.string:
            return this.parseExprAtom();

          default:
            throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
        }
      };

      _proto.jsxParseEmptyExpression = function jsxParseEmptyExpression() {
        var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
      };

      _proto.jsxParseSpreadChild = function jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.expect(types.braceR);
        return this.finishNode(node, "JSXSpreadChild");
      };

      _proto.jsxParseExpressionContainer = function jsxParseExpressionContainer(node) {
        if (this.match(types.braceR)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          node.expression = this.parseExpression();
        }

        this.expect(types.braceR);
        return this.finishNode(node, "JSXExpressionContainer");
      };

      _proto.jsxParseAttribute = function jsxParseAttribute() {
        var node = this.startNode();

        if (this.eat(types.braceL)) {
          this.expect(types.ellipsis);
          node.argument = this.parseMaybeAssign();
          this.expect(types.braceR);
          return this.finishNode(node, "JSXSpreadAttribute");
        }

        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      };

      _proto.jsxParseOpeningElementAt = function jsxParseOpeningElementAt(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);

        if (this.match(types.jsxTagEnd)) {
          this.expect(types.jsxTagEnd);
          return this.finishNode(node, "JSXOpeningFragment");
        }

        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      };

      _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
        var attributes = [];

        while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
          attributes.push(this.jsxParseAttribute());
        }

        node.attributes = attributes;
        node.selfClosing = this.eat(types.slash);
        this.expect(types.jsxTagEnd);
        return this.finishNode(node, "JSXOpeningElement");
      };

      _proto.jsxParseClosingElementAt = function jsxParseClosingElementAt(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);

        if (this.match(types.jsxTagEnd)) {
          this.expect(types.jsxTagEnd);
          return this.finishNode(node, "JSXClosingFragment");
        }

        node.name = this.jsxParseElementName();
        this.expect(types.jsxTagEnd);
        return this.finishNode(node, "JSXClosingElement");
      };

      _proto.jsxParseElementAt = function jsxParseElementAt(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);
        var children = [];
        var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
        var closingElement = null;

        if (!openingElement.selfClosing) {
          contents: for (;;) {
            switch (this.state.type) {
              case types.jsxTagStart:
                startPos = this.state.start;
                startLoc = this.state.startLoc;
                this.next();

                if (this.eat(types.slash)) {
                  closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                  break contents;
                }

                children.push(this.jsxParseElementAt(startPos, startLoc));
                break;

              case types.jsxText:
                children.push(this.parseExprAtom());
                break;

              case types.braceL:
                {
                  var _node = this.startNode();

                  this.next();

                  if (this.match(types.ellipsis)) {
                    children.push(this.jsxParseSpreadChild(_node));
                  } else {
                    children.push(this.jsxParseExpressionContainer(_node));
                  }

                  break;
                }

              default:
                throw this.unexpected();
            }
          }

          if (isFragment(openingElement) && !isFragment(closingElement)) {
            this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
            }
          }
        }

        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }

        node.children = children;

        if (this.isRelational("<")) {
          throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
        }

        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      };

      _proto.jsxParseElement = function jsxParseElement() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startPos, startLoc);
      };

      _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
        if (this.match(types.jsxText)) {
          return this.parseLiteral(this.state.value, "JSXText");
        } else if (this.match(types.jsxTagStart)) {
          return this.jsxParseElement();
        } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
          this.finishToken(types.jsxTagStart);
          return this.jsxParseElement();
        } else {
          return _superClass.prototype.parseExprAtom.call(this, refExpressionErrors);
        }
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        if (this.state.inPropertyName) return _superClass.prototype.getTokenFromCode.call(this, code);
        var context = this.curContext();

        if (context === types$1.j_expr) {
          return this.jsxReadToken();
        }

        if (context === types$1.j_oTag || context === types$1.j_cTag) {
          if (isIdentifierStart(code)) {
            return this.jsxReadWord();
          }

          if (code === 62) {
            ++this.state.pos;
            return this.finishToken(types.jsxTagEnd);
          }

          if ((code === 34 || code === 39) && context === types$1.j_oTag) {
            return this.jsxReadString(code);
          }
        }

        if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          return this.finishToken(types.jsxTagStart);
        }

        return _superClass.prototype.getTokenFromCode.call(this, code);
      };

      _proto.updateContext = function updateContext(prevType) {
        if (this.match(types.braceL)) {
          var curContext = this.curContext();

          if (curContext === types$1.j_oTag) {
            this.state.context.push(types$1.braceExpression);
          } else if (curContext === types$1.j_expr) {
            this.state.context.push(types$1.templateQuasi);
          } else {
            _superClass.prototype.updateContext.call(this, prevType);
          }

          this.state.exprAllowed = true;
        } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
          this.state.context.length -= 2;
          this.state.context.push(types$1.j_cTag);
          this.state.exprAllowed = false;
        } else {
          return _superClass.prototype.updateContext.call(this, prevType);
        }
      };

      return _class;
    }(superClass);
  });

  var Scope$2 = function Scope(flags) {
    this["var"] = [];
    this.lexical = [];
    this.functions = [];
    this.flags = flags;
  };

  var ScopeHandler = function () {
    function ScopeHandler(raise, inModule) {
      this.scopeStack = [];
      this.undefinedExports = new Map();
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
      this.inModule = inModule;
    }

    var _proto = ScopeHandler.prototype;

    _proto.createScope = function createScope(flags) {
      return new Scope$2(flags);
    };

    _proto.enter = function enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    };

    _proto.exit = function exit() {
      this.scopeStack.pop();
    };

    _proto.treatFunctionsAsVarInScope = function treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
    };

    _proto.declareName = function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);

        if (bindingType & BIND_SCOPE_FUNCTION) {
          scope.functions.push(name);
        } else {
          scope.lexical.push(name);
        }

        if (bindingType & BIND_SCOPE_LEXICAL) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & BIND_SCOPE_VAR) {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          scope["var"].push(name);
          this.maybeExportDefined(scope, name);
          if (scope.flags & SCOPE_VAR) break;
        }
      }

      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports["delete"](name);
      }
    };

    _proto.maybeExportDefined = function maybeExportDefined(scope, name) {
      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports["delete"](name);
      }
    };

    _proto.checkRedeclarationInScope = function checkRedeclarationInScope(scope, name, bindingType, pos) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.raise(pos, Errors.VarRedeclaration, name);
      }
    };

    _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & BIND_KIND_VALUE)) return false;

      if (bindingType & BIND_SCOPE_LEXICAL) {
        return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope["var"].indexOf(name) > -1;
      }

      if (bindingType & BIND_SCOPE_FUNCTION) {
        return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope["var"].indexOf(name) > -1;
      }

      return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;
    };

    _proto.checkLocalExport = function checkLocalExport(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0]["var"].indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {
        this.undefinedExports.set(id.name, id.start);
      }
    };

    _proto.currentScope = function currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    };

    _proto.currentVarScope = function currentVarScope() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];

        if (scope.flags & SCOPE_VAR) {
          return scope;
        }
      }
    };

    _proto.currentThisScope = function currentThisScope() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];

        if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {
          return scope;
        }
      }
    };

    _createClass(ScopeHandler, [{
      key: "inFunction",
      get: function get() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      }
    }, {
      key: "allowSuper",
      get: function get() {
        return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
      }
    }, {
      key: "allowDirectSuper",
      get: function get() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      }
    }, {
      key: "inClass",
      get: function get() {
        return (this.currentThisScope().flags & SCOPE_CLASS) > 0;
      }
    }, {
      key: "inNonArrowFunction",
      get: function get() {
        return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
      }
    }, {
      key: "treatFunctionsAsVar",
      get: function get() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
    }]);

    return ScopeHandler;
  }();

  var TypeScriptScope = function (_Scope) {
    _inheritsLoose(TypeScriptScope, _Scope);

    function TypeScriptScope() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _Scope.call.apply(_Scope, [this].concat(args)) || this;
      _this.types = [];
      _this.enums = [];
      _this.constEnums = [];
      _this.classes = [];
      _this.exportOnlyBindings = [];
      return _this;
    }

    return TypeScriptScope;
  }(Scope$2);

  var TypeScriptScopeHandler = function (_ScopeHandler) {
    _inheritsLoose(TypeScriptScopeHandler, _ScopeHandler);

    function TypeScriptScopeHandler() {
      return _ScopeHandler.apply(this, arguments) || this;
    }

    var _proto = TypeScriptScopeHandler.prototype;

    _proto.createScope = function createScope(flags) {
      return new TypeScriptScope(flags);
    };

    _proto.declareName = function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
        this.maybeExportDefined(scope, name);
        scope.exportOnlyBindings.push(name);
        return;
      }

      _ScopeHandler.prototype.declareName.apply(this, arguments);

      if (bindingType & BIND_KIND_TYPE) {
        if (!(bindingType & BIND_KIND_VALUE)) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          this.maybeExportDefined(scope, name);
        }

        scope.types.push(name);
      }

      if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);
      if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
      if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);
    };

    _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.indexOf(name) > -1) {
        if (bindingType & BIND_FLAGS_TS_ENUM) {
          var isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
          var wasConst = scope.constEnums.indexOf(name) > -1;
          return isConst !== wasConst;
        }

        return true;
      }

      if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {
        if (scope.lexical.indexOf(name) > -1) {
          return !!(bindingType & BIND_KIND_VALUE);
        } else {
          return false;
        }
      }

      if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {
        return true;
      }

      return _ScopeHandler.prototype.isRedeclaredInScope.apply(this, arguments);
    };

    _proto.checkLocalExport = function checkLocalExport(id) {
      if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {
        _ScopeHandler.prototype.checkLocalExport.call(this, id);
      }
    };

    return TypeScriptScopeHandler;
  }(ScopeHandler);

  var PARAM = 0,
      PARAM_YIELD = 1,
      PARAM_AWAIT = 2,
      PARAM_RETURN = 4;

  var ProductionParameterHandler = function () {
    function ProductionParameterHandler() {
      this.stacks = [];
    }

    var _proto = ProductionParameterHandler.prototype;

    _proto.enter = function enter(flags) {
      this.stacks.push(flags);
    };

    _proto.exit = function exit() {
      this.stacks.pop();
    };

    _proto.currentFlags = function currentFlags() {
      return this.stacks[this.stacks.length - 1];
    };

    _createClass(ProductionParameterHandler, [{
      key: "hasAwait",
      get: function get() {
        return (this.currentFlags() & PARAM_AWAIT) > 0;
      }
    }, {
      key: "hasYield",
      get: function get() {
        return (this.currentFlags() & PARAM_YIELD) > 0;
      }
    }, {
      key: "hasReturn",
      get: function get() {
        return (this.currentFlags() & PARAM_RETURN) > 0;
      }
    }]);

    return ProductionParameterHandler;
  }();
  function functionFlags(isAsync, isGenerator) {
    return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
  }

  function nonNull(x) {
    if (x == null) {
      throw new Error("Unexpected " + x + " value.");
    }

    return x;
  }

  function assert$1(x) {
    if (!x) {
      throw new Error("Assert fail");
    }
  }

  var TSErrors = Object.freeze({
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier",
    DeclareClassFieldHasInitializer: "'declare' class fields cannot have an initializer",
    DuplicateModifier: "Duplicate modifier: '%0'",
    EmptyHeritageClauseType: "'%0' list cannot be empty.",
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier",
    IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0')",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0')",
    TemplateTypeHasSubstitution: "Template literal types cannot have any substitution",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0"
  });

  function keywordTypeFromName(value) {
    switch (value) {
      case "any":
        return "TSAnyKeyword";

      case "boolean":
        return "TSBooleanKeyword";

      case "bigint":
        return "TSBigIntKeyword";

      case "never":
        return "TSNeverKeyword";

      case "number":
        return "TSNumberKeyword";

      case "object":
        return "TSObjectKeyword";

      case "string":
        return "TSStringKeyword";

      case "symbol":
        return "TSSymbolKeyword";

      case "undefined":
        return "TSUndefinedKeyword";

      case "unknown":
        return "TSUnknownKeyword";

      default:
        return undefined;
    }
  }

  var typescript = (function (superClass) {
    return function (_superClass) {
      _inheritsLoose(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.getScopeHandler = function getScopeHandler() {
        return TypeScriptScopeHandler;
      };

      _proto.tsIsIdentifier = function tsIsIdentifier() {
        return this.match(types.name);
      };

      _proto.tsNextTokenCanFollowModifier = function tsNextTokenCanFollowModifier() {
        this.next();
        return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.parenR) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question) && !this.match(types.bang);
      };

      _proto.tsParseModifier = function tsParseModifier(allowedModifiers) {
        if (!this.match(types.name)) {
          return undefined;
        }

        var modifier = this.state.value;

        if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
          return modifier;
        }

        return undefined;
      };

      _proto.tsParseModifiers = function tsParseModifiers(modified, allowedModifiers) {
        for (;;) {
          var startPos = this.state.start;
          var modifier = this.tsParseModifier(allowedModifiers);
          if (!modifier) break;

          if (Object.hasOwnProperty.call(modified, modifier)) {
            this.raise(startPos, TSErrors.DuplicateModifier, modifier);
          }

          modified[modifier] = true;
        }
      };

      _proto.tsIsListTerminator = function tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(types.braceR);

          case "HeritageClauseElement":
            return this.match(types.braceL);

          case "TupleElementTypes":
            return this.match(types.bracketR);

          case "TypeParametersOrArguments":
            return this.isRelational(">");
        }

        throw new Error("Unreachable");
      };

      _proto.tsParseList = function tsParseList(kind, parseElement) {
        var result = [];

        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }

        return result;
      };

      _proto.tsParseDelimitedList = function tsParseDelimitedList(kind, parseElement) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
      };

      _proto.tsParseDelimitedListWorker = function tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
        var result = [];

        for (;;) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }

          var element = parseElement();

          if (element == null) {
            return undefined;
          }

          result.push(element);

          if (this.eat(types.comma)) {
            continue;
          }

          if (this.tsIsListTerminator(kind)) {
            break;
          }

          if (expectSuccess) {
            this.expect(types.comma);
          }

          return undefined;
        }

        return result;
      };

      _proto.tsParseBracketedList = function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(types.bracketL);
          } else {
            this.expectRelational("<");
          }
        }

        var result = this.tsParseDelimitedList(kind, parseElement);

        if (bracket) {
          this.expect(types.bracketR);
        } else {
          this.expectRelational(">");
        }

        return result;
      };

      _proto.tsParseImportType = function tsParseImportType() {
        var node = this.startNode();
        this.expect(types._import);
        this.expect(types.parenL);

        if (!this.match(types.string)) {
          this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
        }

        node.argument = this.parseExprAtom();
        this.expect(types.parenR);

        if (this.eat(types.dot)) {
          node.qualifier = this.tsParseEntityName(true);
        }

        if (this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, "TSImportType");
      };

      _proto.tsParseEntityName = function tsParseEntityName(allowReservedWords) {
        var entity = this.parseIdentifier();

        while (this.eat(types.dot)) {
          var node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }

        return entity;
      };

      _proto.tsParseTypeReference = function tsParseTypeReference() {
        var node = this.startNode();
        node.typeName = this.tsParseEntityName(false);

        if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, "TSTypeReference");
      };

      _proto.tsParseThisTypePredicate = function tsParseThisTypePredicate(lhs) {
        this.next();
        var node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        return this.finishNode(node, "TSTypePredicate");
      };

      _proto.tsParseThisTypeNode = function tsParseThisTypeNode() {
        var node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      };

      _proto.tsParseTypeQuery = function tsParseTypeQuery() {
        var node = this.startNode();
        this.expect(types._typeof);

        if (this.match(types._import)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName(true);
        }

        return this.finishNode(node, "TSTypeQuery");
      };

      _proto.tsParseTypeParameter = function tsParseTypeParameter() {
        var node = this.startNode();
        node.name = this.parseIdentifierName(node.start);
        node.constraint = this.tsEatThenParseType(types._extends);
        node["default"] = this.tsEatThenParseType(types.eq);
        return this.finishNode(node, "TSTypeParameter");
      };

      _proto.tsTryParseTypeParameters = function tsTryParseTypeParameters() {
        if (this.isRelational("<")) {
          return this.tsParseTypeParameters();
        }
      };

      _proto.tsParseTypeParameters = function tsParseTypeParameters() {
        var node = this.startNode();

        if (this.isRelational("<") || this.match(types.jsxTagStart)) {
          this.next();
        } else {
          this.unexpected();
        }

        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
        return this.finishNode(node, "TSTypeParameterDeclaration");
      };

      _proto.tsTryNextParseConstantContext = function tsTryNextParseConstantContext() {
        if (this.lookahead().type === types._const) {
          this.next();
          return this.tsParseTypeReference();
        }

        return null;
      };

      _proto.tsFillSignature = function tsFillSignature(returnToken, signature) {
        var returnTokenRequired = returnToken === types.arrow;
        signature.typeParameters = this.tsTryParseTypeParameters();
        this.expect(types.parenL);
        signature.parameters = this.tsParseBindingListForSignature();

        if (returnTokenRequired) {
          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      };

      _proto.tsParseBindingListForSignature = function tsParseBindingListForSignature() {
        var _this = this;

        return this.parseBindingList(types.parenR, 41).map(function (pattern) {
          if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
            _this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
          }

          return pattern;
        });
      };

      _proto.tsParseTypeMemberSemicolon = function tsParseTypeMemberSemicolon() {
        if (!this.eat(types.comma)) {
          this.semicolon();
        }
      };

      _proto.tsParseSignatureMember = function tsParseSignatureMember(kind, node) {
        this.tsFillSignature(types.colon, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      };

      _proto.tsIsUnambiguouslyIndexSignature = function tsIsUnambiguouslyIndexSignature() {
        this.next();
        return this.eat(types.name) && this.match(types.colon);
      };

      _proto.tsTryParseIndexSignature = function tsTryParseIndexSignature(node) {
        if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return undefined;
        }

        this.expect(types.bracketL);
        var id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(types.bracketR);
        node.parameters = [id];
        var type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      };

      _proto.tsParsePropertyOrMethodSignature = function tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(types.question)) node.optional = true;
        var nodeAny = node;

        if (!readonly && (this.match(types.parenL) || this.isRelational("<"))) {
          var method = nodeAny;
          this.tsFillSignature(types.colon, method);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(method, "TSMethodSignature");
        } else {
          var property = nodeAny;
          if (readonly) property.readonly = true;
          var type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      };

      _proto.tsParseTypeMember = function tsParseTypeMember() {
        var node = this.startNode();

        if (this.match(types.parenL) || this.isRelational("<")) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }

        if (this.match(types._new)) {
          var id = this.startNode();
          this.next();

          if (this.match(types.parenL) || this.isRelational("<")) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }

        var readonly = !!this.tsParseModifier(["readonly"]);
        var idx = this.tsTryParseIndexSignature(node);

        if (idx) {
          if (readonly) node.readonly = true;
          return idx;
        }

        this.parsePropertyName(node, false);
        return this.tsParsePropertyOrMethodSignature(node, readonly);
      };

      _proto.tsParseTypeLiteral = function tsParseTypeLiteral() {
        var node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      };

      _proto.tsParseObjectTypeMembers = function tsParseObjectTypeMembers() {
        this.expect(types.braceL);
        var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(types.braceR);
        return members;
      };

      _proto.tsIsStartOfMappedType = function tsIsStartOfMappedType() {
        this.next();

        if (this.eat(types.plusMin)) {
          return this.isContextual("readonly");
        }

        if (this.isContextual("readonly")) {
          this.next();
        }

        if (!this.match(types.bracketL)) {
          return false;
        }

        this.next();

        if (!this.tsIsIdentifier()) {
          return false;
        }

        this.next();
        return this.match(types._in);
      };

      _proto.tsParseMappedTypeParameter = function tsParseMappedTypeParameter() {
        var node = this.startNode();
        node.name = this.parseIdentifierName(node.start);
        node.constraint = this.tsExpectThenParseType(types._in);
        return this.finishNode(node, "TSTypeParameter");
      };

      _proto.tsParseMappedType = function tsParseMappedType() {
        var node = this.startNode();
        this.expect(types.braceL);

        if (this.match(types.plusMin)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual("readonly");
        } else if (this.eatContextual("readonly")) {
          node.readonly = true;
        }

        this.expect(types.bracketL);
        node.typeParameter = this.tsParseMappedTypeParameter();
        this.expect(types.bracketR);

        if (this.match(types.plusMin)) {
          node.optional = this.state.value;
          this.next();
          this.expect(types.question);
        } else if (this.eat(types.question)) {
          node.optional = true;
        }

        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(types.braceR);
        return this.finishNode(node, "TSMappedType");
      };

      _proto.tsParseTupleType = function tsParseTupleType() {
        var _this2 = this;

        var node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        var seenOptionalElement = false;
        node.elementTypes.forEach(function (elementNode) {
          if (elementNode.type === "TSOptionalType") {
            seenOptionalElement = true;
          } else if (seenOptionalElement && elementNode.type !== "TSRestType") {
            _this2.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
          }
        });
        return this.finishNode(node, "TSTupleType");
      };

      _proto.tsParseTupleElementType = function tsParseTupleElementType() {
        if (this.match(types.ellipsis)) {
          var restNode = this.startNode();
          this.next();
          restNode.typeAnnotation = this.tsParseType();

          if (this.match(types.comma) && this.lookaheadCharCode() !== 93) {
            this.raiseRestNotLast(this.state.start);
          }

          return this.finishNode(restNode, "TSRestType");
        }

        var type = this.tsParseType();

        if (this.eat(types.question)) {
          var optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          return this.finishNode(optionalTypeNode, "TSOptionalType");
        }

        return type;
      };

      _proto.tsParseParenthesizedType = function tsParseParenthesizedType() {
        var node = this.startNode();
        this.expect(types.parenL);
        node.typeAnnotation = this.tsParseType();
        this.expect(types.parenR);
        return this.finishNode(node, "TSParenthesizedType");
      };

      _proto.tsParseFunctionOrConstructorType = function tsParseFunctionOrConstructorType(type) {
        var node = this.startNode();

        if (type === "TSConstructorType") {
          this.expect(types._new);
        }

        this.tsFillSignature(types.arrow, node);
        return this.finishNode(node, type);
      };

      _proto.tsParseLiteralTypeNode = function tsParseLiteralTypeNode() {
        var _this3 = this;

        var node = this.startNode();

        node.literal = function () {
          switch (_this3.state.type) {
            case types.num:
            case types.string:
            case types._true:
            case types._false:
              return _this3.parseExprAtom();

            default:
              throw _this3.unexpected();
          }
        }();

        return this.finishNode(node, "TSLiteralType");
      };

      _proto.tsParseTemplateLiteralType = function tsParseTemplateLiteralType() {
        var node = this.startNode();
        var templateNode = this.parseTemplate(false);

        if (templateNode.expressions.length > 0) {
          this.raise(templateNode.expressions[0].start, TSErrors.TemplateTypeHasSubstitution);
        }

        node.literal = templateNode;
        return this.finishNode(node, "TSLiteralType");
      };

      _proto.tsParseThisTypeOrThisTypePredicate = function tsParseThisTypeOrThisTypePredicate() {
        var thisKeyword = this.tsParseThisTypeNode();

        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      };

      _proto.tsParseNonArrayType = function tsParseNonArrayType() {
        switch (this.state.type) {
          case types.name:
          case types._void:
          case types._null:
            {
              var type = this.match(types._void) ? "TSVoidKeyword" : this.match(types._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

              if (type !== undefined && this.lookaheadCharCode() !== 46) {
                var node = this.startNode();
                this.next();
                return this.finishNode(node, type);
              }

              return this.tsParseTypeReference();
            }

          case types.string:
          case types.num:
          case types._true:
          case types._false:
            return this.tsParseLiteralTypeNode();

          case types.plusMin:
            if (this.state.value === "-") {
              var _node = this.startNode();

              if (this.lookahead().type !== types.num) {
                throw this.unexpected();
              }

              _node.literal = this.parseMaybeUnary();
              return this.finishNode(_node, "TSLiteralType");
            }

            break;

          case types._this:
            return this.tsParseThisTypeOrThisTypePredicate();

          case types._typeof:
            return this.tsParseTypeQuery();

          case types._import:
            return this.tsParseImportType();

          case types.braceL:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

          case types.bracketL:
            return this.tsParseTupleType();

          case types.parenL:
            return this.tsParseParenthesizedType();

          case types.backQuote:
            return this.tsParseTemplateLiteralType();
        }

        throw this.unexpected();
      };

      _proto.tsParseArrayTypeOrHigher = function tsParseArrayTypeOrHigher() {
        var type = this.tsParseNonArrayType();

        while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {
          if (this.match(types.bracketR)) {
            var node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(types.bracketR);
            type = this.finishNode(node, "TSArrayType");
          } else {
            var _node2 = this.startNodeAtNode(type);

            _node2.objectType = type;
            _node2.indexType = this.tsParseType();
            this.expect(types.bracketR);
            type = this.finishNode(_node2, "TSIndexedAccessType");
          }
        }

        return type;
      };

      _proto.tsParseTypeOperator = function tsParseTypeOperator(operator) {
        var node = this.startNode();
        this.expectContextual(operator);
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }

        return this.finishNode(node, "TSTypeOperator");
      };

      _proto.tsCheckTypeAnnotationForReadOnly = function tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;

          default:
            this.raise(node.start, TSErrors.UnexpectedReadonly);
        }
      };

      _proto.tsParseInferType = function tsParseInferType() {
        var node = this.startNode();
        this.expectContextual("infer");
        var typeParameter = this.startNode();
        typeParameter.name = this.parseIdentifierName(typeParameter.start);
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      };

      _proto.tsParseTypeOperatorOrHigher = function tsParseTypeOperatorOrHigher() {
        var _this4 = this;

        var operator = ["keyof", "unique", "readonly"].find(function (kw) {
          return _this4.isContextual(kw);
        });
        return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
      };

      _proto.tsParseUnionOrIntersectionType = function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        this.eat(operator);
        var type = parseConstituentType();

        if (this.match(operator)) {
          var types = [type];

          while (this.eat(operator)) {
            types.push(parseConstituentType());
          }

          var node = this.startNodeAtNode(type);
          node.types = types;
          type = this.finishNode(node, kind);
        }

        return type;
      };

      _proto.tsParseIntersectionTypeOrHigher = function tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);
      };

      _proto.tsParseUnionTypeOrHigher = function tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);
      };

      _proto.tsIsStartOfFunctionType = function tsIsStartOfFunctionType() {
        if (this.isRelational("<")) {
          return true;
        }

        return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      };

      _proto.tsSkipParameterStart = function tsSkipParameterStart() {
        if (this.match(types.name) || this.match(types._this)) {
          this.next();
          return true;
        }

        if (this.match(types.braceL)) {
          var braceStackCounter = 1;
          this.next();

          while (braceStackCounter > 0) {
            if (this.match(types.braceL)) {
              ++braceStackCounter;
            } else if (this.match(types.braceR)) {
              --braceStackCounter;
            }

            this.next();
          }

          return true;
        }

        if (this.match(types.bracketL)) {
          var _braceStackCounter = 1;
          this.next();

          while (_braceStackCounter > 0) {
            if (this.match(types.bracketL)) {
              ++_braceStackCounter;
            } else if (this.match(types.bracketR)) {
              --_braceStackCounter;
            }

            this.next();
          }

          return true;
        }

        return false;
      };

      _proto.tsIsUnambiguouslyStartOfFunctionType = function tsIsUnambiguouslyStartOfFunctionType() {
        this.next();

        if (this.match(types.parenR) || this.match(types.ellipsis)) {
          return true;
        }

        if (this.tsSkipParameterStart()) {
          if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {
            return true;
          }

          if (this.match(types.parenR)) {
            this.next();

            if (this.match(types.arrow)) {
              return true;
            }
          }
        }

        return false;
      };

      _proto.tsParseTypeOrTypePredicateAnnotation = function tsParseTypeOrTypePredicateAnnotation(returnToken) {
        var _this5 = this;

        return this.tsInType(function () {
          var t = _this5.startNode();

          _this5.expect(returnToken);

          var asserts = _this5.tsTryParse(_this5.tsParseTypePredicateAsserts.bind(_this5));

          if (asserts && _this5.match(types._this)) {
            var thisTypePredicate = _this5.tsParseThisTypeOrThisTypePredicate();

            if (thisTypePredicate.type === "TSThisType") {
              var _node3 = _this5.startNodeAtNode(t);

              _node3.parameterName = thisTypePredicate;
              _node3.asserts = true;
              thisTypePredicate = _this5.finishNode(_node3, "TSTypePredicate");
            } else {
              thisTypePredicate.asserts = true;
            }

            t.typeAnnotation = thisTypePredicate;
            return _this5.finishNode(t, "TSTypeAnnotation");
          }

          var typePredicateVariable = _this5.tsIsIdentifier() && _this5.tsTryParse(_this5.tsParseTypePredicatePrefix.bind(_this5));

          if (!typePredicateVariable) {
            if (!asserts) {
              return _this5.tsParseTypeAnnotation(false, t);
            }

            var _node4 = _this5.startNodeAtNode(t);

            _node4.parameterName = _this5.parseIdentifier();
            _node4.asserts = asserts;
            t.typeAnnotation = _this5.finishNode(_node4, "TSTypePredicate");
            return _this5.finishNode(t, "TSTypeAnnotation");
          }

          var type = _this5.tsParseTypeAnnotation(false);

          var node = _this5.startNodeAtNode(t);

          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = _this5.finishNode(node, "TSTypePredicate");
          return _this5.finishNode(t, "TSTypeAnnotation");
        });
      };

      _proto.tsTryParseTypeOrTypePredicateAnnotation = function tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;
      };

      _proto.tsTryParseTypeAnnotation = function tsTryParseTypeAnnotation() {
        return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;
      };

      _proto.tsTryParseType = function tsTryParseType() {
        return this.tsEatThenParseType(types.colon);
      };

      _proto.tsParseTypePredicatePrefix = function tsParseTypePredicatePrefix() {
        var id = this.parseIdentifier();

        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      };

      _proto.tsParseTypePredicateAsserts = function tsParseTypePredicateAsserts() {
        if (!this.match(types.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
          return false;
        }

        var containsEsc = this.state.containsEsc;
        this.next();

        if (!this.match(types.name) && !this.match(types._this)) {
          return false;
        }

        if (containsEsc) {
          this.raise(this.state.lastTokStart, Errors.InvalidEscapedReservedWord, "asserts");
        }

        return true;
      };

      _proto.tsParseTypeAnnotation = function tsParseTypeAnnotation(eatColon, t) {
        var _this6 = this;

        if (eatColon === void 0) {
          eatColon = true;
        }

        if (t === void 0) {
          t = this.startNode();
        }

        this.tsInType(function () {
          if (eatColon) _this6.expect(types.colon);
          t.typeAnnotation = _this6.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      };

      _proto.tsParseType = function tsParseType() {
        assert$1(this.state.inType);
        var type = this.tsParseNonConditionalType();

        if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {
          return type;
        }

        var node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsParseNonConditionalType();
        this.expect(types.question);
        node.trueType = this.tsParseType();
        this.expect(types.colon);
        node.falseType = this.tsParseType();
        return this.finishNode(node, "TSConditionalType");
      };

      _proto.tsParseNonConditionalType = function tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }

        if (this.match(types._new)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        }

        return this.tsParseUnionTypeOrHigher();
      };

      _proto.tsParseTypeAssertion = function tsParseTypeAssertion() {
        var node = this.startNode();

        var _const = this.tsTryNextParseConstantContext();

        node.typeAnnotation = _const || this.tsNextThenParseType();
        this.expectRelational(">");
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      };

      _proto.tsParseHeritageClause = function tsParseHeritageClause(descriptor) {
        var originalStart = this.state.start;
        var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

        if (!delimitedList.length) {
          this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
        }

        return delimitedList;
      };

      _proto.tsParseExpressionWithTypeArguments = function tsParseExpressionWithTypeArguments() {
        var node = this.startNode();
        node.expression = this.tsParseEntityName(false);

        if (this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, "TSExpressionWithTypeArguments");
      };

      _proto.tsParseInterfaceDeclaration = function tsParseInterfaceDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, BIND_TS_INTERFACE, undefined, "typescript interface declaration");
        node.typeParameters = this.tsTryParseTypeParameters();

        if (this.eat(types._extends)) {
          node["extends"] = this.tsParseHeritageClause("extends");
        }

        var body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      };

      _proto.tsParseTypeAliasDeclaration = function tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, BIND_TS_TYPE, undefined, "typescript type alias");
        node.typeParameters = this.tsTryParseTypeParameters();
        node.typeAnnotation = this.tsExpectThenParseType(types.eq);
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      };

      _proto.tsInNoContext = function tsInNoContext(cb) {
        var oldContext = this.state.context;
        this.state.context = [oldContext[0]];

        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      };

      _proto.tsInType = function tsInType(cb) {
        var oldInType = this.state.inType;
        this.state.inType = true;

        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      };

      _proto.tsEatThenParseType = function tsEatThenParseType(token) {
        return !this.match(token) ? undefined : this.tsNextThenParseType();
      };

      _proto.tsExpectThenParseType = function tsExpectThenParseType(token) {
        var _this7 = this;

        return this.tsDoThenParseType(function () {
          return _this7.expect(token);
        });
      };

      _proto.tsNextThenParseType = function tsNextThenParseType() {
        var _this8 = this;

        return this.tsDoThenParseType(function () {
          return _this8.next();
        });
      };

      _proto.tsDoThenParseType = function tsDoThenParseType(cb) {
        var _this9 = this;

        return this.tsInType(function () {
          cb();
          return _this9.tsParseType();
        });
      };

      _proto.tsParseEnumMember = function tsParseEnumMember() {
        var node = this.startNode();
        node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);

        if (this.eat(types.eq)) {
          node.initializer = this.parseMaybeAssign();
        }

        return this.finishNode(node, "TSEnumMember");
      };

      _proto.tsParseEnumDeclaration = function tsParseEnumDeclaration(node, isConst) {
        if (isConst) node["const"] = true;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM, undefined, "typescript enum declaration");
        this.expect(types.braceL);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(types.braceR);
        return this.finishNode(node, "TSEnumDeclaration");
      };

      _proto.tsParseModuleBlock = function tsParseModuleBlock() {
        var node = this.startNode();
        this.scope.enter(SCOPE_OTHER);
        this.expect(types.braceL);
        this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      };

      _proto.tsParseModuleOrNamespaceDeclaration = function tsParseModuleOrNamespaceDeclaration(node, nested) {
        if (nested === void 0) {
          nested = false;
        }

        node.id = this.parseIdentifier();

        if (!nested) {
          this.checkLVal(node.id, BIND_TS_NAMESPACE, null, "module or namespace declaration");
        }

        if (this.eat(types.dot)) {
          var inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }

        return this.finishNode(node, "TSModuleDeclaration");
      };

      _proto.tsParseAmbientExternalModuleDeclaration = function tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual("global")) {
          node.global = true;
          node.id = this.parseIdentifier();
        } else if (this.match(types.string)) {
          node.id = this.parseExprAtom();
        } else {
          this.unexpected();
        }

        if (this.match(types.braceL)) {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }

        return this.finishNode(node, "TSModuleDeclaration");
      };

      _proto.tsParseImportEqualsDeclaration = function tsParseImportEqualsDeclaration(node, isExport) {
        node.isExport = isExport || false;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, BIND_LEXICAL, undefined, "import equals declaration");
        this.expect(types.eq);
        node.moduleReference = this.tsParseModuleReference();
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      };

      _proto.tsIsExternalModuleReference = function tsIsExternalModuleReference() {
        return this.isContextual("require") && this.lookaheadCharCode() === 40;
      };

      _proto.tsParseModuleReference = function tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
      };

      _proto.tsParseExternalModuleReference = function tsParseExternalModuleReference() {
        var node = this.startNode();
        this.expectContextual("require");
        this.expect(types.parenL);

        if (!this.match(types.string)) {
          throw this.unexpected();
        }

        node.expression = this.parseExprAtom();
        this.expect(types.parenR);
        return this.finishNode(node, "TSExternalModuleReference");
      };

      _proto.tsLookAhead = function tsLookAhead(f) {
        var state = this.state.clone();
        var res = f();
        this.state = state;
        return res;
      };

      _proto.tsTryParseAndCatch = function tsTryParseAndCatch(f) {
        var result = this.tryParse(function (abort) {
          return f() || abort();
        });
        if (result.aborted || !result.node) return undefined;
        if (result.error) this.state = result.failState;
        return result.node;
      };

      _proto.tsTryParse = function tsTryParse(f) {
        var state = this.state.clone();
        var result = f();

        if (result !== undefined && result !== false) {
          return result;
        } else {
          this.state = state;
          return undefined;
        }
      };

      _proto.tsTryParseDeclare = function tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }

        var starttype = this.state.type;
        var kind;

        if (this.isContextual("let")) {
          starttype = types._var;
          kind = "let";
        }

        switch (starttype) {
          case types._function:
            return this.parseFunctionStatement(nany, false, true);

          case types._class:
            nany.declare = true;
            return this.parseClass(nany, true, false);

          case types._const:
            if (this.match(types._const) && this.isLookaheadContextual("enum")) {
              this.expect(types._const);
              this.expectContextual("enum");
              return this.tsParseEnumDeclaration(nany, true);
            }

          case types._var:
            kind = kind || this.state.value;
            return this.parseVarStatement(nany, kind);

          case types.name:
            {
              var value = this.state.value;

              if (value === "global") {
                return this.tsParseAmbientExternalModuleDeclaration(nany);
              } else {
                return this.tsParseDeclaration(nany, value, true);
              }
            }
        }
      };

      _proto.tsTryParseExportDeclaration = function tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true);
      };

      _proto.tsParseExpressionStatement = function tsParseExpressionStatement(node, expr) {
        switch (expr.name) {
          case "declare":
            {
              var declaration = this.tsTryParseDeclare(node);

              if (declaration) {
                declaration.declare = true;
                return declaration;
              }

              break;
            }

          case "global":
            if (this.match(types.braceL)) {
              this.scope.enter(SCOPE_TS_MODULE);
              this.prodParam.enter(PARAM);
              var mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }

            break;

          default:
            return this.tsParseDeclaration(node, expr.name, false);
        }
      };

      _proto.tsParseDeclaration = function tsParseDeclaration(node, value, next) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {
              var cls = node;
              cls["abstract"] = true;

              if (next) {
                this.next();

                if (!this.match(types._class)) {
                  this.unexpected(null, types._class);
                }
              }

              return this.parseClass(cls, true, false);
            }

            break;

          case "enum":
            if (next || this.match(types.name)) {
              if (next) this.next();
              return this.tsParseEnumDeclaration(node, false);
            }

            break;

          case "interface":
            if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
              if (next) this.next();
              return this.tsParseInterfaceDeclaration(node);
            }

            break;

          case "module":
            if (next) this.next();

            if (this.match(types.string)) {
              return this.tsParseAmbientExternalModuleDeclaration(node);
            } else if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }

            break;

          case "namespace":
            if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
              if (next) this.next();
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }

            break;

          case "type":
            if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
              if (next) this.next();
              return this.tsParseTypeAliasDeclaration(node);
            }

            break;
        }
      };

      _proto.tsCheckLineTerminatorAndMatch = function tsCheckLineTerminatorAndMatch(tokenType, next) {
        return (next || this.match(tokenType)) && !this.isLineTerminator();
      };

      _proto.tsTryParseGenericAsyncArrowFunction = function tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
        var _this10 = this;

        if (!this.isRelational("<")) {
          return undefined;
        }

        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        var oldYieldPos = this.state.yieldPos;
        var oldAwaitPos = this.state.awaitPos;
        this.state.maybeInArrowParameters = true;
        this.state.yieldPos = -1;
        this.state.awaitPos = -1;
        var res = this.tsTryParseAndCatch(function () {
          var node = _this10.startNodeAt(startPos, startLoc);

          node.typeParameters = _this10.tsParseTypeParameters();

          _superClass.prototype.parseFunctionParams.call(_this10, node);

          node.returnType = _this10.tsTryParseTypeOrTypePredicateAnnotation();

          _this10.expect(types.arrow);

          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.yieldPos = oldYieldPos;
        this.state.awaitPos = oldAwaitPos;

        if (!res) {
          return undefined;
        }

        return this.parseArrowExpression(res, null, true);
      };

      _proto.tsParseTypeArguments = function tsParseTypeArguments() {
        var _this11 = this;

        var node = this.startNode();
        node.params = this.tsInType(function () {
          return _this11.tsInNoContext(function () {
            _this11.expectRelational("<");

            return _this11.tsParseDelimitedList("TypeParametersOrArguments", _this11.tsParseType.bind(_this11));
          });
        });
        this.state.exprAllowed = false;
        this.expectRelational(">");
        return this.finishNode(node, "TSTypeParameterInstantiation");
      };

      _proto.tsIsDeclarationStart = function tsIsDeclarationStart() {
        if (this.match(types.name)) {
          switch (this.state.value) {
            case "abstract":
            case "declare":
            case "enum":
            case "interface":
            case "module":
            case "namespace":
            case "type":
              return true;
          }
        }

        return false;
      };

      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        return _superClass.prototype.isExportDefaultSpecifier.call(this);
      };

      _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var accessibility;
        var readonly = false;

        if (allowModifiers) {
          accessibility = this.parseAccessModifier();
          readonly = !!this.tsParseModifier(["readonly"]);
        }

        var left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

        if (accessibility || readonly) {
          var pp = this.startNodeAt(startPos, startLoc);

          if (decorators.length) {
            pp.decorators = decorators;
          }

          if (accessibility) pp.accessibility = accessibility;
          if (readonly) pp.readonly = readonly;

          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
          }

          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }

        if (decorators.length) {
          left.decorators = decorators;
        }

        return elt;
      };

      _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }

        if (this.match(types.colon)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
        }

        var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : undefined;

        if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {
          this.finishNode(node, bodilessType);
          return;
        }

        _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, isMethod);
      };

      _proto.registerFunctionStatementId = function registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkLVal(node.id, BIND_TS_AMBIENT, null, "function name");
        } else {
          _superClass.prototype.registerFunctionStatementId.apply(this, arguments);
        }
      };

      _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
        var _this12 = this;

        if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {
          this.state.exprAllowed = false;
          this.next();
          var nonNullExpression = this.startNodeAt(startPos, startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }

        if (this.isRelational("<")) {
          var result = this.tsTryParseAndCatch(function () {
            if (!noCalls && _this12.atPossibleAsyncArrow(base)) {
              var asyncArrowFn = _this12.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }

            var node = _this12.startNodeAt(startPos, startLoc);

            node.callee = base;

            var typeArguments = _this12.tsParseTypeArguments();

            if (typeArguments) {
              if (!noCalls && _this12.eat(types.parenL)) {
                node.arguments = _this12.parseCallExpressionArguments(types.parenR, false);
                node.typeParameters = typeArguments;
                return _this12.finishCallExpression(node, state.optionalChainMember);
              } else if (_this12.match(types.backQuote)) {
                return _this12.parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments);
              }
            }

            _this12.unexpected();
          });
          if (result) return result;
        }

        return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, state);
      };

      _proto.parseNewArguments = function parseNewArguments(node) {
        var _this13 = this;

        if (this.isRelational("<")) {
          var typeParameters = this.tsTryParseAndCatch(function () {
            var args = _this13.tsParseTypeArguments();

            if (!_this13.match(types.parenL)) _this13.unexpected();
            return args;
          });

          if (typeParameters) {
            node.typeParameters = typeParameters;
          }
        }

        _superClass.prototype.parseNewArguments.call(this, node);
      };

      _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
        if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.expression = left;

          var _const = this.tsTryNextParseConstantContext();

          if (_const) {
            node.typeAnnotation = _const;
          } else {
            node.typeAnnotation = this.tsNextThenParseType();
          }

          this.finishNode(node, "TSAsExpression");
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }

        return _superClass.prototype.parseExprOp.call(this, left, leftStartPos, leftStartLoc, minPrec, noIn);
      };

      _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {};

      _proto.checkDuplicateExports = function checkDuplicateExports() {};

      _proto.parseImport = function parseImport(node) {
        if (this.match(types.name) || this.match(types.star) || this.match(types.braceL)) {
          var ahead = this.lookahead();

          if (this.match(types.name) && ahead.type === types.eq) {
            return this.tsParseImportEqualsDeclaration(node);
          }

          if (this.isContextual("type") && ahead.type !== types.comma && !(ahead.type === types.name && ahead.value === "from")) {
            node.importKind = "type";
            this.next();
          } else {
            node.importKind = "value";
          }
        }

        var importNode = _superClass.prototype.parseImport.call(this, node);

        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(importNode.start, "A type-only import can specify a default import or named bindings, but not both.");
        }

        return importNode;
      };

      _proto.parseExport = function parseExport(node) {
        if (this.match(types._import)) {
          this.expect(types._import);
          return this.tsParseImportEqualsDeclaration(node, true);
        } else if (this.eat(types.eq)) {
          var assign = node;
          assign.expression = this.parseExpression();
          this.semicolon();
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual("as")) {
          var decl = node;
          this.expectContextual("namespace");
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          if (this.isContextual("type") && this.lookahead().type === types.braceL) {
            this.next();
            node.exportKind = "type";
          } else {
            node.exportKind = "value";
          }

          return _superClass.prototype.parseExport.call(this, node);
        }
      };

      _proto.isAbstractClass = function isAbstractClass() {
        return this.isContextual("abstract") && this.lookahead().type === types._class;
      };

      _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          var cls = this.startNode();
          this.next();
          this.parseClass(cls, true, true);
          cls["abstract"] = true;
          return cls;
        }

        if (this.state.value === "interface") {
          var result = this.tsParseDeclaration(this.startNode(), this.state.value, true);
          if (result) return result;
        }

        return _superClass.prototype.parseExportDefaultExpression.call(this);
      };

      _proto.parseStatementContent = function parseStatementContent(context, topLevel) {
        if (this.state.type === types._const) {
          var ahead = this.lookahead();

          if (ahead.type === types.name && ahead.value === "enum") {
            var node = this.startNode();
            this.expect(types._const);
            this.expectContextual("enum");
            return this.tsParseEnumDeclaration(node, true);
          }
        }

        return _superClass.prototype.parseStatementContent.call(this, context, topLevel);
      };

      _proto.parseAccessModifier = function parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      };

      _proto.parseClassMember = function parseClassMember(classBody, member, state, constructorAllowsSuper) {
        this.tsParseModifiers(member, ["declare"]);
        var accessibility = this.parseAccessModifier();
        if (accessibility) member.accessibility = accessibility;
        this.tsParseModifiers(member, ["declare"]);

        _superClass.prototype.parseClassMember.call(this, classBody, member, state, constructorAllowsSuper);
      };

      _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
        this.tsParseModifiers(member, ["abstract", "readonly", "declare"]);
        var idx = this.tsTryParseIndexSignature(member);

        if (idx) {
          classBody.body.push(idx);

          if (member["abstract"]) {
            this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
          }

          if (isStatic) {
            this.raise(member.start, TSErrors.IndexSignatureHasStatic);
          }

          if (member.accessibility) {
            this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
          }

          return;
        }

        _superClass.prototype.parseClassMemberWithIsStatic.call(this, classBody, member, state, isStatic, constructorAllowsSuper);
      };

      _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {
        var optional = this.eat(types.question);
        if (optional) methodOrProp.optional = true;

        if (methodOrProp.readonly && this.match(types.parenL)) {
          this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
        }

        if (methodOrProp.declare && this.match(types.parenL)) {
          this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
        }
      };

      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
        var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
        return decl || _superClass.prototype.parseExpressionStatement.call(this, node, expr);
      };

      _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart()) return true;
        return _superClass.prototype.shouldParseExportDeclaration.call(this);
      };

      _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
        var _this14 = this;

        if (!refNeedsArrowPos || !this.match(types.question)) {
          return _superClass.prototype.parseConditional.call(this, expr, noIn, startPos, startLoc, refNeedsArrowPos);
        }

        var result = this.tryParse(function () {
          return _superClass.prototype.parseConditional.call(_this14, expr, noIn, startPos, startLoc);
        });

        if (!result.node) {
          refNeedsArrowPos.start = result.error.pos || this.state.start;
          return expr;
        }

        if (result.error) this.state = result.failState;
        return result.node;
      };

      _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
        node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);

        if (this.eat(types.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }

        if (this.match(types.colon)) {
          var typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }

        return node;
      };

      _proto.parseExportDeclaration = function parseExportDeclaration(node) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var isDeclare = this.eatContextual("declare");
        var declaration;

        if (this.match(types.name)) {
          declaration = this.tsTryParseExportDeclaration();
        }

        if (!declaration) {
          declaration = _superClass.prototype.parseExportDeclaration.call(this, node);
        }

        if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
          node.exportKind = "type";
        }

        if (declaration && isDeclare) {
          this.resetStartLocation(declaration, startPos, startLoc);
          declaration.declare = true;
        }

        return declaration;
      };

      _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
        if ((!isStatement || optionalId) && this.isContextual("implements")) {
          return;
        }

        _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);

        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) node.typeParameters = typeParameters;
      };

      _proto.parseClassPropertyAnnotation = function parseClassPropertyAnnotation(node) {
        if (!node.optional && this.eat(types.bang)) {
          node.definite = true;
        }

        var type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      };

      _proto.parseClassProperty = function parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);

        if (node.declare && this.match(types.equal)) {
          this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
        }

        return _superClass.prototype.parseClassProperty.call(this, node);
      };

      _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
        if (node["abstract"]) {
          this.raise(node.start, TSErrors.PrivateElementHasAbstract);
        }

        if (node.accessibility) {
          this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);
        }

        this.parseClassPropertyAnnotation(node);
        return _superClass.prototype.parseClassPrivateProperty.call(this, node);
      };

      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) method.typeParameters = typeParameters;

        _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      };

      _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) method.typeParameters = typeParameters;

        _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
      };

      _proto.parseClassSuper = function parseClassSuper(node) {
        _superClass.prototype.parseClassSuper.call(this, node);

        if (node.superClass && this.isRelational("<")) {
          node.superTypeParameters = this.tsParseTypeArguments();
        }

        if (this.eatContextual("implements")) {
          node["implements"] = this.tsParseHeritageClause("implements");
        }
      };

      _proto.parseObjPropValue = function parseObjPropValue(prop) {
        var _superClass$prototype;

        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) prop.typeParameters = typeParameters;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        (_superClass$prototype = _superClass.prototype.parseObjPropValue).call.apply(_superClass$prototype, [this, prop].concat(args));
      };

      _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) node.typeParameters = typeParameters;

        _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);
      };

      _proto.parseVarId = function parseVarId(decl, kind) {
        _superClass.prototype.parseVarId.call(this, decl, kind);

        if (decl.id.type === "Identifier" && this.eat(types.bang)) {
          decl.definite = true;
        }

        var type = this.tsTryParseTypeAnnotation();

        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      };

      _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types.colon)) {
          node.returnType = this.tsParseTypeAnnotation();
        }

        return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
      };

      _proto.parseMaybeAssign = function parseMaybeAssign() {
        var _this15 = this;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var state;
        var jsx;
        var typeCast;

        if (this.match(types.jsxTagStart)) {
          state = this.state.clone();
          jsx = this.tryParse(function () {
            var _superClass$prototype2;

            return (_superClass$prototype2 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype2, [_this15].concat(args));
          }, state);
          if (!jsx.error) return jsx.node;
          var context = this.state.context;

          if (context[context.length - 1] === types$1.j_oTag) {
            context.length -= 2;
          } else if (context[context.length - 1] === types$1.j_expr) {
            context.length -= 1;
          }
        }

        if (!(jsx && jsx.error) && !this.isRelational("<")) {
          var _superClass$prototype3;

          return (_superClass$prototype3 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype3, [this].concat(args));
        }

        var typeParameters;
        state = state || this.state.clone();
        var arrow = this.tryParse(function (abort) {
          var _superClass$prototype4;

          typeParameters = _this15.tsParseTypeParameters();

          var expr = (_superClass$prototype4 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype4, [_this15].concat(args));

          if (expr.type !== "ArrowFunctionExpression" || expr.extra && expr.extra.parenthesized) {
            abort();
          }

          if (typeParameters && typeParameters.params.length !== 0) {
            _this15.resetStartLocationFromNode(expr, typeParameters);
          }

          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) return arrow.node;

        if (!jsx) {
          assert$1(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(function () {
            var _superClass$prototype5;

            return (_superClass$prototype5 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype5, [_this15].concat(args));
          }, state);
          if (!typeCast.error) return typeCast.node;
        }

        if (jsx && jsx.node) {
          this.state = jsx.failState;
          return jsx.node;
        }

        if (arrow.node) {
          this.state = arrow.failState;
          return arrow.node;
        }

        if (typeCast && typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }

        if (jsx && jsx.thrown) throw jsx.error;
        if (arrow.thrown) throw arrow.error;
        if (typeCast && typeCast.thrown) throw typeCast.error;
        throw jsx && jsx.error || arrow.error || typeCast && typeCast.error;
      };

      _proto.parseMaybeUnary = function parseMaybeUnary(refExpressionErrors) {
        if (!this.hasPlugin("jsx") && this.isRelational("<")) {
          return this.tsParseTypeAssertion();
        } else {
          return _superClass.prototype.parseMaybeUnary.call(this, refExpressionErrors);
        }
      };

      _proto.parseArrow = function parseArrow(node) {
        var _this16 = this;

        if (this.match(types.colon)) {
          var result = this.tryParse(function (abort) {
            var returnType = _this16.tsParseTypeOrTypePredicateAnnotation(types.colon);

            if (_this16.canInsertSemicolon() || !_this16.match(types.arrow)) abort();
            return returnType;
          });
          if (result.aborted) return;

          if (!result.thrown) {
            if (result.error) this.state = result.failState;
            node.returnType = result.node;
          }
        }

        return _superClass.prototype.parseArrow.call(this, node);
      };

      _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
        if (this.eat(types.question)) {
          if (param.type !== "Identifier") {
            this.raise(param.start, TSErrors.PatternIsOptional);
          }

          param.optional = true;
        }

        var type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      };

      _proto.toAssignable = function toAssignable(node) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node));

          case "TSParameterProperty":
            return _superClass.prototype.toAssignable.call(this, node);

          case "TSAsExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            node.expression = this.toAssignable(node.expression);
            return node;

          default:
            return _superClass.prototype.toAssignable.call(this, node);
        }
      };

      _proto.checkLVal = function checkLVal(expr, bindingType, checkClashes, contextDescription) {
        if (bindingType === void 0) {
          bindingType = BIND_NONE;
        }

        switch (expr.type) {
          case "TSTypeCastExpression":
            return;

          case "TSParameterProperty":
            this.checkLVal(expr.parameter, bindingType, checkClashes, "parameter property");
            return;

          case "TSAsExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            this.checkLVal(expr.expression, bindingType, checkClashes, contextDescription);
            return;

          default:
            _superClass.prototype.checkLVal.call(this, expr, bindingType, checkClashes, contextDescription);

            return;
        }
      };

      _proto.parseBindingAtom = function parseBindingAtom() {
        switch (this.state.type) {
          case types._this:
            return this.parseIdentifier(true);

          default:
            return _superClass.prototype.parseBindingAtom.call(this);
        }
      };

      _proto.parseMaybeDecoratorArguments = function parseMaybeDecoratorArguments(expr) {
        if (this.isRelational("<")) {
          var typeArguments = this.tsParseTypeArguments();

          if (this.match(types.parenL)) {
            var call = _superClass.prototype.parseMaybeDecoratorArguments.call(this, expr);

            call.typeParameters = typeArguments;
            return call;
          }

          this.unexpected(this.state.start, types.parenL);
        }

        return _superClass.prototype.parseMaybeDecoratorArguments.call(this, expr);
      };

      _proto.isClassMethod = function isClassMethod() {
        return this.isRelational("<") || _superClass.prototype.isClassMethod.call(this);
      };

      _proto.isClassProperty = function isClassProperty() {
        return this.match(types.bang) || this.match(types.colon) || _superClass.prototype.isClassProperty.call(this);
      };

      _proto.parseMaybeDefault = function parseMaybeDefault() {
        var _superClass$prototype6;

        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var node = (_superClass$prototype6 = _superClass.prototype.parseMaybeDefault).call.apply(_superClass$prototype6, [this].concat(args));

        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
        }

        return node;
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(types.relational, 1);
        } else {
          return _superClass.prototype.getTokenFromCode.call(this, code);
        }
      };

      _proto.toAssignableList = function toAssignableList(exprList) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];
          if (!expr) continue;

          switch (expr.type) {
            case "TSTypeCastExpression":
              exprList[i] = this.typeCastToParameter(expr);
              break;

            case "TSAsExpression":
            case "TSTypeAssertion":
              if (!this.state.maybeInArrowParameters) {
                exprList[i] = this.typeCastToParameter(expr);
              } else {
                this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
              }

              break;
          }
        }

        return _superClass.prototype.toAssignableList.apply(this, arguments);
      };

      _proto.typeCastToParameter = function typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
        return node.expression;
      };

      _proto.toReferencedList = function toReferencedList(exprList, isInParens) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];

          if (expr && expr.type === "TSTypeCastExpression") {
            this.raise(expr.start, TSErrors.UnexpectedTypeAnnotation);
          }
        }

        return exprList;
      };

      _proto.shouldParseArrow = function shouldParseArrow() {
        return this.match(types.colon) || _superClass.prototype.shouldParseArrow.call(this);
      };

      _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
        return this.match(types.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);
      };

      _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
        return _superClass.prototype.canHaveLeadingDecorator.call(this) || this.isAbstractClass();
      };

      _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
        var _this17 = this;

        if (this.isRelational("<")) {
          var typeArguments = this.tsTryParseAndCatch(function () {
            return _this17.tsParseTypeArguments();
          });
          if (typeArguments) node.typeParameters = typeArguments;
        }

        return _superClass.prototype.jsxParseOpeningElementAfterName.call(this, node);
      };

      _proto.getGetterSetterExpectedParamCount = function getGetterSetterExpectedParamCount(method) {
        var baseCount = _superClass.prototype.getGetterSetterExpectedParamCount.call(this, method);

        var firstParam = method.params[0];
        var hasContextParam = firstParam && firstParam.type === "Identifier" && firstParam.name === "this";
        return hasContextParam ? baseCount + 1 : baseCount;
      };

      return _class;
    }(superClass);
  });

  types.placeholder = new TokenType("%%", {
    startsExpr: true
  });
  var placeholders = (function (superClass) {
    return function (_superClass) {
      _inheritsLoose(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.parsePlaceholder = function parsePlaceholder(expectedNode) {
        if (this.match(types.placeholder)) {
          var node = this.startNode();
          this.next();
          this.assertNoSpace("Unexpected space in placeholder.");
          node.name = _superClass.prototype.parseIdentifier.call(this, true);
          this.assertNoSpace("Unexpected space in placeholder.");
          this.expect(types.placeholder);
          return this.finishPlaceholder(node, expectedNode);
        }
      };

      _proto.finishPlaceholder = function finishPlaceholder(node, expectedNode) {
        var isFinished = !!(node.expectedNode && node.type === "Placeholder");
        node.expectedNode = expectedNode;
        return isFinished ? node : this.finishNode(node, "Placeholder");
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          return this.finishOp(types.placeholder, 2);
        }

        return _superClass.prototype.getTokenFromCode.apply(this, arguments);
      };

      _proto.parseExprAtom = function parseExprAtom() {
        return this.parsePlaceholder("Expression") || _superClass.prototype.parseExprAtom.apply(this, arguments);
      };

      _proto.parseIdentifier = function parseIdentifier() {
        return this.parsePlaceholder("Identifier") || _superClass.prototype.parseIdentifier.apply(this, arguments);
      };

      _proto.checkReservedWord = function checkReservedWord(word) {
        if (word !== undefined) _superClass.prototype.checkReservedWord.apply(this, arguments);
      };

      _proto.parseBindingAtom = function parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || _superClass.prototype.parseBindingAtom.apply(this, arguments);
      };

      _proto.checkLVal = function checkLVal(expr) {
        if (expr.type !== "Placeholder") _superClass.prototype.checkLVal.apply(this, arguments);
      };

      _proto.toAssignable = function toAssignable(node) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
          return node;
        }

        return _superClass.prototype.toAssignable.apply(this, arguments);
      };

      _proto.verifyBreakContinue = function verifyBreakContinue(node) {
        if (node.label && node.label.type === "Placeholder") return;

        _superClass.prototype.verifyBreakContinue.apply(this, arguments);
      };

      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
        if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
          return _superClass.prototype.parseExpressionStatement.apply(this, arguments);
        }

        if (this.match(types.colon)) {
          var stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = this.parseStatement("label");
          return this.finishNode(stmt, "LabeledStatement");
        }

        this.semicolon();
        node.name = expr.name;
        return this.finishPlaceholder(node, "Statement");
      };

      _proto.parseBlock = function parseBlock() {
        return this.parsePlaceholder("BlockStatement") || _superClass.prototype.parseBlock.apply(this, arguments);
      };

      _proto.parseFunctionId = function parseFunctionId() {
        return this.parsePlaceholder("Identifier") || _superClass.prototype.parseFunctionId.apply(this, arguments);
      };

      _proto.parseClass = function parseClass(node, isStatement, optionalId) {
        var type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        this.takeDecorators(node);
        var placeholder = this.parsePlaceholder("Identifier");

        if (placeholder) {
          if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            this.unexpected(null, "A class name is required");
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }

        this.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass);
        return this.finishNode(node, type);
      };

      _proto.parseExport = function parseExport(node) {
        var placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return _superClass.prototype.parseExport.apply(this, arguments);

        if (!this.isContextual("from") && !this.match(types.comma)) {
          node.specifiers = [];
          node.source = null;
          node.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node, "ExportNamedDeclaration");
        }

        this.expectPlugin("exportDefaultFrom");
        var specifier = this.startNode();
        specifier.exported = placeholder;
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return _superClass.prototype.parseExport.call(this, node);
      };

      _proto.maybeParseExportDefaultSpecifier = function maybeParseExportDefaultSpecifier(node) {
        if (node.specifiers && node.specifiers.length > 0) {
          return true;
        }

        return _superClass.prototype.maybeParseExportDefaultSpecifier.apply(this, arguments);
      };

      _proto.checkExport = function checkExport(node) {
        var specifiers = node.specifiers;

        if (specifiers && specifiers.length) {
          node.specifiers = specifiers.filter(function (node) {
            return node.exported.type === "Placeholder";
          });
        }

        _superClass.prototype.checkExport.call(this, node);

        node.specifiers = specifiers;
      };

      _proto.parseImport = function parseImport(node) {
        var placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return _superClass.prototype.parseImport.apply(this, arguments);
        node.specifiers = [];

        if (!this.isContextual("from") && !this.match(types.comma)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }

        var specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        this.finishNode(specifier, "ImportDefaultSpecifier");
        node.specifiers.push(specifier);

        if (this.eat(types.comma)) {
          var hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport) this.parseNamedImportSpecifiers(node);
        }

        this.expectContextual("from");
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };

      _proto.parseImportSource = function parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || _superClass.prototype.parseImportSource.apply(this, arguments);
      };

      return _class;
    }(superClass);
  });

  var v8intrinsic = (function (superClass) {
    return function (_superClass) {
      _inheritsLoose(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.parseV8Intrinsic = function parseV8Intrinsic() {
        if (this.match(types.modulo)) {
          var v8IntrinsicStart = this.state.start;
          var node = this.startNode();
          this.eat(types.modulo);

          if (this.match(types.name)) {
            var name = this.parseIdentifierName(this.state.start);
            var identifier = this.createIdentifier(node, name);
            identifier.type = "V8IntrinsicIdentifier";

            if (this.match(types.parenL)) {
              return identifier;
            }
          }

          this.unexpected(v8IntrinsicStart);
        }
      };

      _proto.parseExprAtom = function parseExprAtom() {
        return this.parseV8Intrinsic() || _superClass.prototype.parseExprAtom.apply(this, arguments);
      };

      return _class;
    }(superClass);
  });

  function hasPlugin(plugins, name) {
    return plugins.some(function (plugin) {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });
  }
  function getPluginOption(plugins, name, option) {
    var plugin = plugins.find(function (plugin) {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });

    if (plugin && Array.isArray(plugin)) {
      return plugin[1][option];
    }

    return null;
  }
  var PIPELINE_PROPOSALS = ["minimal", "smart", "fsharp"];
  var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
  function validatePlugins(plugins) {
    if (hasPlugin(plugins, "decorators")) {
      if (hasPlugin(plugins, "decorators-legacy")) {
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      }

      var decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

      if (decoratorsBeforeExport == null) {
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
      } else if (typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }

    if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
      throw new Error("Cannot combine flow and typescript plugins.");
    }

    if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    }

    if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
      throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map(function (p) {
        return "'" + p + "'";
      }).join(", "));
    }

    if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(function (p) {
        return "'" + p + "'";
      }).join(", "));
    }
  }
  var mixinPlugins = {
    estree: estree,
    jsx: jsx,
    flow: flow,
    typescript: typescript,
    v8intrinsic: v8intrinsic,
    placeholders: placeholders
  };
  var mixinPluginNames = Object.keys(mixinPlugins);

  var defaultOptions = {
    sourceType: "script",
    sourceFilename: undefined,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createParenthesizedExpressions: false,
    errorRecovery: false
  };
  function getOptions(opts) {
    var options = {};

    for (var _i2 = 0, _Object$keys2 = Object.keys(defaultOptions); _i2 < _Object$keys2.length; _i2++) {
      var key = _Object$keys2[_i2];
      options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
    }

    return options;
  }

  var State = function () {
    function State() {
      this.errors = [];
      this.potentialArrowAt = -1;
      this.noArrowAt = [];
      this.noArrowParamsConversionAt = [];
      this.inParameters = false;
      this.maybeInArrowParameters = false;
      this.maybeInAsyncArrowHead = false;
      this.inPipeline = false;
      this.inType = false;
      this.noAnonFunctionType = false;
      this.inPropertyName = false;
      this.hasFlowComment = false;
      this.isIterator = false;
      this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      this.soloAwait = false;
      this.inFSharpPipelineDirectBody = false;
      this.labels = [];
      this.decoratorStack = [[]];
      this.yieldPos = -1;
      this.awaitPos = -1;
      this.comments = [];
      this.trailingComments = [];
      this.leadingComments = [];
      this.commentStack = [];
      this.commentPreviousNode = null;
      this.pos = 0;
      this.lineStart = 0;
      this.type = types.eof;
      this.value = null;
      this.start = 0;
      this.end = 0;
      this.lastTokEndLoc = null;
      this.lastTokStartLoc = null;
      this.lastTokStart = 0;
      this.lastTokEnd = 0;
      this.context = [types$1.braceStatement];
      this.exprAllowed = true;
      this.containsEsc = false;
      this.octalPositions = [];
      this.exportedIdentifiers = [];
      this.tokensLength = 0;
    }

    var _proto = State.prototype;

    _proto.init = function init(options) {
      this.strict = options.strictMode === false ? false : options.sourceType === "module";
      this.curLine = options.startLine;
      this.startLoc = this.endLoc = this.curPosition();
    };

    _proto.curPosition = function curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart);
    };

    _proto.clone = function clone(skipArrays) {
      var state = new State();
      var keys = Object.keys(this);

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var val = this[key];

        if (!skipArrays && Array.isArray(val)) {
          val = val.slice();
        }

        state[key] = val;
      }

      return state;
    };

    return State;
  }();

  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  var VALID_REGEX_FLAGS = new Set(["g", "m", "s", "i", "y", "u"]);
  var forbiddenNumericSeparatorSiblings = {
    decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
    hex: [46, 88, 95, 120]
  };
  var allowedNumericSeparatorSiblings = {};
  allowedNumericSeparatorSiblings.bin = [48, 49];
  allowedNumericSeparatorSiblings.oct = [].concat(allowedNumericSeparatorSiblings.bin, [50, 51, 52, 53, 54, 55]);
  allowedNumericSeparatorSiblings.dec = [].concat(allowedNumericSeparatorSiblings.oct, [56, 57]);
  allowedNumericSeparatorSiblings.hex = [].concat(allowedNumericSeparatorSiblings.dec, [65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]);
  var Token = function Token(state) {
    this.type = state.type;
    this.value = state.value;
    this.start = state.start;
    this.end = state.end;
    this.loc = new SourceLocation(state.startLoc, state.endLoc);
  };

  var Tokenizer = function (_LocationParser) {
    _inheritsLoose(Tokenizer, _LocationParser);

    function Tokenizer(options, input) {
      var _this;

      _this = _LocationParser.call(this) || this;
      _this.tokens = [];
      _this.state = new State();

      _this.state.init(options);

      _this.input = input;
      _this.length = input.length;
      _this.isLookahead = false;
      return _this;
    }

    var _proto = Tokenizer.prototype;

    _proto.pushToken = function pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    };

    _proto.next = function next() {
      if (!this.isLookahead) {
        this.checkKeywordEscapes();

        if (this.options.tokens) {
          this.pushToken(new Token(this.state));
        }
      }

      this.state.lastTokEnd = this.state.end;
      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    };

    _proto.eat = function eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    };

    _proto.match = function match(type) {
      return this.state.type === type;
    };

    _proto.lookahead = function lookahead() {
      var old = this.state;
      this.state = old.clone(true);
      this.isLookahead = true;
      this.next();
      this.isLookahead = false;
      var curr = this.state;
      this.state = old;
      return curr;
    };

    _proto.nextTokenStart = function nextTokenStart() {
      var thisTokEnd = this.state.pos;
      skipWhiteSpace.lastIndex = thisTokEnd;
      var skip = skipWhiteSpace.exec(this.input);
      return thisTokEnd + skip[0].length;
    };

    _proto.lookaheadCharCode = function lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    };

    _proto.setStrict = function setStrict(strict) {
      this.state.strict = strict;
      if (!this.match(types.num) && !this.match(types.string)) return;
      this.state.pos = this.state.start;

      while (this.state.pos < this.state.lineStart) {
        this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
        --this.state.curLine;
      }

      this.nextToken();
    };

    _proto.curContext = function curContext() {
      return this.state.context[this.state.context.length - 1];
    };

    _proto.nextToken = function nextToken() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) this.skipSpace();
      this.state.octalPositions = [];
      this.state.start = this.state.pos;
      this.state.startLoc = this.state.curPosition();

      if (this.state.pos >= this.length) {
        this.finishToken(types.eof);
        return;
      }

      var override = curContext == null ? void 0 : curContext.override;

      if (override) {
        override(this);
      } else {
        this.getTokenFromCode(this.input.codePointAt(this.state.pos));
      }
    };

    _proto.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "CommentBlock" : "CommentLine",
        value: text,
        start: start,
        end: end,
        loc: new SourceLocation(startLoc, endLoc)
      };
      if (this.options.tokens) this.pushToken(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    };

    _proto.skipBlockComment = function skipBlockComment() {
      var startLoc = this.state.curPosition();
      var start = this.state.pos;
      var end = this.input.indexOf("*/", this.state.pos + 2);
      if (end === -1) throw this.raise(start, Errors.UnterminatedComment);
      this.state.pos = end + 2;
      lineBreakG.lastIndex = start;
      var match;

      while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
        ++this.state.curLine;
        this.state.lineStart = match.index + match[0].length;
      }

      if (this.isLookahead) return;
      this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
    };

    _proto.skipLineComment = function skipLineComment(startSkip) {
      var start = this.state.pos;
      var startLoc = this.state.curPosition();
      var ch = this.input.charCodeAt(this.state.pos += startSkip);

      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }

      if (this.isLookahead) return;
      this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
    };

    _proto.skipSpace = function skipSpace() {
      loop: while (this.state.pos < this.length) {
        var ch = this.input.charCodeAt(this.state.pos);

        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;

          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }

          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;

          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;

              case 47:
                this.skipLineComment(2);
                break;

              default:
                break loop;
            }

            break;

          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else {
              break loop;
            }

        }
      }
    };

    _proto.finishToken = function finishToken(type, val) {
      this.state.end = this.state.pos;
      this.state.endLoc = this.state.curPosition();
      var prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;
      if (!this.isLookahead) this.updateContext(prevType);
    };

    _proto.readToken_numberSign = function readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }

      var nextPos = this.state.pos + 1;
      var next = this.input.charCodeAt(nextPos);

      if (next >= 48 && next <= 57) {
        throw this.raise(this.state.pos, Errors.UnexpectedDigitAfterHash);
      }

      if (this.hasPlugin("recordAndTuple") && (next === 123 || next === 91)) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
          throw this.raise(this.state.pos, next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType);
        }

        if (next === 123) {
          this.finishToken(types.braceHashL);
        } else {
          this.finishToken(types.bracketHashL);
        }

        this.state.pos += 2;
      } else if (this.hasPlugin("classPrivateProperties") || this.hasPlugin("classPrivateMethods") || this.getPluginOption("pipelineOperator", "proposal") === "smart") {
        this.finishOp(types.hash, 1);
      } else {
        throw this.raise(this.state.pos, Errors.InvalidOrUnexpectedToken, "#");
      }
    };

    _proto.readToken_dot = function readToken_dot() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }

      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(types.ellipsis);
      } else {
        ++this.state.pos;
        this.finishToken(types.dot);
      }
    };

    _proto.readToken_slash = function readToken_slash() {
      if (this.state.exprAllowed && !this.state.inType) {
        ++this.state.pos;
        this.readRegexp();
        return;
      }

      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.slash, 1);
      }
    };

    _proto.readToken_interpreter = function readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return false;
      var ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33) return false;
      var start = this.state.pos;
      this.state.pos += 1;

      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }

      var value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(types.interpreterDirective, value);
      return true;
    };

    _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
      var type = code === 42 ? types.star : types.modulo;
      var width = 1;
      var next = this.input.charCodeAt(this.state.pos + 1);
      var exprAllowed = this.state.exprAllowed;

      if (code === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = types.exponent;
      }

      if (next === 61 && !exprAllowed) {
        width++;
        type = types.assign;
      }

      this.finishOp(type, width);
    };

    _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(types.assign, 3);
        } else {
          this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
        }

        return;
      }

      if (code === 124) {
        if (next === 62) {
          this.finishOp(types.pipeline, 2);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, Errors.RecordExpressionBarIncorrectEndSyntaxType);
          }

          this.finishOp(types.braceBarR, 2);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, Errors.TupleExpressionBarIncorrectEndSyntaxType);
          }

          this.finishOp(types.bracketBarR, 2);
          return;
        }
      }

      if (next === 61) {
        this.finishOp(types.assign, 2);
        return;
      }

      this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
    };

    _proto.readToken_caret = function readToken_caret() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.bitwiseXOR, 1);
      }
    };

    _proto.readToken_plus_min = function readToken_plus_min(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos)))) {
          this.skipLineComment(3);
          this.skipSpace();
          this.nextToken();
          return;
        }

        this.finishOp(types.incDec, 2);
        return;
      }

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.plusMin, 1);
      }
    };

    _proto.readToken_lt_gt = function readToken_lt_gt(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var size = 1;

      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;

        if (this.input.charCodeAt(this.state.pos + size) === 61) {
          this.finishOp(types.assign, size + 1);
          return;
        }

        this.finishOp(types.bitShift, size);
        return;
      }

      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        this.nextToken();
        return;
      }

      if (next === 61) {
        size = 2;
      }

      this.finishOp(types.relational, size);
    };

    _proto.readToken_eq_excl = function readToken_eq_excl(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }

      if (code === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(types.arrow);
        return;
      }

      this.finishOp(code === 61 ? types.eq : types.bang, 1);
    };

    _proto.readToken_question = function readToken_question() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var next2 = this.input.charCodeAt(this.state.pos + 2);

      if (next === 63 && !this.state.inType) {
        if (next2 === 61) {
          this.finishOp(types.assign, 3);
        } else {
          this.finishOp(types.nullishCoalescing, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(types.questionDot);
      } else {
        ++this.state.pos;
        this.finishToken(types.question);
      }
    };

    _proto.getTokenFromCode = function getTokenFromCode(code) {
      switch (code) {
        case 46:
          this.readToken_dot();
          return;

        case 40:
          ++this.state.pos;
          this.finishToken(types.parenL);
          return;

        case 41:
          ++this.state.pos;
          this.finishToken(types.parenR);
          return;

        case 59:
          ++this.state.pos;
          this.finishToken(types.semi);
          return;

        case 44:
          ++this.state.pos;
          this.finishToken(types.comma);
          return;

        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, Errors.TupleExpressionBarIncorrectStartSyntaxType);
            }

            this.finishToken(types.bracketBarL);
            this.state.pos += 2;
          } else {
            ++this.state.pos;
            this.finishToken(types.bracketL);
          }

          return;

        case 93:
          ++this.state.pos;
          this.finishToken(types.bracketR);
          return;

        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, Errors.RecordExpressionBarIncorrectStartSyntaxType);
            }

            this.finishToken(types.braceBarL);
            this.state.pos += 2;
          } else {
            ++this.state.pos;
            this.finishToken(types.braceL);
          }

          return;

        case 125:
          ++this.state.pos;
          this.finishToken(types.braceR);
          return;

        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(types.doubleColon, 2);
          } else {
            ++this.state.pos;
            this.finishToken(types.colon);
          }

          return;

        case 63:
          this.readToken_question();
          return;

        case 96:
          ++this.state.pos;
          this.finishToken(types.backQuote);
          return;

        case 48:
          {
            var next = this.input.charCodeAt(this.state.pos + 1);

            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }

            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }

            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }

        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;

        case 34:
        case 39:
          this.readString(code);
          return;

        case 47:
          this.readToken_slash();
          return;

        case 37:
        case 42:
          this.readToken_mult_modulo(code);
          return;

        case 124:
        case 38:
          this.readToken_pipe_amp(code);
          return;

        case 94:
          this.readToken_caret();
          return;

        case 43:
        case 45:
          this.readToken_plus_min(code);
          return;

        case 60:
        case 62:
          this.readToken_lt_gt(code);
          return;

        case 61:
        case 33:
          this.readToken_eq_excl(code);
          return;

        case 126:
          this.finishOp(types.tilde, 1);
          return;

        case 64:
          ++this.state.pos;
          this.finishToken(types.at);
          return;

        case 35:
          this.readToken_numberSign();
          return;

        case 92:
          this.readWord();
          return;

        default:
          if (isIdentifierStart(code)) {
            this.readWord();
            return;
          }

      }

      throw this.raise(this.state.pos, Errors.InvalidOrUnexpectedToken, String.fromCodePoint(code));
    };

    _proto.finishOp = function finishOp(type, size) {
      var str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    };

    _proto.readRegexp = function readRegexp() {
      var start = this.state.pos;
      var escaped, inClass;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(start, Errors.UnterminatedRegExp);
        }

        var ch = this.input.charAt(this.state.pos);

        if (lineBreak.test(ch)) {
          throw this.raise(start, Errors.UnterminatedRegExp);
        }

        if (escaped) {
          escaped = false;
        } else {
          if (ch === "[") {
            inClass = true;
          } else if (ch === "]" && inClass) {
            inClass = false;
          } else if (ch === "/" && !inClass) {
            break;
          }

          escaped = ch === "\\";
        }

        ++this.state.pos;
      }

      var content = this.input.slice(start, this.state.pos);
      ++this.state.pos;
      var mods = "";

      while (this.state.pos < this.length) {
        var _char = this.input[this.state.pos];
        var charCode = this.input.codePointAt(this.state.pos);

        if (VALID_REGEX_FLAGS.has(_char)) {
          if (mods.indexOf(_char) > -1) {
            this.raise(this.state.pos + 1, Errors.DuplicateRegExpFlags);
          }
        } else if (isIdentifierChar(charCode) || charCode === 92) {
          this.raise(this.state.pos + 1, Errors.MalformedRegExpFlags);
        } else {
          break;
        }

        ++this.state.pos;
        mods += _char;
      }

      this.finishToken(types.regexp, {
        pattern: content,
        flags: mods
      });
    };

    _proto.readInt = function readInt(radix, len, forceLen, allowNumSeparator) {
      if (allowNumSeparator === void 0) {
        allowNumSeparator = true;
      }

      var start = this.state.pos;
      var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      var allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
      var invalid = false;
      var total = 0;

      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        var code = this.input.charCodeAt(this.state.pos);
        var val = void 0;

        if (this.hasPlugin("numericSeparator")) {
          if (code === 95) {
            var prev = this.input.charCodeAt(this.state.pos - 1);
            var next = this.input.charCodeAt(this.state.pos + 1);

            if (allowedSiblings.indexOf(next) === -1) {
              this.raise(this.state.pos, Errors.UnexpectedNumericSeparator);
            } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
              this.raise(this.state.pos, Errors.UnexpectedNumericSeparator);
            }

            if (!allowNumSeparator) {
              this.raise(this.state.pos, Errors.NumericSeparatorInEscapeSequence);
            }

            ++this.state.pos;
            continue;
          }
        }

        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }

        if (val >= radix) {
          if (this.options.errorRecovery && val <= 9) {
            val = 0;
            this.raise(this.state.start + i + 2, Errors.InvalidDigit, radix);
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }

        ++this.state.pos;
        total = total * radix + val;
      }

      if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
        return null;
      }

      return total;
    };

    _proto.readRadixNumber = function readRadixNumber(radix) {
      var start = this.state.pos;
      var isBigInt = false;
      this.state.pos += 2;
      var val = this.readInt(radix);

      if (val == null) {
        this.raise(this.state.start + 2, Errors.InvalidDigit, radix);
      }

      if (this.input.charCodeAt(this.state.pos) === 110) {
        ++this.state.pos;
        isBigInt = true;
      }

      if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
        throw this.raise(this.state.pos, Errors.NumberIdentifier);
      }

      if (isBigInt) {
        var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(types.bigint, str);
        return;
      }

      this.finishToken(types.num, val);
    };

    _proto.readNumber = function readNumber(startsWithDot) {
      var start = this.state.pos;
      var isFloat = false;
      var isBigInt = false;
      var isNonOctalDecimalInt = false;

      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(start, Errors.InvalidNumber);
      }

      var octal = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

      if (octal) {
        if (this.state.strict) {
          this.raise(start, Errors.StrictOctalLiteral);
        }

        if (/[89]/.test(this.input.slice(start, this.state.pos))) {
          octal = false;
          isNonOctalDecimalInt = true;
        }
      }

      var next = this.input.charCodeAt(this.state.pos);

      if (next === 46 && !octal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.state.pos);

        if (next === 43 || next === 45) {
          ++this.state.pos;
        }

        if (this.readInt(10) === null) this.raise(start, "Invalid number");
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if (this.hasPlugin("numericSeparator") && (octal || isNonOctalDecimalInt)) {
        var underscorePos = this.input.slice(start, this.state.pos).indexOf("_");

        if (underscorePos > 0) {
          this.raise(underscorePos + start, Errors.ZeroDigitNumericSeparator);
        }
      }

      if (next === 110) {
        if (isFloat || octal || isNonOctalDecimalInt) {
          this.raise(start, "Invalid BigIntLiteral");
        }

        ++this.state.pos;
        isBigInt = true;
      }

      if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
        throw this.raise(this.state.pos, Errors.NumberIdentifier);
      }

      var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");

      if (isBigInt) {
        this.finishToken(types.bigint, str);
        return;
      }

      var val = octal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(types.num, val);
    };

    _proto.readCodePoint = function readCodePoint(throwOnInvalid) {
      var ch = this.input.charCodeAt(this.state.pos);
      var code;

      if (ch === 123) {
        var codePos = ++this.state.pos;
        code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
        ++this.state.pos;

        if (code !== null && code > 0x10ffff) {
          if (throwOnInvalid) {
            this.raise(codePos, Errors.InvalidCodePoint);
          } else {
            return null;
          }
        }
      } else {
        code = this.readHexChar(4, false, throwOnInvalid);
      }

      return code;
    };

    _proto.readString = function readString(quote) {
      var out = "",
          chunkStart = ++this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, Errors.UnterminatedString);
        }

        var ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.state.pos;
        } else if (ch === 8232 || ch === 8233) {
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
        } else if (isNewLine(ch)) {
          throw this.raise(this.state.start, Errors.UnterminatedString);
        } else {
          ++this.state.pos;
        }
      }

      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(types.string, out);
    };

    _proto.readTmplToken = function readTmplToken() {
      var out = "",
          chunkStart = this.state.pos,
          containsInvalid = false;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, Errors.UnterminatedTemplate);
        }

        var ch = this.input.charCodeAt(this.state.pos);

        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          if (this.state.pos === this.state.start && this.match(types.template)) {
            if (ch === 36) {
              this.state.pos += 2;
              this.finishToken(types.dollarBraceL);
              return;
            } else {
              ++this.state.pos;
              this.finishToken(types.backQuote);
              return;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos);
          this.finishToken(types.template, containsInvalid ? null : out);
          return;
        }

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          var escaped = this.readEscapedChar(true);

          if (escaped === null) {
            containsInvalid = true;
          } else {
            out += escaped;
          }

          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          ++this.state.pos;

          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
              }

            case 10:
              out += "\n";
              break;

            default:
              out += String.fromCharCode(ch);
              break;
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
    };

    _proto.readEscapedChar = function readEscapedChar(inTemplate) {
      var throwOnInvalid = !inTemplate;
      var ch = this.input.charCodeAt(++this.state.pos);
      ++this.state.pos;

      switch (ch) {
        case 110:
          return "\n";

        case 114:
          return "\r";

        case 120:
          {
            var code = this.readHexChar(2, false, throwOnInvalid);
            return code === null ? null : String.fromCharCode(code);
          }

        case 117:
          {
            var _code = this.readCodePoint(throwOnInvalid);

            return _code === null ? null : String.fromCodePoint(_code);
          }

        case 116:
          return "\t";

        case 98:
          return "\b";

        case 118:
          return "\x0B";

        case 102:
          return "\f";

        case 13:
          if (this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
          }

        case 10:
          this.state.lineStart = this.state.pos;
          ++this.state.curLine;

        case 8232:
        case 8233:
          return "";

        case 56:
        case 57:
          if (inTemplate) {
            return null;
          }

        default:
          if (ch >= 48 && ch <= 55) {
            var codePos = this.state.pos - 1;
            var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);

            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }

            this.state.pos += octalStr.length - 1;
            var next = this.input.charCodeAt(this.state.pos);

            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return null;
              } else if (this.state.strict) {
                this.raise(codePos, Errors.StrictOctalLiteral);
              } else {
                this.state.octalPositions.push(codePos);
              }
            }

            return String.fromCharCode(octal);
          }

          return String.fromCharCode(ch);
      }
    };

    _proto.readHexChar = function readHexChar(len, forceLen, throwOnInvalid) {
      var codePos = this.state.pos;
      var n = this.readInt(16, len, forceLen, false);

      if (n === null) {
        if (throwOnInvalid) {
          this.raise(codePos, Errors.InvalidEscapeSequence);
        } else {
          this.state.pos = codePos - 1;
        }
      }

      return n;
    };

    _proto.readWord1 = function readWord1() {
      var word = "";
      this.state.containsEsc = false;
      var start = this.state.pos;
      var chunkStart = this.state.pos;

      while (this.state.pos < this.length) {
        var ch = this.input.codePointAt(this.state.pos);

        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 0xffff ? 1 : 2;
        } else if (this.state.isIterator && ch === 64) {
          ++this.state.pos;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          var escStart = this.state.pos;
          var identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, Errors.MissingUnicodeEscape);
            continue;
          }

          ++this.state.pos;
          var esc = this.readCodePoint(true);

          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(escStart, Errors.EscapedCharNotAnIdentifier);
            }

            word += String.fromCodePoint(esc);
          }

          chunkStart = this.state.pos;
        } else {
          break;
        }
      }

      return word + this.input.slice(chunkStart, this.state.pos);
    };

    _proto.isIterator = function isIterator(word) {
      return word === "@@iterator" || word === "@@asyncIterator";
    };

    _proto.readWord = function readWord() {
      var word = this.readWord1();
      var type = keywords$1.get(word) || types.name;

      if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {
        this.raise(this.state.pos, Errors.InvalidIdentifier, word);
      }

      this.finishToken(type, word);
    };

    _proto.checkKeywordEscapes = function checkKeywordEscapes() {
      var kw = this.state.type.keyword;

      if (kw && this.state.containsEsc) {
        this.raise(this.state.start, Errors.InvalidEscapedReservedWord, kw);
      }
    };

    _proto.braceIsBlock = function braceIsBlock(prevType) {
      var parent = this.curContext();

      if (parent === types$1.functionExpression || parent === types$1.functionStatement) {
        return true;
      }

      if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {
        return !parent.isExpr;
      }

      if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {
        return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
      }

      if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
        return true;
      }

      if (prevType === types.braceL) {
        return parent === types$1.braceStatement;
      }

      if (prevType === types._var || prevType === types._const || prevType === types.name) {
        return false;
      }

      if (prevType === types.relational) {
        return true;
      }

      return !this.state.exprAllowed;
    };

    _proto.updateContext = function updateContext(prevType) {
      var type = this.state.type;
      var update;

      if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {
        this.state.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.state.exprAllowed = type.beforeExpr;
      }
    };

    return Tokenizer;
  }(LocationParser);

  var UtilParser = function (_Tokenizer) {
    _inheritsLoose(UtilParser, _Tokenizer);

    function UtilParser() {
      return _Tokenizer.apply(this, arguments) || this;
    }

    var _proto = UtilParser.prototype;

    _proto.addExtra = function addExtra(node, key, val) {
      if (!node) return;
      var extra = node.extra = node.extra || {};
      extra[key] = val;
    };

    _proto.isRelational = function isRelational(op) {
      return this.match(types.relational) && this.state.value === op;
    };

    _proto.isLookaheadRelational = function isLookaheadRelational(op) {
      var next = this.nextTokenStart();

      if (this.input.charAt(next) === op) {
        if (next + 1 === this.input.length) {
          return true;
        }

        var afterNext = this.input.charCodeAt(next + 1);
        return afterNext !== op.charCodeAt(0) && afterNext !== 61;
      }

      return false;
    };

    _proto.expectRelational = function expectRelational(op) {
      if (this.isRelational(op)) {
        this.next();
      } else {
        this.unexpected(null, types.relational);
      }
    };

    _proto.isContextual = function isContextual(name) {
      return this.match(types.name) && this.state.value === name && !this.state.containsEsc;
    };

    _proto.isUnparsedContextual = function isUnparsedContextual(nameStart, name) {
      var nameEnd = nameStart + name.length;
      return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));
    };

    _proto.isLookaheadContextual = function isLookaheadContextual(name) {
      var next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    };

    _proto.eatContextual = function eatContextual(name) {
      return this.isContextual(name) && this.eat(types.name);
    };

    _proto.expectContextual = function expectContextual(name, message) {
      if (!this.eatContextual(name)) this.unexpected(null, message);
    };

    _proto.canInsertSemicolon = function canInsertSemicolon() {
      return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();
    };

    _proto.hasPrecedingLineBreak = function hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    };

    _proto.isLineTerminator = function isLineTerminator() {
      return this.eat(types.semi) || this.canInsertSemicolon();
    };

    _proto.semicolon = function semicolon() {
      if (!this.isLineTerminator()) this.unexpected(null, types.semi);
    };

    _proto.expect = function expect(type, pos) {
      this.eat(type) || this.unexpected(pos, type);
    };

    _proto.assertNoSpace = function assertNoSpace(message) {
      if (message === void 0) {
        message = "Unexpected space.";
      }

      if (this.state.start > this.state.lastTokEnd) {
        this.raise(this.state.lastTokEnd, message);
      }
    };

    _proto.unexpected = function unexpected(pos, messageOrType) {
      if (messageOrType === void 0) {
        messageOrType = "Unexpected token";
      }

      if (typeof messageOrType !== "string") {
        messageOrType = "Unexpected token, expected \"" + messageOrType.label + "\"";
      }

      throw this.raise(pos != null ? pos : this.state.start, messageOrType);
    };

    _proto.expectPlugin = function expectPlugin(name, pos) {
      if (!this.hasPlugin(name)) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: [name]
        }, "This experimental syntax requires enabling the parser plugin: '" + name + "'");
      }

      return true;
    };

    _proto.expectOnePlugin = function expectOnePlugin(names, pos) {
      var _this = this;

      if (!names.some(function (n) {
        return _this.hasPlugin(n);
      })) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: names
        }, "This experimental syntax requires enabling one of the following parser plugin(s): '" + names.join(", ") + "'");
      }
    };

    _proto.checkYieldAwaitInDefaultParams = function checkYieldAwaitInDefaultParams() {
      if (this.state.yieldPos !== -1 && (this.state.awaitPos === -1 || this.state.yieldPos < this.state.awaitPos)) {
        this.raise(this.state.yieldPos, "Yield cannot be used as name inside a generator function");
      }

      if (this.state.awaitPos !== -1) {
        this.raise(this.state.awaitPos, "Await cannot be used as name inside an async function");
      }
    };

    _proto.tryParse = function tryParse(fn, oldState) {
      if (oldState === void 0) {
        oldState = this.state.clone();
      }

      var abortSignal = {
        node: null
      };

      try {
        var _node = fn(function (node) {
          if (node === void 0) {
            node = null;
          }

          abortSignal.node = node;
          throw abortSignal;
        });

        if (this.state.errors.length > oldState.errors.length) {
          var failState = this.state;
          this.state = oldState;
          return {
            node: _node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState: failState
          };
        }

        return {
          node: _node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        var _failState = this.state;
        this.state = oldState;

        if (error instanceof SyntaxError) {
          return {
            node: null,
            error: error,
            thrown: true,
            aborted: false,
            failState: _failState
          };
        }

        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState: _failState
          };
        }

        throw error;
      }
    };

    _proto.checkExpressionErrors = function checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return false;
      var shorthandAssign = refExpressionErrors.shorthandAssign,
          doubleProto = refExpressionErrors.doubleProto;
      if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;

      if (shorthandAssign >= 0) {
        this.unexpected(shorthandAssign);
      }

      if (doubleProto >= 0) {
        this.raise(doubleProto, Errors.DuplicateProto);
      }
    };

    return UtilParser;
  }(Tokenizer);
  var ExpressionErrors = function ExpressionErrors() {
    this.shorthandAssign = -1;
    this.doubleProto = -1;
  };

  var Node = function () {
    function Node(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      this.loc = new SourceLocation(loc);
      if (parser && parser.options.ranges) this.range = [pos, 0];
      if (parser && parser.filename) this.loc.filename = parser.filename;
    }

    var _proto = Node.prototype;

    _proto.__clone = function __clone() {
      var newNode = new Node();
      var keys = Object.keys(this);

      for (var i = 0, length = keys.length; i < length; i++) {
        var _key = keys[i];

        if (_key !== "leadingComments" && _key !== "trailingComments" && _key !== "innerComments") {
          newNode[_key] = this[_key];
        }
      }

      return newNode;
    };

    return Node;
  }();

  var NodeUtils = function (_UtilParser) {
    _inheritsLoose(NodeUtils, _UtilParser);

    function NodeUtils() {
      return _UtilParser.apply(this, arguments) || this;
    }

    var _proto2 = NodeUtils.prototype;

    _proto2.startNode = function startNode() {
      return new Node(this, this.state.start, this.state.startLoc);
    };

    _proto2.startNodeAt = function startNodeAt(pos, loc) {
      return new Node(this, pos, loc);
    };

    _proto2.startNodeAtNode = function startNodeAtNode(type) {
      return this.startNodeAt(type.start, type.loc.start);
    };

    _proto2.finishNode = function finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
    };

    _proto2.finishNodeAt = function finishNodeAt(node, type, pos, loc) {
      if ( node.end > 0) {
        throw new Error("Do not call finishNode*() twice on the same node." + " Instead use resetEndLocation() or change type directly.");
      }

      node.type = type;
      node.end = pos;
      node.loc.end = loc;
      if (this.options.ranges) node.range[1] = pos;
      this.processComment(node);
      return node;
    };

    _proto2.resetStartLocation = function resetStartLocation(node, start, startLoc) {
      node.start = start;
      node.loc.start = startLoc;
      if (this.options.ranges) node.range[0] = start;
    };

    _proto2.resetEndLocation = function resetEndLocation(node, end, endLoc) {
      if (end === void 0) {
        end = this.state.lastTokEnd;
      }

      if (endLoc === void 0) {
        endLoc = this.state.lastTokEndLoc;
      }

      node.end = end;
      node.loc.end = endLoc;
      if (this.options.ranges) node.range[1] = end;
    };

    _proto2.resetStartLocationFromNode = function resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
    };

    return NodeUtils;
  }(UtilParser);

  var unwrapParenthesizedExpression = function unwrapParenthesizedExpression(node) {
    return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
  };

  var LValParser = function (_NodeUtils) {
    _inheritsLoose(LValParser, _NodeUtils);

    function LValParser() {
      return _NodeUtils.apply(this, arguments) || this;
    }

    var _proto = LValParser.prototype;

    _proto.toAssignable = function toAssignable(node) {
      var _node$extra, _node$extra3;

      var parenthesized = undefined;

      if (node.type === "ParenthesizedExpression" || ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized)) {
        parenthesized = unwrapParenthesizedExpression(node);

        if (parenthesized.type !== "Identifier" && parenthesized.type !== "MemberExpression") {
          this.raise(node.start, Errors.InvalidParenthesizedAssignment);
        }
      }

      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
          break;

        case "ObjectExpression":
          node.type = "ObjectPattern";

          for (var i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
            var _node$extra2;

            var prop = node.properties[i];
            var isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isLast);

            if (isLast && prop.type === "RestElement" && ((_node$extra2 = node.extra) == null ? void 0 : _node$extra2.trailingComma)) {
              this.raiseRestNotLast(node.extra.trailingComma);
            }
          }

          break;

        case "ObjectProperty":
          this.toAssignable(node.value);
          break;

        case "SpreadElement":
          {
            this.checkToRestConversion(node);
            node.type = "RestElement";
            var arg = node.argument;
            this.toAssignable(arg);
            break;
          }

        case "ArrayExpression":
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma);
          break;

        case "AssignmentExpression":
          if (node.operator !== "=") {
            this.raise(node.left.end, Errors.MissingEqInAssignment);
          }

          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left);
          break;

        case "ParenthesizedExpression":
          this.toAssignable(parenthesized);
          break;
      }

      return node;
    };

    _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isLast) {
      if (prop.type === "ObjectMethod") {
        var error = prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod;
        this.raise(prop.key.start, error);
      } else if (prop.type === "SpreadElement" && !isLast) {
        this.raiseRestNotLast(prop.start);
      } else {
        this.toAssignable(prop);
      }
    };

    _proto.toAssignableList = function toAssignableList(exprList, trailingCommaPos) {
      var end = exprList.length;

      if (end) {
        var last = exprList[end - 1];

        if (last && last.type === "RestElement") {
          --end;
        } else if (last && last.type === "SpreadElement") {
          last.type = "RestElement";
          var arg = last.argument;
          this.toAssignable(arg);

          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
            this.unexpected(arg.start);
          }

          if (trailingCommaPos) {
            this.raiseTrailingCommaAfterRest(trailingCommaPos);
          }

          --end;
        }
      }

      for (var i = 0; i < end; i++) {
        var elt = exprList[i];

        if (elt) {
          this.toAssignable(elt);

          if (elt.type === "RestElement") {
            this.raiseRestNotLast(elt.start);
          }
        }
      }

      return exprList;
    };

    _proto.toReferencedList = function toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    };

    _proto.toReferencedListDeep = function toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);

      for (var _i2 = 0; _i2 < exprList.length; _i2++) {
        var expr = exprList[_i2];

        if (expr && expr.type === "ArrayExpression") {
          this.toReferencedListDeep(expr.elements);
        }
      }
    };

    _proto.parseSpread = function parseSpread(refExpressionErrors, refNeedsArrowPos) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refExpressionErrors, undefined, refNeedsArrowPos);
      return this.finishNode(node, "SpreadElement");
    };

    _proto.parseRestBinding = function parseRestBinding() {
      var node = this.startNode();
      this.next();
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    };

    _proto.parseBindingAtom = function parseBindingAtom() {
      switch (this.state.type) {
        case types.bracketL:
          {
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types.bracketR, 93, true);
            return this.finishNode(node, "ArrayPattern");
          }

        case types.braceL:
          return this.parseObj(types.braceR, true);
      }

      return this.parseIdentifier();
    };

    _proto.parseBindingList = function parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
        }

        if (allowEmpty && this.match(types.comma)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(types.ellipsis)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
          this.checkCommaAfterRest(closeCharCode);
          this.expect(close);
          break;
        } else {
          var decorators = [];

          if (this.match(types.at) && this.hasPlugin("decorators")) {
            this.raise(this.state.start, Errors.UnsupportedParameterDecorator);
          }

          while (this.match(types.at)) {
            decorators.push(this.parseDecorator());
          }

          elts.push(this.parseAssignableListItem(allowModifiers, decorators));
        }
      }

      return elts;
    };

    _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {
      var left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

      if (decorators.length) {
        left.decorators = decorators;
      }

      return elt;
    };

    _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
      return param;
    };

    _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {
      startLoc = startLoc || this.state.startLoc;
      startPos = startPos || this.state.start;
      left = left || this.parseBindingAtom();
      if (!this.eat(types.eq)) return left;
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern");
    };

    _proto.checkLVal = function checkLVal(expr, bindingType, checkClashes, contextDescription, disallowLetBinding, strictModeChanged) {
      if (bindingType === void 0) {
        bindingType = BIND_NONE;
      }

      if (strictModeChanged === void 0) {
        strictModeChanged = false;
      }

      switch (expr.type) {
        case "Identifier":
          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(expr.name, this.inModule) : isStrictBindOnlyReservedWord(expr.name))) {
            this.raise(expr.start, bindingType === BIND_NONE ? Errors.StrictEvalArguments : Errors.StrictEvalArgumentsBinding, expr.name);
          }

          if (checkClashes) {
            var _key = "_" + expr.name;

            if (checkClashes[_key]) {
              this.raise(expr.start, Errors.ParamDupe);
            } else {
              checkClashes[_key] = true;
            }
          }

          if (disallowLetBinding && expr.name === "let") {
            this.raise(expr.start, Errors.LetInLexicalBinding);
          }

          if (!(bindingType & BIND_NONE)) {
            this.scope.declareName(expr.name, bindingType, expr.start);
          }

          break;

        case "MemberExpression":
          if (bindingType !== BIND_NONE) {
            this.raise(expr.start, Errors.InvalidPropertyBindingPattern);
          }

          break;

        case "ObjectPattern":
          for (var _i4 = 0, _expr$properties2 = expr.properties; _i4 < _expr$properties2.length; _i4++) {
            var prop = _expr$properties2[_i4];
            if (prop.type === "ObjectProperty") prop = prop.value;else if (prop.type === "ObjectMethod") continue;
            this.checkLVal(prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
          }

          break;

        case "ArrayPattern":
          for (var _i6 = 0, _expr$elements2 = expr.elements; _i6 < _expr$elements2.length; _i6++) {
            var elem = _expr$elements2[_i6];

            if (elem) {
              this.checkLVal(elem, bindingType, checkClashes, "array destructuring pattern", disallowLetBinding);
            }
          }

          break;

        case "AssignmentPattern":
          this.checkLVal(expr.left, bindingType, checkClashes, "assignment pattern");
          break;

        case "RestElement":
          this.checkLVal(expr.argument, bindingType, checkClashes, "rest element");
          break;

        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, bindingType, checkClashes, "parenthesized expression");
          break;

        default:
          {
            this.raise(expr.start, bindingType === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding, contextDescription);
          }
      }
    };

    _proto.checkToRestConversion = function checkToRestConversion(node) {
      if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
        this.raise(node.argument.start, Errors.InvalidRestAssignmentPattern);
      }
    };

    _proto.checkCommaAfterRest = function checkCommaAfterRest(close) {
      if (this.match(types.comma)) {
        if (this.lookaheadCharCode() === close) {
          this.raiseTrailingCommaAfterRest(this.state.start);
        } else {
          this.raiseRestNotLast(this.state.start);
        }
      }
    };

    _proto.raiseRestNotLast = function raiseRestNotLast(pos) {
      throw this.raise(pos, Errors.ElementAfterRest);
    };

    _proto.raiseTrailingCommaAfterRest = function raiseTrailingCommaAfterRest(pos) {
      this.raise(pos, Errors.RestTrailingComma);
    };

    return LValParser;
  }(NodeUtils);

  var ExpressionParser = function (_LValParser) {
    _inheritsLoose(ExpressionParser, _LValParser);

    function ExpressionParser() {
      return _LValParser.apply(this, arguments) || this;
    }

    var _proto = ExpressionParser.prototype;

    _proto.checkDuplicatedProto = function checkDuplicatedProto(prop, protoRef, refExpressionErrors) {
      if (prop.type === "SpreadElement" || prop.computed || prop.kind || prop.shorthand) {
        return;
      }

      var key = prop.key;
      var name = key.type === "Identifier" ? key.name : String(key.value);

      if (name === "__proto__") {
        if (protoRef.used) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProto === -1) {
              refExpressionErrors.doubleProto = key.start;
            }
          } else {
            this.raise(key.start, Errors.DuplicateProto);
          }
        }

        protoRef.used = true;
      }
    };

    _proto.getExpression = function getExpression() {
      var paramFlags = PARAM;

      if (this.hasPlugin("topLevelAwait") && this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
      this.nextToken();
      var expr = this.parseExpression();

      if (!this.match(types.eof)) {
        this.unexpected();
      }

      expr.comments = this.state.comments;
      expr.errors = this.state.errors;
      return expr;
    };

    _proto.parseExpression = function parseExpression(noIn, refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseMaybeAssign(noIn, refExpressionErrors);

      if (this.match(types.comma)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];

        while (this.eat(types.comma)) {
          node.expressions.push(this.parseMaybeAssign(noIn, refExpressionErrors));
        }

        this.toReferencedList(node.expressions);
        return this.finishNode(node, "SequenceExpression");
      }

      return expr;
    };

    _proto.parseMaybeAssign = function parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      if (this.isContextual("yield")) {
        if (this.prodParam.hasYield) {
          var _left = this.parseYield(noIn);

          if (afterLeftParse) {
            _left = afterLeftParse.call(this, _left, startPos, startLoc);
          }

          return _left;
        } else {
          this.state.exprAllowed = false;
        }
      }

      var ownExpressionErrors;

      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors();
        ownExpressionErrors = true;
      }

      if (this.match(types.parenL) || this.match(types.name)) {
        this.state.potentialArrowAt = this.state.start;
      }

      var left = this.parseMaybeConditional(noIn, refExpressionErrors, refNeedsArrowPos);

      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }

      if (this.state.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        var operator = this.state.value;
        node.operator = operator;

        if (operator === "??=") {
          this.expectPlugin("logicalAssignment");
        }

        if (operator === "||=" || operator === "&&=") {
          this.expectPlugin("logicalAssignment");
        }

        if (this.match(types.eq)) {
          node.left = this.toAssignable(left);
          refExpressionErrors.doubleProto = -1;
        } else {
          node.left = left;
        }

        if (refExpressionErrors.shorthandAssign >= node.left.start) {
          refExpressionErrors.shorthandAssign = -1;
        }

        this.checkLVal(left, undefined, undefined, "assignment expression");
        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression");
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      return left;
    };

    _proto.parseMaybeConditional = function parseMaybeConditional(noIn, refExpressionErrors, refNeedsArrowPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprOps(noIn, refExpressionErrors);

      if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
        return expr;
      }

      if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
      return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
    };

    _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
      if (this.eat(types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression");
      }

      return expr;
    };

    _proto.parseExprOps = function parseExprOps(noIn, refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseMaybeUnary(refExpressionErrors);

      if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
        return expr;
      }

      if (this.checkExpressionErrors(refExpressionErrors, false)) {
        return expr;
      }

      return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
    };

    _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
      var prec = this.state.type.binop;

      if (prec != null && (!noIn || !this.match(types._in))) {
        if (prec > minPrec) {
          var operator = this.state.value;

          if (operator === "|>" && this.state.inFSharpPipelineDirectBody) {
            return left;
          }

          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = operator;

          if (operator === "**" && left.type === "UnaryExpression" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {
            this.raise(left.argument.start, Errors.UnexpectedTokenUnaryExponentiation);
          }

          var op = this.state.type;
          var logical = op === types.logicalOR || op === types.logicalAND;
          var coalesce = op === types.nullishCoalescing;

          if (op === types.pipeline) {
            this.expectPlugin("pipelineOperator");
            this.state.inPipeline = true;
            this.checkPipelineAtInfixOperator(left, leftStartPos);
          } else if (coalesce) {
            prec = types.logicalAND.binop;
          }

          this.next();

          if (op === types.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
            if (this.match(types.name) && this.state.value === "await" && this.prodParam.hasAwait) {
              throw this.raise(this.state.start, Errors.UnexpectedAwaitAfterPipelineBody);
            }
          }

          node.right = this.parseExprOpRightExpr(op, prec, noIn);
          this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
          var nextOp = this.state.type;

          if (coalesce && (nextOp === types.logicalOR || nextOp === types.logicalAND) || logical && nextOp === types.nullishCoalescing) {
            throw this.raise(this.state.start, Errors.MixingCoalesceWithLogical);
          }

          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }
      }

      return left;
    };

    _proto.parseExprOpRightExpr = function parseExprOpRightExpr(op, prec, noIn) {
      var _this = this;

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      switch (op) {
        case types.pipeline:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "smart":
              return this.withTopicPermittingContext(function () {
                return _this.parseSmartPipelineBody(_this.parseExprOpBaseRightExpr(op, prec, noIn), startPos, startLoc);
              });

            case "fsharp":
              return this.withSoloAwaitPermittingContext(function () {
                return _this.parseFSharpPipelineBody(prec, noIn);
              });
          }

        default:
          return this.parseExprOpBaseRightExpr(op, prec, noIn);
      }
    };

    _proto.parseExprOpBaseRightExpr = function parseExprOpBaseRightExpr(op, prec, noIn) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);
    };

    _proto.parseMaybeUnary = function parseMaybeUnary(refExpressionErrors) {
      if (this.isContextual("await") && this.isAwaitAllowed()) {
        return this.parseAwait();
      } else if (this.state.type.prefix) {
        var node = this.startNode();
        var update = this.match(types.incDec);
        node.operator = this.state.value;
        node.prefix = true;

        if (node.operator === "throw") {
          this.expectPlugin("throwExpressions");
        }

        this.next();
        node.argument = this.parseMaybeUnary();
        this.checkExpressionErrors(refExpressionErrors, true);

        if (update) {
          this.checkLVal(node.argument, undefined, undefined, "prefix operation");
        } else if (this.state.strict && node.operator === "delete") {
          var arg = node.argument;

          if (arg.type === "Identifier") {
            this.raise(node.start, Errors.StrictDelete);
          } else if (arg.type === "MemberExpression" && arg.property.type === "PrivateName") {
            this.raise(node.start, Errors.DeletePrivateField);
          }
        }

        return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      }

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;

      while (this.state.type.postfix && !this.canInsertSemicolon()) {
        var _node = this.startNodeAt(startPos, startLoc);

        _node.operator = this.state.value;
        _node.prefix = false;
        _node.argument = expr;
        this.checkLVal(expr, undefined, undefined, "postfix operation");
        this.next();
        expr = this.finishNode(_node, "UpdateExpression");
      }

      return expr;
    };

    _proto.parseExprSubscripts = function parseExprSubscripts(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprAtom(refExpressionErrors);

      if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
        return expr;
      }

      return this.parseSubscripts(expr, startPos, startLoc);
    };

    _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {
      var state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: false
      };

      do {
        var oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;

        if (state.maybeAsyncArrow) {
          this.state.maybeInAsyncArrowHead = true;
        }

        base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
        this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;
      } while (!state.stop);

      return base;
    };

    _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!noCalls && this.eat(types.doubleColon)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
      }

      var optional = false;

      if (this.match(types.questionDot)) {
        state.optionalChainMember = optional = true;

        if (noCalls && this.lookaheadCharCode() === 40) {
          state.stop = true;
          return base;
        }

        this.next();
      }

      var computed = this.eat(types.bracketL);

      if (optional && !this.match(types.parenL) && !this.match(types.backQuote) || computed || this.eat(types.dot)) {
        var _node2 = this.startNodeAt(startPos, startLoc);

        _node2.object = base;
        _node2.property = computed ? this.parseExpression() : optional ? this.parseIdentifier(true) : this.parseMaybePrivateName(true);
        _node2.computed = computed;

        if (_node2.property.type === "PrivateName") {
          if (_node2.object.type === "Super") {
            this.raise(startPos, Errors.SuperPrivateField);
          }

          this.classScope.usePrivateName(_node2.property.id.name, _node2.property.start);
        }

        if (computed) {
          this.expect(types.bracketR);
        }

        if (state.optionalChainMember) {
          _node2.optional = optional;
          return this.finishNode(_node2, "OptionalMemberExpression");
        } else {
          return this.finishNode(_node2, "MemberExpression");
        }
      } else if (!noCalls && this.match(types.parenL)) {
        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        var oldYieldPos = this.state.yieldPos;
        var oldAwaitPos = this.state.awaitPos;
        this.state.maybeInArrowParameters = true;
        this.state.yieldPos = -1;
        this.state.awaitPos = -1;
        this.next();

        var _node3 = this.startNodeAt(startPos, startLoc);

        _node3.callee = base;

        if (optional) {
          _node3.optional = true;
          _node3.arguments = this.parseCallExpressionArguments(types.parenR, false);
        } else {
          _node3.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === "Import", base.type !== "Super", _node3);
        }

        this.finishCallExpression(_node3, state.optionalChainMember);

        if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
          state.stop = true;
          _node3 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node3);
          this.checkYieldAwaitInDefaultParams();
          this.state.yieldPos = oldYieldPos;
          this.state.awaitPos = oldAwaitPos;
        } else {
          this.toReferencedListDeep(_node3.arguments);
          if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;

          if (!this.isAwaitAllowed() && !oldMaybeInArrowParameters || oldAwaitPos !== -1) {
            this.state.awaitPos = oldAwaitPos;
          }
        }

        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return _node3;
      } else if (this.match(types.backQuote)) {
        return this.parseTaggedTemplateExpression(startPos, startLoc, base, state);
      } else {
        state.stop = true;
        return base;
      }
    };

    _proto.parseTaggedTemplateExpression = function parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);
      if (typeArguments) node.typeParameters = typeArguments;

      if (state.optionalChainMember) {
        this.raise(startPos, Errors.OptionalChainingNoTemplate);
      }

      return this.finishNode(node, "TaggedTemplateExpression");
    };

    _proto.atPossibleAsyncArrow = function atPossibleAsyncArrow(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
    };

    _proto.finishCallExpression = function finishCallExpression(node, optional) {
      if (node.callee.type === "Import") {
        if (node.arguments.length !== 1) {
          this.raise(node.start, Errors.ImportCallArity);
        } else {
          var importArg = node.arguments[0];

          if (importArg && importArg.type === "SpreadElement") {
            this.raise(importArg.start, Errors.ImportCallSpreadArgument);
          }
        }
      }

      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    };

    _proto.parseCallExpressionArguments = function parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {
      var elts = [];
      var innerParenStart;
      var first = true;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            if (dynamicImport) {
              this.raise(this.state.lastTokStart, Errors.ImportCallArgumentTrailingComma);
            }

            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        if (this.match(types.parenL) && !innerParenStart) {
          innerParenStart = this.state.start;
        }

        elts.push(this.parseExprListItem(false, possibleAsyncArrow ? new ExpressionErrors() : undefined, possibleAsyncArrow ? {
          start: 0
        } : undefined, allowPlaceholder));
      }

      if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
        this.unexpected();
      }

      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    };

    _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
      return this.match(types.arrow) && !this.canInsertSemicolon();
    };

    _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;

      this.expect(types.arrow);
      this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
      return node;
    };

    _proto.parseNoCallExpr = function parseNoCallExpr() {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    };

    _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
      if (this.state.type === types.slash) this.readRegexp();
      var canBeArrow = this.state.potentialArrowAt === this.state.start;
      var node;

      switch (this.state.type) {
        case types._super:
          node = this.startNode();
          this.next();

          if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(node.start, Errors.SuperNotAllowed);
          } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(node.start, Errors.UnexpectedSuper);
          }

          if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
            this.raise(node.start, Errors.UnsupportedSuper);
          }

          return this.finishNode(node, "Super");

        case types._import:
          node = this.startNode();
          this.next();

          if (this.match(types.dot)) {
            return this.parseImportMetaProperty(node);
          }

          if (!this.match(types.parenL)) {
            this.raise(this.state.lastTokStart, Errors.UnsupportedImport);
          }

          return this.finishNode(node, "Import");

        case types._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");

        case types.name:
          {
            node = this.startNode();
            var containsEsc = this.state.containsEsc;
            var id = this.parseIdentifier();

            if (!containsEsc && id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) {
              var last = this.state.context.length - 1;

              if (this.state.context[last] !== types$1.functionStatement) {
                throw new Error("Internal error");
              }

              this.state.context[last] = types$1.functionExpression;
              this.next();
              return this.parseFunction(node, undefined, true);
            } else if (canBeArrow && !containsEsc && id.name === "async" && this.match(types.name) && !this.canInsertSemicolon()) {
              var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
              var oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;
              var oldYieldPos = this.state.yieldPos;
              var oldAwaitPos = this.state.awaitPos;
              this.state.maybeInArrowParameters = true;
              this.state.maybeInAsyncArrowHead = true;
              this.state.yieldPos = -1;
              this.state.awaitPos = -1;
              var params = [this.parseIdentifier()];
              this.expect(types.arrow);
              this.checkYieldAwaitInDefaultParams();
              this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
              this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;
              this.state.yieldPos = oldYieldPos;
              this.state.awaitPos = oldAwaitPos;
              this.parseArrowExpression(node, params, true);
              return node;
            }

            if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {
              this.next();
              this.parseArrowExpression(node, [id], false);
              return node;
            }

            return id;
          }

        case types._do:
          {
            this.expectPlugin("doExpressions");

            var _node4 = this.startNode();

            this.next();
            var oldLabels = this.state.labels;
            this.state.labels = [];
            _node4.body = this.parseBlock();
            this.state.labels = oldLabels;
            return this.finishNode(_node4, "DoExpression");
          }

        case types.regexp:
          {
            var value = this.state.value;
            node = this.parseLiteral(value.value, "RegExpLiteral");
            node.pattern = value.pattern;
            node.flags = value.flags;
            return node;
          }

        case types.num:
          return this.parseLiteral(this.state.value, "NumericLiteral");

        case types.bigint:
          return this.parseLiteral(this.state.value, "BigIntLiteral");

        case types.string:
          return this.parseLiteral(this.state.value, "StringLiteral");

        case types._null:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "NullLiteral");

        case types._true:
        case types._false:
          return this.parseBooleanLiteral();

        case types.parenL:
          return this.parseParenAndDistinguishExpression(canBeArrow);

        case types.bracketBarL:
        case types.bracketHashL:
          {
            this.expectPlugin("recordAndTuple");
            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            var close = this.state.type === types.bracketBarL ? types.bracketBarR : types.bracketR;
            this.state.inFSharpPipelineDirectBody = false;
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(close, true, refExpressionErrors, node);
            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            return this.finishNode(node, "TupleExpression");
          }

        case types.bracketL:
          {
            var _oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types.bracketR, true, refExpressionErrors, node);

            if (!this.state.maybeInArrowParameters) {
              this.toReferencedList(node.elements);
            }

            this.state.inFSharpPipelineDirectBody = _oldInFSharpPipelineDirectBody;
            return this.finishNode(node, "ArrayExpression");
          }

        case types.braceBarL:
        case types.braceHashL:
          {
            this.expectPlugin("recordAndTuple");
            var _oldInFSharpPipelineDirectBody2 = this.state.inFSharpPipelineDirectBody;

            var _close = this.state.type === types.braceBarL ? types.braceBarR : types.braceR;

            this.state.inFSharpPipelineDirectBody = false;
            var ret = this.parseObj(_close, false, true, refExpressionErrors);
            this.state.inFSharpPipelineDirectBody = _oldInFSharpPipelineDirectBody2;
            return ret;
          }

        case types.braceL:
          {
            var _oldInFSharpPipelineDirectBody3 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;

            var _ret = this.parseObj(types.braceR, false, false, refExpressionErrors);

            this.state.inFSharpPipelineDirectBody = _oldInFSharpPipelineDirectBody3;
            return _ret;
          }

        case types._function:
          return this.parseFunctionExpression();

        case types.at:
          this.parseDecorators();

        case types._class:
          node = this.startNode();
          this.takeDecorators(node);
          return this.parseClass(node, false);

        case types._new:
          return this.parseNew();

        case types.backQuote:
          return this.parseTemplate(false);

        case types.doubleColon:
          {
            node = this.startNode();
            this.next();
            node.object = null;
            var callee = node.callee = this.parseNoCallExpr();

            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(callee.start, Errors.UnsupportedBind);
            }
          }

        case types.hash:
          {
            if (this.state.inPipeline) {
              node = this.startNode();

              if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
                this.raise(node.start, Errors.PrimaryTopicRequiresSmartPipeline);
              }

              this.next();

              if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
                this.raise(node.start, Errors.PrimaryTopicNotAllowed);
              }

              this.registerTopicReference();
              return this.finishNode(node, "PipelinePrimaryTopicReference");
            }
          }

        default:
          throw this.unexpected();
      }
    };

    _proto.parseBooleanLiteral = function parseBooleanLiteral() {
      var node = this.startNode();
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    };

    _proto.parseMaybePrivateName = function parseMaybePrivateName(isPrivateNameAllowed) {
      var isPrivate = this.match(types.hash);

      if (isPrivate) {
        this.expectOnePlugin(["classPrivateProperties", "classPrivateMethods"]);

        if (!isPrivateNameAllowed) {
          this.raise(this.state.pos, Errors.UnexpectedPrivateField);
        }

        var node = this.startNode();
        this.next();
        this.assertNoSpace("Unexpected space between # and identifier");
        node.id = this.parseIdentifier(true);
        return this.finishNode(node, "PrivateName");
      } else {
        return this.parseIdentifier(true);
      }
    };

    _proto.parseFunctionExpression = function parseFunctionExpression() {
      var node = this.startNode();
      var meta = this.startNode();
      this.next();
      meta = this.createIdentifier(meta, "function");

      if (this.prodParam.hasYield && this.eat(types.dot)) {
        return this.parseMetaProperty(node, meta, "sent");
      }

      return this.parseFunction(node);
    };

    _proto.parseMetaProperty = function parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;

      if (meta.name === "function" && propertyName === "sent") {
        if (this.isContextual(propertyName)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
      }

      var containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);

      if (node.property.name !== propertyName || containsEsc) {
        this.raise(node.property.start, Errors.UnsupportedMetaProperty, meta.name, propertyName);
      }

      return this.finishNode(node, "MetaProperty");
    };

    _proto.parseImportMetaProperty = function parseImportMetaProperty(node) {
      var id = this.createIdentifier(this.startNodeAtNode(node), "import");
      this.expect(types.dot);

      if (this.isContextual("meta")) {
        this.expectPlugin("importMeta");

        if (!this.inModule) {
          this.raiseWithData(id.start, {
            code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
          }, Errors.ImportMetaOutsideModule);
        }

        this.sawUnambiguousESM = true;
      } else if (!this.hasPlugin("importMeta")) {
        this.raise(id.start, Errors.ImportCallArityLtOne);
      }

      return this.parseMetaProperty(node, id, "meta");
    };

    _proto.parseLiteral = function parseLiteral(value, type, startPos, startLoc) {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      var node = this.startNodeAt(startPos, startLoc);
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    };

    _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var val;
      this.expect(types.parenL);
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldYieldPos = this.state.yieldPos;
      var oldAwaitPos = this.state.awaitPos;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.state.inFSharpPipelineDirectBody = false;
      var innerStartPos = this.state.start;
      var innerStartLoc = this.state.startLoc;
      var exprList = [];
      var refExpressionErrors = new ExpressionErrors();
      var refNeedsArrowPos = {
        start: 0
      };
      var first = true;
      var spreadStart;
      var optionalCommaStart;

      while (!this.match(types.parenR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma, refNeedsArrowPos.start || null);

          if (this.match(types.parenR)) {
            optionalCommaStart = this.state.start;
            break;
          }
        }

        if (this.match(types.ellipsis)) {
          var spreadNodeStartPos = this.state.start;
          var spreadNodeStartLoc = this.state.startLoc;
          spreadStart = this.state.start;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
          this.checkCommaAfterRest(41);
          break;
        } else {
          exprList.push(this.parseMaybeAssign(false, refExpressionErrors, this.parseParenItem, refNeedsArrowPos));
        }
      }

      var innerEndPos = this.state.start;
      var innerEndLoc = this.state.startLoc;
      this.expect(types.parenR);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var arrowNode = this.startNodeAt(startPos, startLoc);

      if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
        if (!this.isAwaitAllowed() && !this.state.maybeInAsyncArrowHead) {
          this.state.awaitPos = oldAwaitPos;
        }

        this.checkYieldAwaitInDefaultParams();
        this.state.yieldPos = oldYieldPos;
        this.state.awaitPos = oldAwaitPos;

        for (var _i2 = 0; _i2 < exprList.length; _i2++) {
          var param = exprList[_i2];

          if (param.extra && param.extra.parenthesized) {
            this.unexpected(param.extra.parenStart);
          }
        }

        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }

      if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;
      if (oldAwaitPos !== -1) this.state.awaitPos = oldAwaitPos;

      if (!exprList.length) {
        this.unexpected(this.state.lastTokStart);
      }

      if (optionalCommaStart) this.unexpected(optionalCommaStart);
      if (spreadStart) this.unexpected(spreadStart);
      this.checkExpressionErrors(refExpressionErrors, true);
      if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);
      this.toReferencedListDeep(exprList, true);

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }

      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(val, "parenthesized", true);
        this.addExtra(val, "parenStart", startPos);
        return val;
      }

      var parenExpression = this.startNodeAt(startPos, startLoc);
      parenExpression.expression = val;
      this.finishNode(parenExpression, "ParenthesizedExpression");
      return parenExpression;
    };

    _proto.shouldParseArrow = function shouldParseArrow() {
      return !this.canInsertSemicolon();
    };

    _proto.parseArrow = function parseArrow(node) {
      if (this.eat(types.arrow)) {
        return node;
      }
    };

    _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
      return node;
    };

    _proto.parseNew = function parseNew() {
      var node = this.startNode();
      var meta = this.startNode();
      this.next();
      meta = this.createIdentifier(meta, "new");

      if (this.eat(types.dot)) {
        var metaProp = this.parseMetaProperty(node, meta, "target");

        if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
          var error = Errors.UnexpectedNewTarget;

          if (this.hasPlugin("classProperties")) {
            error += " or class properties";
          }

          this.raise(metaProp.start, error);
        }

        return metaProp;
      }

      node.callee = this.parseNoCallExpr();

      if (node.callee.type === "Import") {
        this.raise(node.callee.start, Errors.ImportCallNotNewExpression);
      } else if (node.callee.type === "OptionalMemberExpression" || node.callee.type === "OptionalCallExpression") {
        this.raise(this.state.lastTokEnd, Errors.OptionalChainingNoNew);
      } else if (this.eat(types.questionDot)) {
        this.raise(this.state.start, Errors.OptionalChainingNoNew);
      }

      this.parseNewArguments(node);
      return this.finishNode(node, "NewExpression");
    };

    _proto.parseNewArguments = function parseNewArguments(node) {
      if (this.eat(types.parenL)) {
        var args = this.parseExprList(types.parenR);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }
    };

    _proto.parseTemplateElement = function parseTemplateElement(isTagged) {
      var elem = this.startNode();

      if (this.state.value === null) {
        if (!isTagged) {
          this.raise(this.state.start + 1, Errors.InvalidEscapeSequenceTemplate);
        }
      }

      elem.value = {
        raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
        cooked: this.state.value
      };
      this.next();
      elem.tail = this.match(types.backQuote);
      return this.finishNode(elem, "TemplateElement");
    };

    _proto.parseTemplate = function parseTemplate(isTagged) {
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];

      while (!curElt.tail) {
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }

      this.next();
      return this.finishNode(node, "TemplateLiteral");
    };

    _proto.parseObj = function parseObj(close, isPattern, isRecord, refExpressionErrors) {
      var propHash = Object.create(null);
      var first = true;
      var node = this.startNode();
      node.properties = [];
      this.next();

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            this.addExtra(node, "trailingComma", this.state.lastTokStart);
            this.next();
            break;
          }
        }

        var prop = this.parseObjectMember(isPattern, refExpressionErrors);

        if (!isPattern) {
          this.checkDuplicatedProto(prop, propHash, refExpressionErrors);
        }

        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }

        node.properties.push(prop);
      }

      var type = "ObjectExpression";

      if (isPattern) {
        type = "ObjectPattern";
      } else if (isRecord) {
        type = "RecordExpression";
      }

      return this.finishNode(node, type);
    };

    _proto.isAsyncProp = function isAsyncProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.match(types.name) || this.match(types.num) || this.match(types.string) || this.match(types.bracketL) || this.state.type.keyword || this.match(types.star)) && !this.hasPrecedingLineBreak();
    };

    _proto.parseObjectMember = function parseObjectMember(isPattern, refExpressionErrors) {
      var decorators = [];

      if (this.match(types.at)) {
        if (this.hasPlugin("decorators")) {
          this.raise(this.state.start, Errors.UnsupportedPropertyDecorator);
        }

        while (this.match(types.at)) {
          decorators.push(this.parseDecorator());
        }
      }

      var prop = this.startNode();
      var isGenerator = false;
      var isAsync = false;
      var startPos;
      var startLoc;

      if (this.match(types.ellipsis)) {
        if (decorators.length) this.unexpected();

        if (isPattern) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }

        return this.parseSpread();
      }

      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }

      prop.method = false;

      if (isPattern || refExpressionErrors) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }

      if (!isPattern) {
        isGenerator = this.eat(types.star);
      }

      var containsEsc = this.state.containsEsc;
      this.parsePropertyName(prop, false);

      if (!isPattern && !containsEsc && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.eat(types.star);
        this.parsePropertyName(prop, false);
      } else {
        isAsync = false;
      }

      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc);
      return prop;
    };

    _proto.isGetterOrSetterMethod = function isGetterOrSetterMethod(prop, isPattern) {
      return !isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.match(types.string) || this.match(types.num) || this.match(types.bracketL) || this.match(types.name) || !!this.state.type.keyword);
    };

    _proto.getGetterSetterExpectedParamCount = function getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    };

    _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
      var paramCount = this.getGetterSetterExpectedParamCount(method);
      var start = method.start;

      if (method.params.length !== paramCount) {
        if (method.kind === "get") {
          this.raise(start, Errors.BadGetterArity);
        } else {
          this.raise(start, Errors.BadSetterArity);
        }
      }

      if (method.kind === "set" && method.params[method.params.length - 1].type === "RestElement") {
        this.raise(start, Errors.BadSetterRestParameter);
      }
    };

    _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
      if (isAsync || isGenerator || this.match(types.parenL)) {
        if (isPattern) this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }

      if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {
        if (isGenerator || isAsync) this.unexpected();
        prop.kind = prop.key.name;
        this.parsePropertyName(prop, false);
        this.parseMethod(prop, false, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(prop);
        return prop;
      }
    };

    _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
      prop.shorthand = false;

      if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refExpressionErrors);
        return this.finishNode(prop, "ObjectProperty");
      }

      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.start, true, true);

        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else if (this.match(types.eq) && refExpressionErrors) {
          if (refExpressionErrors.shorthandAssign === -1) {
            refExpressionErrors.shorthandAssign = this.state.start;
          }

          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else {
          prop.value = prop.key.__clone();
        }

        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    };

    _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc) {
      var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
      if (!node) this.unexpected();
      return node;
    };

    _proto.parsePropertyName = function parsePropertyName(prop, isPrivateNameAllowed) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
      } else {
        var oldInPropertyName = this.state.inPropertyName;
        this.state.inPropertyName = true;
        prop.key = this.match(types.num) || this.match(types.string) || this.match(types.bigint) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);

        if (prop.key.type !== "PrivateName") {
          prop.computed = false;
        }

        this.state.inPropertyName = oldInPropertyName;
      }

      return prop.key;
    };

    _proto.initFunction = function initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = !!isAsync;
    };

    _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
      if (inClassScope === void 0) {
        inClassScope = false;
      }

      var oldYieldPos = this.state.yieldPos;
      var oldAwaitPos = this.state.awaitPos;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.initFunction(node, isAsync);
      node.generator = !!isGenerator;
      var allowModifiers = isConstructor;
      this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      this.parseFunctionParams(node, allowModifiers);
      this.parseFunctionBodyAndFinish(node, type, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      return node;
    };

    _proto.parseArrowExpression = function parseArrowExpression(node, params, isAsync, trailingCommaPos) {
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
      this.prodParam.enter(functionFlags(isAsync, false));
      this.initFunction(node, isAsync);
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldYieldPos = this.state.yieldPos;
      var oldAwaitPos = this.state.awaitPos;

      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node, params, trailingCommaPos);
      }

      this.state.maybeInArrowParameters = false;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.parseFunctionBody(node, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      return this.finishNode(node, "ArrowFunctionExpression");
    };

    _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params, trailingCommaPos) {
      node.params = this.toAssignableList(params, trailingCommaPos);
    };

    _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
      if (isMethod === void 0) {
        isMethod = false;
      }

      this.parseFunctionBody(node, false, isMethod);
      this.finishNode(node, type);
    };

    _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression, isMethod) {
      var _this2 = this;

      if (isMethod === void 0) {
        isMethod = false;
      }

      var isExpression = allowExpression && !this.match(types.braceL);
      var oldInParameters = this.state.inParameters;
      this.state.inParameters = false;

      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        var oldStrict = this.state.strict;
        var oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
        node.body = this.parseBlock(true, false, function (hasStrictModeDirective) {
          var nonSimple = !_this2.isSimpleParamList(node.params);

          if (hasStrictModeDirective && nonSimple) {
            var errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;

            _this2.raise(errorPos, Errors.IllegalLanguageModeDirective);
          }

          var strictModeChanged = !oldStrict && _this2.state.strict;

          _this2.checkParams(node, !_this2.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);

          if (_this2.state.strict && node.id) {
            _this2.checkLVal(node.id, BIND_OUTSIDE, undefined, "function name", undefined, strictModeChanged);
          }
        });
        this.prodParam.exit();
        this.state.labels = oldLabels;
      }

      this.state.inParameters = oldInParameters;
    };

    _proto.isSimpleParamList = function isSimpleParamList(params) {
      for (var i = 0, len = params.length; i < len; i++) {
        if (params[i].type !== "Identifier") return false;
      }

      return true;
    };

    _proto.checkParams = function checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged) {
      if (strictModeChanged === void 0) {
        strictModeChanged = true;
      }

      var nameHash = Object.create(null);

      for (var i = 0; i < node.params.length; i++) {
        this.checkLVal(node.params[i], BIND_VAR, allowDuplicates ? null : nameHash, "function parameter list", undefined, strictModeChanged);
      }
    };

    _proto.parseExprList = function parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }

      return elts;
    };

    _proto.parseExprListItem = function parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {
      var elt;

      if (allowEmpty && this.match(types.comma)) {
        elt = null;
      } else if (this.match(types.ellipsis)) {
        var spreadNodeStartPos = this.state.start;
        var spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);
      } else if (this.match(types.question)) {
        this.expectPlugin("partialApplication");

        if (!allowPlaceholder) {
          this.raise(this.state.start, Errors.UnexpectedArgumentPlaceholder);
        }

        var node = this.startNode();
        this.next();
        elt = this.finishNode(node, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssign(false, refExpressionErrors, this.parseParenItem, refNeedsArrowPos);
      }

      return elt;
    };

    _proto.parseIdentifier = function parseIdentifier(liberal) {
      var node = this.startNode();
      var name = this.parseIdentifierName(node.start, liberal);
      return this.createIdentifier(node, name);
    };

    _proto.createIdentifier = function createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, "Identifier");
    };

    _proto.parseIdentifierName = function parseIdentifierName(pos, liberal) {
      var name;

      if (this.match(types.name)) {
        name = this.state.value;
      } else if (this.state.type.keyword) {
        name = this.state.type.keyword;

        if ((name === "class" || name === "function") && (this.state.lastTokEnd !== this.state.lastTokStart + 1 || this.input.charCodeAt(this.state.lastTokStart) !== 46)) {
          this.state.context.pop();
        }
      } else {
        throw this.unexpected();
      }

      if (liberal) {
        this.state.type = types.name;
      } else {
        this.checkReservedWord(name, this.state.start, !!this.state.type.keyword, false);
      }

      this.next();
      return name;
    };

    _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (this.prodParam.hasYield && word === "yield") {
        this.raise(startLoc, Errors.YieldBindingIdentifier);
        return;
      }

      if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(startLoc, Errors.AwaitBindingIdentifier);
          return;
        }

        if (this.state.awaitPos === -1 && (this.state.maybeInAsyncArrowHead || this.isAwaitAllowed())) {
          this.state.awaitPos = this.state.start;
        }
      }

      if (this.scope.inClass && !this.scope.inNonArrowFunction && word === "arguments") {
        this.raise(startLoc, Errors.ArgumentsDisallowedInInitializer);
        return;
      }

      if (checkKeywords && isKeyword(word)) {
        this.raise(startLoc, Errors.UnexpectedKeyword, word);
        return;
      }

      var reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

      if (reservedTest(word, this.inModule)) {
        if (!this.prodParam.hasAwait && word === "await") {
          this.raise(startLoc, Errors.AwaitNotInAsyncFunction);
        } else {
          this.raise(startLoc, Errors.UnexpectedReservedWord, word);
        }
      }
    };

    _proto.isAwaitAllowed = function isAwaitAllowed() {
      if (this.scope.inFunction) return this.prodParam.hasAwait;
      if (this.options.allowAwaitOutsideFunction) return true;

      if (this.hasPlugin("topLevelAwait")) {
        return this.inModule && this.prodParam.hasAwait;
      }

      return false;
    };

    _proto.parseAwait = function parseAwait() {
      var node = this.startNode();
      this.next();

      if (this.state.inParameters) {
        this.raise(node.start, Errors.AwaitExpressionFormalParameter);
      } else if (this.state.awaitPos === -1) {
        this.state.awaitPos = node.start;
      }

      if (this.eat(types.star)) {
        this.raise(node.start, Errors.ObsoleteAwaitStar);
      }

      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin("v8intrinsic") && this.match(types.modulo)) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }

      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary();
      }

      return this.finishNode(node, "AwaitExpression");
    };

    _proto.parseYield = function parseYield(noIn) {
      var node = this.startNode();

      if (this.state.inParameters) {
        this.raise(node.start, Errors.YieldInParameter);
      } else if (this.state.yieldPos === -1) {
        this.state.yieldPos = node.start;
      }

      this.next();

      if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign(noIn);
      }

      return this.finishNode(node, "YieldExpression");
    };

    _proto.checkPipelineAtInfixOperator = function checkPipelineAtInfixOperator(left, leftStartPos) {
      if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
        if (left.type === "SequenceExpression") {
          this.raise(leftStartPos, Errors.PipelineHeadSequenceExpression);
        }
      }
    };

    _proto.parseSmartPipelineBody = function parseSmartPipelineBody(childExpression, startPos, startLoc) {
      var pipelineStyle = this.checkSmartPipelineBodyStyle(childExpression);
      this.checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos);
      return this.parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc);
    };

    _proto.checkSmartPipelineBodyEarlyErrors = function checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos) {
      if (this.match(types.arrow)) {
        throw this.raise(this.state.start, Errors.PipelineBodyNoArrow);
      } else if (pipelineStyle === "PipelineTopicExpression" && childExpression.type === "SequenceExpression") {
        this.raise(startPos, Errors.PipelineBodySequenceExpression);
      }
    };

    _proto.parseSmartPipelineBodyInStyle = function parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc) {
      var bodyNode = this.startNodeAt(startPos, startLoc);

      switch (pipelineStyle) {
        case "PipelineBareFunction":
          bodyNode.callee = childExpression;
          break;

        case "PipelineBareConstructor":
          bodyNode.callee = childExpression.callee;
          break;

        case "PipelineBareAwaitedFunction":
          bodyNode.callee = childExpression.argument;
          break;

        case "PipelineTopicExpression":
          if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
            this.raise(startPos, Errors.PipelineTopicUnused);
          }

          bodyNode.expression = childExpression;
          break;

        default:
          throw new Error("Internal @babel/parser error: Unknown pipeline style (" + pipelineStyle + ")");
      }

      return this.finishNode(bodyNode, pipelineStyle);
    };

    _proto.checkSmartPipelineBodyStyle = function checkSmartPipelineBodyStyle(expression) {
      switch (expression.type) {
        default:
          return this.isSimpleReference(expression) ? "PipelineBareFunction" : "PipelineTopicExpression";
      }
    };

    _proto.isSimpleReference = function isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);

        case "Identifier":
          return true;

        default:
          return false;
      }
    };

    _proto.withTopicPermittingContext = function withTopicPermittingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    };

    _proto.withTopicForbiddingContext = function withTopicForbiddingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    };

    _proto.withSoloAwaitPermittingContext = function withSoloAwaitPermittingContext(callback) {
      var outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;

      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    };

    _proto.registerTopicReference = function registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    };

    _proto.primaryTopicReferenceIsAllowedInCurrentTopicContext = function primaryTopicReferenceIsAllowedInCurrentTopicContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    };

    _proto.topicReferenceWasUsedInCurrentTopicContext = function topicReferenceWasUsedInCurrentTopicContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    };

    _proto.parseFSharpPipelineBody = function parseFSharpPipelineBody(prec, noIn) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      var ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    };

    return ExpressionParser;
  }(LValParser);

  var loopLabel = {
    kind: "loop"
  },
      switchLabel = {
    kind: "switch"
  };
  var FUNC_NO_FLAGS = 0,
      FUNC_STATEMENT = 1,
      FUNC_HANGING_STATEMENT = 2,
      FUNC_NULLABLE_ID = 4;

  var StatementParser = function (_ExpressionParser) {
    _inheritsLoose(StatementParser, _ExpressionParser);

    function StatementParser() {
      return _ExpressionParser.apply(this, arguments) || this;
    }

    var _proto = StatementParser.prototype;

    _proto.parseTopLevel = function parseTopLevel(file, program) {
      program.sourceType = this.options.sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, types.eof);

      if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
        for (var _i2 = 0, _Array$from2 = Array.from(this.scope.undefinedExports); _i2 < _Array$from2.length; _i2++) {
          var _Array$from2$_i = _Array$from2[_i2],
              name = _Array$from2$_i[0];
          var pos = this.scope.undefinedExports.get(name);
          this.raise(pos, Errors.ModuleExportUndefined, name);
        }
      }

      file.program = this.finishNode(program, "Program");
      file.comments = this.state.comments;
      if (this.options.tokens) file.tokens = this.tokens;
      return this.finishNode(file, "File");
    };

    _proto.stmtToDirective = function stmtToDirective(stmt) {
      var expr = stmt.expression;
      var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
      var directive = this.startNodeAt(stmt.start, stmt.loc.start);
      var raw = this.input.slice(expr.start, expr.end);
      var val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
      return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
    };

    _proto.parseInterpreterDirective = function parseInterpreterDirective() {
      if (!this.match(types.interpreterDirective)) {
        return null;
      }

      var node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, "InterpreterDirective");
    };

    _proto.isLet = function isLet(context) {
      if (!this.isContextual("let")) {
        return false;
      }

      var next = this.nextTokenStart();
      var nextCh = this.input.charCodeAt(next);
      if (nextCh === 91) return true;
      if (context) return false;
      if (nextCh === 123) return true;

      if (isIdentifierStart(nextCh)) {
        var pos = next + 1;

        while (isIdentifierChar(this.input.charCodeAt(pos))) {
          ++pos;
        }

        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) return true;
      }

      return false;
    };

    _proto.parseStatement = function parseStatement(context, topLevel) {
      if (this.match(types.at)) {
        this.parseDecorators(true);
      }

      return this.parseStatementContent(context, topLevel);
    };

    _proto.parseStatementContent = function parseStatementContent(context, topLevel) {
      var starttype = this.state.type;
      var node = this.startNode();
      var kind;

      if (this.isLet(context)) {
        starttype = types._var;
        kind = "let";
      }

      switch (starttype) {
        case types._break:
        case types._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);

        case types._debugger:
          return this.parseDebuggerStatement(node);

        case types._do:
          return this.parseDoStatement(node);

        case types._for:
          return this.parseForStatement(node);

        case types._function:
          if (this.lookaheadCharCode() === 46) break;

          if (context) {
            if (this.state.strict) {
              this.raise(this.state.start, Errors.StrictFunction);
            } else if (context !== "if" && context !== "label") {
              this.raise(this.state.start, Errors.SloppyFunction);
            }
          }

          return this.parseFunctionStatement(node, false, !context);

        case types._class:
          if (context) this.unexpected();
          return this.parseClass(node, true);

        case types._if:
          return this.parseIfStatement(node);

        case types._return:
          return this.parseReturnStatement(node);

        case types._switch:
          return this.parseSwitchStatement(node);

        case types._throw:
          return this.parseThrowStatement(node);

        case types._try:
          return this.parseTryStatement(node);

        case types._const:
        case types._var:
          kind = kind || this.state.value;

          if (context && kind !== "var") {
            this.raise(this.state.start, Errors.UnexpectedLexicalDeclaration);
          }

          return this.parseVarStatement(node, kind);

        case types._while:
          return this.parseWhileStatement(node);

        case types._with:
          return this.parseWithStatement(node);

        case types.braceL:
          return this.parseBlock();

        case types.semi:
          return this.parseEmptyStatement(node);

        case types._export:
        case types._import:
          {
            var nextTokenCharCode = this.lookaheadCharCode();

            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }

            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(this.state.start, Errors.UnexpectedImportExport);
            }

            this.next();
            var result;

            if (starttype === types._import) {
              result = this.parseImport(node);

              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node);

              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }

            this.assertModuleNodeAllowed(node);
            return result;
          }

        default:
          {
            if (this.isAsyncFunction()) {
              if (context) {
                this.raise(this.state.start, Errors.AsyncFunctionInSingleStatementContext);
              }

              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
          }
      }

      var maybeName = this.state.value;
      var expr = this.parseExpression();

      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
    };

    _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raiseWithData(node.start, {
          code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
        }, Errors.ImportOutsideModule);
      }
    };

    _proto.takeDecorators = function takeDecorators(node) {
      var decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
      }
    };

    _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
      return this.match(types._class);
    };

    _proto.parseDecorators = function parseDecorators(allowExport) {
      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      while (this.match(types.at)) {
        var decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }

      if (this.match(types._export)) {
        if (!allowExport) {
          this.unexpected();
        }

        if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, Errors.DecoratorExportClass);
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(this.state.start, Errors.UnexpectedLeadingDecorator);
      }
    };

    _proto.parseDecorator = function parseDecorator() {
      this.expectOnePlugin(["decorators-legacy", "decorators"]);
      var node = this.startNode();
      this.next();

      if (this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var expr;

        if (this.eat(types.parenL)) {
          expr = this.parseExpression();
          this.expect(types.parenR);
        } else {
          expr = this.parseIdentifier(false);

          while (this.eat(types.dot)) {
            var _node = this.startNodeAt(startPos, startLoc);

            _node.object = expr;
            _node.property = this.parseIdentifier(true);
            _node.computed = false;
            expr = this.finishNode(_node, "MemberExpression");
          }
        }

        node.expression = this.parseMaybeDecoratorArguments(expr);
        this.state.decoratorStack.pop();
      } else {
        node.expression = this.parseExprSubscripts();
      }

      return this.finishNode(node, "Decorator");
    };

    _proto.parseMaybeDecoratorArguments = function parseMaybeDecoratorArguments(expr) {
      if (this.eat(types.parenL)) {
        var node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
        this.toReferencedList(node.arguments);
        return this.finishNode(node, "CallExpression");
      }

      return expr;
    };

    _proto.parseBreakContinueStatement = function parseBreakContinueStatement(node, keyword) {
      var isBreak = keyword === "break";
      this.next();

      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }

      this.verifyBreakContinue(node, keyword);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };

    _proto.verifyBreakContinue = function verifyBreakContinue(node, keyword) {
      var isBreak = keyword === "break";
      var i;

      for (i = 0; i < this.state.labels.length; ++i) {
        var lab = this.state.labels[i];

        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }

      if (i === this.state.labels.length) {
        this.raise(node.start, Errors.IllegalBreakContinue, keyword);
      }
    };

    _proto.parseDebuggerStatement = function parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    };

    _proto.parseHeaderExpression = function parseHeaderExpression() {
      this.expect(types.parenL);
      var val = this.parseExpression();
      this.expect(types.parenR);
      return val;
    };

    _proto.parseDoStatement = function parseDoStatement(node) {
      var _this = this;

      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(function () {
        return _this.parseStatement("do");
      });
      this.state.labels.pop();
      this.expect(types._while);
      node.test = this.parseHeaderExpression();
      this.eat(types.semi);
      return this.finishNode(node, "DoWhileStatement");
    };

    _proto.parseForStatement = function parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      var awaitAt = -1;

      if (this.isAwaitAllowed() && this.eatContextual("await")) {
        awaitAt = this.state.lastTokStart;
      }

      this.scope.enter(SCOPE_OTHER);
      this.expect(types.parenL);

      if (this.match(types.semi)) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, null);
      }

      var isLet = this.isLet();

      if (this.match(types._var) || this.match(types._const) || isLet) {
        var _init = this.startNode();

        var kind = isLet ? "let" : this.state.value;
        this.next();
        this.parseVar(_init, true, kind);
        this.finishNode(_init, "VariableDeclaration");

        if ((this.match(types._in) || this.isContextual("of")) && _init.declarations.length === 1) {
          return this.parseForIn(node, _init, awaitAt);
        }

        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, _init);
      }

      var refExpressionErrors = new ExpressionErrors();
      var init = this.parseExpression(true, refExpressionErrors);

      if (this.match(types._in) || this.isContextual("of")) {
        this.toAssignable(init);
        var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
        this.checkLVal(init, undefined, undefined, description);
        return this.parseForIn(node, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    };

    _proto.parseFunctionStatement = function parseFunctionStatement(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
    };

    _proto.parseIfStatement = function parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    };

    _proto.parseReturnStatement = function parseReturnStatement(node) {
      if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
        this.raise(this.state.start, Errors.IllegalReturn);
      }

      this.next();

      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }

      return this.finishNode(node, "ReturnStatement");
    };

    _proto.parseSwitchStatement = function parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      var cases = node.cases = [];
      this.expect(types.braceL);
      this.state.labels.push(switchLabel);
      this.scope.enter(SCOPE_OTHER);
      var cur;

      for (var sawDefault; !this.match(types.braceR);) {
        if (this.match(types._case) || this.match(types._default)) {
          var isCase = this.match(types._case);
          if (cur) this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();

          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(this.state.lastTokStart, Errors.MultipleDefaultsInSwitch);
            }

            sawDefault = true;
            cur.test = null;
          }

          this.expect(types.colon);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatement(null));
          } else {
            this.unexpected();
          }
        }
      }

      this.scope.exit();
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    };

    _proto.parseThrowStatement = function parseThrowStatement(node) {
      this.next();

      if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) {
        this.raise(this.state.lastTokEnd, Errors.NewlineAfterThrow);
      }

      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    };

    _proto.parseTryStatement = function parseTryStatement(node) {
      var _this2 = this;

      this.next();
      node.block = this.parseBlock();
      node.handler = null;

      if (this.match(types._catch)) {
        var clause = this.startNode();
        this.next();

        if (this.match(types.parenL)) {
          this.expect(types.parenL);
          clause.param = this.parseBindingAtom();
          var simple = clause.param.type === "Identifier";
          this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(clause.param, BIND_LEXICAL, null, "catch clause");
          this.expect(types.parenR);
        } else {
          clause.param = null;
          this.scope.enter(SCOPE_OTHER);
        }

        clause.body = this.withTopicForbiddingContext(function () {
          return _this2.parseBlock(false, false);
        });
        this.scope.exit();
        node.handler = this.finishNode(clause, "CatchClause");
      }

      node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

      if (!node.handler && !node.finalizer) {
        this.raise(node.start, Errors.NoCatchOrFinally);
      }

      return this.finishNode(node, "TryStatement");
    };

    _proto.parseVarStatement = function parseVarStatement(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    };

    _proto.parseWhileStatement = function parseWhileStatement(node) {
      var _this3 = this;

      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(function () {
        return _this3.parseStatement("while");
      });
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    };

    _proto.parseWithStatement = function parseWithStatement(node) {
      var _this4 = this;

      if (this.state.strict) {
        this.raise(this.state.start, Errors.StrictWith);
      }

      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withTopicForbiddingContext(function () {
        return _this4.parseStatement("with");
      });
      return this.finishNode(node, "WithStatement");
    };

    _proto.parseEmptyStatement = function parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    };

    _proto.parseLabeledStatement = function parseLabeledStatement(node, maybeName, expr, context) {
      for (var _i4 = 0, _this$state$labels2 = this.state.labels; _i4 < _this$state$labels2.length; _i4++) {
        var label = _this$state$labels2[_i4];

        if (label.name === maybeName) {
          this.raise(expr.start, Errors.LabelRedeclaration, maybeName);
        }
      }

      var kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;

      for (var i = this.state.labels.length - 1; i >= 0; i--) {
        var _label = this.state.labels[i];

        if (_label.statementStart === node.start) {
          _label.statementStart = this.state.start;
          _label.kind = kind;
        } else {
          break;
        }
      }

      this.state.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.state.start
      });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    };

    _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    };

    _proto.parseBlock = function parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
      if (allowDirectives === void 0) {
        allowDirectives = false;
      }

      if (createNewLexicalScope === void 0) {
        createNewLexicalScope = true;
      }

      var node = this.startNode();
      this.expect(types.braceL);

      if (createNewLexicalScope) {
        this.scope.enter(SCOPE_OTHER);
      }

      this.parseBlockBody(node, allowDirectives, false, types.braceR, afterBlockParse);

      if (createNewLexicalScope) {
        this.scope.exit();
      }

      return this.finishNode(node, "BlockStatement");
    };

    _proto.isValidDirective = function isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    };

    _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      var body = node.body = [];
      var directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
    };

    _proto.parseBlockOrModuleBlockBody = function parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      var octalPositions = [];
      var oldStrict = this.state.strict;
      var hasStrictModeDirective = false;
      var parsedNonDirective = false;

      while (!this.match(end)) {
        if (!parsedNonDirective && this.state.octalPositions.length) {
          octalPositions.push.apply(octalPositions, this.state.octalPositions);
        }

        var stmt = this.parseStatement(null, topLevel);

        if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {
          var directive = this.stmtToDirective(stmt);
          directives.push(directive);

          if (!hasStrictModeDirective && directive.value.value === "use strict") {
            hasStrictModeDirective = true;
            this.setStrict(true);
          }

          continue;
        }

        parsedNonDirective = true;
        body.push(stmt);
      }

      if (this.state.strict && octalPositions.length) {
        for (var _i6 = 0; _i6 < octalPositions.length; _i6++) {
          var pos = octalPositions[_i6];
          this.raise(pos, Errors.StrictOctalLiteral);
        }
      }

      if (afterBlockParse) {
        afterBlockParse.call(this, hasStrictModeDirective);
      }

      if (!oldStrict) {
        this.setStrict(false);
      }

      this.next();
    };

    _proto.parseFor = function parseFor(node, init) {
      var _this5 = this;

      node.init = init;
      this.expect(types.semi);
      node.test = this.match(types.semi) ? null : this.parseExpression();
      this.expect(types.semi);
      node.update = this.match(types.parenR) ? null : this.parseExpression();
      this.expect(types.parenR);
      node.body = this.withTopicForbiddingContext(function () {
        return _this5.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    };

    _proto.parseForIn = function parseForIn(node, init, awaitAt) {
      var _this6 = this;

      var isForIn = this.match(types._in);
      this.next();

      if (isForIn) {
        if (awaitAt > -1) this.unexpected(awaitAt);
      } else {
        node["await"] = awaitAt > -1;
      }

      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(init.start, Errors.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, Errors.InvalidLhs, "for-loop");
      }

      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types.parenR);
      node.body = this.withTopicForbiddingContext(function () {
        return _this6.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    };

    _proto.parseVar = function parseVar(node, isFor, kind) {
      var declarations = node.declarations = [];
      var isTypescript = this.hasPlugin("typescript");
      node.kind = kind;

      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);

        if (this.eat(types.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else {
          if (kind === "const" && !(this.match(types._in) || this.isContextual("of"))) {
            if (!isTypescript) {
              this.unexpected();
            }
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
            this.raise(this.state.lastTokEnd, Errors.DeclarationMissingInitializer, "Complex binding patterns");
          }

          decl.init = null;
        }

        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types.comma)) break;
      }

      return node;
    };

    _proto.parseVarId = function parseVarId(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, "variable declaration", kind !== "var");
    };

    _proto.parseFunction = function parseFunction(node, statement, isAsync) {
      var _this7 = this;

      if (statement === void 0) {
        statement = FUNC_NO_FLAGS;
      }

      if (isAsync === void 0) {
        isAsync = false;
      }

      var isStatement = statement & FUNC_STATEMENT;
      var isHangingStatement = statement & FUNC_HANGING_STATEMENT;
      var requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
      this.initFunction(node, isAsync);

      if (this.match(types.star) && isHangingStatement) {
        this.raise(this.state.start, Errors.GeneratorInSingleStatementContext);
      }

      node.generator = this.eat(types.star);

      if (isStatement) {
        node.id = this.parseFunctionId(requireId);
      }

      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldYieldPos = this.state.yieldPos;
      var oldAwaitPos = this.state.awaitPos;
      this.state.maybeInArrowParameters = false;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.scope.enter(SCOPE_FUNCTION);
      this.prodParam.enter(functionFlags(isAsync, node.generator));

      if (!isStatement) {
        node.id = this.parseFunctionId();
      }

      this.parseFunctionParams(node);
      this.withTopicForbiddingContext(function () {
        _this7.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.prodParam.exit();
      this.scope.exit();

      if (isStatement && !isHangingStatement) {
        this.registerFunctionStatementId(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      return node;
    };

    _proto.parseFunctionId = function parseFunctionId(requireId) {
      return requireId || this.match(types.name) ? this.parseIdentifier() : null;
    };

    _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
      var oldInParameters = this.state.inParameters;
      this.state.inParameters = true;
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);
      this.state.inParameters = oldInParameters;
      this.checkYieldAwaitInDefaultParams();
    };

    _proto.registerFunctionStatementId = function registerFunctionStatementId(node) {
      if (!node.id) return;
      this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
    };

    _proto.parseClass = function parseClass(node, isStatement, optionalId) {
      this.next();
      this.takeDecorators(node);
      var oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass, oldStrict);
      this.state.strict = oldStrict;
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };

    _proto.isClassProperty = function isClassProperty() {
      return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
    };

    _proto.isClassMethod = function isClassMethod() {
      return this.match(types.parenL);
    };

    _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
      return !method.computed && !method["static"] && (method.key.name === "constructor" || method.key.value === "constructor");
    };

    _proto.parseClassBody = function parseClassBody(constructorAllowsSuper, oldStrict) {
      var _this8 = this;

      this.classScope.enter();
      var state = {
        hadConstructor: false
      };
      var decorators = [];
      var classBody = this.startNode();
      classBody.body = [];
      this.expect(types.braceL);
      this.withTopicForbiddingContext(function () {
        while (!_this8.match(types.braceR)) {
          if (_this8.eat(types.semi)) {
            if (decorators.length > 0) {
              throw _this8.raise(_this8.state.lastTokEnd, Errors.DecoratorSemicolon);
            }

            continue;
          }

          if (_this8.match(types.at)) {
            decorators.push(_this8.parseDecorator());
            continue;
          }

          var member = _this8.startNode();

          if (decorators.length) {
            member.decorators = decorators;

            _this8.resetStartLocationFromNode(member, decorators[0]);

            decorators = [];
          }

          _this8.parseClassMember(classBody, member, state, constructorAllowsSuper);

          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            _this8.raise(member.start, Errors.DecoratorConstructor);
          }
        }
      });

      if (!oldStrict) {
        this.state.strict = false;
      }

      this.next();

      if (decorators.length) {
        throw this.raise(this.state.start, Errors.TrailingDecorator);
      }

      this.classScope.exit();
      return this.finishNode(classBody, "ClassBody");
    };

    _proto.parseClassMemberFromModifier = function parseClassMemberFromModifier(classBody, member) {
      var containsEsc = this.state.containsEsc;
      var key = this.parseIdentifier(true);

      if (this.isClassMethod()) {
        var method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method["static"] = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        var prop = member;
        prop.computed = false;
        prop.key = key;
        prop["static"] = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      } else if (containsEsc) {
        throw this.unexpected();
      }

      return false;
    };

    _proto.parseClassMember = function parseClassMember(classBody, member, state, constructorAllowsSuper) {
      var isStatic = this.isContextual("static");

      if (isStatic && this.parseClassMemberFromModifier(classBody, member)) {
        return;
      }

      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);
    };

    _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
      var publicMethod = member;
      var privateMethod = member;
      var publicProp = member;
      var privateProp = member;
      var method = publicMethod;
      var publicMember = publicMethod;
      member["static"] = isStatic;

      if (this.eat(types.star)) {
        method.kind = "method";
        this.parseClassPropertyName(method);

        if (method.key.type === "PrivateName") {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }

        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, Errors.ConstructorIsGenerator);
        }

        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }

      var containsEsc = this.state.containsEsc;
      var key = this.parseClassPropertyName(member);
      var isPrivate = key.type === "PrivateName";
      var isSimple = key.type === "Identifier";
      var maybeQuestionTokenStart = this.state.start;
      this.parsePostMemberNameModifiers(publicMember);

      if (this.isClassMethod()) {
        method.kind = "method";

        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }

        var isConstructor = this.isNonstaticConstructor(publicMethod);
        var allowsDirectSuper = false;

        if (isConstructor) {
          publicMethod.kind = "constructor";

          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(key.start, Errors.DuplicateConstructor);
          }

          state.hadConstructor = true;
          allowsDirectSuper = constructorAllowsSuper;
        }

        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (isSimple && key.name === "async" && !containsEsc && !this.isLineTerminator()) {
        var isGenerator = this.eat(types.star);

        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStart);
        }

        method.kind = "method";
        this.parseClassPropertyName(method);
        this.parsePostMemberNameModifiers(publicMember);

        if (method.key.type === "PrivateName") {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, Errors.ConstructorIsAsync);
          }

          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if (isSimple && (key.name === "get" || key.name === "set") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {
        method.kind = key.name;
        this.parseClassPropertyName(publicMethod);

        if (method.key.type === "PrivateName") {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, Errors.ConstructorIsAccessor);
          }

          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }

        this.checkGetterSetterParams(publicMethod);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    };

    _proto.parseClassPropertyName = function parseClassPropertyName(member) {
      var key = this.parsePropertyName(member, true);

      if (!member.computed && member["static"] && (key.name === "prototype" || key.value === "prototype")) {
        this.raise(key.start, Errors.StaticPrototype);
      }

      if (key.type === "PrivateName" && key.id.name === "constructor") {
        this.raise(key.start, Errors.ConstructorClassPrivateField);
      }

      return key;
    };

    _proto.pushClassProperty = function pushClassProperty(classBody, prop) {
      if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
        this.raise(prop.key.start, Errors.ConstructorClassField);
      }

      classBody.body.push(this.parseClassProperty(prop));
    };

    _proto.pushClassPrivateProperty = function pushClassPrivateProperty(classBody, prop) {
      this.expectPlugin("classPrivateProperties", prop.key.start);
      var node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node);
      this.classScope.declarePrivateName(node.key.id.name, CLASS_ELEMENT_OTHER, node.key.start);
    };

    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    };

    _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      this.expectPlugin("classPrivateMethods", method.key.start);
      var node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
      classBody.body.push(node);
      var kind = node.kind === "get" ? node["static"] ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node["static"] ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
      this.classScope.declarePrivateName(node.key.id.name, kind, node.key.start);
    };

    _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {};

    _proto.parseAccessModifier = function parseAccessModifier() {
      return undefined;
    };

    _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      this.prodParam.enter(PARAM);
      node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;
      this.semicolon();
      this.prodParam.exit();
      this.scope.exit();
      return this.finishNode(node, "ClassPrivateProperty");
    };

    _proto.parseClassProperty = function parseClassProperty(node) {
      if (!node.typeAnnotation) {
        this.expectPlugin("classProperties");
      }

      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      this.prodParam.enter(PARAM);

      if (this.match(types.eq)) {
        this.expectPlugin("classProperties");
        this.next();
        node.value = this.parseMaybeAssign();
      } else {
        node.value = null;
      }

      this.semicolon();
      this.prodParam.exit();
      this.scope.exit();
      return this.finishNode(node, "ClassProperty");
    };

    _proto.parseClassId = function parseClassId(node, isStatement, optionalId, bindingType) {
      if (bindingType === void 0) {
        bindingType = BIND_CLASS;
      }

      if (this.match(types.name)) {
        node.id = this.parseIdentifier();

        if (isStatement) {
          this.checkLVal(node.id, bindingType, undefined, "class name");
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          this.unexpected(null, Errors.MissingClassName);
        }
      }
    };

    _proto.parseClassSuper = function parseClassSuper(node) {
      node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
    };

    _proto.parseExport = function parseExport(node) {
      var hasDefault = this.maybeParseExportDefaultSpecifier(node);
      var parseAfterDefault = !hasDefault || this.eat(types.comma);
      var hasStar = parseAfterDefault && this.eatExportStar(node);
      var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
      var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));
      var isFromRequired = hasDefault || hasStar;

      if (hasStar && !hasNamespace) {
        if (hasDefault) this.unexpected();
        this.parseExportFrom(node, true);
        return this.finishNode(node, "ExportAllDeclaration");
      }

      var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
        throw this.unexpected(null, types.braceL);
      }

      var hasDeclaration;

      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }

      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        this.checkExport(node, true, false, !!node.source);
        return this.finishNode(node, "ExportNamedDeclaration");
      }

      if (this.eat(types._default)) {
        node.declaration = this.parseExportDefaultExpression();
        this.checkExport(node, true, true);
        return this.finishNode(node, "ExportDefaultDeclaration");
      }

      throw this.unexpected(null, types.braceL);
    };

    _proto.eatExportStar = function eatExportStar(node) {
      return this.eat(types.star);
    };

    _proto.maybeParseExportDefaultSpecifier = function maybeParseExportDefaultSpecifier(node) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        var specifier = this.startNode();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }

      return false;
    };

    _proto.maybeParseExportNamespaceSpecifier = function maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual("as")) {
        if (!node.specifiers) node.specifiers = [];
        var specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }

      return false;
    };

    _proto.maybeParseExportNamedSpecifiers = function maybeParseExportNamedSpecifiers(node) {
      if (this.match(types.braceL)) {
        var _node$specifiers;

        if (!node.specifiers) node.specifiers = [];

        (_node$specifiers = node.specifiers).push.apply(_node$specifiers, this.parseExportSpecifiers());

        node.source = null;
        node.declaration = null;
        return true;
      }

      return false;
    };

    _proto.maybeParseExportDeclaration = function maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        if (this.isContextual("async")) {
          var next = this.nextTokenStart();

          if (!this.isUnparsedContextual(next, "function")) {
            this.unexpected(next, types._function);
          }
        }

        node.specifiers = [];
        node.source = null;
        node.declaration = this.parseExportDeclaration(node);
        return true;
      }

      return false;
    };

    _proto.isAsyncFunction = function isAsyncFunction() {
      if (!this.isContextual("async")) return false;
      var next = this.nextTokenStart();
      return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
    };

    _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
      var expr = this.startNode();
      var isAsync = this.isAsyncFunction();

      if (this.match(types._function) || isAsync) {
        this.next();

        if (isAsync) {
          this.next();
        }

        return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
      } else if (this.match(types._class)) {
        return this.parseClass(expr, true, true);
      } else if (this.match(types.at)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, Errors.DecoratorBeforeExport);
        }

        this.parseDecorators(false);
        return this.parseClass(expr, true, true);
      } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {
        throw this.raise(this.state.start, Errors.UnsupportedDefaultExport);
      } else {
        var res = this.parseMaybeAssign();
        this.semicolon();
        return res;
      }
    };

    _proto.parseExportDeclaration = function parseExportDeclaration(node) {
      return this.parseStatement(null);
    };

    _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
      if (this.match(types.name)) {
        return this.state.value !== "async" && this.state.value !== "let";
      }

      if (!this.match(types._default)) {
        return false;
      }

      var next = this.nextTokenStart();
      return this.input.charCodeAt(next) === 44 || this.isUnparsedContextual(next, "from");
    };

    _proto.parseExportFrom = function parseExportFrom(node, expect) {
      if (this.eatContextual("from")) {
        node.source = this.parseImportSource();
        this.checkExport(node);
      } else {
        if (expect) {
          this.unexpected();
        } else {
          node.source = null;
        }
      }

      this.semicolon();
    };

    _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
      if (this.match(types.at)) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);

        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.unexpected(this.state.start, Errors.DecoratorBeforeExport);
          } else {
            return true;
          }
        }
      }

      return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
    };

    _proto.checkExport = function checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        if (isDefault) {
          this.checkDuplicateExports(node, "default");
        } else if (node.specifiers && node.specifiers.length) {
          for (var _i8 = 0, _node$specifiers3 = node.specifiers; _i8 < _node$specifiers3.length; _i8++) {
            var specifier = _node$specifiers3[_i8];
            this.checkDuplicateExports(specifier, specifier.exported.name);

            if (!isFrom && specifier.local) {
              this.checkReservedWord(specifier.local.name, specifier.local.start, true, false);
              this.scope.checkLocalExport(specifier.local);
            }
          }
        } else if (node.declaration) {
          if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
            var id = node.declaration.id;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (node.declaration.type === "VariableDeclaration") {
            for (var _i10 = 0, _node$declaration$dec2 = node.declaration.declarations; _i10 < _node$declaration$dec2.length; _i10++) {
              var declaration = _node$declaration$dec2[_i10];
              this.checkDeclaration(declaration.id);
            }
          }
        }
      }

      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (currentContextDecorators.length) {
        var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");

        if (!node.declaration || !isClass) {
          throw this.raise(node.start, Errors.UnsupportedDecoratorExport);
        }

        this.takeDecorators(node.declaration);
      }
    };

    _proto.checkDeclaration = function checkDeclaration(node) {
      if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === "ObjectPattern") {
        for (var _i12 = 0, _node$properties2 = node.properties; _i12 < _node$properties2.length; _i12++) {
          var prop = _node$properties2[_i12];
          this.checkDeclaration(prop);
        }
      } else if (node.type === "ArrayPattern") {
        for (var _i14 = 0, _node$elements2 = node.elements; _i14 < _node$elements2.length; _i14++) {
          var elem = _node$elements2[_i14];

          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "AssignmentPattern") {
        this.checkDeclaration(node.left);
      }
    };

    _proto.checkDuplicateExports = function checkDuplicateExports(node, name) {
      if (this.state.exportedIdentifiers.indexOf(name) > -1) {
        this.raise(node.start, name === "default" ? Errors.DuplicateDefaultExport : Errors.DuplicateExport, name);
      }

      this.state.exportedIdentifiers.push(name);
    };

    _proto.parseExportSpecifiers = function parseExportSpecifiers() {
      var nodes = [];
      var first = true;
      this.expect(types.braceL);

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
          if (this.eat(types.braceR)) break;
        }

        var node = this.startNode();
        node.local = this.parseIdentifier(true);
        node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }

      return nodes;
    };

    _proto.parseImport = function parseImport(node) {
      node.specifiers = [];

      if (!this.match(types.string)) {
        var hasDefault = this.maybeParseDefaultImportSpecifier(node);
        var parseNext = !hasDefault || this.eat(types.comma);
        var hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual("from");
      }

      node.source = this.parseImportSource();
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    };

    _proto.parseImportSource = function parseImportSource() {
      if (!this.match(types.string)) this.unexpected();
      return this.parseExprAtom();
    };

    _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {
      return this.match(types.name);
    };

    _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = this.parseIdentifier();
      this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);
      node.specifiers.push(this.finishNode(specifier, type));
    };

    _proto.maybeParseDefaultImportSpecifier = function maybeParseDefaultImportSpecifier(node) {
      if (this.shouldParseDefaultImport(node)) {
        this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
        return true;
      }

      return false;
    };

    _proto.maybeParseStarImportSpecifier = function maybeParseStarImportSpecifier(node) {
      if (this.match(types.star)) {
        var specifier = this.startNode();
        this.next();
        this.expectContextual("as");
        this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
        return true;
      }

      return false;
    };

    _proto.parseNamedImportSpecifiers = function parseNamedImportSpecifiers(node) {
      var first = true;
      this.expect(types.braceL);

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(types.colon)) {
            throw this.raise(this.state.start, Errors.DestructureNamedImport);
          }

          this.expect(types.comma);
          if (this.eat(types.braceR)) break;
        }

        this.parseImportSpecifier(node);
      }
    };

    _proto.parseImportSpecifier = function parseImportSpecifier(node) {
      var specifier = this.startNode();
      specifier.imported = this.parseIdentifier(true);

      if (this.eatContextual("as")) {
        specifier.local = this.parseIdentifier();
      } else {
        this.checkReservedWord(specifier.imported.name, specifier.start, true, true);
        specifier.local = specifier.imported.__clone();
      }

      this.checkLVal(specifier.local, BIND_LEXICAL, undefined, "import specifier");
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    };

    return StatementParser;
  }(ExpressionParser);

  var ClassScope = function ClassScope() {
    this.privateNames = new Set();
    this.loneAccessors = new Map();
    this.undefinedPrivateNames = new Map();
  };

  var ClassScopeHandler = function () {
    function ClassScopeHandler(raise) {
      this.stack = [];
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
    }

    var _proto = ClassScopeHandler.prototype;

    _proto.current = function current() {
      return this.stack[this.stack.length - 1];
    };

    _proto.enter = function enter() {
      this.stack.push(new ClassScope());
    };

    _proto.exit = function exit() {
      var oldClassScope = this.stack.pop();
      var current = this.current();

      for (var _i2 = 0, _Array$from2 = Array.from(oldClassScope.undefinedPrivateNames); _i2 < _Array$from2.length; _i2++) {
        var _Array$from2$_i = _Array$from2[_i2],
            name = _Array$from2$_i[0],
            pos = _Array$from2$_i[1];

        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, pos);
          }
        } else {
          this.raise(pos, Errors.InvalidPrivateFieldResolution, name);
        }
      }
    };

    _proto.declarePrivateName = function declarePrivateName(name, elementType, pos) {
      var classScope = this.current();
      var redefined = classScope.privateNames.has(name);

      if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
        var accessor = redefined && classScope.loneAccessors.get(name);

        if (accessor) {
          var oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
          var newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
          var oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
          var newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined) classScope.loneAccessors["delete"](name);
        } else if (!redefined) {
          classScope.loneAccessors.set(name, elementType);
        }
      }

      if (redefined) {
        this.raise(pos, Errors.PrivateNameRedeclaration, name);
      }

      classScope.privateNames.add(name);
      classScope.undefinedPrivateNames["delete"](name);
    };

    _proto.usePrivateName = function usePrivateName(name, pos) {
      var classScope;

      for (var _i4 = 0, _this$stack2 = this.stack; _i4 < _this$stack2.length; _i4++) {
        classScope = _this$stack2[_i4];
        if (classScope.privateNames.has(name)) return;
      }

      if (classScope) {
        classScope.undefinedPrivateNames.set(name, pos);
      } else {
        this.raise(pos, Errors.InvalidPrivateFieldResolution, name);
      }
    };

    return ClassScopeHandler;
  }();

  var Parser = function (_StatementParser) {
    _inheritsLoose(Parser, _StatementParser);

    function Parser(options, input) {
      var _this;

      options = getOptions(options);
      _this = _StatementParser.call(this, options, input) || this;

      var ScopeHandler = _this.getScopeHandler();

      _this.options = options;
      _this.inModule = _this.options.sourceType === "module";
      _this.scope = new ScopeHandler(_this.raise.bind(_assertThisInitialized(_this)), _this.inModule);
      _this.prodParam = new ProductionParameterHandler();
      _this.classScope = new ClassScopeHandler(_this.raise.bind(_assertThisInitialized(_this)));
      _this.plugins = pluginsMap(_this.options.plugins);
      _this.filename = options.sourceFilename;
      return _this;
    }

    var _proto = Parser.prototype;

    _proto.getScopeHandler = function getScopeHandler() {
      return ScopeHandler;
    };

    _proto.parse = function parse() {
      var paramFlags = PARAM;

      if (this.hasPlugin("topLevelAwait") && this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
      var file = this.startNode();
      var program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      return file;
    };

    return Parser;
  }(StatementParser);

  function pluginsMap(plugins) {
    var pluginMap = new Map();

    for (var _i2 = 0; _i2 < plugins.length; _i2++) {
      var plugin = plugins[_i2];

      var _ref = Array.isArray(plugin) ? plugin : [plugin, {}],
          name = _ref[0],
          options = _ref[1];

      if (!pluginMap.has(name)) pluginMap.set(name, options || {});
    }

    return pluginMap;
  }

  function parse$1(input, options) {
    if (options && options.sourceType === "unambiguous") {
      options = Object.assign({}, options);

      try {
        options.sourceType = "module";
        var parser = getParser(options, input);
        var ast = parser.parse();

        if (parser.sawUnambiguousESM) {
          return ast;
        }

        if (parser.ambiguousScriptDifferentAst) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused) {}
        } else {
          ast.program.sourceType = "script";
        }

        return ast;
      } catch (moduleError) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused2) {}

        throw moduleError;
      }
    } else {
      return getParser(options, input).parse();
    }
  }

  function getParser(options, input) {
    var cls = Parser;

    if (options && options.plugins) {
      validatePlugins(options.plugins);
      cls = getParserClass(options.plugins);
    }

    return new cls(options, input);
  }

  var parserClassCache = {};

  function getParserClass(pluginsFromOptions) {
    var pluginList = mixinPluginNames.filter(function (name) {
      return hasPlugin(pluginsFromOptions, name);
    });
    var key = pluginList.join("/");
    var cls = parserClassCache[key];

    if (!cls) {
      cls = Parser;

      for (var _i2 = 0; _i2 < pluginList.length; _i2++) {
        var plugin = pluginList[_i2];
        cls = mixinPlugins[plugin](cls);
      }

      parserClassCache[key] = cls;
    }

    return cls;
  }

  var hoistVariablesVisitor = {
    Function: function Function(path) {
      path.skip();
    },
    VariableDeclaration: function VariableDeclaration(path) {
      if (path.node.kind !== "var") return;
      var bindings = path.getBindingIdentifiers();

      for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        path.scope.push({
          id: bindings[key]
        });
      }

      var exprs = [];

      for (var _i2 = 0, _arr = path.node.declarations; _i2 < _arr.length; _i2++) {
        var declar = _arr[_i2];

        if (declar.init) {
          exprs.push(ExpressionStatement(AssignmentExpression("=", declar.id, declar.init)));
        }
      }

      path.replaceWithMultiple(exprs);
    }
  };
  function replaceWithMultiple(nodes) {
    this.resync();
    nodes = this._verifyNodeList(nodes);
    inheritLeadingComments(nodes[0], this.node);
    inheritTrailingComments(nodes[nodes.length - 1], this.node);
    this.node = this.container[this.key] = null;
    var paths = this.insertAfter(nodes);

    if (this.node) {
      this.requeue();
    } else {
      this.remove();
    }

    return paths;
  }
  function replaceWithSourceString(replacement) {
    this.resync();

    try {
      replacement = "(" + replacement + ")";
      replacement = parse$1(replacement);
    } catch (err) {
      var loc = err.loc;

      if (loc) {
        err.message += " - make sure this is an expression.\n" + codeFrameColumns(replacement, {
          start: {
            line: loc.line,
            column: loc.column + 1
          }
        });
        err.code = "BABEL_REPLACE_SOURCE_ERROR";
      }

      throw err;
    }

    replacement = replacement.program.body[0].expression;
    traverse$1.removeProperties(replacement);
    return this.replaceWith(replacement);
  }
  function replaceWith(replacement) {
    this.resync();

    if (this.removed) {
      throw new Error("You can't replace this node, we've already removed it");
    }

    if (replacement instanceof NodePath) {
      replacement = replacement.node;
    }

    if (!replacement) {
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    }

    if (this.node === replacement) {
      return [this];
    }

    if (this.isProgram() && !isProgram(replacement)) {
      throw new Error("You can only replace a Program root node with another Program node");
    }

    if (Array.isArray(replacement)) {
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    }

    if (typeof replacement === "string") {
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    }

    var nodePath = "";

    if (this.isNodeType("Statement") && isExpression(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
        replacement = ExpressionStatement(replacement);
        nodePath = "expression";
      }
    }

    if (this.isNodeType("Expression") && isStatement(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
        return this.replaceExpressionWithStatements([replacement]);
      }
    }

    var oldNode = this.node;

    if (oldNode) {
      inheritsComments(replacement, oldNode);
      removeComments(oldNode);
    }

    this._replaceWith(replacement);

    this.type = replacement.type;
    this.setScope();
    this.requeue();
    return [nodePath ? this.get(nodePath) : this];
  }
  function _replaceWith(node) {
    if (!this.container) {
      throw new ReferenceError("Container is falsy");
    }

    if (this.inList) {
      validate(this.parent, this.key, [node]);
    } else {
      validate(this.parent, this.key, node);
    }

    this.debug("Replace with " + (node && node.type));
    this.node = this.container[this.key] = node;
  }
  function replaceExpressionWithStatements(nodes) {
    this.resync();
    var toSequenceExpression$1 = toSequenceExpression(nodes, this.scope);

    if (toSequenceExpression$1) {
      return this.replaceWith(toSequenceExpression$1)[0].get("expressions");
    }

    var functionParent = this.getFunctionParent();
    var isParentAsync = functionParent && functionParent.is("async");
    var container = ArrowFunctionExpression([], BlockStatement(nodes));
    this.replaceWith(CallExpression(container, []));
    this.traverse(hoistVariablesVisitor);
    var completionRecords = this.get("callee").getCompletionRecords();

    for (var _iterator = completionRecords, _isArray = Array.isArray(_iterator), _i3 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i3 >= _iterator.length) break;
        _ref = _iterator[_i3++];
      } else {
        _i3 = _iterator.next();
        if (_i3.done) break;
        _ref = _i3.value;
      }

      var path = _ref;
      if (!path.isExpressionStatement()) continue;
      var loop = path.findParent(function (path) {
        return path.isLoop();
      });

      if (loop) {
        var uid = loop.getData("expressionReplacementReturnUid");

        if (!uid) {
          var _callee = this.get("callee");

          uid = _callee.scope.generateDeclaredUidIdentifier("ret");

          _callee.get("body").pushContainer("body", ReturnStatement(cloneNode(uid)));

          loop.setData("expressionReplacementReturnUid", uid);
        } else {
          uid = Identifier(uid.name);
        }

        path.get("expression").replaceWith(AssignmentExpression("=", cloneNode(uid), path.node.expression));
      } else {
        path.replaceWith(ReturnStatement(path.node.expression));
      }
    }

    var callee = this.get("callee");
    callee.arrowFunctionToExpression();

    if (isParentAsync && traverse$1.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES)) {
      callee.set("async", true);
      this.replaceWith(AwaitExpression(this.node));
    }

    return callee.get("body.body");
  }
  function replaceInline(nodes) {
    this.resync();

    if (Array.isArray(nodes)) {
      if (Array.isArray(this.container)) {
        nodes = this._verifyNodeList(nodes);

        var paths = this._containerInsertAfter(nodes);

        this.remove();
        return paths;
      } else {
        return this.replaceWithMultiple(nodes);
      }
    } else {
      return this.replaceWith(nodes);
    }
  }

  var NodePath_replacement = /*#__PURE__*/Object.freeze({
    __proto__: null,
    replaceWithMultiple: replaceWithMultiple,
    replaceWithSourceString: replaceWithSourceString,
    replaceWith: replaceWith,
    _replaceWith: _replaceWith,
    replaceExpressionWithStatements: replaceExpressionWithStatements,
    replaceInline: replaceInline
  });

  var VALID_CALLEES = ["String", "Number", "Math"];
  var INVALID_METHODS = ["random"];
  function evaluateTruthy() {
    var res = this.evaluate();
    if (res.confident) return !!res.value;
  }

  function deopt(path, state) {
    if (!state.confident) return;
    state.deoptPath = path;
    state.confident = false;
  }

  function evaluateCached(path, state) {
    var node = path.node;
    var seen = state.seen;

    if (seen.has(node)) {
      var existing = seen.get(node);

      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path, state);
        return;
      }
    } else {
      var item = {
        resolved: false
      };
      seen.set(node, item);

      var val = _evaluate(path, state);

      if (state.confident) {
        item.resolved = true;
        item.value = val;
      }

      return val;
    }
  }

  function _evaluate(path, state) {
    if (!state.confident) return;
    var node = path.node;

    if (path.isSequenceExpression()) {
      var exprs = path.get("expressions");
      return evaluateCached(exprs[exprs.length - 1], state);
    }

    if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
      return node.value;
    }

    if (path.isNullLiteral()) {
      return null;
    }

    if (path.isTemplateLiteral()) {
      return evaluateQuasis(path, node.quasis, state);
    }

    if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
      var object = path.get("tag.object");
      var name = object.node.name;
      var property = path.get("tag.property");

      if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name, true) && property.isIdentifier && property.node.name === "raw") {
        return evaluateQuasis(path, node.quasi.quasis, state, true);
      }
    }

    if (path.isConditionalExpression()) {
      var testResult = evaluateCached(path.get("test"), state);
      if (!state.confident) return;

      if (testResult) {
        return evaluateCached(path.get("consequent"), state);
      } else {
        return evaluateCached(path.get("alternate"), state);
      }
    }

    if (path.isExpressionWrapper()) {
      return evaluateCached(path.get("expression"), state);
    }

    if (path.isMemberExpression() && !path.parentPath.isCallExpression({
      callee: node
    })) {
      var _property = path.get("property");

      var _object = path.get("object");

      if (_object.isLiteral() && _property.isIdentifier()) {
        var value = _object.node.value;
        var type = typeof value;

        if (type === "number" || type === "string") {
          return value[_property.node.name];
        }
      }
    }

    if (path.isReferencedIdentifier()) {
      var binding = path.scope.getBinding(node.name);

      if (binding && binding.constantViolations.length > 0) {
        return deopt(binding.path, state);
      }

      if (binding && path.node.start < binding.path.node.end) {
        return deopt(binding.path, state);
      }

      if (binding && binding.hasValue) {
        return binding.value;
      } else {
        if (node.name === "undefined") {
          return binding ? deopt(binding.path, state) : undefined;
        } else if (node.name === "Infinity") {
          return binding ? deopt(binding.path, state) : Infinity;
        } else if (node.name === "NaN") {
          return binding ? deopt(binding.path, state) : NaN;
        }

        var resolved = path.resolve();

        if (resolved === path) {
          return deopt(path, state);
        } else {
          return evaluateCached(resolved, state);
        }
      }
    }

    if (path.isUnaryExpression({
      prefix: true
    })) {
      if (node.operator === "void") {
        return undefined;
      }

      var argument = path.get("argument");

      if (node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
        return "function";
      }

      var arg = evaluateCached(argument, state);
      if (!state.confident) return;

      switch (node.operator) {
        case "!":
          return !arg;

        case "+":
          return +arg;

        case "-":
          return -arg;

        case "~":
          return ~arg;

        case "typeof":
          return typeof arg;
      }
    }

    if (path.isArrayExpression()) {
      var arr = [];
      var elems = path.get("elements");

      for (var _iterator = elems, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var elem = _ref;
        var elemValue = elem.evaluate();

        if (elemValue.confident) {
          arr.push(elemValue.value);
        } else {
          return deopt(elem, state);
        }
      }

      return arr;
    }

    if (path.isObjectExpression()) {
      var obj = {};
      var props = path.get("properties");

      for (var _iterator2 = props, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var prop = _ref2;

        if (prop.isObjectMethod() || prop.isSpreadElement()) {
          return deopt(prop, state);
        }

        var keyPath = prop.get("key");
        var key = keyPath;

        if (prop.node.computed) {
          key = key.evaluate();

          if (!key.confident) {
            return deopt(keyPath, state);
          }

          key = key.value;
        } else if (key.isIdentifier()) {
          key = key.node.name;
        } else {
          key = key.node.value;
        }

        var valuePath = prop.get("value");

        var _value = valuePath.evaluate();

        if (!_value.confident) {
          return deopt(valuePath, state);
        }

        _value = _value.value;
        obj[key] = _value;
      }

      return obj;
    }

    if (path.isLogicalExpression()) {
      var wasConfident = state.confident;
      var left = evaluateCached(path.get("left"), state);
      var leftConfident = state.confident;
      state.confident = wasConfident;
      var right = evaluateCached(path.get("right"), state);
      var rightConfident = state.confident;

      switch (node.operator) {
        case "||":
          state.confident = leftConfident && (!!left || rightConfident);
          if (!state.confident) return;
          return left || right;

        case "&&":
          state.confident = leftConfident && (!left || rightConfident);
          if (!state.confident) return;
          return left && right;
      }
    }

    if (path.isBinaryExpression()) {
      var _left = evaluateCached(path.get("left"), state);

      if (!state.confident) return;

      var _right = evaluateCached(path.get("right"), state);

      if (!state.confident) return;

      switch (node.operator) {
        case "-":
          return _left - _right;

        case "+":
          return _left + _right;

        case "/":
          return _left / _right;

        case "*":
          return _left * _right;

        case "%":
          return _left % _right;

        case "**":
          return Math.pow(_left, _right);

        case "<":
          return _left < _right;

        case ">":
          return _left > _right;

        case "<=":
          return _left <= _right;

        case ">=":
          return _left >= _right;

        case "==":
          return _left == _right;

        case "!=":
          return _left != _right;

        case "===":
          return _left === _right;

        case "!==":
          return _left !== _right;

        case "|":
          return _left | _right;

        case "&":
          return _left & _right;

        case "^":
          return _left ^ _right;

        case "<<":
          return _left << _right;

        case ">>":
          return _left >> _right;

        case ">>>":
          return _left >>> _right;
      }
    }

    if (path.isCallExpression()) {
      var callee = path.get("callee");
      var context;
      var func;

      if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
        func = global$1[node.callee.name];
      }

      if (callee.isMemberExpression()) {
        var _object2 = callee.get("object");

        var _property2 = callee.get("property");

        if (_object2.isIdentifier() && _property2.isIdentifier() && VALID_CALLEES.indexOf(_object2.node.name) >= 0 && INVALID_METHODS.indexOf(_property2.node.name) < 0) {
          context = global$1[_object2.node.name];
          func = context[_property2.node.name];
        }

        if (_object2.isLiteral() && _property2.isIdentifier()) {
          var _type = typeof _object2.node.value;

          if (_type === "string" || _type === "number") {
            context = _object2.node.value;
            func = context[_property2.node.name];
          }
        }
      }

      if (func) {
        var args = path.get("arguments").map(function (arg) {
          return evaluateCached(arg, state);
        });
        if (!state.confident) return;
        return func.apply(context, args);
      }
    }

    deopt(path, state);
  }

  function evaluateQuasis(path, quasis, state, raw) {
    if (raw === void 0) {
      raw = false;
    }

    var str = "";
    var i = 0;
    var exprs = path.get("expressions");

    for (var _iterator3 = quasis, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var elem = _ref3;
      if (!state.confident) break;
      str += raw ? elem.value.raw : elem.value.cooked;
      var expr = exprs[i++];
      if (expr) str += String(evaluateCached(expr, state));
    }

    if (!state.confident) return;
    return str;
  }

  function evaluate() {
    var state = {
      confident: true,
      deoptPath: null,
      seen: new Map()
    };
    var value = evaluateCached(this, state);
    if (!state.confident) value = undefined;
    return {
      confident: state.confident,
      deopt: state.deoptPath,
      value: value
    };
  }

  var NodePath_evaluation = /*#__PURE__*/Object.freeze({
    __proto__: null,
    evaluateTruthy: evaluateTruthy,
    evaluate: evaluate
  });

  function getFunctionArity (node) {
    var params = node.params;

    for (var i = 0; i < params.length; i++) {
      var param = params[i];

      if (isAssignmentPattern(param) || isRestElement(param)) {
        return i;
      }
    }

    return params.length;
  }

  function makeStatementFormatter(fn) {
    return {
      code: function code(str) {
        return "/* @babel/template */;\n" + str;
      },
      validate: function validate() {},
      unwrap: function unwrap(ast) {
        return fn(ast.program.body.slice(1));
      }
    };
  }

  var smart = makeStatementFormatter(function (body) {
    if (body.length > 1) {
      return body;
    } else {
      return body[0];
    }
  });
  var statements = makeStatementFormatter(function (body) {
    return body;
  });
  var statement = makeStatementFormatter(function (body) {
    if (body.length === 0) {
      throw new Error("Found nothing to return.");
    }

    if (body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }

    return body[0];
  });
  var expression = {
    code: function code(str) {
      return "(\n" + str + "\n)";
    },
    validate: function validate(_ref) {
      var program = _ref.program;

      if (program.body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }

      var expression = program.body[0].expression;

      if (expression.start === 0) {
        throw new Error("Parse result included parens.");
      }
    },
    unwrap: function unwrap(ast) {
      return ast.program.body[0].expression;
    }
  };
  var program = {
    code: function code(str) {
      return str;
    },
    validate: function validate() {},
    unwrap: function unwrap(ast) {
      return ast.program;
    }
  };

  function merge(a, b) {
    var _b$placeholderWhiteli = b.placeholderWhitelist,
        placeholderWhitelist = _b$placeholderWhiteli === void 0 ? a.placeholderWhitelist : _b$placeholderWhiteli,
        _b$placeholderPattern = b.placeholderPattern,
        placeholderPattern = _b$placeholderPattern === void 0 ? a.placeholderPattern : _b$placeholderPattern,
        _b$preserveComments = b.preserveComments,
        preserveComments = _b$preserveComments === void 0 ? a.preserveComments : _b$preserveComments,
        _b$syntacticPlacehold = b.syntacticPlaceholders,
        syntacticPlaceholders = _b$syntacticPlacehold === void 0 ? a.syntacticPlaceholders : _b$syntacticPlacehold;
    return {
      parser: Object.assign({}, a.parser, {}, b.parser),
      placeholderWhitelist: placeholderWhitelist,
      placeholderPattern: placeholderPattern,
      preserveComments: preserveComments,
      syntacticPlaceholders: syntacticPlaceholders
    };
  }
  function validate$2(opts) {
    if (opts != null && typeof opts !== "object") {
      throw new Error("Unknown template options.");
    }

    var _ref = opts || {},
        placeholderWhitelist = _ref.placeholderWhitelist,
        placeholderPattern = _ref.placeholderPattern,
        preserveComments = _ref.preserveComments,
        syntacticPlaceholders = _ref.syntacticPlaceholders,
        parser = _objectWithoutPropertiesLoose(_ref, ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"]);

    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    }

    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    }

    if (preserveComments != null && typeof preserveComments !== "boolean") {
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    }

    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    }

    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }

    return {
      parser: parser,
      placeholderWhitelist: placeholderWhitelist || undefined,
      placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
      preserveComments: preserveComments == null ? undefined : preserveComments,
      syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders
    };
  }
  function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
      return replacements.reduce(function (acc, replacement, i) {
        acc["$" + i] = replacement;
        return acc;
      }, {});
    } else if (typeof replacements === "object" || replacements == null) {
      return replacements || undefined;
    }

    throw new Error("Template replacements must be an array, object, null, or undefined");
  }

  var PATTERN = /^[_$A-Z0-9]+$/;
  function parseAndBuildMetadata(formatter, code, opts) {
    var ast = parseWithCodeFrame(code, opts.parser);
    var placeholderWhitelist = opts.placeholderWhitelist,
        placeholderPattern = opts.placeholderPattern,
        preserveComments = opts.preserveComments,
        syntacticPlaceholders = opts.syntacticPlaceholders;
    removePropertiesDeep(ast, {
      preserveComments: preserveComments
    });
    formatter.validate(ast);
    var syntactic = {
      placeholders: [],
      placeholderNames: new Set()
    };
    var legacy = {
      placeholders: [],
      placeholderNames: new Set()
    };
    var isLegacyRef = {
      value: undefined
    };
    traverse(ast, placeholderVisitorHandler, {
      syntactic: syntactic,
      legacy: legacy,
      isLegacyRef: isLegacyRef,
      placeholderWhitelist: placeholderWhitelist,
      placeholderPattern: placeholderPattern,
      syntacticPlaceholders: syntacticPlaceholders
    });
    return Object.assign({
      ast: ast
    }, isLegacyRef.value ? legacy : syntactic);
  }

  function placeholderVisitorHandler(node, ancestors, state) {
    var name;

    if (isPlaceholder(node)) {
      if (state.syntacticPlaceholders === false) {
        throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
      } else {
        name = node.name.name;
        state.isLegacyRef.value = false;
      }
    } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {
      return;
    } else if (isIdentifier(node) || isJSXIdentifier(node)) {
      name = node.name;
      state.isLegacyRef.value = true;
    } else if (isStringLiteral(node)) {
      name = node.value;
      state.isLegacyRef.value = true;
    } else {
      return;
    }

    if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }

    if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && (!state.placeholderWhitelist || !state.placeholderWhitelist.has(name))) {
      return;
    }

    ancestors = ancestors.slice();
    var _ancestors = ancestors[ancestors.length - 1],
        parent = _ancestors.node,
        key = _ancestors.key;
    var type;

    if (isStringLiteral(node) || isPlaceholder(node, {
      expectedNode: "StringLiteral"
    })) {
      type = "string";
    } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
      type = "param";
    } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
      type = "statement";
      ancestors = ancestors.slice(0, -1);
    } else if (isStatement(node) && isPlaceholder(node)) {
      type = "statement";
    } else {
      type = "other";
    }

    var _ref = state.isLegacyRef.value ? state.legacy : state.syntactic,
        placeholders = _ref.placeholders,
        placeholderNames = _ref.placeholderNames;

    placeholders.push({
      name: name,
      type: type,
      resolve: function resolve(ast) {
        return resolveAncestors(ast, ancestors);
      },
      isDuplicate: placeholderNames.has(name)
    });
    placeholderNames.add(name);
  }

  function resolveAncestors(ast, ancestors) {
    var parent = ast;

    for (var i = 0; i < ancestors.length - 1; i++) {
      var _ancestors$i = ancestors[i],
          _key = _ancestors$i.key,
          _index = _ancestors$i.index;

      if (_index === undefined) {
        parent = parent[_key];
      } else {
        parent = parent[_key][_index];
      }
    }

    var _ancestors2 = ancestors[ancestors.length - 1],
        key = _ancestors2.key,
        index = _ancestors2.index;
    return {
      parent: parent,
      key: key,
      index: index
    };
  }

  function parseWithCodeFrame(code, parserOpts) {
    parserOpts = Object.assign({
      allowReturnOutsideFunction: true,
      allowSuperOutsideMethod: true,
      sourceType: "module"
    }, parserOpts, {
      plugins: (parserOpts.plugins || []).concat("placeholders")
    });

    try {
      return parse$1(code, parserOpts);
    } catch (err) {
      var loc = err.loc;

      if (loc) {
        err.message += "\n" + codeFrameColumns(code, {
          start: loc
        });
        err.code = "BABEL_TEMPLATE_PARSE_ERROR";
      }

      throw err;
    }
  }

  function populatePlaceholders(metadata, replacements) {
    var ast = cloneNode(metadata.ast);

    if (replacements) {
      metadata.placeholders.forEach(function (placeholder) {
        if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
          var placeholderName = placeholder.name;
          throw new Error("Error: No substitution given for \"" + placeholderName + "\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['" + placeholderName + "'])}\n            - { placeholderPattern: /^" + placeholderName + "$/ }");
        }
      });
      Object.keys(replacements).forEach(function (key) {
        if (!metadata.placeholderNames.has(key)) {
          throw new Error("Unknown substitution \"" + key + "\" given");
        }
      });
    }

    metadata.placeholders.slice().reverse().forEach(function (placeholder) {
      try {
        applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
      } catch (e) {
        e.message = "@babel/template placeholder \"" + placeholder.name + "\": " + e.message;
        throw e;
      }
    });
    return ast;
  }

  function applyReplacement(placeholder, ast, replacement) {
    if (placeholder.isDuplicate) {
      if (Array.isArray(replacement)) {
        replacement = replacement.map(function (node) {
          return cloneNode(node);
        });
      } else if (typeof replacement === "object") {
        replacement = cloneNode(replacement);
      }
    }

    var _placeholder$resolve = placeholder.resolve(ast),
        parent = _placeholder$resolve.parent,
        key = _placeholder$resolve.key,
        index = _placeholder$resolve.index;

    if (placeholder.type === "string") {
      if (typeof replacement === "string") {
        replacement = StringLiteral(replacement);
      }

      if (!replacement || !isStringLiteral(replacement)) {
        throw new Error("Expected string substitution");
      }
    } else if (placeholder.type === "statement") {
      if (index === undefined) {
        if (!replacement) {
          replacement = EmptyStatement();
        } else if (Array.isArray(replacement)) {
          replacement = BlockStatement(replacement);
        } else if (typeof replacement === "string") {
          replacement = ExpressionStatement(Identifier(replacement));
        } else if (!isStatement(replacement)) {
          replacement = ExpressionStatement(replacement);
        }
      } else {
        if (replacement && !Array.isArray(replacement)) {
          if (typeof replacement === "string") {
            replacement = Identifier(replacement);
          }

          if (!isStatement(replacement)) {
            replacement = ExpressionStatement(replacement);
          }
        }
      }
    } else if (placeholder.type === "param") {
      if (typeof replacement === "string") {
        replacement = Identifier(replacement);
      }

      if (index === undefined) throw new Error("Assertion failure.");
    } else {
      if (typeof replacement === "string") {
        replacement = Identifier(replacement);
      }

      if (Array.isArray(replacement)) {
        throw new Error("Cannot replace single expression with an array.");
      }
    }

    if (index === undefined) {
      validate(parent, key, replacement);
      parent[key] = replacement;
    } else {
      var items = parent[key].slice();

      if (placeholder.type === "statement" || placeholder.type === "param") {
        if (replacement == null) {
          items.splice(index, 1);
        } else if (Array.isArray(replacement)) {
          items.splice.apply(items, [index, 1].concat(replacement));
        } else {
          items[index] = replacement;
        }
      } else {
        items[index] = replacement;
      }

      validate(parent, key, items);
      parent[key] = items;
    }
  }

  function stringTemplate(formatter, code, opts) {
    code = formatter.code(code);
    var metadata;
    return function (arg) {
      var replacements = normalizeReplacements(arg);
      if (!metadata) metadata = parseAndBuildMetadata(formatter, code, opts);
      return formatter.unwrap(populatePlaceholders(metadata, replacements));
    };
  }

  function literalTemplate(formatter, tpl, opts) {
    var _buildLiteralData = buildLiteralData(formatter, tpl, opts),
        metadata = _buildLiteralData.metadata,
        names = _buildLiteralData.names;

    return function (arg) {
      var defaultReplacements = arg.reduce(function (acc, replacement, i) {
        acc[names[i]] = replacement;
        return acc;
      }, {});
      return function (arg) {
        var replacements = normalizeReplacements(arg);

        if (replacements) {
          Object.keys(replacements).forEach(function (key) {
            if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
              throw new Error("Unexpected replacement overlap.");
            }
          });
        }

        return formatter.unwrap(populatePlaceholders(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
      };
    };
  }

  function buildLiteralData(formatter, tpl, opts) {
    var names;
    var nameSet;
    var metadata;
    var prefix = "";

    do {
      prefix += "$";
      var result = buildTemplateCode(tpl, prefix);
      names = result.names;
      nameSet = new Set(names);
      metadata = parseAndBuildMetadata(formatter, formatter.code(result.code), {
        parser: opts.parser,
        placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders
      });
    } while (metadata.placeholders.some(function (placeholder) {
      return placeholder.isDuplicate && nameSet.has(placeholder.name);
    }));

    return {
      metadata: metadata,
      names: names
    };
  }

  function buildTemplateCode(tpl, prefix) {
    var names = [];
    var code = tpl[0];

    for (var i = 1; i < tpl.length; i++) {
      var value = "" + prefix + (i - 1);
      names.push(value);
      code += value + tpl[i];
    }

    return {
      names: names,
      code: code
    };
  }

  var NO_PLACEHOLDER = validate$2({
    placeholderPattern: false
  });
  function createTemplateBuilder(formatter, defaultOpts) {
    var templateFnCache = new WeakMap();
    var templateAstCache = new WeakMap();
    var cachedOpts = defaultOpts || validate$2(null);
    return Object.assign(function (tpl) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (typeof tpl === "string") {
        if (args.length > 1) throw new Error("Unexpected extra params.");
        return extendedTrace(stringTemplate(formatter, tpl, merge(cachedOpts, validate$2(args[0]))));
      } else if (Array.isArray(tpl)) {
        var builder = templateFnCache.get(tpl);

        if (!builder) {
          builder = literalTemplate(formatter, tpl, cachedOpts);
          templateFnCache.set(tpl, builder);
        }

        return extendedTrace(builder(args));
      } else if (typeof tpl === "object" && tpl) {
        if (args.length > 0) throw new Error("Unexpected extra params.");
        return createTemplateBuilder(formatter, merge(cachedOpts, validate$2(tpl)));
      }

      throw new Error("Unexpected template param " + typeof tpl);
    }, {
      ast: function ast(tpl) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return stringTemplate(formatter, tpl, merge(merge(cachedOpts, validate$2(args[0])), NO_PLACEHOLDER))();
        } else if (Array.isArray(tpl)) {
          var builder = templateAstCache.get(tpl);

          if (!builder) {
            builder = literalTemplate(formatter, tpl, merge(cachedOpts, NO_PLACEHOLDER));
            templateAstCache.set(tpl, builder);
          }

          return builder(args)();
        }

        throw new Error("Unexpected template param " + typeof tpl);
      }
    });
  }

  function extendedTrace(fn) {
    var rootStack = "";

    try {
      throw new Error();
    } catch (error) {
      if (error.stack) {
        rootStack = error.stack.split("\n").slice(3).join("\n");
      }
    }

    return function (arg) {
      try {
        return fn(arg);
      } catch (err) {
        err.stack += "\n    =============\n" + rootStack;
        throw err;
      }
    };
  }

  var smart$1 = createTemplateBuilder(smart);
  var statement$1 = createTemplateBuilder(statement);
  var statements$1 = createTemplateBuilder(statements);
  var expression$1 = createTemplateBuilder(expression);
  var program$1 = createTemplateBuilder(program);
  var template = Object.assign(smart$1.bind(undefined), {
    smart: smart$1,
    statement: statement$1,
    statements: statements$1,
    expression: expression$1,
    program: program$1,
    ast: smart$1.ast
  });

  var buildPropertyMethodAssignmentWrapper = template("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
  var buildGeneratorPropertyMethodAssignmentWrapper = template("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
  var visitor = {
    "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
      if (path.node.name !== state.name) return;
      var localDeclar = path.scope.getBindingIdentifier(state.name);
      if (localDeclar !== state.outerDeclar) return;
      state.selfReference = true;
      path.stop();
    }
  };

  function getNameFromLiteralId(id) {
    if (isNullLiteral(id)) {
      return "null";
    }

    if (isRegExpLiteral(id)) {
      return "_" + id.pattern + "_" + id.flags;
    }

    if (isTemplateLiteral(id)) {
      return id.quasis.map(function (quasi) {
        return quasi.value.raw;
      }).join("");
    }

    if (id.value !== undefined) {
      return id.value + "";
    }

    return "";
  }

  function wrap(state, method, id, scope) {
    if (state.selfReference) {
      if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
        scope.rename(id.name);
      } else {
        if (!isFunction(method)) return;
        var build = buildPropertyMethodAssignmentWrapper;

        if (method.generator) {
          build = buildGeneratorPropertyMethodAssignmentWrapper;
        }

        var _template = build({
          FUNCTION: method,
          FUNCTION_ID: id,
          FUNCTION_KEY: scope.generateUidIdentifier(id.name)
        }).expression;
        var params = _template.callee.body.body[0].params;

        for (var i = 0, len = getFunctionArity(method); i < len; i++) {
          params.push(scope.generateUidIdentifier("x"));
        }

        return _template;
      }
    }

    method.id = id;
    scope.getProgramParent().references[id.name] = true;
  }

  function visit(node, name, scope) {
    var state = {
      selfAssignment: false,
      selfReference: false,
      outerDeclar: scope.getBindingIdentifier(name),
      references: [],
      name: name
    };
    var binding = scope.getOwnBinding(name);

    if (binding) {
      if (binding.kind === "param") {
        state.selfReference = true;
      }
    } else if (state.outerDeclar || scope.hasGlobal(name)) {
      scope.traverse(node, visitor, state);
    }

    return state;
  }

  function nameFunction (_ref, localBinding) {
    var node = _ref.node,
        parent = _ref.parent,
        scope = _ref.scope,
        id = _ref.id;

    if (localBinding === void 0) {
      localBinding = false;
    }

    if (node.id) return;

    if ((isObjectProperty(parent) || isObjectMethod(parent, {
      kind: "method"
    })) && (!parent.computed || isLiteral(parent.key))) {
      id = parent.key;
    } else if (isVariableDeclarator(parent)) {
      id = parent.id;

      if (isIdentifier(id) && !localBinding) {
        var binding = scope.parent.getBinding(id.name);

        if (binding && binding.constant && scope.getBinding(id.name) === binding) {
          node.id = cloneNode(id);
          node.id[NOT_LOCAL_BINDING] = true;
          return;
        }
      }
    } else if (isAssignmentExpression(parent)) {
      id = parent.left;
    } else if (!id) {
      return;
    }

    var name;

    if (id && isLiteral(id)) {
      name = getNameFromLiteralId(id);
    } else if (id && isIdentifier(id)) {
      name = id.name;
    }

    if (name === undefined) {
      return;
    }

    name = toBindingIdentifierName(name);
    id = Identifier(name);
    id[NOT_LOCAL_BINDING] = true;
    var state = visit(node, name, scope);
    return wrap(state, node, id, scope) || node;
  }

  function toComputedKey$1() {
    var node = this.node;
    var key;

    if (this.isMemberExpression()) {
      key = node.property;
    } else if (this.isProperty() || this.isMethod()) {
      key = node.key;
    } else {
      throw new ReferenceError("todo");
    }

    if (!node.computed) {
      if (isIdentifier(key)) key = StringLiteral(key.name);
    }

    return key;
  }
  function ensureBlock$1() {
    var body = this.get("body");
    var bodyNode = body.node;

    if (Array.isArray(body)) {
      throw new Error("Can't convert array path to a block statement");
    }

    if (!bodyNode) {
      throw new Error("Can't convert node without a body");
    }

    if (body.isBlockStatement()) {
      return bodyNode;
    }

    var statements = [];
    var stringPath = "body";
    var key;
    var listKey;

    if (body.isStatement()) {
      listKey = "body";
      key = 0;
      statements.push(body.node);
    } else {
      stringPath += ".body.0";

      if (this.isFunction()) {
        key = "argument";
        statements.push(ReturnStatement(body.node));
      } else {
        key = "expression";
        statements.push(ExpressionStatement(body.node));
      }
    }

    this.node.body = BlockStatement(statements);
    var parentPath = this.get(stringPath);
    body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
    return this.node;
  }
  function arrowFunctionToShadowed() {
    if (!this.isArrowFunctionExpression()) return;
    this.arrowFunctionToExpression();
  }
  function unwrapFunctionEnvironment() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    }

    hoistFunctionEnvironment(this);
  }
  function arrowFunctionToExpression(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$allowInsertArrow = _ref.allowInsertArrow,
        allowInsertArrow = _ref$allowInsertArrow === void 0 ? true : _ref$allowInsertArrow,
        _ref$specCompliant = _ref.specCompliant,
        specCompliant = _ref$specCompliant === void 0 ? false : _ref$specCompliant;

    if (!this.isArrowFunctionExpression()) {
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    }

    var thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);
    this.ensureBlock();
    this.node.type = "FunctionExpression";

    if (specCompliant) {
      var checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier("arrowCheckId");

      if (checkBinding) {
        this.parentPath.scope.push({
          id: checkBinding,
          init: ObjectExpression([])
        });
      }

      this.get("body").unshiftContainer("body", ExpressionStatement(CallExpression(this.hub.addHelper("newArrowCheck"), [ThisExpression(), checkBinding ? Identifier(checkBinding.name) : Identifier(thisBinding)])));
      this.replaceWith(CallExpression(MemberExpression(nameFunction(this, true) || this.node, Identifier("bind")), [checkBinding ? Identifier(checkBinding.name) : ThisExpression()]));
    }
  }

  function hoistFunctionEnvironment(fnPath, specCompliant, allowInsertArrow) {
    if (specCompliant === void 0) {
      specCompliant = false;
    }

    if (allowInsertArrow === void 0) {
      allowInsertArrow = true;
    }

    var thisEnvFn = fnPath.findParent(function (p) {
      return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({
        "static": false
      });
    });
    var inConstructor = thisEnvFn && thisEnvFn.node.kind === "constructor";

    if (thisEnvFn.isClassProperty()) {
      throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
    }

    var _getScopeInformation = getScopeInformation(fnPath),
        thisPaths = _getScopeInformation.thisPaths,
        argumentsPaths = _getScopeInformation.argumentsPaths,
        newTargetPaths = _getScopeInformation.newTargetPaths,
        superProps = _getScopeInformation.superProps,
        superCalls = _getScopeInformation.superCalls;

    if (inConstructor && superCalls.length > 0) {
      if (!allowInsertArrow) {
        throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
      }

      var allSuperCalls = [];
      thisEnvFn.traverse({
        Function: function Function(child) {
          if (child.isArrowFunctionExpression()) return;
          child.skip();
        },
        ClassProperty: function ClassProperty(child) {
          child.skip();
        },
        CallExpression: function CallExpression(child) {
          if (!child.get("callee").isSuper()) return;
          allSuperCalls.push(child);
        }
      });
      var superBinding = getSuperBinding(thisEnvFn);
      allSuperCalls.forEach(function (superCall) {
        var callee = Identifier(superBinding);
        callee.loc = superCall.node.callee.loc;
        superCall.get("callee").replaceWith(callee);
      });
    }

    if (argumentsPaths.length > 0) {
      var argumentsBinding = getBinding(thisEnvFn, "arguments", function () {
        return Identifier("arguments");
      });
      argumentsPaths.forEach(function (argumentsChild) {
        var argsRef = Identifier(argumentsBinding);
        argsRef.loc = argumentsChild.node.loc;
        argumentsChild.replaceWith(argsRef);
      });
    }

    if (newTargetPaths.length > 0) {
      var newTargetBinding = getBinding(thisEnvFn, "newtarget", function () {
        return MetaProperty(Identifier("new"), Identifier("target"));
      });
      newTargetPaths.forEach(function (targetChild) {
        var targetRef = Identifier(newTargetBinding);
        targetRef.loc = targetChild.node.loc;
        targetChild.replaceWith(targetRef);
      });
    }

    if (superProps.length > 0) {
      if (!allowInsertArrow) {
        throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
      }

      var flatSuperProps = superProps.reduce(function (acc, superProp) {
        return acc.concat(standardizeSuperProperty(superProp));
      }, []);
      flatSuperProps.forEach(function (superProp) {
        var key = superProp.node.computed ? "" : superProp.get("property").node.name;
        var isAssignment = superProp.parentPath.isAssignmentExpression({
          left: superProp.node
        });
        var isCall = superProp.parentPath.isCallExpression({
          callee: superProp.node
        });
        var superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
        var args = [];

        if (superProp.node.computed) {
          args.push(superProp.get("property").node);
        }

        if (isAssignment) {
          var value = superProp.parentPath.node.right;
          args.push(value);
        }

        var call = CallExpression(Identifier(superBinding), args);

        if (isCall) {
          superProp.parentPath.unshiftContainer("arguments", ThisExpression());
          superProp.replaceWith(MemberExpression(call, Identifier("call")));
          thisPaths.push(superProp.parentPath.get("arguments.0"));
        } else if (isAssignment) {
          superProp.parentPath.replaceWith(call);
        } else {
          superProp.replaceWith(call);
        }
      });
    }

    var thisBinding;

    if (thisPaths.length > 0 || specCompliant) {
      thisBinding = getThisBinding(thisEnvFn, inConstructor);

      if (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) {
        thisPaths.forEach(function (thisChild) {
          var thisRef = thisChild.isJSX() ? JSXIdentifier(thisBinding) : Identifier(thisBinding);
          thisRef.loc = thisChild.node.loc;
          thisChild.replaceWith(thisRef);
        });
        if (specCompliant) thisBinding = null;
      }
    }

    return thisBinding;
  }

  function standardizeSuperProperty(superProp) {
    if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
      var assignmentPath = superProp.parentPath;
      var op = assignmentPath.node.operator.slice(0, -1);
      var value = assignmentPath.node.right;
      assignmentPath.node.operator = "=";

      if (superProp.node.computed) {
        var tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        assignmentPath.get("left").replaceWith(MemberExpression(superProp.node.object, AssignmentExpression("=", tmp, superProp.node.property), true));
        assignmentPath.get("right").replaceWith(BinaryExpression(op, MemberExpression(superProp.node.object, Identifier(tmp.name), true), value));
      } else {
        assignmentPath.get("left").replaceWith(MemberExpression(superProp.node.object, superProp.node.property));
        assignmentPath.get("right").replaceWith(BinaryExpression(op, MemberExpression(superProp.node.object, Identifier(superProp.node.property.name)), value));
      }

      return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
    } else if (superProp.parentPath.isUpdateExpression()) {
      var updateExpr = superProp.parentPath;

      var _tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");

      var computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
      var parts = [AssignmentExpression("=", _tmp, MemberExpression(superProp.node.object, computedKey ? AssignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), AssignmentExpression("=", MemberExpression(superProp.node.object, computedKey ? Identifier(computedKey.name) : superProp.node.property, superProp.node.computed), BinaryExpression("+", Identifier(_tmp.name), NumericLiteral(1)))];

      if (!superProp.parentPath.node.prefix) {
        parts.push(Identifier(_tmp.name));
      }

      updateExpr.replaceWith(SequenceExpression(parts));
      var left = updateExpr.get("expressions.0.right");
      var right = updateExpr.get("expressions.1.left");
      return [left, right];
    }

    return [superProp];
  }

  function hasSuperClass(thisEnvFn) {
    return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
  }

  function getThisBinding(thisEnvFn, inConstructor) {
    return getBinding(thisEnvFn, "this", function (thisBinding) {
      if (!inConstructor || !hasSuperClass(thisEnvFn)) return ThisExpression();
      var supers = new WeakSet();
      thisEnvFn.traverse({
        Function: function Function(child) {
          if (child.isArrowFunctionExpression()) return;
          child.skip();
        },
        ClassProperty: function ClassProperty(child) {
          child.skip();
        },
        CallExpression: function CallExpression(child) {
          if (!child.get("callee").isSuper()) return;
          if (supers.has(child.node)) return;
          supers.add(child.node);
          child.replaceWithMultiple([child.node, AssignmentExpression("=", Identifier(thisBinding), Identifier("this"))]);
        }
      });
    });
  }

  function getSuperBinding(thisEnvFn) {
    return getBinding(thisEnvFn, "supercall", function () {
      var argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
      return ArrowFunctionExpression([RestElement(argsBinding)], CallExpression(Super(), [SpreadElement(Identifier(argsBinding.name))]));
    });
  }

  function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
    var op = isAssignment ? "set" : "get";
    return getBinding(thisEnvFn, "superprop_" + op + ":" + (propName || ""), function () {
      var argsList = [];
      var fnBody;

      if (propName) {
        fnBody = MemberExpression(Super(), Identifier(propName));
      } else {
        var method = thisEnvFn.scope.generateUidIdentifier("prop");
        argsList.unshift(method);
        fnBody = MemberExpression(Super(), Identifier(method.name), true);
      }

      if (isAssignment) {
        var valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
        argsList.push(valueIdent);
        fnBody = AssignmentExpression("=", fnBody, Identifier(valueIdent.name));
      }

      return ArrowFunctionExpression(argsList, fnBody);
    });
  }

  function getBinding(thisEnvFn, key, init) {
    var cacheKey = "binding:" + key;
    var data = thisEnvFn.getData(cacheKey);

    if (!data) {
      var id = thisEnvFn.scope.generateUidIdentifier(key);
      data = id.name;
      thisEnvFn.setData(cacheKey, data);
      thisEnvFn.scope.push({
        id: id,
        init: init(data)
      });
    }

    return data;
  }

  function getScopeInformation(fnPath) {
    var thisPaths = [];
    var argumentsPaths = [];
    var newTargetPaths = [];
    var superProps = [];
    var superCalls = [];
    fnPath.traverse({
      ClassProperty: function ClassProperty(child) {
        child.skip();
      },
      Function: function Function(child) {
        if (child.isArrowFunctionExpression()) return;
        child.skip();
      },
      ThisExpression: function ThisExpression(child) {
        thisPaths.push(child);
      },
      JSXIdentifier: function JSXIdentifier(child) {
        if (child.node.name !== "this") return;

        if (!child.parentPath.isJSXMemberExpression({
          object: child.node
        }) && !child.parentPath.isJSXOpeningElement({
          name: child.node
        })) {
          return;
        }

        thisPaths.push(child);
      },
      CallExpression: function CallExpression(child) {
        if (child.get("callee").isSuper()) superCalls.push(child);
      },
      MemberExpression: function MemberExpression(child) {
        if (child.get("object").isSuper()) superProps.push(child);
      },
      ReferencedIdentifier: function ReferencedIdentifier(child) {
        if (child.node.name !== "arguments") return;
        argumentsPaths.push(child);
      },
      MetaProperty: function MetaProperty(child) {
        if (!child.get("meta").isIdentifier({
          name: "new"
        })) return;
        if (!child.get("property").isIdentifier({
          name: "target"
        })) return;
        newTargetPaths.push(child);
      }
    });
    return {
      thisPaths: thisPaths,
      argumentsPaths: argumentsPaths,
      newTargetPaths: newTargetPaths,
      superProps: superProps,
      superCalls: superCalls
    };
  }

  var NodePath_conversion = /*#__PURE__*/Object.freeze({
    __proto__: null,
    toComputedKey: toComputedKey$1,
    ensureBlock: ensureBlock$1,
    arrowFunctionToShadowed: arrowFunctionToShadowed,
    unwrapFunctionEnvironment: unwrapFunctionEnvironment,
    arrowFunctionToExpression: arrowFunctionToExpression
  });

  function matchesPattern$1(pattern, allowPartial) {
    return matchesPattern(this.node, pattern, allowPartial);
  }
  function has$2(key) {
    var val = this.node && this.node[key];

    if (val && Array.isArray(val)) {
      return !!val.length;
    } else {
      return !!val;
    }
  }
  function isStatic() {
    return this.scope.isStatic(this.node);
  }
  var is$1 = has$2;
  function isnt(key) {
    return !this.has(key);
  }
  function equals(key, value) {
    return this.node[key] === value;
  }
  function isNodeType(type) {
    return isType(this.type, type);
  }
  function canHaveVariableDeclarationOrExpression() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  function canSwapBetweenExpressionAndStatement(replacement) {
    if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
      return false;
    }

    if (this.isExpression()) {
      return isBlockStatement(replacement);
    } else if (this.isBlockStatement()) {
      return isExpression(replacement);
    }

    return false;
  }
  function isCompletionRecord(allowInsideFunction) {
    var path = this;
    var first = true;

    do {
      var container = path.container;

      if (path.isFunction() && !first) {
        return !!allowInsideFunction;
      }

      first = false;

      if (Array.isArray(container) && path.key !== container.length - 1) {
        return false;
      }
    } while ((path = path.parentPath) && !path.isProgram());

    return true;
  }
  function isStatementOrBlock() {
    if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
      return false;
    } else {
      return includes_1(STATEMENT_OR_BLOCK_KEYS, this.key);
    }
  }
  function referencesImport(moduleSource, importName) {
    if (!this.isReferencedIdentifier()) return false;
    var binding = this.scope.getBinding(this.node.name);
    if (!binding || binding.kind !== "module") return false;
    var path = binding.path;
    var parent = path.parentPath;
    if (!parent.isImportDeclaration()) return false;

    if (parent.node.source.value === moduleSource) {
      if (!importName) return true;
    } else {
      return false;
    }

    if (path.isImportDefaultSpecifier() && importName === "default") {
      return true;
    }

    if (path.isImportNamespaceSpecifier() && importName === "*") {
      return true;
    }

    if (path.isImportSpecifier() && path.node.imported.name === importName) {
      return true;
    }

    return false;
  }
  function getSource() {
    var node = this.node;

    if (node.end) {
      var code = this.hub.getCode();
      if (code) return code.slice(node.start, node.end);
    }

    return "";
  }
  function willIMaybeExecuteBefore(target) {
    return this._guessExecutionStatusRelativeTo(target) !== "after";
  }

  function getOuterFunction(path) {
    return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;
  }

  function isExecutionUncertain(type, key) {
    switch (type) {
      case "LogicalExpression":
        return key === "right";

      case "ConditionalExpression":
      case "IfStatement":
        return key === "consequent" || key === "alternate";

      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return key === "body";

      case "ForStatement":
        return key === "body" || key === "update";

      case "SwitchStatement":
        return key === "cases";

      case "TryStatement":
        return key === "handler";

      case "AssignmentPattern":
        return key === "right";

      case "OptionalMemberExpression":
        return key === "property";

      case "OptionalCallExpression":
        return key === "arguments";

      default:
        return false;
    }
  }

  function isExecutionUncertainInList(paths, maxIndex) {
    for (var i = 0; i < maxIndex; i++) {
      var path = paths[i];

      if (isExecutionUncertain(path.parent.type, path.parentKey)) {
        return true;
      }
    }

    return false;
  }

  function _guessExecutionStatusRelativeTo(target) {
    var funcParent = {
      "this": getOuterFunction(this),
      target: getOuterFunction(target)
    };

    if (funcParent.target.node !== funcParent["this"].node) {
      return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);
    }

    var paths = {
      target: target.getAncestry(),
      "this": this.getAncestry()
    };
    if (paths.target.indexOf(this) >= 0) return "after";
    if (paths["this"].indexOf(target) >= 0) return "before";
    var commonPath;
    var commonIndex = {
      target: 0,
      "this": 0
    };

    while (!commonPath && commonIndex["this"] < paths["this"].length) {
      var path = paths["this"][commonIndex["this"]];
      commonIndex.target = paths.target.indexOf(path);

      if (commonIndex.target >= 0) {
        commonPath = path;
      } else {
        commonIndex["this"]++;
      }
    }

    if (!commonPath) {
      throw new Error("Internal Babel error - The two compared nodes" + " don't appear to belong to the same program.");
    }

    if (isExecutionUncertainInList(paths["this"], commonIndex["this"] - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
      return "unknown";
    }

    var divergence = {
      "this": paths["this"][commonIndex["this"] - 1],
      target: paths.target[commonIndex.target - 1]
    };

    if (divergence.target.listKey && divergence["this"].listKey && divergence.target.container === divergence["this"].container) {
      return divergence.target.key > divergence["this"].key ? "before" : "after";
    }

    var keys = VISITOR_KEYS[commonPath.type];
    var keyPosition = {
      "this": keys.indexOf(divergence["this"].parentKey),
      target: keys.indexOf(divergence.target.parentKey)
    };
    return keyPosition.target > keyPosition["this"] ? "before" : "after";
  }
  var executionOrderCheckedNodes = new WeakSet();
  function _guessExecutionStatusRelativeToDifferentFunctions(target) {
    if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {
      return "unknown";
    }

    var binding = target.scope.getBinding(target.node.id.name);
    if (!binding.references) return "before";
    var referencePaths = binding.referencePaths;
    var allStatus;

    for (var _iterator = referencePaths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var path = _ref;
      var childOfFunction = !!path.find(function (path) {
        return path.node === target.node;
      });
      if (childOfFunction) continue;

      if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
        return "unknown";
      }

      if (executionOrderCheckedNodes.has(path.node)) continue;
      executionOrderCheckedNodes.add(path.node);

      var status = this._guessExecutionStatusRelativeTo(path);

      executionOrderCheckedNodes["delete"](path.node);

      if (allStatus && allStatus !== status) {
        return "unknown";
      } else {
        allStatus = status;
      }
    }

    return allStatus;
  }
  function resolve(dangerous, resolved) {
    return this._resolve(dangerous, resolved) || this;
  }
  function _resolve(dangerous, resolved) {
    if (resolved && resolved.indexOf(this) >= 0) return;
    resolved = resolved || [];
    resolved.push(this);

    if (this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier()) {
        return this.get("init").resolve(dangerous, resolved);
      }
    } else if (this.isReferencedIdentifier()) {
      var binding = this.scope.getBinding(this.node.name);
      if (!binding) return;
      if (!binding.constant) return;
      if (binding.kind === "module") return;

      if (binding.path !== this) {
        var ret = binding.path.resolve(dangerous, resolved);
        if (this.find(function (parent) {
          return parent.node === ret.node;
        })) return;
        return ret;
      }
    } else if (this.isTypeCastExpression()) {
      return this.get("expression").resolve(dangerous, resolved);
    } else if (dangerous && this.isMemberExpression()) {
      var targetKey = this.toComputedKey();
      if (!isLiteral(targetKey)) return;
      var targetName = targetKey.value;
      var target = this.get("object").resolve(dangerous, resolved);

      if (target.isObjectExpression()) {
        var props = target.get("properties");

        for (var _i2 = 0, _arr = props; _i2 < _arr.length; _i2++) {
          var prop = _arr[_i2];
          if (!prop.isProperty()) continue;
          var key = prop.get("key");
          var match = prop.isnt("computed") && key.isIdentifier({
            name: targetName
          });
          match = match || key.isLiteral({
            value: targetName
          });
          if (match) return prop.get("value").resolve(dangerous, resolved);
        }
      } else if (target.isArrayExpression() && !isNaN(+targetName)) {
        var elems = target.get("elements");
        var elem = elems[targetName];
        if (elem) return elem.resolve(dangerous, resolved);
      }
    }
  }
  function isConstantExpression() {
    if (this.isIdentifier()) {
      var binding = this.scope.getBinding(this.node.name);
      if (!binding) return false;
      return binding.constant;
    }

    if (this.isLiteral()) {
      if (this.isRegExpLiteral()) {
        return false;
      }

      if (this.isTemplateLiteral()) {
        return this.get("expressions").every(function (expression) {
          return expression.isConstantExpression();
        });
      }

      return true;
    }

    if (this.isUnaryExpression()) {
      if (this.get("operator").node !== "void") {
        return false;
      }

      return this.get("argument").isConstantExpression();
    }

    if (this.isBinaryExpression()) {
      return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }

    return false;
  }
  function isInStrictMode() {
    var start = this.isProgram() ? this : this.parentPath;
    var strictParent = start.find(function (path) {
      if (path.isProgram({
        sourceType: "module"
      })) return true;
      if (path.isClass()) return true;
      if (!path.isProgram() && !path.isFunction()) return false;

      if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
        return false;
      }

      var node = path.node;
      if (path.isFunction()) node = node.body;

      for (var _iterator2 = node.directives, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i3 >= _iterator2.length) break;
          _ref2 = _iterator2[_i3++];
        } else {
          _i3 = _iterator2.next();
          if (_i3.done) break;
          _ref2 = _i3.value;
        }

        var directive = _ref2;

        if (directive.value.value === "use strict") {
          return true;
        }
      }
    });
    return !!strictParent;
  }

  var NodePath_introspection = /*#__PURE__*/Object.freeze({
    __proto__: null,
    matchesPattern: matchesPattern$1,
    has: has$2,
    isStatic: isStatic,
    is: is$1,
    isnt: isnt,
    equals: equals,
    isNodeType: isNodeType,
    canHaveVariableDeclarationOrExpression: canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: canSwapBetweenExpressionAndStatement,
    isCompletionRecord: isCompletionRecord,
    isStatementOrBlock: isStatementOrBlock,
    referencesImport: referencesImport,
    getSource: getSource,
    willIMaybeExecuteBefore: willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: _guessExecutionStatusRelativeTo,
    _guessExecutionStatusRelativeToDifferentFunctions: _guessExecutionStatusRelativeToDifferentFunctions,
    resolve: resolve,
    _resolve: _resolve,
    isConstantExpression: isConstantExpression,
    isInStrictMode: isInStrictMode
  });

  function call(key) {
    var opts = this.opts;
    this.debug(key);

    if (this.node) {
      if (this._call(opts[key])) return true;
    }

    if (this.node) {
      return this._call(opts[this.node.type] && opts[this.node.type][key]);
    }

    return false;
  }
  function _call(fns) {
    if (!fns) return false;

    for (var _iterator = fns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var fn = _ref;
      if (!fn) continue;
      var node = this.node;
      if (!node) return true;
      var ret = fn.call(this.state, this, this.state);

      if (ret && typeof ret === "object" && typeof ret.then === "function") {
        throw new Error("You appear to be using a plugin with an async traversal visitor, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
      }

      if (ret) {
        throw new Error("Unexpected return value from visitor method " + fn);
      }

      if (this.node !== node) return true;
      if (this._traverseFlags > 0) return true;
    }

    return false;
  }
  function isBlacklisted() {
    var blacklist = this.opts.blacklist;
    return blacklist && blacklist.indexOf(this.node.type) > -1;
  }
  function visit$1() {
    if (!this.node) {
      return false;
    }

    if (this.isBlacklisted()) {
      return false;
    }

    if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
      return false;
    }

    if (this.shouldSkip || this.call("enter") || this.shouldSkip) {
      this.debug("Skip...");
      return this.shouldStop;
    }

    this.debug("Recursing into...");
    traverse$1.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
    this.call("exit");
    return this.shouldStop;
  }
  function skip() {
    this.shouldSkip = true;
  }
  function skipKey(key) {
    if (this.skipKeys == null) {
      this.skipKeys = {};
    }

    this.skipKeys[key] = true;
  }
  function stop() {
    this._traverseFlags |= SHOULD_SKIP | SHOULD_STOP;
  }
  function setScope() {
    if (this.opts && this.opts.noScope) return;
    var path = this.parentPath;
    var target;

    while (path && !target) {
      if (path.opts && path.opts.noScope) return;
      target = path.scope;
      path = path.parentPath;
    }

    this.scope = this.getScope(target);
    if (this.scope) this.scope.init();
  }
  function setContext(context) {
    if (this.skipKeys != null) {
      this.skipKeys = {};
    }

    this._traverseFlags = 0;

    if (context) {
      this.context = context;
      this.state = context.state;
      this.opts = context.opts;
    }

    this.setScope();
    return this;
  }
  function resync() {
    if (this.removed) return;

    this._resyncParent();

    this._resyncList();

    this._resyncKey();
  }
  function _resyncParent() {
    if (this.parentPath) {
      this.parent = this.parentPath.node;
    }
  }
  function _resyncKey() {
    if (!this.container) return;
    if (this.node === this.container[this.key]) return;

    if (Array.isArray(this.container)) {
      for (var i = 0; i < this.container.length; i++) {
        if (this.container[i] === this.node) {
          return this.setKey(i);
        }
      }
    } else {
      for (var _i2 = 0, _Object$keys = Object.keys(this.container); _i2 < _Object$keys.length; _i2++) {
        var key = _Object$keys[_i2];

        if (this.container[key] === this.node) {
          return this.setKey(key);
        }
      }
    }

    this.key = null;
  }
  function _resyncList() {
    if (!this.parent || !this.inList) return;
    var newContainer = this.parent[this.listKey];
    if (this.container === newContainer) return;
    this.container = newContainer || null;
  }
  function _resyncRemoved() {
    if (this.key == null || !this.container || this.container[this.key] !== this.node) {
      this._markRemoved();
    }
  }
  function popContext() {
    this.contexts.pop();

    if (this.contexts.length > 0) {
      this.setContext(this.contexts[this.contexts.length - 1]);
    } else {
      this.setContext(undefined);
    }
  }
  function pushContext(context) {
    this.contexts.push(context);
    this.setContext(context);
  }
  function setup$1(parentPath, container, listKey, key) {
    this.listKey = listKey;
    this.container = container;
    this.parentPath = parentPath || this.parentPath;
    this.setKey(key);
  }
  function setKey(key) {
    this.key = key;
    this.node = this.container[this.key];
    this.type = this.node && this.node.type;
  }
  function requeue(pathToQueue) {
    if (pathToQueue === void 0) {
      pathToQueue = this;
    }

    if (pathToQueue.removed) return;
    var contexts = this.contexts;

    for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i3 >= _iterator2.length) break;
        _ref2 = _iterator2[_i3++];
      } else {
        _i3 = _iterator2.next();
        if (_i3.done) break;
        _ref2 = _i3.value;
      }

      var context = _ref2;
      context.maybeQueue(pathToQueue);
    }
  }
  function _getQueueContexts() {
    var path = this;
    var contexts = this.contexts;

    while (!contexts.length) {
      path = path.parentPath;
      if (!path) break;
      contexts = path.contexts;
    }

    return contexts;
  }

  var NodePath_context = /*#__PURE__*/Object.freeze({
    __proto__: null,
    call: call,
    _call: _call,
    isBlacklisted: isBlacklisted,
    visit: visit$1,
    skip: skip,
    skipKey: skipKey,
    stop: stop,
    setScope: setScope,
    setContext: setContext,
    resync: resync,
    _resyncParent: _resyncParent,
    _resyncKey: _resyncKey,
    _resyncList: _resyncList,
    _resyncRemoved: _resyncRemoved,
    popContext: popContext,
    pushContext: pushContext,
    setup: setup$1,
    setKey: setKey,
    requeue: requeue,
    _getQueueContexts: _getQueueContexts
  });

  var hooks = [function (self, parent) {
    var removeParent = self.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self.key === "declaration" && parent.isExportDeclaration() || self.key === "body" && parent.isLabeledStatement() || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === "expression" && parent.isExpressionStatement();

    if (removeParent) {
      parent.remove();
      return true;
    }
  }, function (self, parent) {
    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
      parent.replaceWith(parent.node.expressions[0]);
      return true;
    }
  }, function (self, parent) {
    if (parent.isBinary()) {
      if (self.key === "left") {
        parent.replaceWith(parent.node.right);
      } else {
        parent.replaceWith(parent.node.left);
      }

      return true;
    }
  }, function (self, parent) {
    if (parent.isIfStatement() && (self.key === "consequent" || self.key === "alternate") || self.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
      self.replaceWith({
        type: "BlockStatement",
        body: []
      });
      return true;
    }
  }];

  function remove() {
    this._assertUnremoved();

    this.resync();

    if (!this.opts || !this.opts.noScope) {
      this._removeFromScope();
    }

    if (this._callRemovalHooks()) {
      this._markRemoved();

      return;
    }

    this.shareCommentsWithSiblings();

    this._remove();

    this._markRemoved();
  }
  function _removeFromScope() {
    var _this = this;

    var bindings = this.getBindingIdentifiers();
    Object.keys(bindings).forEach(function (name) {
      return _this.scope.removeBinding(name);
    });
  }
  function _callRemovalHooks() {
    for (var _i = 0, _arr = hooks; _i < _arr.length; _i++) {
      var fn = _arr[_i];
      if (fn(this, this.parentPath)) return true;
    }
  }
  function _remove() {
    if (Array.isArray(this.container)) {
      this.container.splice(this.key, 1);
      this.updateSiblingKeys(this.key, -1);
    } else {
      this._replaceWith(null);
    }
  }
  function _markRemoved() {
    this._traverseFlags |= SHOULD_SKIP | REMOVED;
    this.node = null;
  }
  function _assertUnremoved() {
    if (this.removed) {
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
    }
  }

  var NodePath_removal = /*#__PURE__*/Object.freeze({
    __proto__: null,
    remove: remove,
    _removeFromScope: _removeFromScope,
    _callRemovalHooks: _callRemovalHooks,
    _remove: _remove,
    _markRemoved: _markRemoved,
    _assertUnremoved: _assertUnremoved
  });

  var referenceVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
        return;
      }

      if (path.node.name === "this") {
        var scope = path.scope;

        do {
          if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
        } while (scope = scope.parent);

        if (scope) state.breakOnScopePaths.push(scope.path);
      }

      var binding = path.scope.getBinding(path.node.name);
      if (!binding) return;

      for (var _iterator = binding.constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var violation = _ref;

        if (violation.scope !== binding.path.scope) {
          state.mutableBinding = true;
          path.stop();
          return;
        }
      }

      if (binding !== state.scope.getBinding(path.node.name)) return;
      state.bindings[path.node.name] = binding;
    }
  };

  var PathHoister = function () {
    function PathHoister(path, scope) {
      this.breakOnScopePaths = [];
      this.bindings = {};
      this.mutableBinding = false;
      this.scopes = [];
      this.scope = scope;
      this.path = path;
      this.attachAfter = false;
    }

    var _proto = PathHoister.prototype;

    _proto.isCompatibleScope = function isCompatibleScope(scope) {
      for (var _i2 = 0, _Object$keys = Object.keys(this.bindings); _i2 < _Object$keys.length; _i2++) {
        var key = _Object$keys[_i2];
        var binding = this.bindings[key];

        if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
          return false;
        }
      }

      return true;
    };

    _proto.getCompatibleScopes = function getCompatibleScopes() {
      var scope = this.path.scope;

      do {
        if (this.isCompatibleScope(scope)) {
          this.scopes.push(scope);
        } else {
          break;
        }

        if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
          break;
        }
      } while (scope = scope.parent);
    };

    _proto.getAttachmentPath = function getAttachmentPath() {
      var path = this._getAttachmentPath();

      if (!path) return;
      var targetScope = path.scope;

      if (targetScope.path === path) {
        targetScope = path.scope.parent;
      }

      if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
        for (var _i3 = 0, _Object$keys2 = Object.keys(this.bindings); _i3 < _Object$keys2.length; _i3++) {
          var name = _Object$keys2[_i3];
          if (!targetScope.hasOwnBinding(name)) continue;
          var binding = this.bindings[name];

          if (binding.kind === "param" || binding.path.parentKey === "params") {
            continue;
          }

          var bindingParentPath = this.getAttachmentParentForPath(binding.path);

          if (bindingParentPath.key >= path.key) {
            this.attachAfter = true;
            path = binding.path;

            for (var _i4 = 0, _arr = binding.constantViolations; _i4 < _arr.length; _i4++) {
              var violationPath = _arr[_i4];

              if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                path = violationPath;
              }
            }
          }
        }
      }

      return path;
    };

    _proto._getAttachmentPath = function _getAttachmentPath() {
      var scopes = this.scopes;
      var scope = scopes.pop();
      if (!scope) return;

      if (scope.path.isFunction()) {
        if (this.hasOwnParamBindings(scope)) {
          if (this.scope === scope) return;
          var bodies = scope.path.get("body").get("body");

          for (var i = 0; i < bodies.length; i++) {
            if (bodies[i].node._blockHoist) continue;
            return bodies[i];
          }
        } else {
          return this.getNextScopeAttachmentParent();
        }
      } else if (scope.path.isProgram()) {
        return this.getNextScopeAttachmentParent();
      }
    };

    _proto.getNextScopeAttachmentParent = function getNextScopeAttachmentParent() {
      var scope = this.scopes.pop();
      if (scope) return this.getAttachmentParentForPath(scope.path);
    };

    _proto.getAttachmentParentForPath = function getAttachmentParentForPath(path) {
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          return path;
        }
      } while (path = path.parentPath);
    };

    _proto.hasOwnParamBindings = function hasOwnParamBindings(scope) {
      for (var _i5 = 0, _Object$keys3 = Object.keys(this.bindings); _i5 < _Object$keys3.length; _i5++) {
        var name = _Object$keys3[_i5];
        if (!scope.hasOwnBinding(name)) continue;
        var binding = this.bindings[name];
        if (binding.kind === "param" && binding.constant) return true;
      }

      return false;
    };

    _proto.run = function run() {
      this.path.traverse(referenceVisitor, this);
      if (this.mutableBinding) return;
      this.getCompatibleScopes();
      var attachTo = this.getAttachmentPath();
      if (!attachTo) return;
      if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
      var uid = attachTo.scope.generateUidIdentifier("ref");
      var declarator = VariableDeclarator(uid, this.path.node);
      var insertFn = this.attachAfter ? "insertAfter" : "insertBefore";

      var _attachTo$insertFn = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : VariableDeclaration("var", [declarator])]),
          attached = _attachTo$insertFn[0];

      var parent = this.path.parentPath;

      if (parent.isJSXElement() && this.path.container === parent.node.children) {
        uid = JSXExpressionContainer(uid);
      }

      this.path.replaceWith(cloneNode(uid));
      return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
    };

    return PathHoister;
  }();

  function insertBefore(nodes) {
    this._assertUnremoved();

    nodes = this._verifyNodeList(nodes);
    var parentPath = this.parentPath;

    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertBefore(nodes);
    } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node) nodes.push(this.node);
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return this._containerInsertBefore(nodes);
    } else if (this.isStatementOrBlock()) {
      var shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);
      this.replaceWith(BlockStatement(shouldInsertCurrentNode ? [this.node] : []));
      return this.unshiftContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }
  function _containerInsert(from, nodes) {
    var _this$container;

    this.updateSiblingKeys(from, nodes.length);
    var paths = [];

    (_this$container = this.container).splice.apply(_this$container, [from, 0].concat(nodes));

    for (var i = 0; i < nodes.length; i++) {
      var to = from + i;
      var path = this.getSibling(to);
      paths.push(path);

      if (this.context && this.context.queue) {
        path.pushContext(this.context);
      }
    }

    var contexts = this._getQueueContexts();

    for (var _i = 0, _paths = paths; _i < _paths.length; _i++) {
      var _path = _paths[_i];

      _path.setScope();

      _path.debug("Inserted.");

      for (var _iterator = contexts, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i2 >= _iterator.length) break;
          _ref = _iterator[_i2++];
        } else {
          _i2 = _iterator.next();
          if (_i2.done) break;
          _ref = _i2.value;
        }

        var context = _ref;
        context.maybeQueue(_path, true);
      }
    }

    return paths;
  }
  function _containerInsertBefore(nodes) {
    return this._containerInsert(this.key, nodes);
  }
  function _containerInsertAfter(nodes) {
    return this._containerInsert(this.key + 1, nodes);
  }
  function insertAfter(nodes) {
    this._assertUnremoved();

    nodes = this._verifyNodeList(nodes);
    var parentPath = this.parentPath;

    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertAfter(nodes.map(function (node) {
        return isExpression(node) ? ExpressionStatement(node) : node;
      }));
    } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node) {
        var scope = this.scope;

        if (parentPath.isMethod({
          computed: true,
          key: this.node
        })) {
          scope = scope.parent;
        }

        var temp = scope.generateDeclaredUidIdentifier();
        nodes.unshift(ExpressionStatement(AssignmentExpression("=", cloneNode(temp), this.node)));
        nodes.push(ExpressionStatement(cloneNode(temp)));
      }

      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return this._containerInsertAfter(nodes);
    } else if (this.isStatementOrBlock()) {
      var shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);
      this.replaceWith(BlockStatement(shouldInsertCurrentNode ? [this.node] : []));
      return this.pushContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }
  function updateSiblingKeys(fromIndex, incrementBy) {
    if (!this.parent) return;
    var paths = path.get(this.parent);

    for (var i = 0; i < paths.length; i++) {
      var path$1 = paths[i];

      if (path$1.key >= fromIndex) {
        path$1.key += incrementBy;
      }
    }
  }
  function _verifyNodeList(nodes) {
    if (!nodes) {
      return [];
    }

    if (nodes.constructor !== Array) {
      nodes = [nodes];
    }

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var msg = void 0;

      if (!node) {
        msg = "has falsy node";
      } else if (typeof node !== "object") {
        msg = "contains a non-object node";
      } else if (!node.type) {
        msg = "without a type";
      } else if (node instanceof NodePath) {
        msg = "has a NodePath when it expected a raw object";
      }

      if (msg) {
        var type = Array.isArray(node) ? "array" : typeof node;
        throw new Error("Node list " + msg + " with the index of " + i + " and type of " + type);
      }
    }

    return nodes;
  }
  function unshiftContainer(listKey, nodes) {
    this._assertUnremoved();

    nodes = this._verifyNodeList(nodes);
    var path = NodePath.get({
      parentPath: this,
      parent: this.node,
      container: this.node[listKey],
      listKey: listKey,
      key: 0
    });
    return path._containerInsertBefore(nodes);
  }
  function pushContainer(listKey, nodes) {
    this._assertUnremoved();

    nodes = this._verifyNodeList(nodes);
    var container = this.node[listKey];
    var path = NodePath.get({
      parentPath: this,
      parent: this.node,
      container: container,
      listKey: listKey,
      key: container.length
    });
    return path.replaceWithMultiple(nodes);
  }
  function hoist(scope) {
    if (scope === void 0) {
      scope = this.scope;
    }

    var hoister = new PathHoister(this, scope);
    return hoister.run();
  }

  var NodePath_modification = /*#__PURE__*/Object.freeze({
    __proto__: null,
    insertBefore: insertBefore,
    _containerInsert: _containerInsert,
    _containerInsertBefore: _containerInsertBefore,
    _containerInsertAfter: _containerInsertAfter,
    insertAfter: insertAfter,
    updateSiblingKeys: updateSiblingKeys,
    _verifyNodeList: _verifyNodeList,
    unshiftContainer: unshiftContainer,
    pushContainer: pushContainer,
    hoist: hoist
  });

  function getOpposite() {
    if (this.key === "left") {
      return this.getSibling("right");
    } else if (this.key === "right") {
      return this.getSibling("left");
    }
  }

  function addCompletionRecords(path, paths) {
    if (path) return paths.concat(path.getCompletionRecords());
    return paths;
  }

  function completionRecordForSwitch(cases, paths) {
    var isLastCaseWithConsequent = true;

    for (var i = cases.length - 1; i >= 0; i--) {
      var switchCase = cases[i];
      var consequent = switchCase.get("consequent");
      var breakStatement = void 0;

      findBreak: for (var _iterator = consequent, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var statement = _ref;

        if (statement.isBlockStatement()) {
          for (var _iterator2 = statement.get("body"), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray2) {
              if (_i2 >= _iterator2.length) break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done) break;
              _ref2 = _i2.value;
            }

            var statementInBlock = _ref2;

            if (statementInBlock.isBreakStatement()) {
              breakStatement = statementInBlock;
              break findBreak;
            }
          }
        } else if (statement.isBreakStatement()) {
          breakStatement = statement;
          break;
        }
      }

      if (breakStatement) {
        while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {
          breakStatement = breakStatement.parentPath;
        }

        var prevSibling = breakStatement.getPrevSibling();

        if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {
          paths = addCompletionRecords(prevSibling, paths);
          breakStatement.remove();
        } else {
          breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());
          paths = addCompletionRecords(breakStatement, paths);
        }
      } else if (isLastCaseWithConsequent) {
        (function () {
          var statementFinder = function statementFinder(statement) {
            return !statement.isBlockStatement() || statement.get("body").some(statementFinder);
          };

          var hasConsequent = consequent.some(statementFinder);

          if (hasConsequent) {
            paths = addCompletionRecords(consequent[consequent.length - 1], paths);
            isLastCaseWithConsequent = false;
          }
        })();
      }
    }

    return paths;
  }

  function getCompletionRecords() {
    var paths = [];

    if (this.isIfStatement()) {
      paths = addCompletionRecords(this.get("consequent"), paths);
      paths = addCompletionRecords(this.get("alternate"), paths);
    } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
      paths = addCompletionRecords(this.get("body"), paths);
    } else if (this.isProgram() || this.isBlockStatement()) {
      paths = addCompletionRecords(this.get("body").pop(), paths);
    } else if (this.isFunction()) {
      return this.get("body").getCompletionRecords();
    } else if (this.isTryStatement()) {
      paths = addCompletionRecords(this.get("block"), paths);
      paths = addCompletionRecords(this.get("handler"), paths);
    } else if (this.isCatchClause()) {
      paths = addCompletionRecords(this.get("body"), paths);
    } else if (this.isSwitchStatement()) {
      paths = completionRecordForSwitch(this.get("cases"), paths);
    } else {
      paths.push(this);
    }

    return paths;
  }
  function getSibling(key) {
    return NodePath.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: key
    });
  }
  function getPrevSibling() {
    return this.getSibling(this.key - 1);
  }
  function getNextSibling() {
    return this.getSibling(this.key + 1);
  }
  function getAllNextSiblings() {
    var _key = this.key;
    var sibling = this.getSibling(++_key);
    var siblings = [];

    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(++_key);
    }

    return siblings;
  }
  function getAllPrevSiblings() {
    var _key = this.key;
    var sibling = this.getSibling(--_key);
    var siblings = [];

    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(--_key);
    }

    return siblings;
  }
  function get(key, context) {
    if (context === true) context = this.context;
    var parts = key.split(".");

    if (parts.length === 1) {
      return this._getKey(key, context);
    } else {
      return this._getPattern(parts, context);
    }
  }
  function _getKey(key, context) {
    var _this = this;

    var node = this.node;
    var container = node[key];

    if (Array.isArray(container)) {
      return container.map(function (_, i) {
        return NodePath.get({
          listKey: key,
          parentPath: _this,
          parent: node,
          container: container,
          key: i
        }).setContext(context);
      });
    } else {
      return NodePath.get({
        parentPath: this,
        parent: node,
        container: node,
        key: key
      }).setContext(context);
    }
  }
  function _getPattern(parts, context) {
    var path = this;

    for (var _iterator3 = parts, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var part = _ref3;

      if (part === ".") {
        path = path.parentPath;
      } else {
        if (Array.isArray(path)) {
          path = path[part];
        } else {
          path = path.get(part, context);
        }
      }
    }

    return path;
  }
  function getBindingIdentifiers$1(duplicates) {
    return getBindingIdentifiers(this.node, duplicates);
  }
  function getOuterBindingIdentifiers$1(duplicates) {
    return getOuterBindingIdentifiers(this.node, duplicates);
  }
  function getBindingIdentifierPaths(duplicates, outerOnly) {
    if (duplicates === void 0) {
      duplicates = false;
    }

    if (outerOnly === void 0) {
      outerOnly = false;
    }

    var path = this;
    var search = [].concat(path);
    var ids = Object.create(null);

    while (search.length) {
      var id = search.shift();
      if (!id) continue;
      if (!id.node) continue;
      var keys = getBindingIdentifiers.keys[id.node.type];

      if (id.isIdentifier()) {
        if (duplicates) {
          var _ids = ids[id.node.name] = ids[id.node.name] || [];

          _ids.push(id);
        } else {
          ids[id.node.name] = id;
        }

        continue;
      }

      if (id.isExportDeclaration()) {
        var declaration = id.get("declaration");

        if (declaration.isDeclaration()) {
          search.push(declaration);
        }

        continue;
      }

      if (outerOnly) {
        if (id.isFunctionDeclaration()) {
          search.push(id.get("id"));
          continue;
        }

        if (id.isFunctionExpression()) {
          continue;
        }
      }

      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var child = id.get(key);

          if (Array.isArray(child) || child.node) {
            search = search.concat(child);
          }
        }
      }
    }

    return ids;
  }
  function getOuterBindingIdentifierPaths(duplicates) {
    return this.getBindingIdentifierPaths(duplicates, true);
  }

  var NodePath_family = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getOpposite: getOpposite,
    getCompletionRecords: getCompletionRecords,
    getSibling: getSibling,
    getPrevSibling: getPrevSibling,
    getNextSibling: getNextSibling,
    getAllNextSiblings: getAllNextSiblings,
    getAllPrevSiblings: getAllPrevSiblings,
    get: get,
    _getKey: _getKey,
    _getPattern: _getPattern,
    getBindingIdentifiers: getBindingIdentifiers$1,
    getOuterBindingIdentifiers: getOuterBindingIdentifiers$1,
    getBindingIdentifierPaths: getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: getOuterBindingIdentifierPaths
  });

  function shareCommentsWithSiblings() {
    if (typeof this.key === "string") return;
    var node = this.node;
    if (!node) return;
    var trailing = node.trailingComments;
    var leading = node.leadingComments;
    if (!trailing && !leading) return;
    var prev = this.getSibling(this.key - 1);
    var next = this.getSibling(this.key + 1);
    var hasPrev = Boolean(prev.node);
    var hasNext = Boolean(next.node);

    if (hasPrev && !hasNext) {
      prev.addComments("trailing", trailing);
    } else if (hasNext && !hasPrev) {
      next.addComments("leading", leading);
    }
  }
  function addComment$1(type, content, line) {
    addComment(this.node, type, content, line);
  }
  function addComments$1(type, comments) {
    addComments(this.node, type, comments);
  }

  var NodePath_comments = /*#__PURE__*/Object.freeze({
    __proto__: null,
    shareCommentsWithSiblings: shareCommentsWithSiblings,
    addComment: addComment$1,
    addComments: addComments$1
  });

  var _debug = browser$1("babel");

  var REMOVED = 1 << 0;
  var SHOULD_STOP = 1 << 1;
  var SHOULD_SKIP = 1 << 2;

  var NodePath = function () {
    function NodePath(hub, parent) {
      this.parent = parent;
      this.hub = hub;
      this.contexts = [];
      this.data = null;
      this._traverseFlags = 0;
      this.state = null;
      this.opts = null;
      this.skipKeys = null;
      this.parentPath = null;
      this.context = null;
      this.container = null;
      this.listKey = null;
      this.key = null;
      this.node = null;
      this.scope = null;
      this.type = null;
    }

    NodePath.get = function get(_ref) {
      var hub = _ref.hub,
          parentPath = _ref.parentPath,
          parent = _ref.parent,
          container = _ref.container,
          listKey = _ref.listKey,
          key = _ref.key;

      if (!hub && parentPath) {
        hub = parentPath.hub;
      }

      if (!parent) {
        throw new Error("To get a node path the parent needs to exist");
      }

      var targetNode = container[key];
      var paths = path.get(parent) || [];

      if (!path.has(parent)) {
        path.set(parent, paths);
      }

      var path$1;

      for (var i = 0; i < paths.length; i++) {
        var pathCheck = paths[i];

        if (pathCheck.node === targetNode) {
          path$1 = pathCheck;
          break;
        }
      }

      if (!path$1) {
        path$1 = new NodePath(hub, parent);
        paths.push(path$1);
      }

      path$1.setup(parentPath, container, listKey, key);
      return path$1;
    };

    var _proto = NodePath.prototype;

    _proto.getScope = function getScope(scope) {
      return this.isScope() ? new Scope$1(this) : scope;
    };

    _proto.setData = function setData(key, val) {
      if (this.data == null) {
        this.data = Object.create(null);
      }

      return this.data[key] = val;
    };

    _proto.getData = function getData(key, def) {
      if (this.data == null) {
        this.data = Object.create(null);
      }

      var val = this.data[key];
      if (val === undefined && def !== undefined) val = this.data[key] = def;
      return val;
    };

    _proto.buildCodeFrameError = function buildCodeFrameError(msg, Error) {
      if (Error === void 0) {
        Error = SyntaxError;
      }

      return this.hub.buildError(this.node, msg, Error);
    };

    _proto.traverse = function traverse(visitor, state) {
      traverse$1(this.node, visitor, this.scope, state, this);
    };

    _proto.set = function set(key, node) {
      validate(this.node, key, node);
      this.node[key] = node;
    };

    _proto.getPathLocation = function getPathLocation() {
      var parts = [];
      var path = this;

      do {
        var key = path.key;
        if (path.inList) key = path.listKey + "[" + key + "]";
        parts.unshift(key);
      } while (path = path.parentPath);

      return parts.join(".");
    };

    _proto.debug = function debug(message) {
      if (!_debug.enabled) return;

      _debug(this.getPathLocation() + " " + this.type + ": " + message);
    };

    _proto.toString = function toString() {
      return generateCode(this.node).code;
    };

    _createClass(NodePath, [{
      key: "inList",
      get: function get() {
        return !!this.listKey;
      },
      set: function set(inList) {
        if (!inList) {
          this.listKey = null;
        }
      }
    }, {
      key: "parentKey",
      get: function get() {
        return this.listKey || this.key;
      }
    }, {
      key: "shouldSkip",
      get: function get() {
        return !!(this._traverseFlags & SHOULD_SKIP);
      },
      set: function set(v) {
        if (v) {
          this._traverseFlags |= SHOULD_SKIP;
        } else {
          this._traverseFlags &= ~SHOULD_SKIP;
        }
      }
    }, {
      key: "shouldStop",
      get: function get() {
        return !!(this._traverseFlags & SHOULD_STOP);
      },
      set: function set(v) {
        if (v) {
          this._traverseFlags |= SHOULD_STOP;
        } else {
          this._traverseFlags &= ~SHOULD_STOP;
        }
      }
    }, {
      key: "removed",
      get: function get() {
        return !!(this._traverseFlags & REMOVED);
      },
      set: function set(v) {
        if (v) {
          this._traverseFlags |= REMOVED;
        } else {
          this._traverseFlags &= ~REMOVED;
        }
      }
    }]);

    return NodePath;
  }();
  Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);

  var _loop = function _loop() {
    var type = _arr[_i$2];
    var typeKey = "is" + type;
    var fn = t[typeKey];

    NodePath.prototype[typeKey] = function (opts) {
      return fn(this.node, opts);
    };

    NodePath.prototype["assert" + type] = function (opts) {
      if (!fn(this.node, opts)) {
        throw new TypeError("Expected node path of type " + type);
      }
    };
  };

  for (var _i$2 = 0, _arr = TYPES; _i$2 < _arr.length; _i$2++) {
    _loop();
  }

  var _loop2 = function _loop2() {
    var type = _Object$keys[_i2];
    if (type[0] === "_") return "continue";
    if (TYPES.indexOf(type) < 0) TYPES.push(type);
    var virtualType = virtualTypes[type];

    NodePath.prototype["is" + type] = function (opts) {
      return virtualType.checkPath(this, opts);
    };
  };

  for (var _i2 = 0, _Object$keys = Object.keys(virtualTypes); _i2 < _Object$keys.length; _i2++) {
    var _ret = _loop2();

    if (_ret === "continue") continue;
  }

  var TraversalContext = function () {
    function TraversalContext(scope, opts, state, parentPath) {
      this.queue = null;
      this.parentPath = parentPath;
      this.scope = scope;
      this.state = state;
      this.opts = opts;
    }

    var _proto = TraversalContext.prototype;

    _proto.shouldVisit = function shouldVisit(node) {
      var opts = this.opts;
      if (opts.enter || opts.exit) return true;
      if (opts[node.type]) return true;
      var keys = VISITOR_KEYS[node.type];
      if (!keys || !keys.length) return false;

      for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var key = _ref;
        if (node[key]) return true;
      }

      return false;
    };

    _proto.create = function create(node, obj, key, listKey) {
      return NodePath.get({
        parentPath: this.parentPath,
        parent: node,
        container: obj,
        key: key,
        listKey: listKey
      });
    };

    _proto.maybeQueue = function maybeQueue(path, notPriority) {
      if (this.trap) {
        throw new Error("Infinite cycle detected");
      }

      if (this.queue) {
        if (notPriority) {
          this.queue.push(path);
        } else {
          this.priorityQueue.push(path);
        }
      }
    };

    _proto.visitMultiple = function visitMultiple(container, parent, listKey) {
      if (container.length === 0) return false;
      var queue = [];

      for (var key = 0; key < container.length; key++) {
        var node = container[key];

        if (node && this.shouldVisit(node)) {
          queue.push(this.create(parent, container, key, listKey));
        }
      }

      return this.visitQueue(queue);
    };

    _proto.visitSingle = function visitSingle(node, key) {
      if (this.shouldVisit(node[key])) {
        return this.visitQueue([this.create(node, node, key)]);
      } else {
        return false;
      }
    };

    _proto.visitQueue = function visitQueue(queue) {
      this.queue = queue;
      this.priorityQueue = [];
      var visited = [];
      var stop = false;

      for (var _iterator2 = queue, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var path = _ref2;
        path.resync();

        if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
          path.pushContext(this);
        }

        if (path.key === null) continue;

        if (visited.indexOf(path.node) >= 0) continue;
        visited.push(path.node);

        if (path.visit()) {
          stop = true;
          break;
        }

        if (this.priorityQueue.length) {
          stop = this.visitQueue(this.priorityQueue);
          this.priorityQueue = [];
          this.queue = queue;
          if (stop) break;
        }
      }

      for (var _iterator3 = queue, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var _path = _ref3;

        _path.popContext();
      }

      this.queue = null;
      return stop;
    };

    _proto.visit = function visit(node, key) {
      var nodes = node[key];
      if (!nodes) return false;

      if (Array.isArray(nodes)) {
        return this.visitMultiple(nodes, node, key);
      } else {
        return this.visitSingle(node, key);
      }
    };

    return TraversalContext;
  }();

  function explode(visitor) {
    if (visitor._exploded) return visitor;
    visitor._exploded = true;

    for (var _i = 0, _Object$keys = Object.keys(visitor); _i < _Object$keys.length; _i++) {
      var nodeType = _Object$keys[_i];
      if (shouldIgnoreKey(nodeType)) continue;
      var parts = nodeType.split("|");
      if (parts.length === 1) continue;
      var fns = visitor[nodeType];
      delete visitor[nodeType];

      for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i5 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i5 >= _iterator.length) break;
          _ref = _iterator[_i5++];
        } else {
          _i5 = _iterator.next();
          if (_i5.done) break;
          _ref = _i5.value;
        }

        var part = _ref;
        visitor[part] = fns;
      }
    }

    verify(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);

    for (var _i2 = 0, _arr = Object.keys(visitor); _i2 < _arr.length; _i2++) {
      var _nodeType = _arr[_i2];
      if (shouldIgnoreKey(_nodeType)) continue;
      var wrapper = virtualTypes[_nodeType];
      if (!wrapper) continue;
      var _fns = visitor[_nodeType];

      for (var _i6 = 0, _Object$keys4 = Object.keys(_fns); _i6 < _Object$keys4.length; _i6++) {
        var _type = _Object$keys4[_i6];
        _fns[_type] = wrapCheck(wrapper, _fns[_type]);
      }

      delete visitor[_nodeType];

      if (wrapper.types) {
        for (var _i7 = 0, _arr2 = wrapper.types; _i7 < _arr2.length; _i7++) {
          var type = _arr2[_i7];

          if (visitor[type]) {
            mergePair(visitor[type], _fns);
          } else {
            visitor[type] = _fns;
          }
        }
      } else {
        mergePair(visitor, _fns);
      }
    }

    for (var _i3 = 0, _Object$keys2 = Object.keys(visitor); _i3 < _Object$keys2.length; _i3++) {
      var _nodeType2 = _Object$keys2[_i3];
      if (shouldIgnoreKey(_nodeType2)) continue;
      var _fns2 = visitor[_nodeType2];
      var aliases = FLIPPED_ALIAS_KEYS[_nodeType2];
      var deprecratedKey = DEPRECATED_KEYS[_nodeType2];

      if (deprecratedKey) {
        console.trace("Visitor defined for " + _nodeType2 + " but it has been renamed to " + deprecratedKey);
        aliases = [deprecratedKey];
      }

      if (!aliases) continue;
      delete visitor[_nodeType2];

      for (var _iterator2 = aliases, _isArray2 = Array.isArray(_iterator2), _i8 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i8 >= _iterator2.length) break;
          _ref2 = _iterator2[_i8++];
        } else {
          _i8 = _iterator2.next();
          if (_i8.done) break;
          _ref2 = _i8.value;
        }

        var alias = _ref2;
        var existing = visitor[alias];

        if (existing) {
          mergePair(existing, _fns2);
        } else {
          visitor[alias] = clone_1(_fns2);
        }
      }
    }

    for (var _i4 = 0, _Object$keys3 = Object.keys(visitor); _i4 < _Object$keys3.length; _i4++) {
      var _nodeType3 = _Object$keys3[_i4];
      if (shouldIgnoreKey(_nodeType3)) continue;
      ensureCallbackArrays(visitor[_nodeType3]);
    }

    return visitor;
  }
  function verify(visitor) {
    if (visitor._verified) return;

    if (typeof visitor === "function") {
      throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
    }

    for (var _i9 = 0, _Object$keys5 = Object.keys(visitor); _i9 < _Object$keys5.length; _i9++) {
      var nodeType = _Object$keys5[_i9];

      if (nodeType === "enter" || nodeType === "exit") {
        validateVisitorMethods(nodeType, visitor[nodeType]);
      }

      if (shouldIgnoreKey(nodeType)) continue;

      if (TYPES.indexOf(nodeType) < 0) {
        throw new Error("You gave us a visitor for the node type " + nodeType + " but it's not a valid type");
      }

      var visitors = visitor[nodeType];

      if (typeof visitors === "object") {
        for (var _i10 = 0, _Object$keys6 = Object.keys(visitors); _i10 < _Object$keys6.length; _i10++) {
          var visitorKey = _Object$keys6[_i10];

          if (visitorKey === "enter" || visitorKey === "exit") {
            validateVisitorMethods(nodeType + "." + visitorKey, visitors[visitorKey]);
          } else {
            throw new Error("You passed `traverse()` a visitor object with the property " + (nodeType + " that has the invalid property " + visitorKey));
          }
        }
      }
    }

    visitor._verified = true;
  }

  function validateVisitorMethods(path, val) {
    var fns = [].concat(val);

    for (var _iterator3 = fns, _isArray3 = Array.isArray(_iterator3), _i11 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i11 >= _iterator3.length) break;
        _ref3 = _iterator3[_i11++];
      } else {
        _i11 = _iterator3.next();
        if (_i11.done) break;
        _ref3 = _i11.value;
      }

      var fn = _ref3;

      if (typeof fn !== "function") {
        throw new TypeError("Non-function found defined in " + path + " with type " + typeof fn);
      }
    }
  }

  function merge$1(visitors, states, wrapper) {
    if (states === void 0) {
      states = [];
    }

    var rootVisitor = {};

    for (var i = 0; i < visitors.length; i++) {
      var visitor = visitors[i];
      var state = states[i];
      explode(visitor);

      for (var _i12 = 0, _Object$keys7 = Object.keys(visitor); _i12 < _Object$keys7.length; _i12++) {
        var type = _Object$keys7[_i12];
        var visitorType = visitor[type];

        if (state || wrapper) {
          visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
        }

        var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
        mergePair(nodeVisitor, visitorType);
      }
    }

    return rootVisitor;
  }

  function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    var newVisitor = {};

    var _loop = function _loop() {
      var key = _Object$keys8[_i13];
      var fns = oldVisitor[key];
      if (!Array.isArray(fns)) return "continue";
      fns = fns.map(function (fn) {
        var newFn = fn;

        if (state) {
          newFn = function newFn(path) {
            return fn.call(state, path, state);
          };
        }

        if (wrapper) {
          newFn = wrapper(state.key, key, newFn);
        }

        if (newFn !== fn) {
          newFn.toString = function () {
            return fn.toString();
          };
        }

        return newFn;
      });
      newVisitor[key] = fns;
    };

    for (var _i13 = 0, _Object$keys8 = Object.keys(oldVisitor); _i13 < _Object$keys8.length; _i13++) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }

    return newVisitor;
  }

  function ensureEntranceObjects(obj) {
    for (var _i14 = 0, _Object$keys9 = Object.keys(obj); _i14 < _Object$keys9.length; _i14++) {
      var key = _Object$keys9[_i14];
      if (shouldIgnoreKey(key)) continue;
      var fns = obj[key];

      if (typeof fns === "function") {
        obj[key] = {
          enter: fns
        };
      }
    }
  }

  function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
    if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
  }

  function wrapCheck(wrapper, fn) {
    var newFn = function newFn(path) {
      if (wrapper.checkPath(path)) {
        return fn.apply(this, arguments);
      }
    };

    newFn.toString = function () {
      return fn.toString();
    };

    return newFn;
  }

  function shouldIgnoreKey(key) {
    if (key[0] === "_") return true;
    if (key === "enter" || key === "exit" || key === "shouldSkip") return true;

    if (key === "blacklist" || key === "noScope" || key === "skipKeys") {
      return true;
    }

    return false;
  }

  function mergePair(dest, src) {
    for (var _i15 = 0, _Object$keys10 = Object.keys(src); _i15 < _Object$keys10.length; _i15++) {
      var key = _Object$keys10[_i15];
      dest[key] = [].concat(dest[key] || [], src[key]);
    }
  }

  var visitors = /*#__PURE__*/Object.freeze({
    __proto__: null,
    explode: explode,
    verify: verify,
    merge: merge$1
  });

  function traverse$1(parent, opts, scope, state, parentPath) {
    if (!parent) return;
    if (!opts) opts = {};

    if (!opts.noScope && !scope) {
      if (parent.type !== "Program" && parent.type !== "File") {
        throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + ("Instead of that you tried to traverse a " + parent.type + " node without ") + "passing scope and parentPath.");
      }
    }

    if (!VISITOR_KEYS[parent.type]) {
      return;
    }

    explode(opts);
    traverse$1.node(parent, opts, scope, state, parentPath);
  }
  traverse$1.visitors = visitors;
  traverse$1.verify = verify;
  traverse$1.explode = explode;

  traverse$1.cheap = function (node, enter) {
    return traverseFast(node, enter);
  };

  traverse$1.node = function (node, opts, scope, state, parentPath, skipKeys) {
    var keys = VISITOR_KEYS[node.type];
    if (!keys) return;
    var context = new TraversalContext(scope, opts, state, parentPath);

    for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var key = _ref;
      if (skipKeys && skipKeys[key]) continue;
      if (context.visit(node, key)) return;
    }
  };

  traverse$1.clearNode = function (node, opts) {
    removeProperties(node, opts);
    path["delete"](node);
  };

  traverse$1.removeProperties = function (tree, opts) {
    traverseFast(tree, traverse$1.clearNode, opts);
    return tree;
  };

  function hasBlacklistedType(path, state) {
    if (path.node.type === state.type) {
      state.has = true;
      path.stop();
    }
  }

  traverse$1.hasType = function (tree, type, blacklistTypes) {
    if (includes_1(blacklistTypes, tree.type)) return false;
    if (tree.type === type) return true;
    var state = {
      has: false,
      type: type
    };
    traverse$1(tree, {
      noScope: true,
      blacklist: blacklistTypes,
      enter: hasBlacklistedType
    }, null, state);
    return state.has;
  };

  traverse$1.cache = cache;

  function _templateObject79() {
    var data = _taggedTemplateLiteralLoose(["\n  import wrapNativeSuper from \"wrapNativeSuper\";\n  import getPrototypeOf from \"getPrototypeOf\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n  import inherits from \"inherits\";\n\n  export default function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, undefined, groups);\n    };\n\n    var _RegExp = wrapNativeSuper(RegExp);\n    var _super = RegExp.prototype;\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, flags, groups) {\n      var _this = _RegExp.call(this, re, flags);\n      // if the regex is recreated with 'g' flag\n      _groups.set(_this, groups || _groups.get(re));\n      return _this;\n    }\n    inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === \"string\") {\n        var groups = _groups.get(this);\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n            return \"$\" + groups[name];\n          })\n        );\n      } else if (typeof substitution === \"function\") {\n        var _this = this;\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          function() {\n            var args = [];\n            args.push.apply(args, arguments);\n            if (typeof args[args.length - 1] !== \"object\") {\n              // Modern engines already pass result.groups as the last arg.\n              args.push(buildGroups(args, _this));\n            }\n            return substitution.apply(this, args);\n          }\n        );\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    }\n\n    function buildGroups(result, re) {\n      // NOTE: This function should return undefined if there are no groups,\n      // but in that case Babel doesn't add the wrapper anyway.\n\n      var g = _groups.get(re);\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n"], ["\n  import wrapNativeSuper from \"wrapNativeSuper\";\n  import getPrototypeOf from \"getPrototypeOf\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n  import inherits from \"inherits\";\n\n  export default function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, undefined, groups);\n    };\n\n    var _RegExp = wrapNativeSuper(RegExp);\n    var _super = RegExp.prototype;\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, flags, groups) {\n      var _this = _RegExp.call(this, re, flags);\n      // if the regex is recreated with 'g' flag\n      _groups.set(_this, groups || _groups.get(re));\n      return _this;\n    }\n    inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === \"string\") {\n        var groups = _groups.get(this);\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\\\$<([^>]+)>/g, function(_, name) {\n            return \"$\" + groups[name];\n          })\n        );\n      } else if (typeof substitution === \"function\") {\n        var _this = this;\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          function() {\n            var args = [];\n            args.push.apply(args, arguments);\n            if (typeof args[args.length - 1] !== \"object\") {\n              // Modern engines already pass result.groups as the last arg.\n              args.push(buildGroups(args, _this));\n            }\n            return substitution.apply(this, args);\n          }\n        );\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    }\n\n    function buildGroups(result, re) {\n      // NOTE: This function should return undefined if there are no groups,\n      // but in that case Babel doesn't add the wrapper anyway.\n\n      var g = _groups.get(re);\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n"]);

    _templateObject79 = function _templateObject79() {
      return data;
    };

    return data;
  }

  function _templateObject78() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateMethodSet() {\n    throw new TypeError(\"attempted to reassign private method\");\n  }\n"]);

    _templateObject78 = function _templateObject78() {
      return data;
    };

    return data;
  }

  function _templateObject77() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return fn;\n  }\n"]);

    _templateObject77 = function _templateObject77() {
      return data;
    };

    return data;
  }

  function _templateObject76() {
    var data = _taggedTemplateLiteralLoose(["\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n"], ["\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n"]);

    _templateObject76 = function _templateObject76() {
      return data;
    };

    return data;
  }

  function _templateObject75() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateMethodSet() {\n    throw new TypeError(\"attempted to set read only static private field\");\n  }\n"]);

    _templateObject75 = function _templateObject75() {
      return data;
    };

    return data;
  }

  function _templateObject74() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    return method;\n  }\n"]);

    _templateObject74 = function _templateObject74() {
      return data;
    };

    return data;
  }

  function _templateObject73() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n"]);

    _templateObject73 = function _templateObject73() {
      return data;
    };

    return data;
  }

  function _templateObject72() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n  }\n"]);

    _templateObject72 = function _templateObject72() {
      return data;
    };

    return data;
  }

  function _templateObject71() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    var descriptor = privateMap.get(receiver);\n    if (descriptor.set) {\n      if (!(\"__destrObj\" in descriptor)) {\n        descriptor.__destrObj = {\n          set value(v) {\n            descriptor.set.call(receiver, v)\n          },\n        };\n      }\n      return descriptor.__destrObj;\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n\n      return descriptor;\n    }\n  }\n"]);

    _templateObject71 = function _templateObject71() {
      return data;
    };

    return data;
  }

  function _templateObject70() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldSet(receiver, privateMap, value) {\n    var descriptor = privateMap.get(receiver);\n    if (!descriptor) {\n      throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n"]);

    _templateObject70 = function _templateObject70() {
      return data;
    };

    return data;
  }

  function _templateObject69() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldGet(receiver, privateMap) {\n    var descriptor = privateMap.get(receiver);\n    if (!descriptor) {\n      throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n  }\n"]);

    _templateObject69 = function _templateObject69() {
      return data;
    };

    return data;
  }

  function _templateObject68() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError(\"attempted to use private field on non-instance\");\n    }\n    return receiver;\n  }\n"]);

    _templateObject68 = function _templateObject68() {
      return data;
    };

    return data;
  }

  function _templateObject67() {
    var data = _taggedTemplateLiteralLoose(["\n  var id = 0;\n  export default function _classPrivateFieldKey(name) {\n    return \"__private_\" + (id++) + \"_\" + name;\n  }\n"]);

    _templateObject67 = function _templateObject67() {
      return data;
    };

    return data;
  }

  function _templateObject66() {
    var data = _taggedTemplateLiteralLoose(["\n    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){\n        var desc = {};\n        Object.keys(descriptor).forEach(function(key){\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n        if ('value' in desc || desc.initializer){\n            desc.writable = true;\n        }\n\n        desc = decorators.slice().reverse().reduce(function(desc, decorator){\n            return decorator(target, property, desc) || desc;\n        }, desc);\n\n        if (context && desc.initializer !== void 0){\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0){\n            // This is a hack to avoid this being processed by 'transform-runtime'.\n            // See issue #9.\n            Object.defineProperty(target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n"]);

    _templateObject66 = function _templateObject66() {
      return data;
    };

    return data;
  }

  function _templateObject65() {
    var data = _taggedTemplateLiteralLoose(["\n    export default function _initializerDefineProperty(target, property, descriptor, context){\n        if (!descriptor) return;\n\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n"]);

    _templateObject65 = function _templateObject65() {
      return data;
    };

    return data;
  }

  function _templateObject64() {
    var data = _taggedTemplateLiteralLoose(["\n    export default function _initializerWarningHelper(descriptor, context){\n        throw new Error(\n          'Decorating class property failed. Please ensure that ' +\n          'proposal-class-properties is enabled and runs after the decorators transform.'\n        );\n    }\n"]);

    _templateObject64 = function _templateObject64() {
      return data;
    };

    return data;
  }

  function _templateObject63() {
    var data = _taggedTemplateLiteralLoose(["\n  import toPrimitive from \"toPrimitive\";\n\n  export default function _toPropertyKey(arg) {\n    var key = toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n"]);

    _templateObject63 = function _templateObject63() {
      return data;
    };

    return data;
  }

  function _templateObject62() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _toPrimitive(\n    input,\n    hint /*: \"default\" | \"string\" | \"number\" | void */\n  ) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n  }\n"]);

    _templateObject62 = function _templateObject62() {
      return data;
    };

    return data;
  }

  function _templateObject61() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _skipFirstGeneratorNext(fn) {\n    return function () {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    }\n  }\n"]);

    _templateObject61 = function _templateObject61() {
      return data;
    };

    return data;
  }

  function _templateObject60() {
    var data = _taggedTemplateLiteralLoose(["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  export default function _createForOfIteratorHelperLoose(o) {\n    var i = 0;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (Array.isArray(o) || (o = unsupportedIterableToArray(o)))\n        return function() {\n          if (i >= o.length) return { done: true };\n          return { done: false, value: o[i++] };\n        }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    i = o[Symbol.iterator]();\n    return i.next.bind(i);\n  }\n"], ["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  export default function _createForOfIteratorHelperLoose(o) {\n    var i = 0;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (Array.isArray(o) || (o = unsupportedIterableToArray(o)))\n        return function() {\n          if (i >= o.length) return { done: true };\n          return { done: false, value: o[i++] };\n        }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    i = o[Symbol.iterator]();\n    return i.next.bind(i);\n  }\n"]);

    _templateObject60 = function _templateObject60() {
      return data;
    };

    return data;
  }

  function _templateObject59() {
    var data = _taggedTemplateLiteralLoose(["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  // s: start (create the iterator)\n  // n: next\n  // e: error (called whenever something throws)\n  // f: finish (always called at the end)\n\n  export default function _createForOfIteratorHelper(o) {\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n        var i = 0;\n        var F = function(){};\n        return {\n          s: F,\n          n: function() {\n            if (i >= o.length) return { done: true };\n            return { done: false, value: o[i++] };\n          },\n          e: function(e) { throw e; },\n          f: F,\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var it, normalCompletion = true, didErr = false, err;\n\n    return {\n      s: function() {\n        it = o[Symbol.iterator]();\n      },\n      n: function() {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function(e) {\n        didErr = true;\n        err = e;\n      },\n      f: function() {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n"], ["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  // s: start (create the iterator)\n  // n: next\n  // e: error (called whenever something throws)\n  // f: finish (always called at the end)\n\n  export default function _createForOfIteratorHelper(o) {\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n        var i = 0;\n        var F = function(){};\n        return {\n          s: F,\n          n: function() {\n            if (i >= o.length) return { done: true };\n            return { done: false, value: o[i++] };\n          },\n          e: function(e) { throw e; },\n          f: F,\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var it, normalCompletion = true, didErr = false, err;\n\n    return {\n      s: function() {\n        it = o[Symbol.iterator]();\n      },\n      n: function() {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function(e) {\n        didErr = true;\n        err = e;\n      },\n      f: function() {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n"]);

    _templateObject59 = function _templateObject59() {
      return data;
    };

    return data;
  }

  function _templateObject58() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _nonIterableRest() {\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"], ["\n  export default function _nonIterableRest() {\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"]);

    _templateObject58 = function _templateObject58() {
      return data;
    };

    return data;
  }

  function _templateObject57() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _nonIterableSpread() {\n    throw new TypeError(\n      \"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"], ["\n  export default function _nonIterableSpread() {\n    throw new TypeError(\n      \"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"]);

    _templateObject57 = function _templateObject57() {
      return data;
    };

    return data;
  }

  function _templateObject56() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n"]);

    _templateObject56 = function _templateObject56() {
      return data;
    };

    return data;
  }

  function _templateObject55() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return arrayLikeToArray(o, minLen);\n  }\n"]);

    _templateObject55 = function _templateObject55() {
      return data;
    };

    return data;
  }

  function _templateObject54() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArrayLimitLoose(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n\n    var _arr = [];\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n      if (i && _arr.length === i) break;\n    }\n    return _arr;\n  }\n"]);

    _templateObject54 = function _templateObject54() {
      return data;
    };

    return data;
  }

  function _templateObject53() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of `for...of` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n"], ["\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of \\`for...of\\` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n"]);

    _templateObject53 = function _templateObject53() {
      return data;
    };

    return data;
  }

  function _templateObject52() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n"]);

    _templateObject52 = function _templateObject52() {
      return data;
    };

    return data;
  }

  function _templateObject51() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n"]);

    _templateObject51 = function _templateObject51() {
      return data;
    };

    return data;
  }

  function _templateObject50() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return arrayLikeToArray(arr);\n  }\n"]);

    _templateObject50 = function _templateObject50() {
      return data;
    };

    return data;
  }

  function _templateObject49() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayWithoutHoles from \"arrayWithoutHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableSpread from \"nonIterableSpread\";\n\n  export default function _toConsumableArray(arr) {\n    return (\n      arrayWithoutHoles(arr) ||\n      iterableToArray(arr) ||\n      unsupportedIterableToArray(arr) ||\n      nonIterableSpread()\n    );\n  }\n"]);

    _templateObject49 = function _templateObject49() {
      return data;
    };

    return data;
  }

  function _templateObject48() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _toArray(arr) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArray(arr) ||\n      unsupportedIterableToArray(arr) ||\n      nonIterableRest()\n    );\n  }\n"]);

    _templateObject48 = function _templateObject48() {
      return data;
    };

    return data;
  }

  function _templateObject47() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimitLoose from \"iterableToArrayLimitLoose\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArrayLoose(arr, i) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArrayLimitLoose(arr, i) ||\n      unsupportedIterableToArray(arr, i) ||\n      nonIterableRest()\n    );\n  }\n"]);

    _templateObject47 = function _templateObject47() {
      return data;
    };

    return data;
  }

  function _templateObject46() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimit from \"iterableToArrayLimit\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArray(arr, i) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArrayLimit(arr, i) ||\n      unsupportedIterableToArray(arr, i) ||\n      nonIterableRest()\n    );\n  }\n"]);

    _templateObject46 = function _templateObject46() {
      return data;
    };

    return data;
  }

  function _templateObject45() {
    var data = _taggedTemplateLiteralLoose(["\n  import undef from \"temporalUndefined\";\n  import err from \"tdz\";\n\n  export default function _temporalRef(val, name) {\n    return val === undef ? err(name) : val;\n  }\n"]);

    _templateObject45 = function _templateObject45() {
      return data;
    };

    return data;
  }

  function _templateObject44() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _tdzError(name) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  }\n"]);

    _templateObject44 = function _templateObject44() {
      return data;
    };

    return data;
  }

  function _templateObject43() {
    var data = _taggedTemplateLiteralLoose(["\n  // This function isn't mean to be called, but to be used as a reference.\n  // We can't use a normal object because it isn't hoisted.\n  export default function _temporalUndefined() {}\n"]);

    _templateObject43 = function _templateObject43() {
      return data;
    };

    return data;
  }

  function _templateObject42() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\"\" + name + \"\\\" cannot be referenced in computed property keys.\");\n  }\n"], ["\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\\\"\" + name + \"\\\\\" cannot be referenced in computed property keys.\");\n  }\n"]);

    _templateObject42 = function _templateObject42() {
      return data;
    };

    return data;
  }

  function _templateObject41() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _readOnlyError(name) {\n    throw new Error(\"\\\"\" + name + \"\\\" is read-only\");\n  }\n"], ["\n  export default function _readOnlyError(name) {\n    throw new Error(\"\\\\\"\" + name + \"\\\\\" is read-only\");\n  }\n"]);

    _templateObject41 = function _templateObject41() {
      return data;
    };

    return data;
  }

  function _templateObject40() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    strings.raw = raw;\n    return strings;\n  }\n"]);

    _templateObject40 = function _templateObject40() {
      return data;
    };

    return data;
  }

  function _templateObject39() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: { value: Object.freeze(raw) }\n    }));\n  }\n"]);

    _templateObject39 = function _templateObject39() {
      return data;
    };

    return data;
  }

  function _templateObject38() {
    var data = _taggedTemplateLiteralLoose(["\n  import superPropBase from \"superPropBase\";\n  import defineProperty from \"defineProperty\";\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = superPropBase(target, property);\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            // Both getter and non-writable fall into this.\n            return false;\n          }\n        }\n\n        // Without a super that defines the property, spec boils down to\n        // \"define on receiver\" for some reason.\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n        if (desc) {\n          if (!desc.writable) {\n            // Setter, getter, and non-writable fall into this.\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          // Avoid setters that may be defined on Sub's prototype, but not on\n          // the instance.\n          defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  export default function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n"]);

    _templateObject38 = function _templateObject38() {
      return data;
    };

    return data;
  }

  function _templateObject37() {
    var data = _taggedTemplateLiteralLoose(["\n  import superPropBase from \"superPropBase\";\n\n  export default function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = superPropBase(target, property);\n\n        if (!base) return;\n\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n    return _get(target, property, receiver || target);\n  }\n"]);

    _templateObject37 = function _templateObject37() {
      return data;
    };

    return data;
  }

  function _templateObject36() {
    var data = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n\n  export default function _superPropBase(object, property) {\n    // Yes, this throws if object is null to being with, that's on purpose.\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = getPrototypeOf(object);\n      if (object === null) break;\n    }\n    return object;\n  }\n"]);

    _templateObject36 = function _templateObject36() {
      return data;
    };

    return data;
  }

  function _templateObject35() {
    var data = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n\n  export default function _createSuper(Derived) {\n    return function () {\n      var Super = getPrototypeOf(Derived), result;\n      if (isNativeReflectConstruct()) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = getPrototypeOf(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return possibleConstructorReturn(this, result);\n    }\n  }\n "]);

    _templateObject35 = function _templateObject35() {
      return data;
    };

    return data;
  }

  function _templateObject34() {
    var data = _taggedTemplateLiteralLoose(["\n  import assertThisInitialized from \"assertThisInitialized\";\n\n  export default function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n    return assertThisInitialized(self);\n  }\n"]);

    _templateObject34 = function _templateObject34() {
      return data;
    };

    return data;
  }

  function _templateObject33() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n  }\n"]);

    _templateObject33 = function _templateObject33() {
      return data;
    };

    return data;
  }

  function _templateObject32() {
    var data = _taggedTemplateLiteralLoose(["\n  import objectWithoutPropertiesLoose from \"objectWithoutPropertiesLoose\";\n\n  export default function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n"]);

    _templateObject32 = function _templateObject32() {
      return data;
    };

    return data;
  }

  function _templateObject31() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n"]);

    _templateObject31 = function _templateObject31() {
      return data;
    };

    return data;
  }

  function _templateObject30() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  }\n"]);

    _templateObject30 = function _templateObject30() {
      return data;
    };

    return data;
  }

  function _templateObject29() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError(\"Cannot instantiate an arrow function\");\n    }\n  }\n"]);

    _templateObject29 = function _templateObject29() {
      return data;
    };

    return data;
  }

  function _templateObject28() {
    var data = _taggedTemplateLiteralLoose(["\n  function _getRequireWildcardCache() {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cache = new WeakMap();\n    _getRequireWildcardCache = function () { return cache; };\n    return cache;\n  }\n\n  export default function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    }\n\n    if (obj === null || (typeof obj !== \"object\" && typeof obj !== \"function\")) {\n      return { default: obj }\n    }\n\n    var cache = _getRequireWildcardCache();\n    if (cache && cache.has(obj)) {\n      return cache.get(obj);\n    }\n\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor\n          ? Object.getOwnPropertyDescriptor(obj, key)\n          : null;\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n    newObj.default = obj;\n    if (cache) {\n      cache.set(obj, newObj);\n    }\n    return newObj;\n  }\n"]);

    _templateObject28 = function _templateObject28() {
      return data;
    };

    return data;
  }

  function _templateObject27() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n  }\n"]);

    _templateObject27 = function _templateObject27() {
      return data;
    };

    return data;
  }

  function _templateObject26() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n      return !!right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n"]);

    _templateObject26 = function _templateObject26() {
      return data;
    };

    return data;
  }

  function _templateObject25() {
    var data = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeFunction from \"isNativeFunction\";\n  import construct from \"construct\";\n\n  export default function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !isNativeFunction(Class)) return Class;\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n        _cache.set(Class, Wrapper);\n      }\n      function Wrapper() {\n        return construct(Class, arguments, getPrototypeOf(this).constructor)\n      }\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true,\n        }\n      });\n\n      return setPrototypeOf(Wrapper, Class);\n    }\n\n    return _wrapNativeSuper(Class)\n  }\n"]);

    _templateObject25 = function _templateObject25() {
      return data;
    };

    return data;
  }

  function _templateObject24() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _isNativeFunction(fn) {\n    // Note: This function returns \"true\" for core-js functions.\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n"]);

    _templateObject24 = function _templateObject24() {
      return data;
    };

    return data;
  }

  function _templateObject23() {
    var data = _taggedTemplateLiteralLoose(["\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\n\n  export default function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      // NOTE: If Parent !== Class, the correct __proto__ is set *after*\n      //       calling the constructor.\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n    // Avoid issues with Class being present but undefined when it wasn't\n    // present in the original call.\n    return _construct.apply(null, arguments);\n  }\n"]);

    _templateObject23 = function _templateObject23() {
      return data;
    };

    return data;
  }

  function _templateObject22() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n    // core-js@3\n    if (Reflect.construct.sham) return false;\n\n    // Proxy can't be polyfilled. Every browser implemented\n    // proxies before or at the same time as Reflect.construct,\n    // so if they support Proxy they also support Reflect.construct.\n    if (typeof Proxy === \"function\") return true;\n\n    // Since Reflect.construct can't be properly polyfilled, some\n    // implementations (e.g. core-js@2) don't set the correct internal slots.\n    // Those polyfills don't allow us to subclass built-ins, so we need to\n    // use our fallback implementation.\n    try {\n      // If the internal slots aren't set, this throws an error similar to\n      //   TypeError: this is not a Date object.\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n"]);

    _templateObject22 = function _templateObject22() {
      return data;
    };

    return data;
  }

  function _templateObject21() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n"]);

    _templateObject21 = function _templateObject21() {
      return data;
    };

    return data;
  }

  function _templateObject20() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n"]);

    _templateObject20 = function _templateObject20() {
      return data;
    };

    return data;
  }

  function _templateObject19() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n"]);

    _templateObject19 = function _templateObject19() {
      return data;
    };

    return data;
  }

  function _templateObject18() {
    var data = _taggedTemplateLiteralLoose(["\n  import setPrototypeOf from \"setPrototypeOf\";\n\n  export default function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) setPrototypeOf(subClass, superClass);\n  }\n"]);

    _templateObject18 = function _templateObject18() {
      return data;
    };

    return data;
  }

  function _templateObject17() {
    var data = _taggedTemplateLiteralLoose(["\n  import defineProperty from \"defineProperty\";\n\n  // This function is different to \"Reflect.ownKeys\". The enumerableOnly\n  // filters on symbol properties only. Returned string properties are always\n  // enumerable. It is good to use in objectSpread.\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n    return keys;\n  }\n\n  export default function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? arguments[i] : {};\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(\n            target,\n            key,\n            Object.getOwnPropertyDescriptor(source, key)\n          );\n        });\n      }\n    }\n    return target;\n  }\n"]);

    _templateObject17 = function _templateObject17() {
      return data;
    };

    return data;
  }

  function _templateObject16() {
    var data = _taggedTemplateLiteralLoose(["\n  import defineProperty from \"defineProperty\";\n\n  export default function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? Object(arguments[i]) : {};\n      var ownKeys = Object.keys(source);\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n      ownKeys.forEach(function(key) {\n        defineProperty(target, key, source[key]);\n      });\n    }\n    return target;\n  }\n"]);

    _templateObject16 = function _templateObject16() {
      return data;
    };

    return data;
  }

  function _templateObject15() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n"]);

    _templateObject15 = function _templateObject15() {
      return data;
    };

    return data;
  }

  function _templateObject14() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _defineProperty(obj, key, value) {\n    // Shortcircuit the slow defineProperty path when possible.\n    // We are trying to avoid issues where setters defined on the\n    // prototype cause side effects under the fast path of simple\n    // assignment. By checking for existence of the property with\n    // the in operator, we can optimize most of this overhead away.\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n"]);

    _templateObject14 = function _templateObject14() {
      return data;
    };

    return data;
  }

  function _templateObject13() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n    return obj;\n  }\n"]);

    _templateObject13 = function _templateObject13() {
      return data;
    };

    return data;
  }

  function _templateObject12() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    // Symbols are not enumerated over by for-in loops. If native\n    // Symbols are available, fetch all of the descs object's own\n    // symbol properties and define them on our target object too.\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if (\"value\" in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n    return obj;\n  }\n"]);

    _templateObject12 = function _templateObject12() {
      return data;
    };

    return data;
  }

  function _templateObject11() {
    var data = _taggedTemplateLiteralLoose(["\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i ++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  export default function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n"]);

    _templateObject11 = function _templateObject11() {
      return data;
    };

    return data;
  }

  function _templateObject10() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n"]);

    _templateObject10 = function _templateObject10() {
      return data;
    };

    return data;
  }

  function _templateObject9() {
    var data = _taggedTemplateLiteralLoose(["\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  export default function _asyncToGenerator(fn) {\n    return function () {\n      var self = this, args = arguments;\n      return new Promise(function (resolve, reject) {\n        var gen = fn.apply(self, args);\n        function _next(value) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n        }\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n"]);

    _templateObject9 = function _templateObject9() {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {}, waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function (resolve) { resolve(inner[key](value)); });\n      return { done: false, value: awaitWrap(value) };\n    };\n\n    if (typeof Symbol === \"function\" && Symbol.iterator) {\n      iter[Symbol.iterator] = function () { return this; };\n    }\n\n    iter.next = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n      return pump(\"next\", value);\n    };\n\n    if (typeof inner.throw === \"function\") {\n      iter.throw = function (value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n        return pump(\"throw\", value);\n      };\n    }\n\n    if (typeof inner.return === \"function\") {\n      iter.return = function (value) {\n        if (waiting) {\n          waiting = false;\n          return value;\n        }\n        return pump(\"return\", value);\n      };\n    }\n\n    return iter;\n  }\n"]);

    _templateObject8 = function _templateObject8() {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    var data = _taggedTemplateLiteralLoose(["\n  import AwaitValue from \"AwaitValue\";\n\n  export default function _awaitAsyncGenerator(value) {\n    return new AwaitValue(value);\n  }\n"]);

    _templateObject7 = function _templateObject7() {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    var data = _taggedTemplateLiteralLoose(["\n  import AsyncGenerator from \"AsyncGenerator\";\n\n  export default function _wrapAsyncGenerator(fn) {\n    return function () {\n      return new AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n"]);

    _templateObject6 = function _templateObject6() {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    var data = _taggedTemplateLiteralLoose(["\n  import AwaitValue from \"AwaitValue\";\n\n  export default function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null,\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg)\n        var value = result.value;\n        var wrappedAwait = value instanceof AwaitValue;\n\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function (arg) {\n            if (wrappedAwait) {\n              resume(key === \"return\" ? \"return\" : \"next\", arg);\n              return\n            }\n\n            settle(result.done ? \"return\" : \"normal\", arg);\n          },\n          function (err) { resume(\"throw\", err); });\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({ value: value, done: true });\n          break;\n        case \"throw\":\n          front.reject(value);\n          break;\n        default:\n          front.resolve({ value: value, done: false });\n          break;\n      }\n\n      front = front.next;\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    // Hide \"return\" method if generator return is not supported\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) { return this._invoke(\"next\", arg); };\n  AsyncGenerator.prototype.throw = function (arg) { return this._invoke(\"throw\", arg); };\n  AsyncGenerator.prototype.return = function (arg) { return this._invoke(\"return\", arg); };\n"]);

    _templateObject5 = function _templateObject5() {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n"]);

    _templateObject4 = function _templateObject4() {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _asyncIterator(iterable) {\n    var method\n    if (typeof Symbol !== \"undefined\") {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator]\n        if (method != null) return method.call(iterable);\n      }\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator]\n        if (method != null) return method.call(iterable);\n      }\n    }\n    throw new TypeError(\"Object is not async iterable\");\n  }\n"]);

    _templateObject3 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    var data = _taggedTemplateLiteralLoose(["\n  var REACT_ELEMENT_TYPE;\n\n  export default function _createRawReactElement(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE = (\n        typeof Symbol === \"function\" && Symbol[\"for\"] && Symbol[\"for\"](\"react.element\")\n      ) || 0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      // If we're going to assign props.children, we create a new object now\n      // to avoid mutating defaultProps.\n      props = {\n        children: void 0,\n      };\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n      props.children = childArray;\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null,\n    };\n  }\n"]);

    _templateObject2 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) { return typeof obj; };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype\n          ? \"symbol\"\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n"]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }
  var helpers = Object.create(null);

  var helper = function helper(minVersion) {
    return function (tpl) {
      return {
        minVersion: minVersion,
        ast: function ast() {
          return template.program.ast(tpl);
        }
      };
    };
  };

  helpers["typeof"] = helper("7.0.0-beta.0")(_templateObject());
  helpers.jsx = helper("7.0.0-beta.0")(_templateObject2());
  helpers.asyncIterator = helper("7.0.0-beta.0")(_templateObject3());
  helpers.AwaitValue = helper("7.0.0-beta.0")(_templateObject4());
  helpers.AsyncGenerator = helper("7.0.0-beta.0")(_templateObject5());
  helpers.wrapAsyncGenerator = helper("7.0.0-beta.0")(_templateObject6());
  helpers.awaitAsyncGenerator = helper("7.0.0-beta.0")(_templateObject7());
  helpers.asyncGeneratorDelegate = helper("7.0.0-beta.0")(_templateObject8());
  helpers.asyncToGenerator = helper("7.0.0-beta.0")(_templateObject9());
  helpers.classCallCheck = helper("7.0.0-beta.0")(_templateObject10());
  helpers.createClass = helper("7.0.0-beta.0")(_templateObject11());
  helpers.defineEnumerableProperties = helper("7.0.0-beta.0")(_templateObject12());
  helpers.defaults = helper("7.0.0-beta.0")(_templateObject13());
  helpers.defineProperty = helper("7.0.0-beta.0")(_templateObject14());
  helpers["extends"] = helper("7.0.0-beta.0")(_templateObject15());
  helpers.objectSpread = helper("7.0.0-beta.0")(_templateObject16());
  helpers.objectSpread2 = helper("7.5.0")(_templateObject17());
  helpers.inherits = helper("7.0.0-beta.0")(_templateObject18());
  helpers.inheritsLoose = helper("7.0.0-beta.0")(_templateObject19());
  helpers.getPrototypeOf = helper("7.0.0-beta.0")(_templateObject20());
  helpers.setPrototypeOf = helper("7.0.0-beta.0")(_templateObject21());
  helpers.isNativeReflectConstruct = helper("7.9.0")(_templateObject22());
  helpers.construct = helper("7.0.0-beta.0")(_templateObject23());
  helpers.isNativeFunction = helper("7.0.0-beta.0")(_templateObject24());
  helpers.wrapNativeSuper = helper("7.0.0-beta.0")(_templateObject25());
  helpers["instanceof"] = helper("7.0.0-beta.0")(_templateObject26());
  helpers.interopRequireDefault = helper("7.0.0-beta.0")(_templateObject27());
  helpers.interopRequireWildcard = helper("7.0.0-beta.0")(_templateObject28());
  helpers.newArrowCheck = helper("7.0.0-beta.0")(_templateObject29());
  helpers.objectDestructuringEmpty = helper("7.0.0-beta.0")(_templateObject30());
  helpers.objectWithoutPropertiesLoose = helper("7.0.0-beta.0")(_templateObject31());
  helpers.objectWithoutProperties = helper("7.0.0-beta.0")(_templateObject32());
  helpers.assertThisInitialized = helper("7.0.0-beta.0")(_templateObject33());
  helpers.possibleConstructorReturn = helper("7.0.0-beta.0")(_templateObject34());
  helpers.createSuper = helper("7.9.0")(_templateObject35());
  helpers.superPropBase = helper("7.0.0-beta.0")(_templateObject36());
  helpers.get = helper("7.0.0-beta.0")(_templateObject37());
  helpers.set = helper("7.0.0-beta.0")(_templateObject38());
  helpers.taggedTemplateLiteral = helper("7.0.0-beta.0")(_templateObject39());
  helpers.taggedTemplateLiteralLoose = helper("7.0.0-beta.0")(_templateObject40());
  helpers.readOnlyError = helper("7.0.0-beta.0")(_templateObject41());
  helpers.classNameTDZError = helper("7.0.0-beta.0")(_templateObject42());
  helpers.temporalUndefined = helper("7.0.0-beta.0")(_templateObject43());
  helpers.tdz = helper("7.5.5")(_templateObject44());
  helpers.temporalRef = helper("7.0.0-beta.0")(_templateObject45());
  helpers.slicedToArray = helper("7.0.0-beta.0")(_templateObject46());
  helpers.slicedToArrayLoose = helper("7.0.0-beta.0")(_templateObject47());
  helpers.toArray = helper("7.0.0-beta.0")(_templateObject48());
  helpers.toConsumableArray = helper("7.0.0-beta.0")(_templateObject49());
  helpers.arrayWithoutHoles = helper("7.0.0-beta.0")(_templateObject50());
  helpers.arrayWithHoles = helper("7.0.0-beta.0")(_templateObject51());
  helpers.iterableToArray = helper("7.0.0-beta.0")(_templateObject52());
  helpers.iterableToArrayLimit = helper("7.0.0-beta.0")(_templateObject53());
  helpers.iterableToArrayLimitLoose = helper("7.0.0-beta.0")(_templateObject54());
  helpers.unsupportedIterableToArray = helper("7.9.0")(_templateObject55());
  helpers.arrayLikeToArray = helper("7.9.0")(_templateObject56());
  helpers.nonIterableSpread = helper("7.0.0-beta.0")(_templateObject57());
  helpers.nonIterableRest = helper("7.0.0-beta.0")(_templateObject58());
  helpers.createForOfIteratorHelper = helper("7.9.0")(_templateObject59());
  helpers.createForOfIteratorHelperLoose = helper("7.9.0")(_templateObject60());
  helpers.skipFirstGeneratorNext = helper("7.0.0-beta.0")(_templateObject61());
  helpers.toPrimitive = helper("7.1.5")(_templateObject62());
  helpers.toPropertyKey = helper("7.1.5")(_templateObject63());
  helpers.initializerWarningHelper = helper("7.0.0-beta.0")(_templateObject64());
  helpers.initializerDefineProperty = helper("7.0.0-beta.0")(_templateObject65());
  helpers.applyDecoratedDescriptor = helper("7.0.0-beta.0")(_templateObject66());
  helpers.classPrivateFieldLooseKey = helper("7.0.0-beta.0")(_templateObject67());
  helpers.classPrivateFieldLooseBase = helper("7.0.0-beta.0")(_templateObject68());
  helpers.classPrivateFieldGet = helper("7.0.0-beta.0")(_templateObject69());
  helpers.classPrivateFieldSet = helper("7.0.0-beta.0")(_templateObject70());
  helpers.classPrivateFieldDestructureSet = helper("7.4.4")(_templateObject71());
  helpers.classStaticPrivateFieldSpecGet = helper("7.0.2")(_templateObject72());
  helpers.classStaticPrivateFieldSpecSet = helper("7.0.2")(_templateObject73());
  helpers.classStaticPrivateMethodGet = helper("7.3.2")(_templateObject74());
  helpers.classStaticPrivateMethodSet = helper("7.3.2")(_templateObject75());
  helpers.decorate = helper("7.1.5")(_templateObject76());
  helpers.classPrivateMethodGet = helper("7.1.6")(_templateObject77());
  helpers.classPrivateMethodSet = helper("7.1.6")(_templateObject78());
  helpers.wrapRegExp = helper("7.2.6")(_templateObject79());

  function makePath(path) {
    var parts = [];

    for (; path.parentPath; path = path.parentPath) {
      parts.push(path.key);
      if (path.inList) parts.push(path.listKey);
    }

    return parts.reverse().join(".");
  }

  var fileClass = undefined;

  function getHelperMetadata(file) {
    var globals = new Set();
    var localBindingNames = new Set();
    var dependencies = new Map();
    var exportName;
    var exportPath;
    var exportBindingAssignments = [];
    var importPaths = [];
    var importBindingsReferences = [];
    var dependencyVisitor = {
      ImportDeclaration: function ImportDeclaration(child) {
        var name = child.node.source.value;

        if (!helpers[name]) {
          throw child.buildCodeFrameError("Unknown helper " + name);
        }

        if (child.get("specifiers").length !== 1 || !child.get("specifiers.0").isImportDefaultSpecifier()) {
          throw child.buildCodeFrameError("Helpers can only import a default value");
        }

        var bindingIdentifier = child.node.specifiers[0].local;
        dependencies.set(bindingIdentifier, name);
        importPaths.push(makePath(child));
      },
      ExportDefaultDeclaration: function ExportDefaultDeclaration(child) {
        var decl = child.get("declaration");

        if (decl.isFunctionDeclaration()) {
          if (!decl.node.id) {
            throw decl.buildCodeFrameError("Helpers should give names to their exported func declaration");
          }

          exportName = decl.node.id.name;
        }

        exportPath = makePath(child);
      },
      ExportAllDeclaration: function ExportAllDeclaration(child) {
        throw child.buildCodeFrameError("Helpers can only export default");
      },
      ExportNamedDeclaration: function ExportNamedDeclaration(child) {
        throw child.buildCodeFrameError("Helpers can only export default");
      },
      Statement: function Statement(child) {
        if (child.isModuleDeclaration()) return;
        child.skip();
      }
    };
    var referenceVisitor = {
      Program: function Program(path) {
        var bindings = path.scope.getAllBindings();
        Object.keys(bindings).forEach(function (name) {
          if (name === exportName) return;
          if (dependencies.has(bindings[name].identifier)) return;
          localBindingNames.add(name);
        });
      },
      ReferencedIdentifier: function ReferencedIdentifier(child) {
        var name = child.node.name;
        var binding = child.scope.getBinding(name, true);

        if (!binding) {
          globals.add(name);
        } else if (dependencies.has(binding.identifier)) {
          importBindingsReferences.push(makePath(child));
        }
      },
      AssignmentExpression: function AssignmentExpression(child) {
        var left = child.get("left");
        if (!(exportName in left.getBindingIdentifiers())) return;

        if (!left.isIdentifier()) {
          throw left.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
        }

        var binding = child.scope.getBinding(exportName);

        if (binding && binding.scope.path.isProgram()) {
          exportBindingAssignments.push(makePath(child));
        }
      }
    };
    traverse$1(file.ast, dependencyVisitor, file.scope);
    traverse$1(file.ast, referenceVisitor, file.scope);
    if (!exportPath) throw new Error("Helpers must default-export something.");
    exportBindingAssignments.reverse();
    return {
      globals: Array.from(globals),
      localBindingNames: Array.from(localBindingNames),
      dependencies: dependencies,
      exportBindingAssignments: exportBindingAssignments,
      exportPath: exportPath,
      exportName: exportName,
      importBindingsReferences: importBindingsReferences,
      importPaths: importPaths
    };
  }

  function permuteHelperAST(file, metadata, id, localBindings, getDependency) {
    if (localBindings && !id) {
      throw new Error("Unexpected local bindings for module-based helpers.");
    }

    if (!id) return;
    var localBindingNames = metadata.localBindingNames,
        dependencies = metadata.dependencies,
        exportBindingAssignments = metadata.exportBindingAssignments,
        exportPath = metadata.exportPath,
        exportName = metadata.exportName,
        importBindingsReferences = metadata.importBindingsReferences,
        importPaths = metadata.importPaths;
    var dependenciesRefs = {};
    dependencies.forEach(function (name, id) {
      dependenciesRefs[id.name] = typeof getDependency === "function" && getDependency(name) || id;
    });
    var toRename = {};
    var bindings = new Set(localBindings || []);
    localBindingNames.forEach(function (name) {
      var newName = name;

      while (bindings.has(newName)) {
        newName = "_" + newName;
      }

      if (newName !== name) toRename[name] = newName;
    });

    if (id.type === "Identifier" && exportName !== id.name) {
      toRename[exportName] = id.name;
    }

    var visitor = {
      Program: function Program(path) {
        var exp = path.get(exportPath);
        var imps = importPaths.map(function (p) {
          return path.get(p);
        });
        var impsBindingRefs = importBindingsReferences.map(function (p) {
          return path.get(p);
        });
        var decl = exp.get("declaration");

        if (id.type === "Identifier") {
          if (decl.isFunctionDeclaration()) {
            exp.replaceWith(decl);
          } else {
            exp.replaceWith(VariableDeclaration("var", [VariableDeclarator(id, decl.node)]));
          }
        } else if (id.type === "MemberExpression") {
          if (decl.isFunctionDeclaration()) {
            exportBindingAssignments.forEach(function (assignPath) {
              var assign = path.get(assignPath);
              assign.replaceWith(AssignmentExpression("=", id, assign.node));
            });
            exp.replaceWith(decl);
            path.pushContainer("body", ExpressionStatement(AssignmentExpression("=", id, Identifier(exportName))));
          } else {
            exp.replaceWith(ExpressionStatement(AssignmentExpression("=", id, decl.node)));
          }
        } else {
          throw new Error("Unexpected helper format.");
        }

        Object.keys(toRename).forEach(function (name) {
          path.scope.rename(name, toRename[name]);
        });

        for (var _iterator = imps, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var _path = _ref;

          _path.remove();
        }

        for (var _iterator2 = impsBindingRefs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
          var _ref2;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
          }

          var _path2 = _ref2;
          var node = cloneNode(dependenciesRefs[_path2.node.name]);

          _path2.replaceWith(node);
        }

        path.stop();
      }
    };
    traverse$1(file.ast, visitor, file.scope);
  }

  var helperData = Object.create(null);

  function loadHelper(name) {
    if (!helperData[name]) {
      var helper = helpers[name];

      if (!helper) {
        throw Object.assign(new ReferenceError("Unknown helper " + name), {
          code: "BABEL_HELPER_UNKNOWN",
          helper: name
        });
      }

      var fn = function fn() {
        var file = {
          ast: File(helper.ast())
        };

        if (fileClass) {
          return new fileClass({
            filename: "babel-helper://" + name
          }, file);
        }

        return file;
      };

      var metadata = getHelperMetadata(fn());
      helperData[name] = {
        build: function build(getDependency, id, localBindings) {
          var file = fn();
          permuteHelperAST(file, metadata, id, localBindings, getDependency);
          return {
            nodes: file.ast.program.body,
            globals: metadata.globals
          };
        },
        minVersion: function minVersion() {
          return helper.minVersion;
        },
        dependencies: metadata.dependencies
      };
    }

    return helperData[name];
  }

  function get$1(name, getDependency, id, localBindings) {
    return loadHelper(name).build(getDependency, id, localBindings);
  }
  function minVersion(name) {
    return loadHelper(name).minVersion();
  }
  function getDependencies(name) {
    return Array.from(loadHelper(name).dependencies.values());
  }
  function ensure(name, newFileClass) {
    if (!fileClass) {
      fileClass = newFileClass;
    }

    loadHelper(name);
  }
  var list$1 = Object.keys(helpers).map(function (name) {
    return name.replace(/^_/, "");
  }).filter(function (name) {
    return name !== "__esModule";
  });

  var inherits$1;

  if (typeof Object.create === 'function') {
    inherits$1 = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    inherits$1 = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function TempCtor() {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }

  var inherits$2 = inherits$1;

  var formatRegExp = /%[sdj%]/g;
  function format(f) {
    if (!isString$2(f)) {
      var objects = [];

      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }

      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function (x) {
      if (x === '%%') return '%';
      if (i >= len) return x;

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

        default:
          return x;
      }
    });

    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject$2(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }

    return str;
  }
  function deprecate(fn, msg) {
    if (isUndefined(global$1.process)) {
      return function () {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }

    if (process.noDeprecation === true) {
      return fn;
    }

    var warned = false;

    function deprecated() {
      if (!warned) {
        if (process.throwDeprecation) {
          throw new Error(msg);
        } else if (process.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }

        warned = true;
      }

      return fn.apply(this, arguments);
    }

    return deprecated;
  }
  var debugs = {};
  var debugEnviron;
  function debuglog(set) {
    if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
    set = set.toUpperCase();

    if (!debugs[set]) {
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
        var pid = 0;

        debugs[set] = function () {
          var msg = format.apply(null, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function () {};
      }
    }

    return debugs[set];
  }
  function inspect(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];

    if (isBoolean(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      _extend(ctx, opts);
    }

    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  inspect.colors = {
    'bold': [1, 22],
    'italic': [3, 23],
    'underline': [4, 24],
    'inverse': [7, 27],
    'white': [37, 39],
    'grey': [90, 39],
    'black': [30, 39],
    'blue': [34, 39],
    'cyan': [36, 39],
    'green': [32, 39],
    'magenta': [35, 39],
    'red': [31, 39],
    'yellow': [33, 39]
  };
  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    'regexp': 'red'
  };

  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }

  function stylizeNoColor(str, styleType) {
    return str;
  }

  function arrayToHash(array) {
    var hash = {};
    array.forEach(function (val, idx) {
      hash[val] = true;
    });
    return hash;
  }

  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction$3(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);

      if (!isString$2(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }

      return ret;
    }

    var primitive = formatPrimitive(ctx, value);

    if (primitive) {
      return primitive;
    }

    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }

    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    }

    if (keys.length === 0) {
      if (isFunction$3(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }

      if (isRegExp$1(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }

      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }

      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '',
        array = false,
        braces = ['{', '}'];

    if (isArray$3(value)) {
      array = true;
      braces = ['[', ']'];
    }

    if (isFunction$3(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    }

    if (isRegExp$1(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    }

    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    }

    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp$1(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);
    var output;

    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function (key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }

  function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

    if (isString$2(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }

    if (isNumber$1(value)) return ctx.stylize('' + value, 'number');
    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
    if (isNull(value)) return ctx.stylize('null', 'null');
  }

  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }

  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];

    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty$d(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push('');
      }
    }

    keys.forEach(function (key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }

  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
      value: value[key]
    };

    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }

    if (!hasOwnProperty$d(visibleKeys, key)) {
      name = '[' + key + ']';
    }

    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }

        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function (line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function (line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }

    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }

      name = JSON.stringify('' + key);

      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }

  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function (prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }

  function isArray$3(ar) {
    return Array.isArray(ar);
  }
  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  function isNumber$1(arg) {
    return typeof arg === 'number';
  }
  function isString$2(arg) {
    return typeof arg === 'string';
  }
  function isSymbol$1(arg) {
    return typeof arg === 'symbol';
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  function isRegExp$1(re) {
    return isObject$2(re) && objectToString$1(re) === '[object RegExp]';
  }
  function isObject$2(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  function isDate(d) {
    return isObject$2(d) && objectToString$1(d) === '[object Date]';
  }
  function isError(e) {
    return isObject$2(e) && (objectToString$1(e) === '[object Error]' || e instanceof Error);
  }
  function isFunction$3(arg) {
    return typeof arg === 'function';
  }
  function isPrimitive(arg) {
    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
  }
  function isBuffer$2(maybeBuf) {
    return isBuffer(maybeBuf);
  }

  function objectToString$1(o) {
    return Object.prototype.toString.call(o);
  }

  function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }

  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

  function timestamp() {
    var d = new Date();
    var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  }

  function log() {
    console.log('%s - %s', timestamp(), format.apply(null, arguments));
  }
  function _extend(origin, add) {
    if (!add || !isObject$2(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;

    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }

    return origin;
  }

  function hasOwnProperty$d(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var _util = {
    inherits: inherits$2,
    _extend: _extend,
    log: log,
    isBuffer: isBuffer$2,
    isPrimitive: isPrimitive,
    isFunction: isFunction$3,
    isError: isError,
    isDate: isDate,
    isObject: isObject$2,
    isRegExp: isRegExp$1,
    isUndefined: isUndefined,
    isSymbol: isSymbol$1,
    isString: isString$2,
    isNumber: isNumber$1,
    isNullOrUndefined: isNullOrUndefined,
    isNull: isNull,
    isBoolean: isBoolean,
    isArray: isArray$3,
    inspect: inspect,
    deprecate: deprecate,
    format: format,
    debuglog: debuglog
  };

  function compare(a, b) {
    if (a === b) {
      return 0;
    }

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) {
      return -1;
    }

    if (y < x) {
      return 1;
    }

    return 0;
  }

  var hasOwn = Object.prototype.hasOwnProperty;

  var objectKeys = Object.keys || function (obj) {
    var keys = [];

    for (var key in obj) {
      if (hasOwn.call(obj, key)) keys.push(key);
    }

    return keys;
  };
  var pSlice = Array.prototype.slice;

  var _functionsHaveNames;

  function functionsHaveNames() {
    if (typeof _functionsHaveNames !== 'undefined') {
      return _functionsHaveNames;
    }

    return _functionsHaveNames = function () {
      return function foo() {}.name === 'foo';
    }();
  }

  function pToString(obj) {
    return Object.prototype.toString.call(obj);
  }

  function isView(arrbuf) {
    if (isBuffer(arrbuf)) {
      return false;
    }

    if (typeof global$1.ArrayBuffer !== 'function') {
      return false;
    }

    if (typeof ArrayBuffer.isView === 'function') {
      return ArrayBuffer.isView(arrbuf);
    }

    if (!arrbuf) {
      return false;
    }

    if (arrbuf instanceof DataView) {
      return true;
    }

    if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
      return true;
    }

    return false;
  }

  function assert$2(value, message) {
    if (!value) fail(value, true, message, '==', ok);
  }
  var regex = /\s*function\s+([^\(\s]*)\s*/;

  function getName(func) {
    if (!isFunction$3(func)) {
      return;
    }

    if (functionsHaveNames()) {
      return func.name;
    }

    var str = func.toString();
    var match = str.match(regex);
    return match && match[1];
  }

  assert$2.AssertionError = AssertionError;
  function AssertionError(options) {
    this.name = 'AssertionError';
    this.actual = options.actual;
    this.expected = options.expected;
    this.operator = options.operator;

    if (options.message) {
      this.message = options.message;
      this.generatedMessage = false;
    } else {
      this.message = getMessage(this);
      this.generatedMessage = true;
    }

    var stackStartFunction = options.stackStartFunction || fail;

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, stackStartFunction);
    } else {
      var err = new Error();

      if (err.stack) {
        var out = err.stack;
        var fn_name = getName(stackStartFunction);
        var idx = out.indexOf('\n' + fn_name);

        if (idx >= 0) {
          var next_line = out.indexOf('\n', idx + 1);
          out = out.substring(next_line + 1);
        }

        this.stack = out;
      }
    }
  }
  inherits$2(AssertionError, Error);

  function truncate(s, n) {
    if (typeof s === 'string') {
      return s.length < n ? s : s.slice(0, n);
    } else {
      return s;
    }
  }

  function inspect$1(something) {
    if (functionsHaveNames() || !isFunction$3(something)) {
      return inspect(something);
    }

    var rawname = getName(something);
    var name = rawname ? ': ' + rawname : '';
    return '[Function' + name + ']';
  }

  function getMessage(self) {
    return truncate(inspect$1(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect$1(self.expected), 128);
  }

  function fail(actual, expected, message, operator, stackStartFunction) {
    throw new AssertionError({
      message: message,
      actual: actual,
      expected: expected,
      operator: operator,
      stackStartFunction: stackStartFunction
    });
  }
  assert$2.fail = fail;
  function ok(value, message) {
    if (!value) fail(value, true, message, '==', ok);
  }
  assert$2.ok = ok;
  assert$2.equal = equal;
  function equal(actual, expected, message) {
    if (actual != expected) fail(actual, expected, message, '==', equal);
  }
  assert$2.notEqual = notEqual;
  function notEqual(actual, expected, message) {
    if (actual == expected) {
      fail(actual, expected, message, '!=', notEqual);
    }
  }
  assert$2.deepEqual = deepEqual;
  function deepEqual(actual, expected, message) {
    if (!_deepEqual(actual, expected, false)) {
      fail(actual, expected, message, 'deepEqual', deepEqual);
    }
  }
  assert$2.deepStrictEqual = deepStrictEqual;
  function deepStrictEqual(actual, expected, message) {
    if (!_deepEqual(actual, expected, true)) {
      fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
    }
  }

  function _deepEqual(actual, expected, strict, memos) {
    if (actual === expected) {
      return true;
    } else if (isBuffer(actual) && isBuffer(expected)) {
      return compare(actual, expected) === 0;
    } else if (isDate(actual) && isDate(expected)) {
      return actual.getTime() === expected.getTime();
    } else if (isRegExp$1(actual) && isRegExp$1(expected)) {
      return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
    } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
      return strict ? actual === expected : actual == expected;
    } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
      return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
    } else if (isBuffer(actual) !== isBuffer(expected)) {
      return false;
    } else {
      memos = memos || {
        actual: [],
        expected: []
      };
      var actualIndex = memos.actual.indexOf(actual);

      if (actualIndex !== -1) {
        if (actualIndex === memos.expected.indexOf(expected)) {
          return true;
        }
      }

      memos.actual.push(actual);
      memos.expected.push(expected);
      return objEquiv(actual, expected, strict, memos);
    }
  }

  function isArguments$1(object) {
    return Object.prototype.toString.call(object) == '[object Arguments]';
  }

  function objEquiv(a, b, strict, actualVisitedObjects) {
    if (a === null || a === undefined || b === null || b === undefined) return false;
    if (isPrimitive(a) || isPrimitive(b)) return a === b;
    if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
    var aIsArgs = isArguments$1(a);
    var bIsArgs = isArguments$1(b);
    if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

    if (aIsArgs) {
      a = pSlice.call(a);
      b = pSlice.call(b);
      return _deepEqual(a, b, strict);
    }

    var ka = objectKeys(a);
    var kb = objectKeys(b);
    var key, i;
    if (ka.length !== kb.length) return false;
    ka.sort();
    kb.sort();

    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] !== kb[i]) return false;
    }

    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
    }

    return true;
  }

  assert$2.notDeepEqual = notDeepEqual;
  function notDeepEqual(actual, expected, message) {
    if (_deepEqual(actual, expected, false)) {
      fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
    }
  }
  assert$2.notDeepStrictEqual = notDeepStrictEqual;
  function notDeepStrictEqual(actual, expected, message) {
    if (_deepEqual(actual, expected, true)) {
      fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
    }
  }
  assert$2.strictEqual = strictEqual;
  function strictEqual(actual, expected, message) {
    if (actual !== expected) {
      fail(actual, expected, message, '===', strictEqual);
    }
  }
  assert$2.notStrictEqual = notStrictEqual;
  function notStrictEqual(actual, expected, message) {
    if (actual === expected) {
      fail(actual, expected, message, '!==', notStrictEqual);
    }
  }

  function expectedException(actual, expected) {
    if (!actual || !expected) {
      return false;
    }

    if (Object.prototype.toString.call(expected) == '[object RegExp]') {
      return expected.test(actual);
    }

    try {
      if (actual instanceof expected) {
        return true;
      }
    } catch (e) {}

    if (Error.isPrototypeOf(expected)) {
      return false;
    }

    return expected.call({}, actual) === true;
  }

  function _tryBlock(block) {
    var error;

    try {
      block();
    } catch (e) {
      error = e;
    }

    return error;
  }

  function _throws(shouldThrow, block, expected, message) {
    var actual;

    if (typeof block !== 'function') {
      throw new TypeError('"block" argument must be a function');
    }

    if (typeof expected === 'string') {
      message = expected;
      expected = null;
    }

    actual = _tryBlock(block);
    message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

    if (shouldThrow && !actual) {
      fail(actual, expected, 'Missing expected exception' + message);
    }

    var userProvidedMessage = typeof message === 'string';
    var isUnwantedException = !shouldThrow && isError(actual);
    var isUnexpectedException = !shouldThrow && actual && !expected;

    if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
      fail(actual, expected, 'Got unwanted exception' + message);
    }

    if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
      throw actual;
    }
  }

  assert$2["throws"] = _throws2;

  function _throws2(block, error, message) {
    _throws(true, block, error, message);
  }
  assert$2.doesNotThrow = doesNotThrow;
  function doesNotThrow(block, error, message) {
    _throws(false, block, error, message);
  }
  assert$2.ifError = ifError;
  function ifError(err) {
    if (err) throw err;
  }

  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }

  var _baseSlice = baseSlice;

  var nativeCeil = Math.ceil,
      nativeMax$2 = Math.max;

  function chunk(array, size, guard) {
    if (guard ? _isIterateeCall(array, size, guard) : size === undefined) {
      size = 1;
    } else {
      size = nativeMax$2(toInteger_1(size), 0);
    }

    var length = array == null ? 0 : array.length;

    if (!length || size < 1) {
      return [];
    }

    var index = 0,
        resIndex = 0,
        result = Array(nativeCeil(length / size));

    while (index < length) {
      result[resIndex++] = _baseSlice(array, index, index += size);
    }

    return result;
  }

  var chunk_1 = chunk;

  var ImportBuilder = function () {
    function ImportBuilder(importedSource, scope, hub) {
      this._statements = [];
      this._resultName = null;
      this._scope = null;
      this._hub = null;
      this._scope = scope;
      this._hub = hub;
      this._importedSource = importedSource;
    }

    var _proto = ImportBuilder.prototype;

    _proto.done = function done() {
      return {
        statements: this._statements,
        resultName: this._resultName
      };
    };

    _proto["import"] = function _import() {
      this._statements.push(ImportDeclaration([], StringLiteral(this._importedSource)));

      return this;
    };

    _proto.require = function require() {
      this._statements.push(ExpressionStatement(CallExpression(Identifier("require"), [StringLiteral(this._importedSource)])));

      return this;
    };

    _proto.namespace = function namespace(name) {
      if (name === void 0) {
        name = "namespace";
      }

      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];
      assert$2(statement.type === "ImportDeclaration");
      assert$2(statement.specifiers.length === 0);
      statement.specifiers = [ImportNamespaceSpecifier(name)];
      this._resultName = cloneNode(name);
      return this;
    };

    _proto["default"] = function _default(name) {
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];
      assert$2(statement.type === "ImportDeclaration");
      assert$2(statement.specifiers.length === 0);
      statement.specifiers = [ImportDefaultSpecifier(name)];
      this._resultName = cloneNode(name);
      return this;
    };

    _proto.named = function named(name, importName) {
      if (importName === "default") return this["default"](name);
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];
      assert$2(statement.type === "ImportDeclaration");
      assert$2(statement.specifiers.length === 0);
      statement.specifiers = [ImportSpecifier(name, Identifier(importName))];
      this._resultName = cloneNode(name);
      return this;
    };

    _proto["var"] = function _var(name) {
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];

      if (statement.type !== "ExpressionStatement") {
        assert$2(this._resultName);
        statement = ExpressionStatement(this._resultName);

        this._statements.push(statement);
      }

      this._statements[this._statements.length - 1] = VariableDeclaration("var", [VariableDeclarator(name, statement.expression)]);
      this._resultName = cloneNode(name);
      return this;
    };

    _proto.defaultInterop = function defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    };

    _proto.wildcardInterop = function wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    };

    _proto._interop = function _interop(callee) {
      var statement = this._statements[this._statements.length - 1];

      if (statement.type === "ExpressionStatement") {
        statement.expression = CallExpression(callee, [statement.expression]);
      } else if (statement.type === "VariableDeclaration") {
        assert$2(statement.declarations.length === 1);
        statement.declarations[0].init = CallExpression(callee, [statement.declarations[0].init]);
      } else {
        assert$2.fail("Unexpected type.");
      }

      return this;
    };

    _proto.prop = function prop(name) {
      var statement = this._statements[this._statements.length - 1];

      if (statement.type === "ExpressionStatement") {
        statement.expression = MemberExpression(statement.expression, Identifier(name));
      } else if (statement.type === "VariableDeclaration") {
        assert$2(statement.declarations.length === 1);
        statement.declarations[0].init = MemberExpression(statement.declarations[0].init, Identifier(name));
      } else {
        assert$2.fail("Unexpected type:" + statement.type);
      }

      return this;
    };

    _proto.read = function read(name) {
      this._resultName = MemberExpression(this._resultName, Identifier(name));
    };

    return ImportBuilder;
  }();

  function isModule(path) {
    var sourceType = path.node.sourceType;

    if (sourceType !== "module" && sourceType !== "script") {
      throw path.buildCodeFrameError("Unknown sourceType \"" + sourceType + "\", cannot transform.");
    }

    return path.node.sourceType === "module";
  }

  var ImportInjector = function () {
    function ImportInjector(path, importedSource, opts) {
      this._defaultOpts = {
        importedSource: null,
        importedType: "commonjs",
        importedInterop: "babel",
        importingInterop: "babel",
        ensureLiveReference: false,
        ensureNoContext: false
      };
      var programPath = path.find(function (p) {
        return p.isProgram();
      });
      this._programPath = programPath;
      this._programScope = programPath.scope;
      this._hub = programPath.hub;
      this._defaultOpts = this._applyDefaults(importedSource, opts, true);
    }

    var _proto = ImportInjector.prototype;

    _proto.addDefault = function addDefault(importedSourceIn, opts) {
      return this.addNamed("default", importedSourceIn, opts);
    };

    _proto.addNamed = function addNamed(importName, importedSourceIn, opts) {
      assert$2(typeof importName === "string");
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
    };

    _proto.addNamespace = function addNamespace(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
    };

    _proto.addSideEffect = function addSideEffect(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), false);
    };

    _proto._applyDefaults = function _applyDefaults(importedSource, opts, isInit) {
      if (isInit === void 0) {
        isInit = false;
      }

      var optsList = [];

      if (typeof importedSource === "string") {
        optsList.push({
          importedSource: importedSource
        });
        optsList.push(opts);
      } else {
        assert$2(!opts, "Unexpected secondary arguments.");
        optsList.push(importedSource);
      }

      var newOpts = Object.assign({}, this._defaultOpts);

      var _loop = function _loop() {
        var opts = _optsList[_i];
        if (!opts) return "continue";
        Object.keys(newOpts).forEach(function (key) {
          if (opts[key] !== undefined) newOpts[key] = opts[key];
        });

        if (!isInit) {
          if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;
          if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;
        }
      };

      for (var _i = 0, _optsList = optsList; _i < _optsList.length; _i++) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }

      return newOpts;
    };

    _proto._generateImport = function _generateImport(opts, importName) {
      var isDefault = importName === "default";
      var isNamed = !!importName && !isDefault;
      var isNamespace = importName === null;
      var importedSource = opts.importedSource,
          importedType = opts.importedType,
          importedInterop = opts.importedInterop,
          importingInterop = opts.importingInterop,
          ensureLiveReference = opts.ensureLiveReference,
          ensureNoContext = opts.ensureNoContext,
          nameHint = opts.nameHint,
          blockHoist = opts.blockHoist;
      var name = nameHint || importName;
      var isMod = isModule(this._programPath);
      var isModuleForNode = isMod && importingInterop === "node";
      var isModuleForBabel = isMod && importingInterop === "babel";
      var builder = new ImportBuilder(importedSource, this._programScope, this._hub);

      if (importedType === "es6") {
        if (!isModuleForNode && !isModuleForBabel) {
          throw new Error("Cannot import an ES6 module from CommonJS");
        }

        builder["import"]();

        if (isNamespace) {
          builder.namespace(nameHint || importedSource);
        } else if (isDefault || isNamed) {
          builder.named(name, importName);
        }
      } else if (importedType !== "commonjs") {
        throw new Error("Unexpected interopType \"" + importedType + "\"");
      } else if (importedInterop === "babel") {
        if (isModuleForNode) {
          name = name !== "default" ? name : importedSource;
          var es6Default = importedSource + "$es6Default";
          builder["import"]();

          if (isNamespace) {
            builder["default"](es6Default)["var"](name || importedSource).wildcardInterop();
          } else if (isDefault) {
            if (ensureLiveReference) {
              builder["default"](es6Default)["var"](name || importedSource).defaultInterop().read("default");
            } else {
              builder["default"](es6Default)["var"](name).defaultInterop().prop(importName);
            }
          } else if (isNamed) {
            builder["default"](es6Default).read(importName);
          }
        } else if (isModuleForBabel) {
          builder["import"]();

          if (isNamespace) {
            builder.namespace(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();

          if (isNamespace) {
            builder["var"](name || importedSource).wildcardInterop();
          } else if ((isDefault || isNamed) && ensureLiveReference) {
            if (isDefault) {
              name = name !== "default" ? name : importedSource;
              builder["var"](name).read(importName);
              builder.defaultInterop();
            } else {
              builder["var"](importedSource).read(importName);
            }
          } else if (isDefault) {
            builder["var"](name).defaultInterop().prop(importName);
          } else if (isNamed) {
            builder["var"](name).prop(importName);
          }
        }
      } else if (importedInterop === "compiled") {
        if (isModuleForNode) {
          builder["import"]();

          if (isNamespace) {
            builder["default"](name || importedSource);
          } else if (isDefault || isNamed) {
            builder["default"](importedSource).read(name);
          }
        } else if (isModuleForBabel) {
          builder["import"]();

          if (isNamespace) {
            builder.namespace(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();

          if (isNamespace) {
            builder["var"](name || importedSource);
          } else if (isDefault || isNamed) {
            if (ensureLiveReference) {
              builder["var"](importedSource).read(name);
            } else {
              builder.prop(importName)["var"](name);
            }
          }
        }
      } else if (importedInterop === "uncompiled") {
        if (isDefault && ensureLiveReference) {
          throw new Error("No live reference for commonjs default");
        }

        if (isModuleForNode) {
          builder["import"]();

          if (isNamespace) {
            builder["default"](name || importedSource);
          } else if (isDefault) {
            builder["default"](name);
          } else if (isNamed) {
            builder["default"](importedSource).read(name);
          }
        } else if (isModuleForBabel) {
          builder["import"]();

          if (isNamespace) {
            builder["default"](name || importedSource);
          } else if (isDefault) {
            builder["default"](name);
          } else if (isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();

          if (isNamespace) {
            builder["var"](name || importedSource);
          } else if (isDefault) {
            builder["var"](name);
          } else if (isNamed) {
            if (ensureLiveReference) {
              builder["var"](importedSource).read(name);
            } else {
              builder["var"](name).prop(importName);
            }
          }
        }
      } else {
        throw new Error("Unknown importedInterop \"" + importedInterop + "\".");
      }

      var _builder$done = builder.done(),
          statements = _builder$done.statements,
          resultName = _builder$done.resultName;

      this._insertStatements(statements, blockHoist);

      if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") {
        return SequenceExpression([NumericLiteral(0), resultName]);
      }

      return resultName;
    };

    _proto._insertStatements = function _insertStatements(statements, blockHoist) {
      if (blockHoist === void 0) {
        blockHoist = 3;
      }

      statements.forEach(function (node) {
        node._blockHoist = blockHoist;
      });

      var targetPath = this._programPath.get("body").find(function (p) {
        var val = p.node._blockHoist;
        return Number.isFinite(val) && val < 4;
      });

      if (targetPath) {
        targetPath.insertBefore(statements);
      } else {
        this._programPath.unshiftContainer("body", statements);
      }
    };

    return ImportInjector;
  }();

  function addDefault(path, importedSource, opts) {
    return new ImportInjector(path).addDefault(importedSource, opts);
  }
  function addNamed(path, name, importedSource, opts) {
    return new ImportInjector(path).addNamed(name, importedSource, opts);
  }
  function addNamespace(path, importedSource, opts) {
    return new ImportInjector(path).addNamespace(importedSource, opts);
  }
  function addSideEffect(path, importedSource, opts) {
    return new ImportInjector(path).addSideEffect(importedSource, opts);
  }

  var AssignmentMemoiser = function () {
    function AssignmentMemoiser() {
      this._map = new WeakMap();
    }

    var _proto = AssignmentMemoiser.prototype;

    _proto.has = function has(key) {
      return this._map.has(key);
    };

    _proto.get = function get(key) {
      if (!this.has(key)) return;

      var record = this._map.get(key);

      var value = record.value;
      record.count--;

      if (record.count === 0) {
        return AssignmentExpression("=", value, key);
      }

      return value;
    };

    _proto.set = function set(key, value, count) {
      return this._map.set(key, {
        count: count,
        value: value
      });
    };

    return AssignmentMemoiser;
  }();

  var handle = {
    memoise: function memoise() {},
    handle: function handle(member) {
      var node = member.node,
          parent = member.parent,
          parentPath = member.parentPath;

      if (parentPath.isUpdateExpression({
        argument: node
      })) {
        var operator = parent.operator,
            prefix = parent.prefix;
        this.memoise(member, 2);
        var value = BinaryExpression(operator[0], UnaryExpression("+", this.get(member)), NumericLiteral(1));

        if (prefix) {
          parentPath.replaceWith(this.set(member, value));
        } else {
          var scope = member.scope;
          var ref = scope.generateUidIdentifierBasedOnNode(node);
          scope.push({
            id: ref
          });
          value.left = AssignmentExpression("=", cloneNode(ref), value.left);
          parentPath.replaceWith(SequenceExpression([this.set(member, value), cloneNode(ref)]));
        }

        return;
      }

      if (parentPath.isAssignmentExpression({
        left: node
      })) {
        var _operator = parent.operator,
            right = parent.right;
        var _value = right;

        if (_operator !== "=") {
          this.memoise(member, 2);
          _value = BinaryExpression(_operator.slice(0, -1), this.get(member), _value);
        }

        parentPath.replaceWith(this.set(member, _value));
        return;
      }

      if (parentPath.isCallExpression({
        callee: node
      })) {
        var args = parent.arguments;
        parentPath.replaceWith(this.call(member, args));
        return;
      }

      if (parentPath.isObjectProperty({
        value: node
      }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({
        left: node
      }) && parentPath.parentPath.isObjectProperty({
        value: parent
      }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({
        left: node
      }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {
        member.replaceWith(this.destructureSet(member));
        return;
      }

      member.replaceWith(this.get(member));
    }
  };
  function memberExpressionToFunctions(path, visitor, state) {
    path.traverse(visitor, Object.assign({}, handle, {}, state, {
      memoiser: new AssignmentMemoiser()
    }));
  }

  function optimiseCall (callee, thisNode, args) {
    if (args.length === 1 && isSpreadElement(args[0]) && isIdentifier(args[0].argument, {
      name: "arguments"
    })) {
      return CallExpression(MemberExpression(callee, Identifier("apply")), [thisNode, args[0].argument]);
    } else {
      return CallExpression(MemberExpression(callee, Identifier("call")), [thisNode].concat(args));
    }
  }

  function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
    objectRef = cloneNode(objectRef);
    var targetRef = isStatic || isPrivateMethod ? objectRef : MemberExpression(objectRef, Identifier("prototype"));
    return CallExpression(file.addHelper("getPrototypeOf"), [targetRef]);
  }

  function skipAllButComputedKey(path) {
    if (!path.node.computed) {
      path.skip();
      return;
    }

    var keys = VISITOR_KEYS[path.type];

    for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var key = _ref;
      if (key !== "key") path.skipKey(key);
    }
  }
  var environmentVisitor = {
    TypeAnnotation: function TypeAnnotation(path) {
      path.skip();
    },
    Function: function Function(path) {
      if (path.isMethod()) return;
      if (path.isArrowFunctionExpression()) return;
      path.skip();
    },
    "Method|ClassProperty|ClassPrivateProperty": function MethodClassPropertyClassPrivateProperty(path) {
      skipAllButComputedKey(path);
    }
  };
  var visitor$1 = traverse$1.visitors.merge([environmentVisitor, {
    Super: function Super(path, state) {
      var node = path.node,
          parentPath = path.parentPath;
      if (!parentPath.isMemberExpression({
        object: node
      })) return;
      state.handle(parentPath);
    }
  }]);
  var specHandlers = {
    memoise: function memoise(superMember, count) {
      var scope = superMember.scope,
          node = superMember.node;
      var computed = node.computed,
          property = node.property;

      if (!computed) {
        return;
      }

      var memo = scope.maybeGenerateMemoised(property);

      if (!memo) {
        return;
      }

      this.memoiser.set(property, memo, count);
    },
    prop: function prop(superMember) {
      var _superMember$node = superMember.node,
          computed = _superMember$node.computed,
          property = _superMember$node.property;

      if (this.memoiser.has(property)) {
        return cloneNode(this.memoiser.get(property));
      }

      if (computed) {
        return cloneNode(property);
      }

      return StringLiteral(property.name);
    },
    get: function get(superMember) {
      return CallExpression(this.file.addHelper("get"), [getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod), this.prop(superMember), ThisExpression()]);
    },
    set: function set(superMember, value) {
      return CallExpression(this.file.addHelper("set"), [getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod), this.prop(superMember), value, ThisExpression(), BooleanLiteral(superMember.isInStrictMode())]);
    },
    destructureSet: function destructureSet(superMember) {
      throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
    },
    call: function call(superMember, args) {
      return optimiseCall(this.get(superMember), ThisExpression(), args);
    }
  };
  var looseHandlers = Object.assign({}, specHandlers, {
    prop: function prop(superMember) {
      var property = superMember.node.property;

      if (this.memoiser.has(property)) {
        return cloneNode(this.memoiser.get(property));
      }

      return cloneNode(property);
    },
    get: function get(superMember) {
      var isStatic = this.isStatic,
          superRef = this.superRef;
      var computed = superMember.node.computed;
      var prop = this.prop(superMember);
      var object;

      if (isStatic) {
        object = superRef ? cloneNode(superRef) : MemberExpression(Identifier("Function"), Identifier("prototype"));
      } else {
        object = superRef ? MemberExpression(cloneNode(superRef), Identifier("prototype")) : MemberExpression(Identifier("Object"), Identifier("prototype"));
      }

      return MemberExpression(object, prop, computed);
    },
    set: function set(superMember, value) {
      var computed = superMember.node.computed;
      var prop = this.prop(superMember);
      return AssignmentExpression("=", MemberExpression(ThisExpression(), prop, computed), value);
    },
    destructureSet: function destructureSet(superMember) {
      var computed = superMember.node.computed;
      var prop = this.prop(superMember);
      return MemberExpression(ThisExpression(), prop, computed);
    }
  });

  var ReplaceSupers = function () {
    function ReplaceSupers(opts) {
      var path = opts.methodPath;
      this.methodPath = path;
      this.isStatic = path.isObjectMethod() || path.node["static"];
      this.isPrivateMethod = path.isPrivate() && path.isMethod();
      this.file = opts.file;
      this.superRef = opts.superRef;
      this.isLoose = opts.isLoose;
      this.opts = opts;
    }

    var _proto = ReplaceSupers.prototype;

    _proto.getObjectRef = function getObjectRef() {
      return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
    };

    _proto.replace = function replace() {
      var handler = this.isLoose ? looseHandlers : specHandlers;
      memberExpressionToFunctions(this.methodPath, visitor$1, Object.assign({
        file: this.file,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        superRef: this.superRef
      }, handler));
    };

    return ReplaceSupers;
  }();

  function rewriteThis(programPath) {
    programPath.traverse(rewriteThisVisitor);
  }
  var rewriteThisVisitor = {
    ThisExpression: function ThisExpression(path) {
      path.replaceWith(path.scope.buildUndefinedNode());
    },
    Function: function Function(path) {
      if (path.isMethod()) skipAllButComputedKey(path);else if (!path.isArrowFunctionExpression()) path.skip();
    },
    ClassProperty: function ClassProperty(path) {
      skipAllButComputedKey(path);
    },
    ClassPrivateProperty: function ClassPrivateProperty(path) {
      path.skip();
    }
  };

  function simplifyAccess(path, bindingNames) {
    path.traverse(simpleAssignmentVisitor, {
      scope: path.scope,
      bindingNames: bindingNames,
      seen: new WeakSet()
    });
  }
  var simpleAssignmentVisitor = {
    UpdateExpression: {
      exit: function exit(path) {
        var scope = this.scope,
            bindingNames = this.bindingNames;
        var arg = path.get("argument");
        if (!arg.isIdentifier()) return;
        var localName = arg.node.name;
        if (!bindingNames.has(localName)) return;

        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
          return;
        }

        if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {
          var operator = path.node.operator == "++" ? "+=" : "-=";
          path.replaceWith(AssignmentExpression(operator, arg.node, NumericLiteral(1)));
        } else if (path.node.prefix) {
          path.replaceWith(AssignmentExpression("=", Identifier(localName), BinaryExpression(path.node.operator[0], UnaryExpression("+", arg.node), NumericLiteral(1))));
        } else {
          var old = path.scope.generateUidIdentifierBasedOnNode(arg.node, "old");
          var varName = old.name;
          path.scope.push({
            id: old
          });
          var binary = BinaryExpression(path.node.operator[0], Identifier(varName), NumericLiteral(1));
          path.replaceWith(SequenceExpression([AssignmentExpression("=", Identifier(varName), UnaryExpression("+", arg.node)), AssignmentExpression("=", cloneNode(arg.node), binary), Identifier(varName)]));
        }
      }
    },
    AssignmentExpression: {
      exit: function exit(path) {
        var scope = this.scope,
            seen = this.seen,
            bindingNames = this.bindingNames;
        if (path.node.operator === "=") return;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        var left = path.get("left");
        if (!left.isIdentifier()) return;
        var localName = left.node.name;
        if (!bindingNames.has(localName)) return;

        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
          return;
        }

        path.node.right = BinaryExpression(path.node.operator.slice(0, -1), cloneNode(path.node.left), path.node.right);
        path.node.operator = "=";
      }
    }
  };

  function _templateObject$1() {
    var data = _taggedTemplateLiteralLoose(["\n    (function() {\n      throw new Error('\"' + '", "' + '\" is read-only.');\n    })()\n  "]);

    _templateObject$1 = function _templateObject() {
      return data;
    };

    return data;
  }
  function rewriteLiveReferences(programPath, metadata) {
    var imported = new Map();
    var exported = new Map();

    var requeueInParent = function requeueInParent(path) {
      programPath.requeue(path);
    };

    for (var _iterator = metadata.source, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var _ref4 = _ref,
          source = _ref4[0],
          data = _ref4[1];

      for (var _iterator3 = data.imports, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref5;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref5 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref5 = _i3.value;
        }

        var _ref7 = _ref5,
            localName = _ref7[0],
            importName = _ref7[1];
        imported.set(localName, [source, importName, null]);
      }

      for (var _iterator4 = data.importsNamespace, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref6;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref6 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref6 = _i4.value;
        }

        var _localName = _ref6;
        imported.set(_localName, [source, null, _localName]);
      }
    }

    for (var _iterator2 = metadata.local, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _exportMeta;

      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var _ref8 = _ref2,
          local = _ref8[0],
          _data = _ref8[1];
      var exportMeta = exported.get(local);

      if (!exportMeta) {
        exportMeta = [];
        exported.set(local, exportMeta);
      }

      (_exportMeta = exportMeta).push.apply(_exportMeta, _data.names);
    }

    programPath.traverse(rewriteBindingInitVisitor, {
      metadata: metadata,
      requeueInParent: requeueInParent,
      scope: programPath.scope,
      exported: exported
    });
    simplifyAccess(programPath, new Set([].concat(Array.from(imported.keys()), Array.from(exported.keys()))));
    programPath.traverse(rewriteReferencesVisitor, {
      seen: new WeakSet(),
      metadata: metadata,
      requeueInParent: requeueInParent,
      scope: programPath.scope,
      imported: imported,
      exported: exported,
      buildImportReference: function buildImportReference(_ref3, identNode) {
        var source = _ref3[0],
            importName = _ref3[1],
            localName = _ref3[2];
        var meta = metadata.source.get(source);

        if (localName) {
          if (meta.lazy) identNode = CallExpression(identNode, []);
          return identNode;
        }

        var namespace = Identifier(meta.name);
        if (meta.lazy) namespace = CallExpression(namespace, []);
        return MemberExpression(namespace, Identifier(importName));
      }
    });
  }
  var rewriteBindingInitVisitor = {
    Scope: function Scope(path) {
      path.skip();
    },
    ClassDeclaration: function ClassDeclaration(path) {
      var requeueInParent = this.requeueInParent,
          exported = this.exported,
          metadata = this.metadata;
      var id = path.node.id;
      if (!id) throw new Error("Expected class to have a name");
      var localName = id.name;
      var exportNames = exported.get(localName) || [];

      if (exportNames.length > 0) {
        var statement = ExpressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, Identifier(localName)));
        statement._blockHoist = path.node._blockHoist;
        requeueInParent(path.insertAfter(statement)[0]);
      }
    },
    VariableDeclaration: function VariableDeclaration(path) {
      var requeueInParent = this.requeueInParent,
          exported = this.exported,
          metadata = this.metadata;
      Object.keys(path.getOuterBindingIdentifiers()).forEach(function (localName) {
        var exportNames = exported.get(localName) || [];

        if (exportNames.length > 0) {
          var statement = ExpressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, Identifier(localName)));
          statement._blockHoist = path.node._blockHoist;
          requeueInParent(path.insertAfter(statement)[0]);
        }
      });
    }
  };

  var buildBindingExportAssignmentExpression = function buildBindingExportAssignmentExpression(metadata, exportNames, localExpr) {
    return (exportNames || []).reduce(function (expr, exportName) {
      return AssignmentExpression("=", MemberExpression(Identifier(metadata.exportName), Identifier(exportName)), expr);
    }, localExpr);
  };

  var buildImportThrow = function buildImportThrow(localName) {
    return template.expression.ast(_templateObject$1(), localName);
  };

  var rewriteReferencesVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(path) {
      var seen = this.seen,
          buildImportReference = this.buildImportReference,
          scope = this.scope,
          imported = this.imported,
          requeueInParent = this.requeueInParent;
      if (seen.has(path.node)) return;
      seen.add(path.node);
      var localName = path.node.name;
      var localBinding = path.scope.getBinding(localName);
      var rootBinding = scope.getBinding(localName);
      if (rootBinding !== localBinding) return;
      var importData = imported.get(localName);

      if (importData) {
        var ref = buildImportReference(importData, path.node);
        ref.loc = path.node.loc;

        if ((path.parentPath.isCallExpression({
          callee: path.node
        }) || path.parentPath.isOptionalCallExpression({
          callee: path.node
        }) || path.parentPath.isTaggedTemplateExpression({
          tag: path.node
        })) && isMemberExpression(ref)) {
          path.replaceWith(SequenceExpression([NumericLiteral(0), ref]));
        } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {
          var object = ref.object,
              property = ref.property;
          path.replaceWith(JSXMemberExpression(JSXIdentifier(object.name), JSXIdentifier(property.name)));
        } else {
          path.replaceWith(ref);
        }

        requeueInParent(path);
        path.skip();
      }
    },
    AssignmentExpression: {
      exit: function exit(path) {
        var _this = this;

        var scope = this.scope,
            seen = this.seen,
            imported = this.imported,
            exported = this.exported,
            requeueInParent = this.requeueInParent,
            buildImportReference = this.buildImportReference;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        var left = path.get("left");
        if (left.isMemberExpression()) return;

        if (left.isIdentifier()) {
          var localName = left.node.name;

          if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
            return;
          }

          var exportedNames = exported.get(localName);
          var importData = imported.get(localName);

          if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
            assert$2(path.node.operator === "=", "Path was not simplified");
            var assignment = path.node;

            if (importData) {
              assignment.left = buildImportReference(importData, assignment.left);
              assignment.right = SequenceExpression([assignment.right, buildImportThrow(localName)]);
            }

            path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));
            requeueInParent(path);
          }
        } else {
          var ids = left.getOuterBindingIdentifiers();
          var programScopeIds = Object.keys(ids).filter(function (localName) {
            return scope.getBinding(localName) === path.scope.getBinding(localName);
          });
          var id = programScopeIds.find(function (localName) {
            return imported.has(localName);
          });

          if (id) {
            path.node.right = SequenceExpression([path.node.right, buildImportThrow(id)]);
          }

          var items = [];
          programScopeIds.forEach(function (localName) {
            var exportedNames = exported.get(localName) || [];

            if (exportedNames.length > 0) {
              items.push(buildBindingExportAssignmentExpression(_this.metadata, exportedNames, Identifier(localName)));
            }
          });

          if (items.length > 0) {
            var node = SequenceExpression(items);

            if (path.parentPath.isExpressionStatement()) {
              node = ExpressionStatement(node);
              node._blockHoist = path.parentPath.node._blockHoist;
            }

            var statement = path.insertAfter(node)[0];
            requeueInParent(statement);
          }
        }
      }
    },
    "ForOfStatement|ForInStatement": function ForOfStatementForInStatement(path) {
      var scope = path.scope,
          node = path.node;
      var left = node.left;
      var exported = this.exported,
          programScope = this.scope;

      if (!isVariableDeclaration(left)) {
        var didTransform = false;
        var bodyPath = path.get("body");
        var loopBodyScope = bodyPath.scope;

        for (var _i5 = 0, _Object$keys = Object.keys(getOuterBindingIdentifiers(left)); _i5 < _Object$keys.length; _i5++) {
          var name = _Object$keys[_i5];

          if (exported.get(name) && programScope.getBinding(name) === scope.getBinding(name)) {
            didTransform = true;

            if (loopBodyScope.hasOwnBinding(name)) {
              loopBodyScope.rename(name);
            }
          }
        }

        if (!didTransform) {
          return;
        }

        var newLoopId = scope.generateUidIdentifierBasedOnNode(left);
        bodyPath.unshiftContainer("body", ExpressionStatement(AssignmentExpression("=", left, newLoopId)));
        path.get("left").replaceWith(VariableDeclaration("let", [VariableDeclarator(newLoopId)]));
        scope.registerDeclaration(path.get("left"));
      }
    }
  };

  function normalizeArray(parts, allowAboveRoot) {
    var up = 0;

    for (var i = parts.length - 1; i >= 0; i--) {
      var last = parts[i];

      if (last === '.') {
        parts.splice(i, 1);
      } else if (last === '..') {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
    }

    if (allowAboveRoot) {
      for (; up--; up) {
        parts.unshift('..');
      }
    }

    return parts;
  }

  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;

  var splitPath = function splitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  function resolve$1() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = i >= 0 ? arguments[i] : '/';

      if (typeof path !== 'string') {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
      return !!p;
    }), !resolvedAbsolute).join('/');
    return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
  }
  function normalize(path) {
    var isPathAbsolute = isAbsolute(path),
        trailingSlash = substr(path, -1) === '/';
    path = normalizeArray(filter(path.split('/'), function (p) {
      return !!p;
    }), !isPathAbsolute).join('/');

    if (!path && !isPathAbsolute) {
      path = '.';
    }

    if (path && trailingSlash) {
      path += '/';
    }

    return (isPathAbsolute ? '/' : '') + path;
  }
  function isAbsolute(path) {
    return path.charAt(0) === '/';
  }
  function join() {
    var paths = Array.prototype.slice.call(arguments, 0);
    return normalize(filter(paths, function (p, index) {
      if (typeof p !== 'string') {
        throw new TypeError('Arguments to path.join must be strings');
      }

      return p;
    }).join('/'));
  }
  function relative(from, to) {
    from = resolve$1(from).substr(1);
    to = resolve$1(to).substr(1);

    function trim(arr) {
      var start = 0;

      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;

      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end - start + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;

    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];

    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join('/');
  }
  var sep = '/';
  var delimiter = ':';
  function dirname(path) {
    var result = splitPath(path),
        root = result[0],
        dir = result[1];

    if (!root && !dir) {
      return '.';
    }

    if (dir) {
      dir = dir.substr(0, dir.length - 1);
    }

    return root + dir;
  }
  function basename(path, ext) {
    var f = splitPath(path)[2];

    if (ext && f.substr(-1 * ext.length) === ext) {
      f = f.substr(0, f.length - ext.length);
    }

    return f;
  }
  function extname(path) {
    return splitPath(path)[3];
  }
  var path$1 = {
    extname: extname,
    basename: basename,
    dirname: dirname,
    sep: sep,
    delimiter: delimiter,
    relative: relative,
    join: join,
    isAbsolute: isAbsolute,
    normalize: normalize,
    resolve: resolve$1
  };

  function filter(xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];

    for (var i = 0; i < xs.length; i++) {
      if (f(xs[i], i, xs)) res.push(xs[i]);
    }

    return res;
  }

  var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
    return str.substr(start, len);
  } : function (str, start, len) {
    if (start < 0) start = str.length + start;
    return str.substr(start, len);
  };

  function hasExports(metadata) {
    return metadata.hasExports;
  }
  function isSideEffectImport(source) {
    return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
  }
  function normalizeModuleAndLoadMetadata(programPath, exportName, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$noInterop = _ref.noInterop,
        noInterop = _ref$noInterop === void 0 ? false : _ref$noInterop,
        _ref$loose = _ref.loose,
        loose = _ref$loose === void 0 ? false : _ref$loose,
        _ref$lazy = _ref.lazy,
        lazy = _ref$lazy === void 0 ? false : _ref$lazy,
        _ref$esNamespaceOnly = _ref.esNamespaceOnly,
        esNamespaceOnly = _ref$esNamespaceOnly === void 0 ? false : _ref$esNamespaceOnly;

    if (!exportName) {
      exportName = programPath.scope.generateUidIdentifier("exports").name;
    }

    nameAnonymousExports(programPath);

    var _getModuleMetadata = getModuleMetadata(programPath, {
      loose: loose,
      lazy: lazy
    }),
        local = _getModuleMetadata.local,
        source = _getModuleMetadata.source,
        hasExports = _getModuleMetadata.hasExports;

    removeModuleDeclarations(programPath);

    for (var _iterator = source, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref2 = _i.value;
      }

      var _ref3 = _ref2,
          metadata = _ref3[1];

      if (metadata.importsNamespace.size > 0) {
        metadata.name = metadata.importsNamespace.values().next().value;
      }

      if (noInterop) metadata.interop = "none";else if (esNamespaceOnly) {
        if (metadata.interop === "namespace") {
          metadata.interop = "default";
        }
      }
    }

    return {
      exportName: exportName,
      exportNameListName: null,
      hasExports: hasExports,
      local: local,
      source: source
    };
  }

  function getModuleMetadata(programPath, _ref4) {
    var loose = _ref4.loose,
        lazy = _ref4.lazy;
    var localData = getLocalExportMetadata(programPath, loose);
    var sourceData = new Map();

    var getData = function getData(sourceNode) {
      var source = sourceNode.value;
      var data = sourceData.get(source);

      if (!data) {
        data = {
          name: programPath.scope.generateUidIdentifier(basename(source, extname(source))).name,
          interop: "none",
          loc: null,
          imports: new Map(),
          importsNamespace: new Set(),
          reexports: new Map(),
          reexportNamespace: new Set(),
          reexportAll: null,
          lazy: false
        };
        sourceData.set(source, data);
      }

      return data;
    };

    var hasExports = false;
    programPath.get("body").forEach(function (child) {
      if (child.isImportDeclaration()) {
        var data = getData(child.node.source);
        if (!data.loc) data.loc = child.node.loc;
        child.get("specifiers").forEach(function (spec) {
          if (spec.isImportDefaultSpecifier()) {
            var localName = spec.get("local").node.name;
            data.imports.set(localName, "default");
            var reexport = localData.get(localName);

            if (reexport) {
              localData["delete"](localName);
              reexport.names.forEach(function (name) {
                data.reexports.set(name, "default");
              });
            }
          } else if (spec.isImportNamespaceSpecifier()) {
            var _localName = spec.get("local").node.name;
            data.importsNamespace.add(_localName);

            var _reexport = localData.get(_localName);

            if (_reexport) {
              localData["delete"](_localName);

              _reexport.names.forEach(function (name) {
                data.reexportNamespace.add(name);
              });
            }
          } else if (spec.isImportSpecifier()) {
            var importName = spec.get("imported").node.name;
            var _localName2 = spec.get("local").node.name;
            data.imports.set(_localName2, importName);

            var _reexport2 = localData.get(_localName2);

            if (_reexport2) {
              localData["delete"](_localName2);

              _reexport2.names.forEach(function (name) {
                data.reexports.set(name, importName);
              });
            }
          }
        });
      } else if (child.isExportAllDeclaration()) {
        hasExports = true;

        var _data = getData(child.node.source);

        if (!_data.loc) _data.loc = child.node.loc;
        _data.reexportAll = {
          loc: child.node.loc
        };
      } else if (child.isExportNamedDeclaration() && child.node.source) {
        hasExports = true;

        var _data2 = getData(child.node.source);

        if (!_data2.loc) _data2.loc = child.node.loc;
        child.get("specifiers").forEach(function (spec) {
          if (!spec.isExportSpecifier()) {
            throw spec.buildCodeFrameError("Unexpected export specifier type");
          }

          var importName = spec.get("local").node.name;
          var exportName = spec.get("exported").node.name;

          _data2.reexports.set(exportName, importName);

          if (exportName === "__esModule") {
            throw exportName.buildCodeFrameError('Illegal export "__esModule".');
          }
        });
      } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
        hasExports = true;
      }
    });

    for (var _iterator2 = sourceData.values(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref5 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref5 = _i2.value;
      }

      var metadata = _ref5;
      var needsDefault = false;
      var needsNamed = false;

      if (metadata.importsNamespace.size > 0) {
        needsDefault = true;
        needsNamed = true;
      }

      if (metadata.reexportAll) {
        needsNamed = true;
      }

      for (var _iterator4 = metadata.imports.values(), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref7;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref7 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref7 = _i4.value;
        }

        var importName = _ref7;
        if (importName === "default") needsDefault = true;else needsNamed = true;
      }

      for (var _iterator5 = metadata.reexports.values(), _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
        var _ref8;

        if (_isArray5) {
          if (_i5 >= _iterator5.length) break;
          _ref8 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done) break;
          _ref8 = _i5.value;
        }

        var _importName = _ref8;
        if (_importName === "default") needsDefault = true;else needsNamed = true;
      }

      if (needsDefault && needsNamed) {
        metadata.interop = "namespace";
      } else if (needsDefault) {
        metadata.interop = "default";
      }
    }

    for (var _iterator3 = sourceData, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref6;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref6 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref6 = _i3.value;
      }

      var _ref9 = _ref6,
          source = _ref9[0],
          _metadata = _ref9[1];

      if (lazy !== false && !(isSideEffectImport(_metadata) || _metadata.reexportAll)) {
        if (lazy === true) {
          _metadata.lazy = !/\./.test(source);
        } else if (Array.isArray(lazy)) {
          _metadata.lazy = lazy.indexOf(source) !== -1;
        } else if (typeof lazy === "function") {
          _metadata.lazy = lazy(source);
        } else {
          throw new Error(".lazy must be a boolean, string array, or function");
        }
      }
    }

    return {
      hasExports: hasExports,
      local: localData,
      source: sourceData
    };
  }

  function getLocalExportMetadata(programPath, loose) {
    var bindingKindLookup = new Map();
    programPath.get("body").forEach(function (child) {
      var kind;

      if (child.isImportDeclaration()) {
        kind = "import";
      } else {
        if (child.isExportDefaultDeclaration()) child = child.get("declaration");

        if (child.isExportNamedDeclaration()) {
          if (child.node.declaration) {
            child = child.get("declaration");
          } else if (loose && child.node.source && child.get("source").isStringLiteral()) {
            child.node.specifiers.forEach(function (specifier) {
              bindingKindLookup.set(specifier.local.name, "block");
            });
            return;
          }
        }

        if (child.isFunctionDeclaration()) {
          kind = "hoisted";
        } else if (child.isClassDeclaration()) {
          kind = "block";
        } else if (child.isVariableDeclaration({
          kind: "var"
        })) {
          kind = "var";
        } else if (child.isVariableDeclaration()) {
          kind = "block";
        } else {
          return;
        }
      }

      Object.keys(child.getOuterBindingIdentifiers()).forEach(function (name) {
        bindingKindLookup.set(name, kind);
      });
    });
    var localMetadata = new Map();

    var getLocalMetadata = function getLocalMetadata(idPath) {
      var localName = idPath.node.name;
      var metadata = localMetadata.get(localName);

      if (!metadata) {
        var kind = bindingKindLookup.get(localName);

        if (kind === undefined) {
          throw idPath.buildCodeFrameError("Exporting local \"" + localName + "\", which is not declared.");
        }

        metadata = {
          names: [],
          kind: kind
        };
        localMetadata.set(localName, metadata);
      }

      return metadata;
    };

    programPath.get("body").forEach(function (child) {
      if (child.isExportNamedDeclaration() && (loose || !child.node.source)) {
        if (child.node.declaration) {
          var declaration = child.get("declaration");
          var ids = declaration.getOuterBindingIdentifierPaths();
          Object.keys(ids).forEach(function (name) {
            if (name === "__esModule") {
              throw declaration.buildCodeFrameError('Illegal export "__esModule".');
            }

            getLocalMetadata(ids[name]).names.push(name);
          });
        } else {
          child.get("specifiers").forEach(function (spec) {
            var local = spec.get("local");
            var exported = spec.get("exported");

            if (exported.node.name === "__esModule") {
              throw exported.buildCodeFrameError('Illegal export "__esModule".');
            }

            getLocalMetadata(local).names.push(exported.node.name);
          });
        }
      } else if (child.isExportDefaultDeclaration()) {
        var _declaration = child.get("declaration");

        if (_declaration.isFunctionDeclaration() || _declaration.isClassDeclaration()) {
          getLocalMetadata(_declaration.get("id")).names.push("default");
        } else {
          throw _declaration.buildCodeFrameError("Unexpected default expression export.");
        }
      }
    });
    return localMetadata;
  }

  function nameAnonymousExports(programPath) {
    programPath.get("body").forEach(function (child) {
      if (!child.isExportDefaultDeclaration()) return;
      splitExportDeclaration(child);
    });
  }

  function removeModuleDeclarations(programPath) {
    programPath.get("body").forEach(function (child) {
      if (child.isImportDeclaration()) {
        child.remove();
      } else if (child.isExportNamedDeclaration()) {
        if (child.node.declaration) {
          child.node.declaration._blockHoist = child.node._blockHoist;
          child.replaceWith(child.node.declaration);
        } else {
          child.remove();
        }
      } else if (child.isExportDefaultDeclaration()) {
        var declaration = child.get("declaration");

        if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
          declaration._blockHoist = child.node._blockHoist;
          child.replaceWith(declaration);
        } else {
          throw declaration.buildCodeFrameError("Unexpected default expression export.");
        }
      } else if (child.isExportAllDeclaration()) {
        child.remove();
      }
    });
  }

  function getModuleName(rootOpts, pluginOpts) {
    var _pluginOpts$moduleRoo, _rootOpts$moduleIds, _rootOpts$moduleRoot;

    var filename = rootOpts.filename,
        _rootOpts$filenameRel = rootOpts.filenameRelative,
        filenameRelative = _rootOpts$filenameRel === void 0 ? filename : _rootOpts$filenameRel,
        _rootOpts$sourceRoot = rootOpts.sourceRoot,
        sourceRoot = _rootOpts$sourceRoot === void 0 ? (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot : _rootOpts$sourceRoot;
    var _pluginOpts$moduleId = pluginOpts.moduleId,
        moduleId = _pluginOpts$moduleId === void 0 ? rootOpts.moduleId : _pluginOpts$moduleId,
        _pluginOpts$moduleIds = pluginOpts.moduleIds,
        moduleIds = _pluginOpts$moduleIds === void 0 ? (_rootOpts$moduleIds = rootOpts.moduleIds) != null ? _rootOpts$moduleIds : !!moduleId : _pluginOpts$moduleIds,
        _pluginOpts$getModule = pluginOpts.getModuleId,
        getModuleId = _pluginOpts$getModule === void 0 ? rootOpts.getModuleId : _pluginOpts$getModule,
        _pluginOpts$moduleRoo2 = pluginOpts.moduleRoot,
        moduleRoot = _pluginOpts$moduleRoo2 === void 0 ? (_rootOpts$moduleRoot = rootOpts.moduleRoot) != null ? _rootOpts$moduleRoot : sourceRoot : _pluginOpts$moduleRoo2;
    if (!moduleIds) return null;

    if (moduleId != null && !getModuleId) {
      return moduleId;
    }

    var moduleName = moduleRoot != null ? moduleRoot + "/" : "";

    if (filenameRelative) {
      var sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
      moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
    }

    moduleName = moduleName.replace(/\\/g, "/");

    if (getModuleId) {
      return getModuleId(moduleName) || moduleName;
    } else {
      return moduleName;
    }
  }

  function _templateObject11$1() {
    var data = _taggedTemplateLiteralLoose(["EXPORTS.NAME = VALUE"]);

    _templateObject11$1 = function _templateObject11() {
      return data;
    };

    return data;
  }

  function _templateObject10$1() {
    var data = _taggedTemplateLiteralLoose(["\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          "]);

    _templateObject10$1 = function _templateObject10() {
      return data;
    };

    return data;
  }

  function _templateObject9$1() {
    var data = _taggedTemplateLiteralLoose(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    "]);

    _templateObject9$1 = function _templateObject9() {
      return data;
    };

    return data;
  }

  function _templateObject8$1() {
    var data = _taggedTemplateLiteralLoose(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      "]);

    _templateObject8$1 = function _templateObject8() {
      return data;
    };

    return data;
  }

  function _templateObject7$1() {
    var data = _taggedTemplateLiteralLoose(["\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      "]);

    _templateObject7$1 = function _templateObject7() {
      return data;
    };

    return data;
  }

  function _templateObject6$1() {
    var data = _taggedTemplateLiteralLoose(["\n        EXPORTS.__esModule = true;\n      "]);

    _templateObject6$1 = function _templateObject6() {
      return data;
    };

    return data;
  }

  function _templateObject5$1() {
    var data = _taggedTemplateLiteralLoose(["\n      Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n        enumerable: true,\n        get: function() {\n          return NAMESPACE.IMPORT_NAME;\n        },\n      });\n    "]);

    _templateObject5$1 = function _templateObject5() {
      return data;
    };

    return data;
  }

  function _templateObject4$1() {
    var data = _taggedTemplateLiteralLoose(["EXPORTS.EXPORT_NAME = NAMESPACE.IMPORT_NAME;"]);

    _templateObject4$1 = function _templateObject4() {
      return data;
    };

    return data;
  }

  function _templateObject3$1() {
    var data = _taggedTemplateLiteralLoose(["EXPORTS.NAME = NAMESPACE;"]);

    _templateObject3$1 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2$1() {
    var data = _taggedTemplateLiteralLoose(["\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          "]);

    _templateObject2$1 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$2() {
    var data = _taggedTemplateLiteralLoose(["var NAME = SOURCE;"]);

    _templateObject$2 = function _templateObject() {
      return data;
    };

    return data;
  }
  function rewriteModuleStatementsAndPrepareHeader(path, _ref) {
    var exportName = _ref.exportName,
        strict = _ref.strict,
        allowTopLevelThis = _ref.allowTopLevelThis,
        strictMode = _ref.strictMode,
        loose = _ref.loose,
        noInterop = _ref.noInterop,
        lazy = _ref.lazy,
        esNamespaceOnly = _ref.esNamespaceOnly;
    assert$2(isModule(path), "Cannot process module statements in a script");
    path.node.sourceType = "script";
    var meta = normalizeModuleAndLoadMetadata(path, exportName, {
      noInterop: noInterop,
      loose: loose,
      lazy: lazy,
      esNamespaceOnly: esNamespaceOnly
    });

    if (!allowTopLevelThis) {
      rewriteThis(path);
    }

    rewriteLiveReferences(path, meta);

    if (strictMode !== false) {
      var hasStrict = path.node.directives.some(function (directive) {
        return directive.value.value === "use strict";
      });

      if (!hasStrict) {
        path.unshiftContainer("directives", Directive(DirectiveLiteral("use strict")));
      }
    }

    var headers = [];

    if (hasExports(meta) && !strict) {
      headers.push(buildESModuleHeader(meta, loose));
    }

    var nameList = buildExportNameListDeclaration(path, meta);

    if (nameList) {
      meta.exportNameListName = nameList.name;
      headers.push(nameList.statement);
    }

    headers.push.apply(headers, buildExportInitializationStatements(path, meta, loose));
    return {
      meta: meta,
      headers: headers
    };
  }
  function ensureStatementsHoisted(statements) {
    statements.forEach(function (header) {
      header._blockHoist = 3;
    });
  }
  function wrapInterop(programPath, expr, type) {
    if (type === "none") {
      return null;
    }

    var helper;

    if (type === "default") {
      helper = "interopRequireDefault";
    } else if (type === "namespace") {
      helper = "interopRequireWildcard";
    } else {
      throw new Error("Unknown interop: " + type);
    }

    return CallExpression(programPath.hub.addHelper(helper), [expr]);
  }
  function buildNamespaceInitStatements(metadata, sourceMetadata, loose) {
    if (loose === void 0) {
      loose = false;
    }

    var statements = [];
    var srcNamespace = Identifier(sourceMetadata.name);
    if (sourceMetadata.lazy) srcNamespace = CallExpression(srcNamespace, []);

    for (var _iterator = sourceMetadata.importsNamespace, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref2 = _i.value;
      }

      var localName = _ref2;
      if (localName === sourceMetadata.name) continue;
      statements.push(template.statement(_templateObject$2())({
        NAME: localName,
        SOURCE: cloneNode(srcNamespace)
      }));
    }

    if (loose) {
      statements.push.apply(statements, buildReexportsFromMeta(metadata, sourceMetadata, loose));
    }

    for (var _iterator2 = sourceMetadata.reexportNamespace, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref3 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref3 = _i2.value;
      }

      var exportName = _ref3;
      statements.push((sourceMetadata.lazy ? template.statement(_templateObject2$1()) : template.statement(_templateObject3$1()))({
        EXPORTS: metadata.exportName,
        NAME: exportName,
        NAMESPACE: cloneNode(srcNamespace)
      }));
    }

    if (sourceMetadata.reexportAll) {
      var statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), loose);
      statement.loc = sourceMetadata.reexportAll.loc;
      statements.push(statement);
    }

    return statements;
  }

  var getTemplateForReexport = function getTemplateForReexport(loose) {
    return loose ? template.statement(_templateObject4$1()) : template(_templateObject5$1());
  };

  var buildReexportsFromMeta = function buildReexportsFromMeta(meta, metadata, loose) {
    var namespace = metadata.lazy ? CallExpression(Identifier(metadata.name), []) : Identifier(metadata.name);
    var templateForCurrentMode = getTemplateForReexport(loose);
    return Array.from(metadata.reexports, function (_ref4) {
      var exportName = _ref4[0],
          importName = _ref4[1];
      return templateForCurrentMode({
        EXPORTS: meta.exportName,
        EXPORT_NAME: exportName,
        NAMESPACE: cloneNode(namespace),
        IMPORT_NAME: importName
      });
    });
  };

  function buildESModuleHeader(metadata, enumerable) {
    if (enumerable === void 0) {
      enumerable = false;
    }

    return (enumerable ? template.statement(_templateObject6$1()) : template.statement(_templateObject7$1()))({
      EXPORTS: metadata.exportName
    });
  }

  function buildNamespaceReexport(metadata, namespace, loose) {
    return (loose ? template.statement(_templateObject8$1()) : template.statement(_templateObject9$1()))({
      NAMESPACE: namespace,
      EXPORTS: metadata.exportName,
      VERIFY_NAME_LIST: metadata.exportNameListName ? template(_templateObject10$1())({
        EXPORTS_LIST: metadata.exportNameListName
      }) : null
    });
  }

  function buildExportNameListDeclaration(programPath, metadata) {
    var exportedVars = Object.create(null);

    for (var _iterator3 = metadata.local.values(), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref5 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref5 = _i3.value;
      }

      var data = _ref5;

      for (var _iterator5 = data.names, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
        var _ref7;

        if (_isArray5) {
          if (_i5 >= _iterator5.length) break;
          _ref7 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done) break;
          _ref7 = _i5.value;
        }

        var _name = _ref7;
        exportedVars[_name] = true;
      }
    }

    var hasReexport = false;

    for (var _iterator4 = metadata.source.values(), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
      var _ref6;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref6 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref6 = _i4.value;
      }

      var _data = _ref6;

      for (var _iterator6 = _data.reexports.keys(), _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
        var _ref8;

        if (_isArray6) {
          if (_i6 >= _iterator6.length) break;
          _ref8 = _iterator6[_i6++];
        } else {
          _i6 = _iterator6.next();
          if (_i6.done) break;
          _ref8 = _i6.value;
        }

        var exportName = _ref8;
        exportedVars[exportName] = true;
      }

      for (var _iterator7 = _data.reexportNamespace, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
        var _ref9;

        if (_isArray7) {
          if (_i7 >= _iterator7.length) break;
          _ref9 = _iterator7[_i7++];
        } else {
          _i7 = _iterator7.next();
          if (_i7.done) break;
          _ref9 = _i7.value;
        }

        var _exportName = _ref9;
        exportedVars[_exportName] = true;
      }

      hasReexport = hasReexport || _data.reexportAll;
    }

    if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
    var name = programPath.scope.generateUidIdentifier("exportNames");
    delete exportedVars["default"];
    return {
      name: name.name,
      statement: VariableDeclaration("var", [VariableDeclarator(name, valueToNode(exportedVars))])
    };
  }

  function buildExportInitializationStatements(programPath, metadata, loose) {
    if (loose === void 0) {
      loose = false;
    }

    var initStatements = [];
    var exportNames = [];

    for (var _iterator8 = metadata.local, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
      var _ref10;

      if (_isArray8) {
        if (_i8 >= _iterator8.length) break;
        _ref10 = _iterator8[_i8++];
      } else {
        _i8 = _iterator8.next();
        if (_i8.done) break;
        _ref10 = _i8.value;
      }

      var _ref12 = _ref10,
          localName = _ref12[0],
          data = _ref12[1];

      if (data.kind === "import") ; else if (data.kind === "hoisted") {
        initStatements.push(buildInitStatement(metadata, data.names, Identifier(localName)));
      } else {
        exportNames.push.apply(exportNames, data.names);
      }
    }

    for (var _iterator9 = metadata.source.values(), _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
      var _ref11;

      if (_isArray9) {
        if (_i9 >= _iterator9.length) break;
        _ref11 = _iterator9[_i9++];
      } else {
        _i9 = _iterator9.next();
        if (_i9.done) break;
        _ref11 = _i9.value;
      }

      var _data2 = _ref11;

      if (!loose) {
        initStatements.push.apply(initStatements, buildReexportsFromMeta(metadata, _data2, loose));
      }

      for (var _iterator10 = _data2.reexportNamespace, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {
        var _ref13;

        if (_isArray10) {
          if (_i10 >= _iterator10.length) break;
          _ref13 = _iterator10[_i10++];
        } else {
          _i10 = _iterator10.next();
          if (_i10.done) break;
          _ref13 = _i10.value;
        }

        var exportName = _ref13;
        exportNames.push(exportName);
      }
    }

    initStatements.push.apply(initStatements, chunk_1(exportNames, 100).map(function (members) {
      return buildInitStatement(metadata, members, programPath.scope.buildUndefinedNode());
    }));
    return initStatements;
  }

  function buildInitStatement(metadata, exportNames, initExpr) {
    return ExpressionStatement(exportNames.reduce(function (acc, exportName) {
      return template.expression(_templateObject11$1())({
        EXPORTS: metadata.exportName,
        NAME: exportName,
        VALUE: acc
      });
    }, initExpr));
  }

  var semver = createCommonjsModule(function (module, exports) {
  exports = module.exports = SemVer;
  var debug;

  if (typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function debug() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift('SEMVER');
      console.log.apply(console, args);
    };
  } else {
    debug = function debug() {};
  }

  exports.SEMVER_SPEC_VERSION = '2.0.0';
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports.re = [];
  var src = exports.src = [];
  var t = exports.tokens = {};
  var R = 0;

  function tok(n) {
    t[n] = R++;
  }

  tok('NUMERICIDENTIFIER');
  src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
  tok('NUMERICIDENTIFIERLOOSE');
  src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+';
  tok('NONNUMERICIDENTIFIER');
  src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
  tok('MAINVERSION');
  src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
  tok('MAINVERSIONLOOSE');
  src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')';
  tok('PRERELEASEIDENTIFIER');
  src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
  tok('PRERELEASEIDENTIFIERLOOSE');
  src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
  tok('PRERELEASE');
  src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
  tok('PRERELEASELOOSE');
  src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))';
  tok('BUILDIDENTIFIER');
  src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
  tok('BUILD');
  src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))';
  tok('FULL');
  tok('FULLPLAIN');
  src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
  src[t.FULL] = '^' + src[t.FULLPLAIN] + '$';
  tok('LOOSEPLAIN');
  src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
  tok('LOOSE');
  src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
  tok('GTLT');
  src[t.GTLT] = '((?:<|>)?=?)';
  tok('XRANGEIDENTIFIERLOOSE');
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
  tok('XRANGEIDENTIFIER');
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
  tok('XRANGEPLAIN');
  src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
  tok('XRANGEPLAINLOOSE');
  src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
  tok('XRANGE');
  src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
  tok('XRANGELOOSE');
  src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$';
  tok('COERCE');
  src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
  tok('COERCERTL');
  re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g');
  tok('LONETILDE');
  src[t.LONETILDE] = '(?:~>?)';
  tok('TILDETRIM');
  src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
  var tildeTrimReplace = '$1~';
  tok('TILDE');
  src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
  tok('TILDELOOSE');
  src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$';
  tok('LONECARET');
  src[t.LONECARET] = '(?:\\^)';
  tok('CARETTRIM');
  src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
  var caretTrimReplace = '$1^';
  tok('CARET');
  src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
  tok('CARETLOOSE');
  src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$';
  tok('COMPARATORLOOSE');
  src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
  tok('COMPARATOR');
  src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$';
  tok('COMPARATORTRIM');
  src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')';
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
  var comparatorTrimReplace = '$1$2$3';
  tok('HYPHENRANGE');
  src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
  tok('HYPHENRANGELOOSE');
  src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$';
  tok('STAR');
  src[t.STAR] = '(<|>)?=?\\s*\\*';

  for (var i = 0; i < R; i++) {
    debug(i, src[i]);

    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }

  exports.parse = parse;

  function parse(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (version instanceof SemVer) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    if (version.length > MAX_LENGTH) {
      return null;
    }

    var r = options.loose ? re[t.LOOSE] : re[t.FULL];

    if (!r.test(version)) {
      return null;
    }

    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }

  exports.valid = valid;

  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }

  exports.clean = clean;

  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ''), options);
    return s ? s.version : null;
  }

  exports.SemVer = SemVer;

  function SemVer(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError('Invalid Version: ' + version);
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
    }

    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }

    debug('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

    if (!m) {
      throw new TypeError('Invalid Version: ' + version);
    }

    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version');
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version');
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version');
    }

    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map(function (id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;

          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }

        return id;
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  SemVer.prototype.format = function () {
    this.version = this.major + '.' + this.minor + '.' + this.patch;

    if (this.prerelease.length) {
      this.version += '-' + this.prerelease.join('.');
    }

    return this.version;
  };

  SemVer.prototype.toString = function () {
    return this.version;
  };

  SemVer.prototype.compare = function (other) {
    debug('SemVer.compare', this.version, this.options, other);

    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    return this.compareMain(other) || this.comparePre(other);
  };

  SemVer.prototype.compareMain = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };

  SemVer.prototype.comparePre = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }

    var i = 0;

    do {
      var a = this.prerelease[i];
      var b = other.prerelease[i];
      debug('prerelease compare', i, a, b);

      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  };

  SemVer.prototype.compareBuild = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    var i = 0;

    do {
      var a = this.build[i];
      var b = other.build[i];
      debug('prerelease compare', i, a, b);

      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  };

  SemVer.prototype.inc = function (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier);
        break;

      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier);
        break;

      case 'prepatch':
        this.prerelease.length = 0;
        this.inc('patch', identifier);
        this.inc('pre', identifier);
        break;

      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier);
        }

        this.inc('pre', identifier);
        break;

      case 'major':
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }

        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;

      case 'minor':
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }

        this.patch = 0;
        this.prerelease = [];
        break;

      case 'patch':
        if (this.prerelease.length === 0) {
          this.patch++;
        }

        this.prerelease = [];
        break;

      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i = this.prerelease.length;

          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }

          if (i === -1) {
            this.prerelease.push(0);
          }
        }

        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }

        break;

      default:
        throw new Error('invalid increment argument: ' + release);
    }

    this.format();
    this.raw = this.version;
    return this;
  };

  exports.inc = inc;

  function inc(version, release, loose, identifier) {
    if (typeof loose === 'string') {
      identifier = loose;
      loose = undefined;
    }

    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }

  exports.diff = diff;

  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = '';

      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = 'pre';
        var defaultResult = 'prerelease';
      }

      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }

      return defaultResult;
    }
  }

  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;

  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);

    if (anum && bnum) {
      a = +a;
      b = +b;
    }

    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }

  exports.rcompareIdentifiers = rcompareIdentifiers;

  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }

  exports.major = major;

  function major(a, loose) {
    return new SemVer(a, loose).major;
  }

  exports.minor = minor;

  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }

  exports.patch = patch;

  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }

  exports.compare = compare;

  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }

  exports.compareLoose = compareLoose;

  function compareLoose(a, b) {
    return compare(a, b, true);
  }

  exports.compareBuild = compareBuild;

  function compareBuild(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }

  exports.rcompare = rcompare;

  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }

  exports.sort = sort;

  function sort(list, loose) {
    return list.sort(function (a, b) {
      return exports.compareBuild(a, b, loose);
    });
  }

  exports.rsort = rsort;

  function rsort(list, loose) {
    return list.sort(function (a, b) {
      return exports.compareBuild(b, a, loose);
    });
  }

  exports.gt = gt;

  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }

  exports.lt = lt;

  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }

  exports.eq = eq;

  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }

  exports.neq = neq;

  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }

  exports.gte = gte;

  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }

  exports.lte = lte;

  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }

  exports.cmp = cmp;

  function cmp(a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a === b;

      case '!==':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a !== b;

      case '':
      case '=':
      case '==':
        return eq(a, b, loose);

      case '!=':
        return neq(a, b, loose);

      case '>':
        return gt(a, b, loose);

      case '>=':
        return gte(a, b, loose);

      case '<':
        return lt(a, b, loose);

      case '<=':
        return lte(a, b, loose);

      default:
        throw new TypeError('Invalid operator: ' + op);
    }
  }

  exports.Comparator = Comparator;

  function Comparator(comp, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }

    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }

    debug('comparator', comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);

    if (this.semver === ANY) {
      this.value = '';
    } else {
      this.value = this.operator + this.semver.version;
    }

    debug('comp', this);
  }

  var ANY = {};

  Comparator.prototype.parse = function (comp) {
    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var m = comp.match(r);

    if (!m) {
      throw new TypeError('Invalid comparator: ' + comp);
    }

    this.operator = m[1] !== undefined ? m[1] : '';

    if (this.operator === '=') {
      this.operator = '';
    }

    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };

  Comparator.prototype.toString = function () {
    return this.value;
  };

  Comparator.prototype.test = function (version) {
    debug('Comparator.test', version, this.options.loose);

    if (this.semver === ANY || version === ANY) {
      return true;
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }

    return cmp(version, this.operator, this.semver, this.options);
  };

  Comparator.prototype.intersects = function (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required');
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    var rangeTmp;

    if (this.operator === '') {
      if (this.value === '') {
        return true;
      }

      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true;
      }

      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }

    var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
    var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
    var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
    var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };

  exports.Range = Range;

  function Range(range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }

    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }

    if (!(this instanceof Range)) {
      return new Range(range, options);
    }

    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function (range) {
      return this.parseRange(range.trim());
    }, this).filter(function (c) {
      return c.length;
    });

    if (!this.set.length) {
      throw new TypeError('Invalid SemVer Range: ' + range);
    }

    this.format();
  }

  Range.prototype.format = function () {
    this.range = this.set.map(function (comps) {
      return comps.join(' ').trim();
    }).join('||').trim();
    return this.range;
  };

  Range.prototype.toString = function () {
    return this.range;
  };

  Range.prototype.parseRange = function (range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug('hyphen replace', range);
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
    debug('comparator trim', range, re[t.COMPARATORTRIM]);
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(' ');
    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var set = range.split(' ').map(function (comp) {
      return parseComparator(comp, this.options);
    }, this).join(' ').split(/\s+/);

    if (this.options.loose) {
      set = set.filter(function (comp) {
        return !!comp.match(compRe);
      });
    }

    set = set.map(function (comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };

  Range.prototype.intersects = function (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required');
    }

    return this.set.some(function (thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
          return rangeComparators.every(function (rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };

  function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();

    while (result && remainingComparators.length) {
      result = remainingComparators.every(function (otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }

    return result;
  }

  exports.toComparators = toComparators;

  function toComparators(range, options) {
    return new Range(range, options).set.map(function (comp) {
      return comp.map(function (c) {
        return c.value;
      }).join(' ').trim().split(' ');
    });
  }

  function parseComparator(comp, options) {
    debug('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug('caret', comp);
    comp = replaceTildes(comp, options);
    debug('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug('xrange', comp);
    comp = replaceStars(comp, options);
    debug('stars', comp);
    return comp;
  }

  function isX(id) {
    return !id || id.toLowerCase() === 'x' || id === '*';
  }

  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceTilde(comp, options);
    }).join(' ');
  }

  function replaceTilde(comp, options) {
    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('tilde', comp, _, M, m, p, pr);
      var ret;

      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (isX(p)) {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else if (pr) {
        debug('replaceTilde pr', pr);
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
      } else {
        ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
      }

      debug('tilde return', ret);
      return ret;
    });
  }

  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceCaret(comp, options);
    }).join(' ');
  }

  function replaceCaret(comp, options) {
    debug('caret', comp, options);
    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('caret', comp, _, M, m, p, pr);
      var ret;

      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (isX(p)) {
        if (M === '0') {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else {
          ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
        }
      } else if (pr) {
        debug('replaceCaret pr', pr);

        if (M === '0') {
          if (m === '0') {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
        }
      } else {
        debug('no pr');

        if (M === '0') {
          if (m === '0') {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
          } else {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
        }
      }

      debug('caret return', ret);
      return ret;
    });
  }

  function replaceXRanges(comp, options) {
    debug('replaceXRanges', comp, options);
    return comp.split(/\s+/).map(function (comp) {
      return replaceXRange(comp, options);
    }).join(' ');
  }

  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug('xRange', comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;

      if (gtlt === '=' && anyX) {
        gtlt = '';
      }

      pr = options.includePrerelease ? '-0' : '';

      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          ret = '<0.0.0-0';
        } else {
          ret = '*';
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }

        p = 0;

        if (gtlt === '>') {
          gtlt = '>=';

          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === '<=') {
          gtlt = '<';

          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }

        ret = gtlt + M + '.' + m + '.' + p + pr;
      } else if (xm) {
        ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
      } else if (xp) {
        ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
      }

      debug('xRange return', ret);
      return ret;
    });
  }

  function replaceStars(comp, options) {
    debug('replaceStars', comp, options);
    return comp.trim().replace(re[t.STAR], '');
  }

  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = '';
    } else if (isX(fm)) {
      from = '>=' + fM + '.0.0';
    } else if (isX(fp)) {
      from = '>=' + fM + '.' + fm + '.0';
    } else {
      from = '>=' + from;
    }

    if (isX(tM)) {
      to = '';
    } else if (isX(tm)) {
      to = '<' + (+tM + 1) + '.0.0';
    } else if (isX(tp)) {
      to = '<' + tM + '.' + (+tm + 1) + '.0';
    } else if (tpr) {
      to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
    } else {
      to = '<=' + to;
    }

    return (from + ' ' + to).trim();
  }

  Range.prototype.test = function (version) {
    if (!version) {
      return false;
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }

    for (var i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true;
      }
    }

    return false;
  };

  function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }

    if (version.prerelease.length && !options.includePrerelease) {
      for (i = 0; i < set.length; i++) {
        debug(set[i].semver);

        if (set[i].semver === ANY) {
          continue;
        }

        if (set[i].semver.prerelease.length > 0) {
          var allowed = set[i].semver;

          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }

      return false;
    }

    return true;
  }

  exports.satisfies = satisfies;

  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }

    return range.test(version);
  }

  exports.maxSatisfying = maxSatisfying;

  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;

    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }

  exports.minSatisfying = minSatisfying;

  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;

    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }

  exports.minVersion = minVersion;

  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer('0.0.0');

    if (range.test(minver)) {
      return minver;
    }

    minver = new SemVer('0.0.0-0');

    if (range.test(minver)) {
      return minver;
    }

    minver = null;

    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i];
      comparators.forEach(function (comparator) {
        var compver = new SemVer(comparator.semver.version);

        switch (comparator.operator) {
          case '>':
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }

            compver.raw = compver.format();

          case '':
          case '>=':
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }

            break;

          case '<':
          case '<=':
            break;

          default:
            throw new Error('Unexpected operation: ' + comparator.operator);
        }
      });
    }

    if (minver && range.test(minver)) {
      return minver;
    }

    return null;
  }

  exports.validRange = validRange;

  function validRange(range, options) {
    try {
      return new Range(range, options).range || '*';
    } catch (er) {
      return null;
    }
  }

  exports.ltr = ltr;

  function ltr(version, range, options) {
    return outside(version, range, '<', options);
  }

  exports.gtr = gtr;

  function gtr(version, range, options) {
    return outside(version, range, '>', options);
  }

  exports.outside = outside;

  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;

    switch (hilo) {
      case '>':
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = '>';
        ecomp = '>=';
        break;

      case '<':
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = '<';
        ecomp = '<=';
        break;

      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }

    if (satisfies(version, range, options)) {
      return false;
    }

    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i];
      var high = null;
      var low = null;
      comparators.forEach(function (comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator('>=0.0.0');
        }

        high = high || comparator;
        low = low || comparator;

        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });

      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }

      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }

    return true;
  }

  exports.prerelease = prerelease;

  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }

  exports.intersects = intersects;

  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }

  exports.coerce = coerce;

  function coerce(version, options) {
    if (version instanceof SemVer) {
      return version;
    }

    if (typeof version === 'number') {
      version = String(version);
    }

    if (typeof version !== 'string') {
      return null;
    }

    options = options || {};
    var match = null;

    if (!options.rtl) {
      match = version.match(re[t.COERCE]);
    } else {
      var next;

      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }

        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }

      re[t.COERCERTL].lastIndex = -1;
    }

    if (match === null) {
      return null;
    }

    return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
  }
  });
  var semver_1 = semver.SEMVER_SPEC_VERSION;
  var semver_2 = semver.re;
  var semver_3 = semver.src;
  var semver_4 = semver.tokens;
  var semver_5 = semver.parse;
  var semver_6 = semver.valid;
  var semver_7 = semver.clean;
  var semver_8 = semver.SemVer;
  var semver_9 = semver.inc;
  var semver_10 = semver.diff;
  var semver_11 = semver.compareIdentifiers;
  var semver_12 = semver.rcompareIdentifiers;
  var semver_13 = semver.major;
  var semver_14 = semver.minor;
  var semver_15 = semver.patch;
  var semver_16 = semver.compare;
  var semver_17 = semver.compareLoose;
  var semver_18 = semver.compareBuild;
  var semver_19 = semver.rcompare;
  var semver_20 = semver.sort;
  var semver_21 = semver.rsort;
  var semver_22 = semver.gt;
  var semver_23 = semver.lt;
  var semver_24 = semver.eq;
  var semver_25 = semver.neq;
  var semver_26 = semver.gte;
  var semver_27 = semver.lte;
  var semver_28 = semver.cmp;
  var semver_29 = semver.Comparator;
  var semver_30 = semver.Range;
  var semver_31 = semver.toComparators;
  var semver_32 = semver.satisfies;
  var semver_33 = semver.maxSatisfying;
  var semver_34 = semver.minSatisfying;
  var semver_35 = semver.minVersion;
  var semver_36 = semver.validRange;
  var semver_37 = semver.ltr;
  var semver_38 = semver.gtr;
  var semver_39 = semver.outside;
  var semver_40 = semver.prerelease;
  var semver_41 = semver.intersects;
  var semver_42 = semver.coerce;

  var errorVisitor = {
    enter: function enter(path, state) {
      var loc = path.node.loc;

      if (loc) {
        state.loc = loc;
        path.stop();
      }
    }
  };

  var File$2 = function () {
    function File(options, _ref) {
      var _this = this;

      var code = _ref.code,
          ast = _ref.ast,
          inputMap = _ref.inputMap;
      this._map = new Map();
      this.declarations = {};
      this.path = null;
      this.ast = {};
      this.metadata = {};
      this.code = "";
      this.inputMap = null;
      this.hub = {
        file: this,
        getCode: function getCode() {
          return _this.code;
        },
        getScope: function getScope() {
          return _this.scope;
        },
        addHelper: this.addHelper.bind(this),
        buildError: this.buildCodeFrameError.bind(this)
      };
      this.opts = options;
      this.code = code;
      this.ast = ast;
      this.inputMap = inputMap;
      this.path = NodePath.get({
        hub: this.hub,
        parentPath: null,
        parent: this.ast,
        container: this.ast,
        key: "program"
      }).setContext();
      this.scope = this.path.scope;
    }

    var _proto = File.prototype;

    _proto.set = function set(key, val) {
      if (key === "helpersNamespace") {
        throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility." + "If you are using @babel/plugin-external-helpers you will need to use a newer " + "version than the one you currently have installed. " + "If you have your own implementation, you'll want to explore using 'helperGenerator' " + "alongside 'file.availableHelper()'.");
      }

      this._map.set(key, val);
    };

    _proto.get = function get(key) {
      return this._map.get(key);
    };

    _proto.has = function has(key) {
      return this._map.has(key);
    };

    _proto.getModuleName = function getModuleName$1() {
      return getModuleName(this.opts, this.opts);
    };

    _proto.addImport = function addImport() {
      throw new Error("This API has been removed. If you're looking for this " + "functionality in Babel 7, you should import the " + "'@babel/helper-module-imports' module and use the functions exposed " + " from that module, such as 'addNamed' or 'addDefault'.");
    };

    _proto.availableHelper = function availableHelper(name, versionRange) {
      var minVersion$1;

      try {
        minVersion$1 = minVersion(name);
      } catch (err) {
        if (err.code !== "BABEL_HELPER_UNKNOWN") throw err;
        return false;
      }

      if (typeof versionRange !== "string") return true;
      if (semver.valid(versionRange)) versionRange = "^" + versionRange;
      return !semver.intersects("<" + minVersion$1, versionRange) && !semver.intersects(">=8.0.0", versionRange);
    };

    _proto.addHelper = function addHelper(name) {
      var _this2 = this;

      var declar = this.declarations[name];
      if (declar) return cloneNode(declar);
      var generator = this.get("helperGenerator");

      if (generator) {
        var res = generator(name);
        if (res) return res;
      }

      ensure(name, File);
      var uid = this.declarations[name] = this.scope.generateUidIdentifier(name);
      var dependencies = {};

      for (var _iterator = getDependencies(name), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref2 = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref2 = _i.value;
        }

        var dep = _ref2;
        dependencies[dep] = this.addHelper(dep);
      }

      var _helpers$get = get$1(name, function (dep) {
        return dependencies[dep];
      }, uid, Object.keys(this.scope.getAllBindings())),
          nodes = _helpers$get.nodes,
          globals = _helpers$get.globals;

      globals.forEach(function (name) {
        if (_this2.path.scope.hasBinding(name, true)) {
          _this2.path.scope.rename(name);
        }
      });
      nodes.forEach(function (node) {
        node._compact = true;
      });
      this.path.unshiftContainer("body", nodes);
      this.path.get("body").forEach(function (path) {
        if (nodes.indexOf(path.node) === -1) return;
        if (path.isVariableDeclaration()) _this2.scope.registerDeclaration(path);
      });
      return uid;
    };

    _proto.addTemplateObject = function addTemplateObject() {
      throw new Error("This function has been moved into the template literal transform itself.");
    };

    _proto.buildCodeFrameError = function buildCodeFrameError(node, msg, Error) {
      if (Error === void 0) {
        Error = SyntaxError;
      }

      var loc = node && (node.loc || node._loc);

      if (!loc && node) {
        var state = {
          loc: null
        };
        traverse$1(node, errorVisitor, this.scope, state);
        loc = state.loc;
        var txt = "This is an error on an internal node. Probably an internal error.";
        if (loc) txt += " Location has been estimated.";
        msg += " (" + txt + ")";
      }

      if (loc) {
        var _this$opts$highlightC = this.opts.highlightCode,
            highlightCode = _this$opts$highlightC === void 0 ? true : _this$opts$highlightC;
        msg += "\n" + codeFrameColumns(this.code, {
          start: {
            line: loc.start.line,
            column: loc.start.column + 1
          },
          end: loc.end && loc.start.line === loc.end.line ? {
            line: loc.end.line,
            column: loc.end.column + 1
          } : undefined
        }, {
          highlightCode: highlightCode
        });
      }

      return new Error(msg);
    };

    _createClass(File, [{
      key: "shebang",
      get: function get() {
        var interpreter = this.path.node.interpreter;
        return interpreter ? interpreter.value : "";
      },
      set: function set(value) {
        if (value) {
          this.path.get("interpreter").replaceWith(InterpreterDirective(value));
        } else {
          this.path.get("interpreter").remove();
        }
      }
    }]);

    return File;
  }();

  function _templateObject$3() {
    var data = _taggedTemplateLiteralLoose(["\n    (function (root, factory) {\n      if (typeof define === \"function\" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === \"object\") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  "]);

    _templateObject$3 = function _templateObject() {
      return data;
    };

    return data;
  }

  var buildUmdWrapper = function buildUmdWrapper(replacements) {
    return template(_templateObject$3())(replacements);
  };

  function buildGlobal(whitelist) {
    var namespace = Identifier("babelHelpers");
    var body = [];
    var container = FunctionExpression(null, [Identifier("global")], BlockStatement(body));
    var tree = Program([ExpressionStatement(CallExpression(container, [ConditionalExpression(BinaryExpression("===", UnaryExpression("typeof", Identifier("global")), StringLiteral("undefined")), Identifier("self"), Identifier("global"))]))]);
    body.push(VariableDeclaration("var", [VariableDeclarator(namespace, AssignmentExpression("=", MemberExpression(Identifier("global"), namespace), ObjectExpression([])))]));
    buildHelpers(body, namespace, whitelist);
    return tree;
  }

  function buildModule(whitelist) {
    var body = [];
    var refs = buildHelpers(body, null, whitelist);
    body.unshift(ExportNamedDeclaration(null, Object.keys(refs).map(function (name) {
      return ExportSpecifier(cloneNode(refs[name]), Identifier(name));
    })));
    return Program(body, [], "module");
  }

  function buildUmd(whitelist) {
    var namespace = Identifier("babelHelpers");
    var body = [];
    body.push(VariableDeclaration("var", [VariableDeclarator(namespace, Identifier("global"))]));
    buildHelpers(body, namespace, whitelist);
    return Program([buildUmdWrapper({
      FACTORY_PARAMETERS: Identifier("global"),
      BROWSER_ARGUMENTS: AssignmentExpression("=", MemberExpression(Identifier("root"), namespace), ObjectExpression([])),
      COMMON_ARGUMENTS: Identifier("exports"),
      AMD_ARGUMENTS: ArrayExpression([StringLiteral("exports")]),
      FACTORY_BODY: body,
      UMD_ROOT: Identifier("this")
    })]);
  }

  function buildVar(whitelist) {
    var namespace = Identifier("babelHelpers");
    var body = [];
    body.push(VariableDeclaration("var", [VariableDeclarator(namespace, ObjectExpression([]))]));
    var tree = Program(body);
    buildHelpers(body, namespace, whitelist);
    body.push(ExpressionStatement(namespace));
    return tree;
  }

  function buildHelpers(body, namespace, whitelist) {
    var getHelperReference = function getHelperReference(name) {
      return namespace ? MemberExpression(namespace, Identifier(name)) : Identifier("_" + name);
    };

    var refs = {};
    list$1.forEach(function (name) {
      if (whitelist && whitelist.indexOf(name) < 0) return;
      var ref = refs[name] = getHelperReference(name);
      ensure(name, File$2);

      var _helpers$get = get$1(name, getHelperReference, ref),
          nodes = _helpers$get.nodes;

      body.push.apply(body, nodes);
    });
    return refs;
  }

  function babelBuildExternalHelpers (whitelist, outputType) {
    if (outputType === void 0) {
      outputType = "global";
    }

    var tree;
    var build = {
      global: buildGlobal,
      module: buildModule,
      umd: buildUmd,
      "var": buildVar
    }[outputType];

    if (build) {
      tree = build(whitelist);
    } else {
      throw new Error("Unsupported output type " + outputType);
    }

    return generateCode(tree).code;
  }

  var runtime_1 = createCommonjsModule(function (module) {
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap;

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        prototype[method] = function (arg) {
          return this._invoke(method, arg);
        };
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;

        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }

      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    exports.AsyncIterator = AsyncIterator;

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        context.delegate = null;

        if (context.method === "throw") {
          if (delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        return info;
      }

      context.delegate = null;
      return ContinueSentinel;
    }

    defineIteratorMethods(Gp);
    Gp[toStringTagSymbol] = "Generator";

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse();
      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    };
    return exports;
  }( module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
  });

  var regenerator = runtime_1;

  var _marked = regenerator.mark(findConfigUpwards),
      _marked2 = regenerator.mark(findPackageData),
      _marked3 = regenerator.mark(findRelativeConfig),
      _marked4 = regenerator.mark(findRootConfig),
      _marked5 = regenerator.mark(loadConfig);

  function findConfigUpwards(rootDir) {
    return regenerator.wrap(function findConfigUpwards$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", null);

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _marked);
  }
  function findPackageData(filepath) {
    return regenerator.wrap(function findPackageData$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", {
              filepath: filepath,
              directories: [],
              pkg: null,
              isPackage: false
            });

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2);
  }
  function findRelativeConfig(pkgData, envName, caller) {
    return regenerator.wrap(function findRelativeConfig$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", {
              pkg: null,
              config: null,
              ignore: null
            });

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _marked3);
  }
  function findRootConfig(dirname, envName, caller) {
    return regenerator.wrap(function findRootConfig$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", null);

          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _marked4);
  }
  function loadConfig(name, dirname, envName, caller) {
    return regenerator.wrap(function loadConfig$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            throw new Error("Cannot load " + name + " relative to " + dirname + " in a browser");

          case 1:
          case "end":
            return _context5.stop();
        }
      }
    }, _marked5);
  }
  var ROOT_CONFIG_FILENAMES = [];
  function resolvePlugin(name, dirname) {
    return null;
  }
  function resolvePreset(name, dirname) {
    return null;
  }
  function loadPlugin(name, dirname) {
    throw new Error("Cannot load plugin " + name + " relative to " + dirname + " in a browser");
  }
  function loadPreset(name, dirname) {
    throw new Error("Cannot load preset " + name + " relative to " + dirname + " in a browser");
  }

  var version$1 = "7.9.0";

  function getEnv(defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = "development";
    }

    return process.env.BABEL_ENV || undefined || defaultValue;
  }

  var GENSYNC_START = Symbol["for"]("gensync:v1:start");
  var GENSYNC_SUSPEND = Symbol["for"]("gensync:v1:suspend");
  var GENSYNC_EXPECTED_START = "GENSYNC_EXPECTED_START";
  var GENSYNC_EXPECTED_SUSPEND = "GENSYNC_EXPECTED_SUSPEND";
  var GENSYNC_OPTIONS_ERROR = "GENSYNC_OPTIONS_ERROR";
  var GENSYNC_RACE_NONEMPTY = "GENSYNC_RACE_NONEMPTY";
  var GENSYNC_ERRBACK_NO_CALLBACK = "GENSYNC_ERRBACK_NO_CALLBACK";
  var gensync = Object.assign(function gensync(optsOrFn) {
    var genFn = optsOrFn;

    if (typeof optsOrFn !== "function") {
      genFn = newGenerator(optsOrFn);
    } else {
      genFn = wrapGenerator(optsOrFn);
    }

    return Object.assign(genFn, makeFunctionAPI(genFn));
  }, {
    all: buildOperation({
      name: "all",
      arity: 1,
      sync: function sync(args) {
        var items = Array.from(args[0]);
        return items.map(function (item) {
          return evaluateSync(item);
        });
      },
      async: function async(args, resolve, reject) {
        var items = Array.from(args[0]);
        var count = 0;
        var results = items.map(function () {
          return undefined;
        });
        items.forEach(function (item, i) {
          evaluateAsync(item, function (val) {
            results[i] = val;
            count += 1;
            if (count === results.length) resolve(results);
          }, reject);
        });
      }
    }),
    race: buildOperation({
      name: "race",
      arity: 1,
      sync: function sync(args) {
        var items = Array.from(args[0]);

        if (items.length === 0) {
          throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
        }

        return evaluateSync(items[0]);
      },
      async: function async(args, resolve, reject) {
        var items = Array.from(args[0]);

        if (items.length === 0) {
          throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
        }

        for (var _i = 0, _items = items; _i < _items.length; _i++) {
          var item = _items[_i];
          evaluateAsync(item, resolve, reject);
        }
      }
    })
  });

  function makeFunctionAPI(genFn) {
    var fns = {
      sync: function sync() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return evaluateSync(genFn.apply(this, args));
      },
      async: function async() {
        var _this = this;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return new Promise(function (resolve, reject) {
          evaluateAsync(genFn.apply(_this, args), resolve, reject);
        });
      },
      errback: function errback() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var cb = args.pop();

        if (typeof cb !== "function") {
          throw makeError("Asynchronous function called without callback", GENSYNC_ERRBACK_NO_CALLBACK);
        }

        var gen;

        try {
          gen = genFn.apply(this, args);
        } catch (err) {
          cb(err);
          return;
        }

        evaluateAsync(gen, function (val) {
          return cb(undefined, val);
        }, function (err) {
          return cb(err);
        });
      }
    };
    return fns;
  }

  function assertTypeof(type, name, value, allowUndefined) {
    if (typeof value === type || allowUndefined && typeof value === "undefined") {
      return;
    }

    var msg;

    if (allowUndefined) {
      msg = "Expected opts." + name + " to be either a " + type + ", or undefined.";
    } else {
      msg = "Expected opts." + name + " to be a " + type + ".";
    }

    throw makeError(msg, GENSYNC_OPTIONS_ERROR);
  }

  function makeError(msg, code) {
    return Object.assign(new Error(msg), {
      code: code
    });
  }

  function newGenerator(_ref) {
    var name = _ref.name,
        arity = _ref.arity,
        _sync = _ref.sync,
        _async = _ref.async,
        errback = _ref.errback;
    assertTypeof("string", "name", name, true);
    assertTypeof("number", "arity", arity, true);
    assertTypeof("function", "sync", _sync);
    assertTypeof("function", "async", _async, true);
    assertTypeof("function", "errback", errback, true);

    if (_async && errback) {
      throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", GENSYNC_OPTIONS_ERROR);
    }

    if (typeof name !== "string") {
      var fnName;

      if (errback && errback.name && errback.name !== "errback") {
        fnName = errback.name;
      }

      if (_async && _async.name && _async.name !== "async") {
        fnName = _async.name.replace(/Async$/, "");
      }

      if (_sync && _sync.name && _sync.name !== "sync") {
        fnName = _sync.name.replace(/Sync$/, "");
      }

      if (typeof fnName === "string") {
        name = fnName;
      }
    }

    if (typeof arity !== "number") {
      arity = _sync.length;
    }

    return buildOperation({
      name: name,
      arity: arity,
      sync: function sync(args) {
        return _sync.apply(this, args);
      },
      async: function async(args, resolve, reject) {
        if (_async) {
          _async.apply(this, args).then(resolve, reject);
        } else if (errback) {
          errback.call.apply(errback, [this].concat(args, [function (err, value) {
            if (err == null) resolve(value);else reject(err);
          }]));
        } else {
          resolve(_sync.apply(this, args));
        }
      }
    });
  }

  function wrapGenerator(genFn) {
    return setFunctionMetadata(genFn.name, genFn.length, function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return genFn.apply(this, args);
    });
  }

  function buildOperation(_ref2) {
    var name = _ref2.name,
        arity = _ref2.arity,
        sync = _ref2.sync,
        async = _ref2.async;
    return setFunctionMetadata(name, arity, regenerator.mark(function _callee() {
      var resume,
          _len5,
          args,
          _key5,
          result,
          _args = arguments;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return GENSYNC_START;

            case 2:
              resume = _context.sent;

              for (_len5 = _args.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                args[_key5] = _args[_key5];
              }

              if (resume) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", sync.call(this, args));

            case 6:
              try {
                async.call(this, args, function (value) {
                  if (result) return;
                  result = {
                    value: value
                  };
                  resume();
                }, function (err) {
                  if (result) return;
                  result = {
                    err: err
                  };
                  resume();
                });
              } catch (err) {
                result = {
                  err: err
                };
                resume();
              }

              _context.next = 9;
              return GENSYNC_SUSPEND;

            case 9:
              if (!result.hasOwnProperty("err")) {
                _context.next = 11;
                break;
              }

              throw result.err;

            case 11:
              return _context.abrupt("return", result.value);

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
  }

  function evaluateSync(gen) {
    var value;

    while (!(_gen$next = gen.next(), value = _gen$next.value, _gen$next).done) {
      var _gen$next;

      assertStart(value, gen);
    }

    return value;
  }

  function evaluateAsync(gen, resolve, reject) {
    (function step() {
      try {
        var value;

        var _loop = function _loop() {
          assertStart(value, gen);
          var sync = true;
          var didSyncResume = false;
          var out = gen.next(function () {
            if (sync) {
              didSyncResume = true;
            } else {
              step();
            }
          });
          sync = false;
          assertSuspend(out, gen);

          if (!didSyncResume) {
            return {
              v: void 0
            };
          }
        };

        while (!(_gen$next2 = gen.next(), value = _gen$next2.value, _gen$next2).done) {
          var _gen$next2;

          var _ret = _loop();

          if (typeof _ret === "object") return _ret.v;
        }

        return resolve(value);
      } catch (err) {
        return reject(err);
      }
    })();
  }

  function assertStart(value, gen) {
    if (value === GENSYNC_START) return;
    throwError(gen, makeError("Got unexpected yielded value in gensync generator: " + JSON.stringify(value) + ". Did you perhaps mean to use 'yield*' instead of 'yield'?", GENSYNC_EXPECTED_START));
  }

  function assertSuspend(_ref3, gen) {
    var value = _ref3.value,
        done = _ref3.done;
    if (!done && value === GENSYNC_SUSPEND) return;
    throwError(gen, makeError(done ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : "Expected GENSYNC_SUSPEND, got " + JSON.stringify(value) + ". If you get this, it is probably a gensync bug.", GENSYNC_EXPECTED_SUSPEND));
  }

  function throwError(gen, err) {
    if (gen["throw"]) gen["throw"](err);
    throw err;
  }

  function setFunctionMetadata(name, arity, fn) {
    if (typeof name === "string") {
      var nameDesc = Object.getOwnPropertyDescriptor(fn, "name");

      if (!nameDesc || nameDesc.configurable) {
        Object.defineProperty(fn, "name", Object.assign(nameDesc || {}, {
          configurable: true,
          value: name
        }));
      }
    }

    if (typeof arity === "number") {
      var lengthDesc = Object.getOwnPropertyDescriptor(fn, "length");

      if (!lengthDesc || lengthDesc.configurable) {
        Object.defineProperty(fn, "length", Object.assign(lengthDesc || {}, {
          configurable: true,
          value: arity
        }));
      }
    }

    return fn;
  }

  var id = function id(x) {
    return x;
  };

  var runGenerator = gensync(regenerator.mark(function _callee(item) {
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(item, "t0", 1);

          case 1:
            return _context.abrupt("return", _context.t0);

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  var isAsync = gensync({
    sync: function sync() {
      return false;
    },
    errback: function errback(cb) {
      return cb(null, true);
    }
  });
  function maybeAsync(fn, message) {
    return gensync({
      sync: function sync() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var result = fn.apply(this, args);
        if (isThenable(result)) throw new Error(message);
        return result;
      },
      async: function async() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return Promise.resolve(fn.apply(this, args));
      }
    });
  }
  var withKind = gensync({
    sync: function sync(cb) {
      return cb("sync");
    },
    async: function async(cb) {
      return cb("async");
    }
  });
  function forwardAsync(action, cb) {
    var g = gensync(action);
    return withKind(function (kind) {
      var adapted = g[kind];
      return cb(adapted);
    });
  }
  var onFirstPause = gensync({
    name: "onFirstPause",
    arity: 2,
    sync: function sync(item) {
      return runGenerator.sync(item);
    },
    errback: function errback(item, firstPause, cb) {
      var completed = false;
      runGenerator.errback(item, function (err, value) {
        completed = true;
        cb(err, value);
      });

      if (!completed) {
        firstPause();
      }
    }
  });
  var waitFor = gensync({
    sync: id,
    async: id
  });
  function isThenable(val) {
    return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
  }

  function mergeOptions(target, source) {
    for (var _i = 0, _Object$keys = Object.keys(source); _i < _Object$keys.length; _i++) {
      var k = _Object$keys[_i];

      if (k === "parserOpts" && source.parserOpts) {
        var parserOpts = source.parserOpts;
        var targetObj = target.parserOpts = target.parserOpts || {};
        mergeDefaultFields(targetObj, parserOpts);
      } else if (k === "generatorOpts" && source.generatorOpts) {
        var generatorOpts = source.generatorOpts;

        var _targetObj = target.generatorOpts = target.generatorOpts || {};

        mergeDefaultFields(_targetObj, generatorOpts);
      } else {
        var val = source[k];
        if (val !== undefined) target[k] = val;
      }
    }
  }

  function mergeDefaultFields(target, source) {
    for (var _i2 = 0, _Object$keys2 = Object.keys(source); _i2 < _Object$keys2.length; _i2++) {
      var k = _Object$keys2[_i2];
      var val = source[k];
      if (val !== undefined) target[k] = val;
    }
  }

  function isIterableIterator(value) {
    return !!value && typeof value.next === "function" && typeof value[Symbol.iterator] === "function";
  }

  var _marked$1 = regenerator.mark(genTrue),
      _marked2$1 = regenerator.mark(getCachedValue),
      _marked3$1 = regenerator.mark(getCachedValueOrWait);

  var synchronize = function synchronize(gen) {
    return gensync(gen).sync;
  };

  function genTrue(data) {
    return regenerator.wrap(function genTrue$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", true);

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$1);
  }

  function makeWeakCache(handler) {
    return makeCachedFunction(WeakMap, handler);
  }
  function makeWeakCacheSync(handler) {
    return synchronize(makeWeakCache(handler));
  }
  function makeStrongCache(handler) {
    return makeCachedFunction(Map, handler);
  }
  function makeStrongCacheSync(handler) {
    return synchronize(makeStrongCache(handler));
  }

  function makeCachedFunction(CallCache, handler) {
    var callCacheSync = new CallCache();
    var callCacheAsync = new CallCache();
    var futureCache = new CallCache();
    return regenerator.mark(function cachedFunction(arg, data) {
      var asyncContext, callCache, cached, cache, handlerResult, finishLock, value, gen;
      return regenerator.wrap(function cachedFunction$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.delegateYield(isAsync(), "t0", 1);

            case 1:
              asyncContext = _context2.t0;
              callCache = asyncContext ? callCacheAsync : callCacheSync;
              return _context2.delegateYield(getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data), "t1", 4);

            case 4:
              cached = _context2.t1;

              if (!cached.valid) {
                _context2.next = 7;
                break;
              }

              return _context2.abrupt("return", cached.value);

            case 7:
              cache = new CacheConfigurator(data);
              handlerResult = handler(arg, cache);

              if (!isIterableIterator(handlerResult)) {
                _context2.next = 15;
                break;
              }

              gen = handlerResult;
              return _context2.delegateYield(onFirstPause(gen, function () {
                finishLock = setupAsyncLocks(cache, futureCache, arg);
              }), "t2", 12);

            case 12:
              value = _context2.t2;
              _context2.next = 16;
              break;

            case 15:
              value = handlerResult;

            case 16:
              updateFunctionCache(callCache, cache, arg, value);

              if (finishLock) {
                futureCache["delete"](arg);
                finishLock.release(value);
              }

              return _context2.abrupt("return", value);

            case 19:
            case "end":
              return _context2.stop();
          }
        }
      }, cachedFunction);
    });
  }

  function getCachedValue(cache, arg, data) {
    var cachedValue, _iterator, _isArray, _i, _ref, _ref2, _value, valid;

    return regenerator.wrap(function getCachedValue$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            cachedValue = cache.get(arg);

            if (!cachedValue) {
              _context3.next = 19;
              break;
            }

            _iterator = cachedValue, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();

          case 3:
            if (!_isArray) {
              _context3.next = 9;
              break;
            }

            if (!(_i >= _iterator.length)) {
              _context3.next = 6;
              break;
            }

            return _context3.abrupt("break", 19);

          case 6:
            _ref = _iterator[_i++];
            _context3.next = 13;
            break;

          case 9:
            _i = _iterator.next();

            if (!_i.done) {
              _context3.next = 12;
              break;
            }

            return _context3.abrupt("break", 19);

          case 12:
            _ref = _i.value;

          case 13:
            _ref2 = _ref, _value = _ref2.value, valid = _ref2.valid;
            return _context3.delegateYield(valid(data), "t0", 15);

          case 15:
            if (!_context3.t0) {
              _context3.next = 17;
              break;
            }

            return _context3.abrupt("return", {
              valid: true,
              value: _value
            });

          case 17:
            _context3.next = 3;
            break;

          case 19:
            return _context3.abrupt("return", {
              valid: false,
              value: null
            });

          case 20:
          case "end":
            return _context3.stop();
        }
      }
    }, _marked2$1);
  }

  function getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {
    var cached, _cached, _value2;

    return regenerator.wrap(function getCachedValueOrWait$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.delegateYield(getCachedValue(callCache, arg, data), "t0", 1);

          case 1:
            cached = _context4.t0;

            if (!cached.valid) {
              _context4.next = 4;
              break;
            }

            return _context4.abrupt("return", cached);

          case 4:
            if (!asyncContext) {
              _context4.next = 11;
              break;
            }

            return _context4.delegateYield(getCachedValue(futureCache, arg, data), "t1", 6);

          case 6:
            _cached = _context4.t1;

            if (!_cached.valid) {
              _context4.next = 11;
              break;
            }

            return _context4.delegateYield(waitFor(_cached.value.promise), "t2", 9);

          case 9:
            _value2 = _context4.t2;
            return _context4.abrupt("return", {
              valid: true,
              value: _value2
            });

          case 11:
            return _context4.abrupt("return", {
              valid: false,
              value: null
            });

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _marked3$1);
  }

  function setupAsyncLocks(config, futureCache, arg) {
    var finishLock = new Lock();
    updateFunctionCache(futureCache, config, arg, finishLock);
    return finishLock;
  }

  function updateFunctionCache(cache, config, arg, value) {
    if (!config.configured()) config.forever();
    var cachedValue = cache.get(arg);
    config.deactivate();

    switch (config.mode()) {
      case "forever":
        cachedValue = [{
          value: value,
          valid: genTrue
        }];
        cache.set(arg, cachedValue);
        break;

      case "invalidate":
        cachedValue = [{
          value: value,
          valid: config.validator()
        }];
        cache.set(arg, cachedValue);
        break;

      case "valid":
        if (cachedValue) {
          cachedValue.push({
            value: value,
            valid: config.validator()
          });
        } else {
          cachedValue = [{
            value: value,
            valid: config.validator()
          }];
          cache.set(arg, cachedValue);
        }

    }
  }

  var CacheConfigurator = function () {
    function CacheConfigurator(data) {
      this._active = true;
      this._never = false;
      this._forever = false;
      this._invalidate = false;
      this._configured = false;
      this._pairs = [];
      this._data = data;
    }

    var _proto = CacheConfigurator.prototype;

    _proto.simple = function simple() {
      return makeSimpleConfigurator(this);
    };

    _proto.mode = function mode() {
      if (this._never) return "never";
      if (this._forever) return "forever";
      if (this._invalidate) return "invalidate";
      return "valid";
    };

    _proto.forever = function forever() {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._never) {
        throw new Error("Caching has already been configured with .never()");
      }

      this._forever = true;
      this._configured = true;
    };

    _proto.never = function never() {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._forever) {
        throw new Error("Caching has already been configured with .forever()");
      }

      this._never = true;
      this._configured = true;
    };

    _proto.using = function using(handler) {
      var _this = this;

      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._never || this._forever) {
        throw new Error("Caching has already been configured with .never or .forever()");
      }

      this._configured = true;
      var key = handler(this._data);
      var fn = maybeAsync(handler, "You appear to be using an async cache handler, but Babel has been called synchronously");

      if (isThenable(key)) {
        return key.then(function (key) {
          _this._pairs.push([key, fn]);

          return key;
        });
      }

      this._pairs.push([key, fn]);

      return key;
    };

    _proto.invalidate = function invalidate(handler) {
      this._invalidate = true;
      return this.using(handler);
    };

    _proto.validator = function validator() {
      var pairs = this._pairs;
      return regenerator.mark(function _callee(data) {
        var _iterator2, _isArray2, _i2, _ref3, _ref4, key, fn;

        return regenerator.wrap(function _callee$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _iterator2 = pairs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();

              case 1:
                if (!_isArray2) {
                  _context5.next = 7;
                  break;
                }

                if (!(_i2 >= _iterator2.length)) {
                  _context5.next = 4;
                  break;
                }

                return _context5.abrupt("break", 19);

              case 4:
                _ref3 = _iterator2[_i2++];
                _context5.next = 11;
                break;

              case 7:
                _i2 = _iterator2.next();

                if (!_i2.done) {
                  _context5.next = 10;
                  break;
                }

                return _context5.abrupt("break", 19);

              case 10:
                _ref3 = _i2.value;

              case 11:
                _ref4 = _ref3, key = _ref4[0], fn = _ref4[1];
                _context5.t0 = key;
                return _context5.delegateYield(fn(data), "t1", 14);

              case 14:
                _context5.t2 = _context5.t1;

                if (!(_context5.t0 !== _context5.t2)) {
                  _context5.next = 17;
                  break;
                }

                return _context5.abrupt("return", false);

              case 17:
                _context5.next = 1;
                break;

              case 19:
                return _context5.abrupt("return", true);

              case 20:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee);
      });
    };

    _proto.deactivate = function deactivate() {
      this._active = false;
    };

    _proto.configured = function configured() {
      return this._configured;
    };

    return CacheConfigurator;
  }();

  function makeSimpleConfigurator(cache) {
    function cacheFn(val) {
      if (typeof val === "boolean") {
        if (val) cache.forever();else cache.never();
        return;
      }

      return cache.using(function () {
        return assertSimpleType(val());
      });
    }

    cacheFn.forever = function () {
      return cache.forever();
    };

    cacheFn.never = function () {
      return cache.never();
    };

    cacheFn.using = function (cb) {
      return cache.using(function () {
        return assertSimpleType(cb());
      });
    };

    cacheFn.invalidate = function (cb) {
      return cache.invalidate(function () {
        return assertSimpleType(cb());
      });
    };

    return cacheFn;
  }

  function assertSimpleType(value) {
    if (isThenable(value)) {
      throw new Error("You appear to be using an async cache handler, " + "which your current version of Babel does not support. " + "We may add support for this in the future, " + "but if you're on the most recent version of @babel/core and still " + "seeing this error, then you'll need to synchronously handle your caching logic.");
    }

    if (value != null && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number") {
      throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
    }

    return value;
  }

  var Lock = function () {
    function Lock() {
      var _this2 = this;

      this.released = false;
      this.promise = new Promise(function (resolve) {
        _this2._resolve = resolve;
      });
    }

    var _proto2 = Lock.prototype;

    _proto2.release = function release(value) {
      this.released = true;

      this._resolve(value);
    };

    return Lock;
  }();

  function isEqualDescriptor(a, b) {
    return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);
  }

  function createCachedDescriptors(dirname, options, alias) {
    var plugins = options.plugins,
        presets = options.presets,
        passPerPreset = options.passPerPreset;
    return {
      options: options,
      plugins: plugins ? function () {
        return createCachedPluginDescriptors(plugins, dirname)(alias);
      } : function () {
        return [];
      },
      presets: presets ? function () {
        return createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset);
      } : function () {
        return [];
      }
    };
  }
  function createUncachedDescriptors(dirname, options, alias) {
    var _plugins;

    var _presets;

    return {
      options: options,
      plugins: function plugins() {
        if (!_plugins) {
          _plugins = createPluginDescriptors(options.plugins || [], dirname, alias);
        }

        return _plugins;
      },
      presets: function presets() {
        if (!_presets) {
          _presets = createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset);
        }

        return _presets;
      }
    };
  }
  var PRESET_DESCRIPTOR_CACHE = new WeakMap();
  var createCachedPresetDescriptors = makeWeakCacheSync(function (items, cache) {
    var dirname = cache.using(function (dir) {
      return dir;
    });
    return makeStrongCacheSync(function (alias) {
      return makeStrongCacheSync(function (passPerPreset) {
        return createPresetDescriptors(items, dirname, alias, passPerPreset).map(function (desc) {
          return loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc);
        });
      });
    });
  });
  var PLUGIN_DESCRIPTOR_CACHE = new WeakMap();
  var createCachedPluginDescriptors = makeWeakCacheSync(function (items, cache) {
    var dirname = cache.using(function (dir) {
      return dir;
    });
    return makeStrongCacheSync(function (alias) {
      return createPluginDescriptors(items, dirname, alias).map(function (desc) {
        return loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc);
      });
    });
  });
  var DEFAULT_OPTIONS = {};

  function loadCachedDescriptor(cache, desc) {
    var value = desc.value,
        _desc$options = desc.options,
        options = _desc$options === void 0 ? DEFAULT_OPTIONS : _desc$options;
    if (options === false) return desc;
    var cacheByOptions = cache.get(value);

    if (!cacheByOptions) {
      cacheByOptions = new WeakMap();
      cache.set(value, cacheByOptions);
    }

    var possibilities = cacheByOptions.get(options);

    if (!possibilities) {
      possibilities = [];
      cacheByOptions.set(options, possibilities);
    }

    if (possibilities.indexOf(desc) === -1) {
      var matches = possibilities.filter(function (possibility) {
        return isEqualDescriptor(possibility, desc);
      });

      if (matches.length > 0) {
        return matches[0];
      }

      possibilities.push(desc);
    }

    return desc;
  }

  function createPresetDescriptors(items, dirname, alias, passPerPreset) {
    return createDescriptors("preset", items, dirname, alias, passPerPreset);
  }

  function createPluginDescriptors(items, dirname, alias) {
    return createDescriptors("plugin", items, dirname, alias);
  }

  function createDescriptors(type, items, dirname, alias, ownPass) {
    var descriptors = items.map(function (item, index) {
      return createDescriptor(item, dirname, {
        type: type,
        alias: alias + "$" + index,
        ownPass: !!ownPass
      });
    });
    assertNoDuplicates(descriptors);
    return descriptors;
  }

  function createDescriptor(pair, dirname, _ref) {
    var type = _ref.type,
        alias = _ref.alias,
        ownPass = _ref.ownPass;
    var desc = getItemDescriptor(pair);

    if (desc) {
      return desc;
    }

    var name;
    var options;
    var value = pair;

    if (Array.isArray(value)) {
      if (value.length === 3) {
        var _value = value;
        value = _value[0];
        options = _value[1];
        name = _value[2];
      } else {
        var _value2 = value;
        value = _value2[0];
        options = _value2[1];
      }
    }

    var file = undefined;
    var filepath = null;

    if (typeof value === "string") {
      if (typeof type !== "string") {
        throw new Error("To resolve a string-based item, the type of item must be given");
      }

      var resolver = type === "plugin" ? loadPlugin : loadPreset;
      var request = value;

      var _resolver = resolver(value, dirname);

      filepath = _resolver.filepath;
      value = _resolver.value;
      file = {
        request: request,
        resolved: filepath
      };
    }

    if (!value) {
      throw new Error("Unexpected falsy value: " + String(value));
    }

    if (typeof value === "object" && value.__esModule) {
      if (value["default"]) {
        value = value["default"];
      } else {
        throw new Error("Must export a default export when using ES6 modules.");
      }
    }

    if (typeof value !== "object" && typeof value !== "function") {
      throw new Error("Unsupported format: " + typeof value + ". Expected an object or a function.");
    }

    if (filepath !== null && typeof value === "object" && value) {
      throw new Error("Plugin/Preset files are not allowed to export objects, only functions. In " + filepath);
    }

    return {
      name: name,
      alias: filepath || alias,
      value: value,
      options: options,
      dirname: dirname,
      ownPass: ownPass,
      file: file
    };
  }

  function assertNoDuplicates(items) {
    var map = new Map();

    var _loop2 = function _loop2() {
      if (_isArray) {
        if (_i >= _iterator.length) return "break";
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) return "break";
        _ref2 = _i.value;
      }

      var item = _ref2;
      if (typeof item.value !== "function") return "continue";
      var nameMap = map.get(item.value);

      if (!nameMap) {
        nameMap = new Set();
        map.set(item.value, nameMap);
      }

      if (nameMap.has(item.name)) {
        var conflicts = items.filter(function (i) {
          return i.value === item.value;
        });
        throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", "" + JSON.stringify(conflicts, null, 2)].join("\n"));
      }

      nameMap.add(item.name);
    };

    _loop: for (var _iterator = items, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref2;

      var _ret = _loop2();

      switch (_ret) {
        case "break":
          break _loop;

        case "continue":
          continue;
      }
    }
  }

  function createItemFromDescriptor(desc) {
    return new ConfigItem(desc);
  }
  function createConfigItem(value, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$dirname = _ref.dirname,
        dirname = _ref$dirname === void 0 ? "." : _ref$dirname,
        type = _ref.type;

    var descriptor = createDescriptor(value, path$1.resolve(dirname), {
      type: type,
      alias: "programmatic item"
    });
    return createItemFromDescriptor(descriptor);
  }
  function getItemDescriptor(item) {
    if (item instanceof ConfigItem) {
      return item._descriptor;
    }

    return undefined;
  }

  var ConfigItem = function ConfigItem(descriptor) {
    this._descriptor = descriptor;
    Object.defineProperty(this, "_descriptor", {
      enumerable: false
    });
    this.value = this._descriptor.value;
    this.options = this._descriptor.options;
    this.dirname = this._descriptor.dirname;
    this.name = this._descriptor.name;
    this.file = this._descriptor.file ? {
      request: this._descriptor.file.request,
      resolved: this._descriptor.file.resolved
    } : undefined;
    Object.freeze(this);
  };

  Object.freeze(ConfigItem.prototype);

  var Plugin = function Plugin(plugin, options, key) {
    this.key = plugin.name || key;
    this.manipulateOptions = plugin.manipulateOptions;
    this.post = plugin.post;
    this.pre = plugin.pre;
    this.visitor = plugin.visitor || {};
    this.parserOverride = plugin.parserOverride;
    this.generatorOverride = plugin.generatorOverride;
    this.options = options;
  };

  var s$1 = 1000;
  var m$1 = s$1 * 60;
  var h$1 = m$1 * 60;
  var d$1 = h$1 * 24;
  var w$1 = d$1 * 7;
  var y$1 = d$1 * 365.25;

  var ms$1 = function (val, options) {
    options = options || {};
    var type = typeof val;

    if (type === 'string' && val.length > 0) {
      return parse$2(val);
    } else if (type === 'number' && isFinite(val)) {
      return options["long"] ? fmtLong$1(val) : fmtShort$1(val);
    }

    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  function parse$2(str) {
    str = String(str);

    if (str.length > 100) {
      return;
    }

    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

    if (!match) {
      return;
    }

    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();

    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y$1;

      case 'weeks':
      case 'week':
      case 'w':
        return n * w$1;

      case 'days':
      case 'day':
      case 'd':
        return n * d$1;

      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h$1;

      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m$1;

      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s$1;

      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;

      default:
        return undefined;
    }
  }

  function fmtShort$1(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d$1) {
      return Math.round(ms / d$1) + 'd';
    }

    if (msAbs >= h$1) {
      return Math.round(ms / h$1) + 'h';
    }

    if (msAbs >= m$1) {
      return Math.round(ms / m$1) + 'm';
    }

    if (msAbs >= s$1) {
      return Math.round(ms / s$1) + 's';
    }

    return ms + 'ms';
  }

  function fmtLong$1(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d$1) {
      return plural$1(ms, msAbs, d$1, 'day');
    }

    if (msAbs >= h$1) {
      return plural$1(ms, msAbs, h$1, 'hour');
    }

    if (msAbs >= m$1) {
      return plural$1(ms, msAbs, m$1, 'minute');
    }

    if (msAbs >= s$1) {
      return plural$1(ms, msAbs, s$1, 'second');
    }

    return ms + ' ms';
  }

  function plural$1(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }

  function setup$2(env) {
    createDebug.debug = createDebug;
    createDebug["default"] = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = ms$1;
    Object.keys(env).forEach(function (key) {
      createDebug[key] = env[key];
    });
    createDebug.instances = [];
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};

    function selectColor(namespace) {
      var hash = 0;

      for (var i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }

      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }

    createDebug.selectColor = selectColor;

    function createDebug(namespace) {
      var prevTime;

      function debug() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (!debug.enabled) {
          return;
        }

        var self = debug;
        var curr = Number(new Date());
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);

        if (typeof args[0] !== 'string') {
          args.unshift('%O');
        }

        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          if (match === '%%') {
            return match;
          }

          index++;
          var formatter = createDebug.formatters[format];

          if (typeof formatter === 'function') {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }

          return match;
        });
        createDebug.formatArgs.call(self, args);
        var logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.enabled = createDebug.enabled(namespace);
      debug.useColors = createDebug.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      debug.extend = extend;

      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }

      createDebug.instances.push(debug);
      return debug;
    }

    function destroy() {
      var index = createDebug.instances.indexOf(this);

      if (index !== -1) {
        createDebug.instances.splice(index, 1);
        return true;
      }

      return false;
    }

    function extend(namespace, delimiter) {
      var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }

    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      var i;
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }

        namespaces = split[i].replace(/\*/g, '.*?');

        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }

      for (i = 0; i < createDebug.instances.length; i++) {
        var instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }

    function disable() {
      var namespaces = [].concat(createDebug.names.map(toNamespace), createDebug.skips.map(toNamespace).map(function (namespace) {
        return '-' + namespace;
      })).join(',');
      createDebug.enable('');
      return namespaces;
    }

    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }

      var i;
      var len;

      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }

      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }

      return false;
    }

    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
    }

    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }

      return val;
    }

    createDebug.enable(createDebug.load());
    return createDebug;
  }

  var common$1 = setup$2;

  var browser$4 = createCommonjsModule(function (module, exports) {
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

  function useColors() {
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
      return true;
    }

    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }

    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }

  function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

    if (!this.useColors) {
      return;
    }

    var c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function (match) {
      if (match === '%%') {
        return;
      }

      index++;

      if (match === '%c') {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }

  function log() {
    var _console;

    return typeof console === 'object' && console.log && (_console = console).log.apply(_console, arguments);
  }

  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem('debug', namespaces);
      } else {
        exports.storage.removeItem('debug');
      }
    } catch (error) {}
  }

  function load() {
    var r;

    try {
      r = exports.storage.getItem('debug');
    } catch (error) {}

    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }

  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }

  module.exports = common$1(exports);
  var formatters = module.exports.formatters;

  formatters.j = function (v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return '[UnexpectedJSONParseError]: ' + error.message;
    }
  };
  });
  var browser_1$1 = browser$4.log;
  var browser_2$1 = browser$4.formatArgs;
  var browser_3$1 = browser$4.save;
  var browser_4$1 = browser$4.load;
  var browser_5$1 = browser$4.useColors;
  var browser_6$1 = browser$4.storage;
  var browser_7$1 = browser$4.colors;

  var removed = {
    auxiliaryComment: {
      message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
    },
    blacklist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    breakConfig: {
      message: "This is not a necessary option in Babel 6"
    },
    experimental: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    externalHelpers: {
      message: "Use the `external-helpers` plugin instead. " + "Check out http://babeljs.io/docs/plugins/external-helpers/"
    },
    extra: {
      message: ""
    },
    jsxPragma: {
      message: "use the `pragma` option in the `react-jsx` plugin. " + "Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
    },
    loose: {
      message: "Specify the `loose` option for the relevant plugin you are using " + "or use a preset that sets the option."
    },
    metadataUsedHelpers: {
      message: "Not required anymore as this is enabled by default"
    },
    modules: {
      message: "Use the corresponding module transform plugin in the `plugins` option. " + "Check out http://babeljs.io/docs/plugins/#modules"
    },
    nonStandard: {
      message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. " + "Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
    },
    optional: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    sourceMapName: {
      message: "The `sourceMapName` option has been removed because it makes more sense for the " + "tooling that calls Babel to assign `map.file` themselves."
    },
    stage: {
      message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
    },
    whitelist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    resolveModuleSource: {
      version: 6,
      message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
    },
    metadata: {
      version: 6,
      message: "Generated plugin metadata is always included in the output result"
    },
    sourceMapTarget: {
      version: 6,
      message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling " + "that calls Babel to assign `map.file` themselves."
    }
  };

  function msg(loc) {
    switch (loc.type) {
      case "root":
        return "";

      case "env":
        return msg(loc.parent) + ".env[\"" + loc.name + "\"]";

      case "overrides":
        return msg(loc.parent) + ".overrides[" + loc.index + "]";

      case "option":
        return msg(loc.parent) + "." + loc.name;

      case "access":
        return msg(loc.parent) + "[" + JSON.stringify(loc.name) + "]";

      default:
        throw new Error("Assertion failure: Unknown type " + loc.type);
    }
  }
  function access(loc, name) {
    return {
      type: "access",
      name: name,
      parent: loc
    };
  }
  function assertRootMode(loc, value) {
    if (value !== undefined && value !== "root" && value !== "upward" && value !== "upward-optional") {
      throw new Error(msg(loc) + " must be a \"root\", \"upward\", \"upward-optional\" or undefined");
    }

    return value;
  }
  function assertSourceMaps(loc, value) {
    if (value !== undefined && typeof value !== "boolean" && value !== "inline" && value !== "both") {
      throw new Error(msg(loc) + " must be a boolean, \"inline\", \"both\", or undefined");
    }

    return value;
  }
  function assertCompact(loc, value) {
    if (value !== undefined && typeof value !== "boolean" && value !== "auto") {
      throw new Error(msg(loc) + " must be a boolean, \"auto\", or undefined");
    }

    return value;
  }
  function assertSourceType(loc, value) {
    if (value !== undefined && value !== "module" && value !== "script" && value !== "unambiguous") {
      throw new Error(msg(loc) + " must be \"module\", \"script\", \"unambiguous\", or undefined");
    }

    return value;
  }
  function assertCallerMetadata(loc, value) {
    var obj = assertObject(loc, value);

    if (obj) {
      if (typeof obj["name"] !== "string") {
        throw new Error(msg(loc) + " set but does not contain \"name\" property string");
      }

      for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
        var prop = _Object$keys[_i];
        var propLoc = access(loc, prop);
        var _value = obj[prop];

        if (_value != null && typeof _value !== "boolean" && typeof _value !== "string" && typeof _value !== "number") {
          throw new Error(msg(propLoc) + " must be null, undefined, a boolean, a string, or a number.");
        }
      }
    }

    return value;
  }
  function assertInputSourceMap(loc, value) {
    if (value !== undefined && typeof value !== "boolean" && (typeof value !== "object" || !value)) {
      throw new Error(msg(loc) + " must be a boolean, object, or undefined");
    }

    return value;
  }
  function assertString(loc, value) {
    if (value !== undefined && typeof value !== "string") {
      throw new Error(msg(loc) + " must be a string, or undefined");
    }

    return value;
  }
  function assertFunction$1(loc, value) {
    if (value !== undefined && typeof value !== "function") {
      throw new Error(msg(loc) + " must be a function, or undefined");
    }

    return value;
  }
  function assertBoolean(loc, value) {
    if (value !== undefined && typeof value !== "boolean") {
      throw new Error(msg(loc) + " must be a boolean, or undefined");
    }

    return value;
  }
  function assertObject(loc, value) {
    if (value !== undefined && (typeof value !== "object" || Array.isArray(value) || !value)) {
      throw new Error(msg(loc) + " must be an object, or undefined");
    }

    return value;
  }
  function assertArray(loc, value) {
    if (value != null && !Array.isArray(value)) {
      throw new Error(msg(loc) + " must be an array, or undefined");
    }

    return value;
  }
  function assertIgnoreList(loc, value) {
    var arr = assertArray(loc, value);

    if (arr) {
      arr.forEach(function (item, i) {
        return assertIgnoreItem(access(loc, i), item);
      });
    }

    return arr;
  }

  function assertIgnoreItem(loc, value) {
    if (typeof value !== "string" && typeof value !== "function" && !(value instanceof RegExp)) {
      throw new Error(msg(loc) + " must be an array of string/Function/RegExp values, or undefined");
    }

    return value;
  }

  function assertConfigApplicableTest(loc, value) {
    if (value === undefined) return value;

    if (Array.isArray(value)) {
      value.forEach(function (item, i) {
        if (!checkValidTest(item)) {
          throw new Error(msg(access(loc, i)) + " must be a string/Function/RegExp.");
        }
      });
    } else if (!checkValidTest(value)) {
      throw new Error(msg(loc) + " must be a string/Function/RegExp, or an array of those");
    }

    return value;
  }

  function checkValidTest(value) {
    return typeof value === "string" || typeof value === "function" || value instanceof RegExp;
  }

  function assertConfigFileSearch(loc, value) {
    if (value !== undefined && typeof value !== "boolean" && typeof value !== "string") {
      throw new Error(msg(loc) + " must be a undefined, a boolean, a string, " + ("got " + JSON.stringify(value)));
    }

    return value;
  }
  function assertBabelrcSearch(loc, value) {
    if (value === undefined || typeof value === "boolean") return value;

    if (Array.isArray(value)) {
      value.forEach(function (item, i) {
        if (!checkValidTest(item)) {
          throw new Error(msg(access(loc, i)) + " must be a string/Function/RegExp.");
        }
      });
    } else if (!checkValidTest(value)) {
      throw new Error(msg(loc) + " must be a undefined, a boolean, a string/Function/RegExp " + ("or an array of those, got " + JSON.stringify(value)));
    }

    return value;
  }
  function assertPluginList(loc, value) {
    var arr = assertArray(loc, value);

    if (arr) {
      arr.forEach(function (item, i) {
        return assertPluginItem(access(loc, i), item);
      });
    }

    return arr;
  }

  function assertPluginItem(loc, value) {
    if (Array.isArray(value)) {
      if (value.length === 0) {
        throw new Error(msg(loc) + " must include an object");
      }

      if (value.length > 3) {
        throw new Error(msg(loc) + " may only be a two-tuple or three-tuple");
      }

      assertPluginTarget(access(loc, 0), value[0]);

      if (value.length > 1) {
        var opts = value[1];

        if (opts !== undefined && opts !== false && (typeof opts !== "object" || Array.isArray(opts) || opts === null)) {
          throw new Error(msg(access(loc, 1)) + " must be an object, false, or undefined");
        }
      }

      if (value.length === 3) {
        var name = value[2];

        if (name !== undefined && typeof name !== "string") {
          throw new Error(msg(access(loc, 2)) + " must be a string, or undefined");
        }
      }
    } else {
      assertPluginTarget(loc, value);
    }

    return value;
  }

  function assertPluginTarget(loc, value) {
    if ((typeof value !== "object" || !value) && typeof value !== "string" && typeof value !== "function") {
      throw new Error(msg(loc) + " must be a string, object, function");
    }

    return value;
  }

  var ROOT_VALIDATORS = {
    cwd: assertString,
    root: assertString,
    rootMode: assertRootMode,
    configFile: assertConfigFileSearch,
    caller: assertCallerMetadata,
    filename: assertString,
    filenameRelative: assertString,
    code: assertBoolean,
    ast: assertBoolean,
    envName: assertString
  };
  var BABELRC_VALIDATORS = {
    babelrc: assertBoolean,
    babelrcRoots: assertBabelrcSearch
  };
  var NONPRESET_VALIDATORS = {
    "extends": assertString,
    ignore: assertIgnoreList,
    only: assertIgnoreList
  };
  var COMMON_VALIDATORS = {
    inputSourceMap: assertInputSourceMap,
    presets: assertPluginList,
    plugins: assertPluginList,
    passPerPreset: assertBoolean,
    env: assertEnvSet,
    overrides: assertOverridesList,
    test: assertConfigApplicableTest,
    include: assertConfigApplicableTest,
    exclude: assertConfigApplicableTest,
    retainLines: assertBoolean,
    comments: assertBoolean,
    shouldPrintComment: assertFunction$1,
    compact: assertCompact,
    minified: assertBoolean,
    auxiliaryCommentBefore: assertString,
    auxiliaryCommentAfter: assertString,
    sourceType: assertSourceType,
    wrapPluginVisitorMethod: assertFunction$1,
    highlightCode: assertBoolean,
    sourceMaps: assertSourceMaps,
    sourceMap: assertSourceMaps,
    sourceFileName: assertString,
    sourceRoot: assertString,
    getModuleId: assertFunction$1,
    moduleRoot: assertString,
    moduleIds: assertBoolean,
    moduleId: assertString,
    parserOpts: assertObject,
    generatorOpts: assertObject
  };

  function getSource$1(loc) {
    return loc.type === "root" ? loc.source : getSource$1(loc.parent);
  }

  function validate$3(type, opts) {
    return validateNested({
      type: "root",
      source: type
    }, opts);
  }

  function validateNested(loc, opts) {
    var type = getSource$1(loc);
    assertNoDuplicateSourcemap(opts);
    Object.keys(opts).forEach(function (key) {
      var optLoc = {
        type: "option",
        name: key,
        parent: loc
      };

      if (type === "preset" && NONPRESET_VALIDATORS[key]) {
        throw new Error(msg(optLoc) + " is not allowed in preset options");
      }

      if (type !== "arguments" && ROOT_VALIDATORS[key]) {
        throw new Error(msg(optLoc) + " is only allowed in root programmatic options");
      }

      if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key]) {
        if (type === "babelrcfile" || type === "extendsfile") {
          throw new Error(msg(optLoc) + " is not allowed in .babelrc or \"extends\"ed files, only in root programmatic options, " + "or babel.config.js/config file options");
        }

        throw new Error(msg(optLoc) + " is only allowed in root programmatic options, or babel.config.js/config file options");
      }

      var validator = COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError;
      validator(optLoc, opts[key]);
    });
    return opts;
  }

  function throwUnknownError(loc) {
    var key = loc.name;

    if (removed[key]) {
      var _removed$key = removed[key],
          message = _removed$key.message,
          _removed$key$version = _removed$key.version,
          version = _removed$key$version === void 0 ? 5 : _removed$key$version;
      throw new Error("Using removed Babel " + version + " option: " + msg(loc) + " - " + message);
    } else {
      var unknownOptErr = new Error("Unknown option: " + msg(loc) + ". Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.");
      unknownOptErr.code = "BABEL_UNKNOWN_OPTION";
      throw unknownOptErr;
    }
  }

  function has$3(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  function assertNoDuplicateSourcemap(opts) {
    if (has$3(opts, "sourceMap") && has$3(opts, "sourceMaps")) {
      throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
    }
  }

  function assertEnvSet(loc, value) {
    if (loc.parent.type === "env") {
      throw new Error(msg(loc) + " is not allowed inside of another .env block");
    }

    var parent = loc.parent;
    var obj = assertObject(loc, value);

    if (obj) {
      for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
        var envName = _Object$keys[_i];
        var env = assertObject(access(loc, envName), obj[envName]);
        if (!env) continue;
        var envLoc = {
          type: "env",
          name: envName,
          parent: parent
        };
        validateNested(envLoc, env);
      }
    }

    return obj;
  }

  function assertOverridesList(loc, value) {
    if (loc.parent.type === "env") {
      throw new Error(msg(loc) + " is not allowed inside an .env block");
    }

    if (loc.parent.type === "overrides") {
      throw new Error(msg(loc) + " is not allowed inside an .overrides block");
    }

    var parent = loc.parent;
    var arr = assertArray(loc, value);

    if (arr) {
      for (var _iterator = arr.entries(), _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i2 >= _iterator.length) break;
          _ref = _iterator[_i2++];
        } else {
          _i2 = _iterator.next();
          if (_i2.done) break;
          _ref = _i2.value;
        }

        var _ref2 = _ref,
            index = _ref2[0],
            item = _ref2[1];
        var objLoc = access(loc, index);
        var env = assertObject(objLoc, item);
        if (!env) throw new Error(msg(objLoc) + " must be an object");
        var overridesLoc = {
          type: "overrides",
          index: index,
          parent: parent
        };
        validateNested(overridesLoc, env);
      }
    }

    return arr;
  }

  function checkNoUnwrappedItemOptionPairs(lastItem, thisItem, type, index, e) {
    if (lastItem.file && lastItem.options === undefined && typeof thisItem.value === "object") {
      e.message += "\n- Maybe you meant to use\n" + ("\"" + type + "\": [\n  [\"" + lastItem.file.request + "\", " + JSON.stringify(thisItem.value, undefined, 2) + "]\n]\n") + ("To be a valid " + type + ", its name and options should be wrapped in a pair of brackets");
    }
  }

  var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar$1.source);

  function escapeRegExp(string) {
    string = toString_1(string);
    return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar$1, '\\$&') : string;
  }

  var escapeRegExp_1 = escapeRegExp;

  var sep$1 = "\\" + path$1.sep;
  var endSep = "(?:" + sep$1 + "|$)";
  var substitution = "[^" + sep$1 + "]+";
  var starPat = "(?:" + substitution + sep$1 + ")";
  var starPatLast = "(?:" + substitution + endSep + ")";
  var starStarPat = starPat + "*?";
  var starStarPatLast = starPat + "*?" + starPatLast + "?";
  function pathToPattern(pattern, dirname) {
    var parts = path$1.resolve(dirname, pattern).split(path$1.sep);
    return new RegExp(["^"].concat(parts.map(function (part, i) {
      var last = i === parts.length - 1;
      if (part === "**") return last ? starStarPatLast : starStarPat;
      if (part === "*") return last ? starPatLast : starPat;

      if (part.indexOf("*.") === 0) {
        return substitution + escapeRegExp_1(part.slice(1)) + (last ? endSep : sep$1);
      }

      return escapeRegExp_1(part) + (last ? endSep : sep$1);
    })).join(""));
  }

  var _marked$2 = regenerator.mark(buildPresetChain),
      _marked2$2 = regenerator.mark(buildRootChain),
      _marked3$2 = regenerator.mark(mergeExtendsChain);
  var debug = browser$4("babel:config:config-chain");
  function buildPresetChain(arg, context) {
    var chain;
    return regenerator.wrap(function buildPresetChain$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(buildPresetChainWalker(arg, context), "t0", 1);

          case 1:
            chain = _context.t0;

            if (chain) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", null);

          case 4:
            return _context.abrupt("return", {
              plugins: dedupDescriptors(chain.plugins),
              presets: dedupDescriptors(chain.presets),
              options: chain.options.map(function (o) {
                return normalizeOptions$1(o);
              })
            });

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$2);
  }
  var buildPresetChainWalker = makeChainWalker({
    init: function init(arg) {
      return arg;
    },
    root: function root(preset) {
      return loadPresetDescriptors(preset);
    },
    env: function env(preset, envName) {
      return loadPresetEnvDescriptors(preset)(envName);
    },
    overrides: function overrides(preset, index) {
      return loadPresetOverridesDescriptors(preset)(index);
    },
    overridesEnv: function overridesEnv(preset, index, envName) {
      return loadPresetOverridesEnvDescriptors(preset)(index)(envName);
    }
  });
  var loadPresetDescriptors = makeWeakCacheSync(function (preset) {
    return buildRootDescriptors(preset, preset.alias, createUncachedDescriptors);
  });
  var loadPresetEnvDescriptors = makeWeakCacheSync(function (preset) {
    return makeStrongCacheSync(function (envName) {
      return buildEnvDescriptors(preset, preset.alias, createUncachedDescriptors, envName);
    });
  });
  var loadPresetOverridesDescriptors = makeWeakCacheSync(function (preset) {
    return makeStrongCacheSync(function (index) {
      return buildOverrideDescriptors(preset, preset.alias, createUncachedDescriptors, index);
    });
  });
  var loadPresetOverridesEnvDescriptors = makeWeakCacheSync(function (preset) {
    return makeStrongCacheSync(function (index) {
      return makeStrongCacheSync(function (envName) {
        return buildOverrideEnvDescriptors(preset, preset.alias, createUncachedDescriptors, index, envName);
      });
    });
  });
  function buildRootChain(opts, context) {
    var programmaticChain, configFile, babelrc, babelrcRoots, babelrcRootsDirectory, configFileChain, validatedFile, result, pkgData, ignoreFile, babelrcFile, fileChain, _ref, _result, chain;

    return regenerator.wrap(function buildRootChain$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.delegateYield(loadProgrammaticChain({
              options: opts,
              dirname: context.cwd
            }, context), "t0", 1);

          case 1:
            programmaticChain = _context2.t0;

            if (programmaticChain) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", null);

          case 4:
            if (!(typeof opts.configFile === "string")) {
              _context2.next = 9;
              break;
            }

            return _context2.delegateYield(loadConfig(opts.configFile, context.cwd, context.envName, context.caller), "t1", 6);

          case 6:
            configFile = _context2.t1;
            _context2.next = 12;
            break;

          case 9:
            if (!(opts.configFile !== false)) {
              _context2.next = 12;
              break;
            }

            return _context2.delegateYield(findRootConfig(context.root, context.envName, context.caller), "t2", 11);

          case 11:
            configFile = _context2.t2;

          case 12:
            babelrc = opts.babelrc, babelrcRoots = opts.babelrcRoots;
            babelrcRootsDirectory = context.cwd;
            configFileChain = emptyChain();

            if (!configFile) {
              _context2.next = 24;
              break;
            }

            validatedFile = validateConfigFile(configFile);
            return _context2.delegateYield(loadFileChain(validatedFile, context), "t3", 18);

          case 18:
            result = _context2.t3;

            if (result) {
              _context2.next = 21;
              break;
            }

            return _context2.abrupt("return", null);

          case 21:
            if (babelrc === undefined) {
              babelrc = validatedFile.options.babelrc;
            }

            if (babelrcRoots === undefined) {
              babelrcRootsDirectory = validatedFile.dirname;
              babelrcRoots = validatedFile.options.babelrcRoots;
            }

            mergeChain(configFileChain, result);

          case 24:
            if (!(typeof context.filename === "string")) {
              _context2.next = 29;
              break;
            }

            return _context2.delegateYield(findPackageData(context.filename), "t5", 26);

          case 26:
            _context2.t4 = _context2.t5;
            _context2.next = 30;
            break;

          case 29:
            _context2.t4 = null;

          case 30:
            pkgData = _context2.t4;
            fileChain = emptyChain();

            if (!((babelrc === true || babelrc === undefined) && pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory))) {
              _context2.next = 45;
              break;
            }

            return _context2.delegateYield(findRelativeConfig(pkgData, context.envName, context.caller), "t6", 34);

          case 34:
            _ref = _context2.t6;
            ignoreFile = _ref.ignore;
            babelrcFile = _ref.config;

            if (!(ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname))) {
              _context2.next = 39;
              break;
            }

            return _context2.abrupt("return", null);

          case 39:
            if (!babelrcFile) {
              _context2.next = 45;
              break;
            }

            return _context2.delegateYield(loadFileChain(validateBabelrcFile(babelrcFile), context), "t7", 41);

          case 41:
            _result = _context2.t7;

            if (_result) {
              _context2.next = 44;
              break;
            }

            return _context2.abrupt("return", null);

          case 44:
            mergeChain(fileChain, _result);

          case 45:
            chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
            return _context2.abrupt("return", {
              plugins: dedupDescriptors(chain.plugins),
              presets: dedupDescriptors(chain.presets),
              options: chain.options.map(function (o) {
                return normalizeOptions$1(o);
              }),
              ignore: ignoreFile || undefined,
              babelrc: babelrcFile || undefined,
              config: configFile || undefined
            });

          case 47:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2$2);
  }

  function babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {
    if (typeof babelrcRoots === "boolean") return babelrcRoots;
    var absoluteRoot = context.root;

    if (babelrcRoots === undefined) {
      return pkgData.directories.indexOf(absoluteRoot) !== -1;
    }

    var babelrcPatterns = babelrcRoots;
    if (!Array.isArray(babelrcPatterns)) babelrcPatterns = [babelrcPatterns];
    babelrcPatterns = babelrcPatterns.map(function (pat) {
      return typeof pat === "string" ? path$1.resolve(babelrcRootsDirectory, pat) : pat;
    });

    if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {
      return pkgData.directories.indexOf(absoluteRoot) !== -1;
    }

    return babelrcPatterns.some(function (pat) {
      if (typeof pat === "string") {
        pat = pathToPattern(pat, babelrcRootsDirectory);
      }

      return pkgData.directories.some(function (directory) {
        return matchPattern(pat, babelrcRootsDirectory, directory, context);
      });
    });
  }

  var validateConfigFile = makeWeakCacheSync(function (file) {
    return {
      filepath: file.filepath,
      dirname: file.dirname,
      options: validate$3("configfile", file.options)
    };
  });
  var validateBabelrcFile = makeWeakCacheSync(function (file) {
    return {
      filepath: file.filepath,
      dirname: file.dirname,
      options: validate$3("babelrcfile", file.options)
    };
  });
  var validateExtendFile = makeWeakCacheSync(function (file) {
    return {
      filepath: file.filepath,
      dirname: file.dirname,
      options: validate$3("extendsfile", file.options)
    };
  });
  var loadProgrammaticChain = makeChainWalker({
    root: function root(input) {
      return buildRootDescriptors(input, "base", createCachedDescriptors);
    },
    env: function env(input, envName) {
      return buildEnvDescriptors(input, "base", createCachedDescriptors, envName);
    },
    overrides: function overrides(input, index) {
      return buildOverrideDescriptors(input, "base", createCachedDescriptors, index);
    },
    overridesEnv: function overridesEnv(input, index, envName) {
      return buildOverrideEnvDescriptors(input, "base", createCachedDescriptors, index, envName);
    }
  });
  var loadFileChain = makeChainWalker({
    root: function root(file) {
      return loadFileDescriptors(file);
    },
    env: function env(file, envName) {
      return loadFileEnvDescriptors(file)(envName);
    },
    overrides: function overrides(file, index) {
      return loadFileOverridesDescriptors(file)(index);
    },
    overridesEnv: function overridesEnv(file, index, envName) {
      return loadFileOverridesEnvDescriptors(file)(index)(envName);
    }
  });
  var loadFileDescriptors = makeWeakCacheSync(function (file) {
    return buildRootDescriptors(file, file.filepath, createUncachedDescriptors);
  });
  var loadFileEnvDescriptors = makeWeakCacheSync(function (file) {
    return makeStrongCacheSync(function (envName) {
      return buildEnvDescriptors(file, file.filepath, createUncachedDescriptors, envName);
    });
  });
  var loadFileOverridesDescriptors = makeWeakCacheSync(function (file) {
    return makeStrongCacheSync(function (index) {
      return buildOverrideDescriptors(file, file.filepath, createUncachedDescriptors, index);
    });
  });
  var loadFileOverridesEnvDescriptors = makeWeakCacheSync(function (file) {
    return makeStrongCacheSync(function (index) {
      return makeStrongCacheSync(function (envName) {
        return buildOverrideEnvDescriptors(file, file.filepath, createUncachedDescriptors, index, envName);
      });
    });
  });

  function buildRootDescriptors(_ref2, alias, descriptors) {
    var dirname = _ref2.dirname,
        options = _ref2.options;
    return descriptors(dirname, options, alias);
  }

  function buildEnvDescriptors(_ref3, alias, descriptors, envName) {
    var dirname = _ref3.dirname,
        options = _ref3.options;
    var opts = options.env && options.env[envName];
    return opts ? descriptors(dirname, opts, alias + ".env[\"" + envName + "\"]") : null;
  }

  function buildOverrideDescriptors(_ref4, alias, descriptors, index) {
    var dirname = _ref4.dirname,
        options = _ref4.options;
    var opts = options.overrides && options.overrides[index];
    if (!opts) throw new Error("Assertion failure - missing override");
    return descriptors(dirname, opts, alias + ".overrides[" + index + "]");
  }

  function buildOverrideEnvDescriptors(_ref5, alias, descriptors, index, envName) {
    var dirname = _ref5.dirname,
        options = _ref5.options;
    var override = options.overrides && options.overrides[index];
    if (!override) throw new Error("Assertion failure - missing override");
    var opts = override.env && override.env[envName];
    return opts ? descriptors(dirname, opts, alias + ".overrides[" + index + "].env[\"" + envName + "\"]") : null;
  }

  function makeChainWalker(_ref6) {
    var root = _ref6.root,
        env = _ref6.env,
        overrides = _ref6.overrides,
        overridesEnv = _ref6.overridesEnv;
    return regenerator.mark(function _callee(input, context, files) {
      var dirname, flattenedConfigs, rootOpts, envOpts, chain, _i, _flattenedConfigs, op;

      return regenerator.wrap(function _callee$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (files === void 0) {
                files = new Set();
              }

              dirname = input.dirname;
              flattenedConfigs = [];
              rootOpts = root(input);

              if (configIsApplicable(rootOpts, dirname, context)) {
                flattenedConfigs.push(rootOpts);
                envOpts = env(input, context.envName);

                if (envOpts && configIsApplicable(envOpts, dirname, context)) {
                  flattenedConfigs.push(envOpts);
                }

                (rootOpts.options.overrides || []).forEach(function (_, index) {
                  var overrideOps = overrides(input, index);

                  if (configIsApplicable(overrideOps, dirname, context)) {
                    flattenedConfigs.push(overrideOps);
                    var overrideEnvOpts = overridesEnv(input, index, context.envName);

                    if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {
                      flattenedConfigs.push(overrideEnvOpts);
                    }
                  }
                });
              }

              if (!flattenedConfigs.some(function (_ref7) {
                var _ref7$options = _ref7.options,
                    ignore = _ref7$options.ignore,
                    only = _ref7$options.only;
                return shouldIgnore(context, ignore, only, dirname);
              })) {
                _context3.next = 7;
                break;
              }

              return _context3.abrupt("return", null);

            case 7:
              chain = emptyChain();
              _i = 0, _flattenedConfigs = flattenedConfigs;

            case 9:
              if (!(_i < _flattenedConfigs.length)) {
                _context3.next = 18;
                break;
              }

              op = _flattenedConfigs[_i];
              return _context3.delegateYield(mergeExtendsChain(chain, op.options, dirname, context, files), "t0", 12);

            case 12:
              if (_context3.t0) {
                _context3.next = 14;
                break;
              }

              return _context3.abrupt("return", null);

            case 14:
              mergeChainOpts(chain, op);

            case 15:
              _i++;
              _context3.next = 9;
              break;

            case 18:
              return _context3.abrupt("return", chain);

            case 19:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee);
    });
  }

  function mergeExtendsChain(chain, opts, dirname, context, files) {
    var file, fileChain;
    return regenerator.wrap(function mergeExtendsChain$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(opts["extends"] === undefined)) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return", true);

          case 2:
            return _context4.delegateYield(loadConfig(opts["extends"], dirname, context.envName, context.caller), "t0", 3);

          case 3:
            file = _context4.t0;

            if (!files.has(file)) {
              _context4.next = 6;
              break;
            }

            throw new Error("Configuration cycle detected loading " + file.filepath + ".\n" + "File already loaded following the config chain:\n" + Array.from(files, function (file) {
              return " - " + file.filepath;
            }).join("\n"));

          case 6:
            files.add(file);
            return _context4.delegateYield(loadFileChain(validateExtendFile(file), context, files), "t1", 8);

          case 8:
            fileChain = _context4.t1;
            files["delete"](file);

            if (fileChain) {
              _context4.next = 12;
              break;
            }

            return _context4.abrupt("return", false);

          case 12:
            mergeChain(chain, fileChain);
            return _context4.abrupt("return", true);

          case 14:
          case "end":
            return _context4.stop();
        }
      }
    }, _marked3$2);
  }

  function mergeChain(target, source) {
    var _target$options, _target$plugins, _target$presets;

    (_target$options = target.options).push.apply(_target$options, source.options);

    (_target$plugins = target.plugins).push.apply(_target$plugins, source.plugins);

    (_target$presets = target.presets).push.apply(_target$presets, source.presets);

    return target;
  }

  function mergeChainOpts(target, _ref8) {
    var _target$plugins2, _target$presets2;

    var options = _ref8.options,
        plugins = _ref8.plugins,
        presets = _ref8.presets;
    target.options.push(options);

    (_target$plugins2 = target.plugins).push.apply(_target$plugins2, plugins());

    (_target$presets2 = target.presets).push.apply(_target$presets2, presets());

    return target;
  }

  function emptyChain() {
    return {
      options: [],
      presets: [],
      plugins: []
    };
  }

  function normalizeOptions$1(opts) {
    var options = Object.assign({}, opts);
    delete options["extends"];
    delete options.env;
    delete options.overrides;
    delete options.plugins;
    delete options.presets;
    delete options.passPerPreset;
    delete options.ignore;
    delete options.only;
    delete options.test;
    delete options.include;
    delete options.exclude;

    if (Object.prototype.hasOwnProperty.call(options, "sourceMap")) {
      options.sourceMaps = options.sourceMap;
      delete options.sourceMap;
    }

    return options;
  }

  function dedupDescriptors(items) {
    var map = new Map();
    var descriptors = [];

    for (var _iterator = items, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref9;

      if (_isArray) {
        if (_i2 >= _iterator.length) break;
        _ref9 = _iterator[_i2++];
      } else {
        _i2 = _iterator.next();
        if (_i2.done) break;
        _ref9 = _i2.value;
      }

      var item = _ref9;

      if (typeof item.value === "function") {
        var fnKey = item.value;
        var nameMap = map.get(fnKey);

        if (!nameMap) {
          nameMap = new Map();
          map.set(fnKey, nameMap);
        }

        var desc = nameMap.get(item.name);

        if (!desc) {
          desc = {
            value: item
          };
          descriptors.push(desc);
          if (!item.ownPass) nameMap.set(item.name, desc);
        } else {
          desc.value = item;
        }
      } else {
        descriptors.push({
          value: item
        });
      }
    }

    return descriptors.reduce(function (acc, desc) {
      acc.push(desc.value);
      return acc;
    }, []);
  }

  function configIsApplicable(_ref10, dirname, context) {
    var options = _ref10.options;
    return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));
  }

  function configFieldIsApplicable(context, test, dirname) {
    var patterns = Array.isArray(test) ? test : [test];
    return matchesPatterns(context, patterns, dirname);
  }

  function shouldIgnore(context, ignore, only, dirname) {
    if (ignore && matchesPatterns(context, ignore, dirname)) {
      debug("Ignored %o because it matched one of %O from %o", context.filename, ignore, dirname);
      return true;
    }

    if (only && !matchesPatterns(context, only, dirname)) {
      debug("Ignored %o because it failed to match one of %O from %o", context.filename, only, dirname);
      return true;
    }

    return false;
  }

  function matchesPatterns(context, patterns, dirname) {
    return patterns.some(function (pattern) {
      return matchPattern(pattern, dirname, context.filename, context);
    });
  }

  function matchPattern(pattern, dirname, pathToTest, context) {
    if (typeof pattern === "function") {
      return !!pattern(pathToTest, {
        dirname: dirname,
        envName: context.envName,
        caller: context.caller
      });
    }

    if (typeof pathToTest !== "string") {
      throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");
    }

    if (typeof pattern === "string") {
      pattern = pathToPattern(pattern, dirname);
    }

    return pattern.test(pathToTest);
  }

  var VALIDATORS = {
    name: assertString,
    manipulateOptions: assertFunction$1,
    pre: assertFunction$1,
    post: assertFunction$1,
    inherits: assertFunction$1,
    visitor: assertVisitorMap,
    parserOverride: assertFunction$1,
    generatorOverride: assertFunction$1
  };

  function assertVisitorMap(key, value) {
    var obj = assertObject(key, value);

    if (obj) {
      Object.keys(obj).forEach(function (prop) {
        return assertVisitorHandler(prop, obj[prop]);
      });

      if (obj.enter || obj.exit) {
        throw new Error("." + key + " cannot contain catch-all \"enter\" or \"exit\" handlers. Please target individual nodes.");
      }
    }

    return obj;
  }

  function assertVisitorHandler(key, value) {
    if (value && typeof value === "object") {
      Object.keys(value).forEach(function (handler) {
        if (handler !== "enter" && handler !== "exit") {
          throw new Error(".visitor[\"" + key + "\"] may only have .enter and/or .exit handlers.");
        }
      });
    } else if (typeof value !== "function") {
      throw new Error(".visitor[\"" + key + "\"] must be a function");
    }

    return value;
  }

  function validatePluginObject(obj) {
    var rootPath = {
      type: "root",
      source: "plugin"
    };
    Object.keys(obj).forEach(function (key) {
      var validator = VALIDATORS[key];
      var optLoc = {
        type: "option",
        name: key,
        parent: rootPath
      };
      if (validator) validator(optLoc, obj[key]);else {
        var invalidPluginPropertyError = new Error("." + key + " is not a valid Plugin property");
        invalidPluginPropertyError.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY";
        throw invalidPluginPropertyError;
      }
    });
    return obj;
  }

  function makeAPI(cache) {
    var env = function env(value) {
      return cache.using(function (data) {
        if (typeof value === "undefined") return data.envName;

        if (typeof value === "function") {
          return assertSimpleType(value(data.envName));
        }

        if (!Array.isArray(value)) value = [value];
        return value.some(function (entry) {
          if (typeof entry !== "string") {
            throw new Error("Unexpected non-string value");
          }

          return entry === data.envName;
        });
      });
    };

    var caller = function caller(cb) {
      return cache.using(function (data) {
        return assertSimpleType(cb(data.caller));
      });
    };

    return {
      version: version$1,
      cache: cache.simple(),
      env: env,
      async: function async() {
        return false;
      },
      caller: caller,
      assertVersion: assertVersion,
      tokTypes: undefined
    };
  }

  function assertVersion(range) {
    if (typeof range === "number") {
      if (!Number.isInteger(range)) {
        throw new Error("Expected string or integer value.");
      }

      range = "^" + range + ".0.0-0";
    }

    if (typeof range !== "string") {
      throw new Error("Expected string or integer value.");
    }

    if (semver.satisfies(version$1, range)) return;
    var limit = Error.stackTraceLimit;

    if (typeof limit === "number" && limit < 25) {
      Error.stackTraceLimit = 25;
    }

    var err = new Error("Requires Babel \"" + range + "\", but was loaded with \"" + version$1 + "\". " + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + "the first entry that doesn't mention \"@babel/core\" or \"babel-core\" " + "to see what is calling Babel.");

    if (typeof limit === "number") {
      Error.stackTraceLimit = limit;
    }

    throw Object.assign(err, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: version$1,
      range: range
    });
  }

  var _marked$3 = regenerator.mark(resolveRootMode),
      _marked2$3 = regenerator.mark(loadPrivatePartialConfig);

  function resolveRootMode(rootDir, rootMode) {
    var upwardRootDir, _upwardRootDir;

    return regenerator.wrap(function resolveRootMode$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.t0 = rootMode;
            _context.next = _context.t0 === "root" ? 3 : _context.t0 === "upward-optional" ? 4 : _context.t0 === "upward" ? 7 : 12;
            break;

          case 3:
            return _context.abrupt("return", rootDir);

          case 4:
            return _context.delegateYield(findConfigUpwards(), "t1", 5);

          case 5:
            upwardRootDir = _context.t1;
            return _context.abrupt("return", upwardRootDir === null ? rootDir : upwardRootDir);

          case 7:
            return _context.delegateYield(findConfigUpwards(), "t2", 8);

          case 8:
            _upwardRootDir = _context.t2;

            if (!(_upwardRootDir !== null)) {
              _context.next = 11;
              break;
            }

            return _context.abrupt("return", _upwardRootDir);

          case 11:
            throw Object.assign(new Error("Babel was run with rootMode:\"upward\" but a root could not " + ("be found when searching upward from \"" + rootDir + "\".\n") + "One of the following config files must be in the directory tree: " + ("\"" + ROOT_CONFIG_FILENAMES.join(", ") + "\".")), {
              code: "BABEL_ROOT_NOT_FOUND",
              dirname: rootDir
            });

          case 12:
            throw new Error("Assertion failure - unknown rootMode value.");

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$3);
  }

  function loadPrivatePartialConfig(inputOpts) {
    var args, _args$envName, envName, _args$cwd, cwd, _args$root, rootDir, _args$rootMode, rootMode, caller, absoluteCwd, absoluteRootDir, context, configChain, options;

    return regenerator.wrap(function loadPrivatePartialConfig$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(inputOpts != null && (typeof inputOpts !== "object" || Array.isArray(inputOpts)))) {
              _context2.next = 2;
              break;
            }

            throw new Error("Babel options must be an object, null, or undefined");

          case 2:
            args = inputOpts ? validate$3("arguments", inputOpts) : {};
            _args$envName = args.envName, envName = _args$envName === void 0 ? getEnv() : _args$envName, _args$cwd = args.cwd, cwd = _args$cwd === void 0 ? "." : _args$cwd, _args$root = args.root, rootDir = _args$root === void 0 ? "." : _args$root, _args$rootMode = args.rootMode, rootMode = _args$rootMode === void 0 ? "root" : _args$rootMode, caller = args.caller;
            absoluteCwd = path$1.resolve(cwd);
            return _context2.delegateYield(resolveRootMode(path$1.resolve(absoluteCwd, rootDir), rootMode), "t0", 6);

          case 6:
            absoluteRootDir = _context2.t0;
            context = {
              filename: typeof args.filename === "string" ? path$1.resolve(cwd, args.filename) : undefined,
              cwd: absoluteCwd,
              root: absoluteRootDir,
              envName: envName,
              caller: caller
            };
            return _context2.delegateYield(buildRootChain(args, context), "t1", 9);

          case 9:
            configChain = _context2.t1;

            if (configChain) {
              _context2.next = 12;
              break;
            }

            return _context2.abrupt("return", null);

          case 12:
            options = {};
            configChain.options.forEach(function (opts) {
              mergeOptions(options, opts);
            });
            options.babelrc = false;
            options.configFile = false;
            options.passPerPreset = false;
            options.envName = context.envName;
            options.cwd = context.cwd;
            options.root = context.root;
            options.filename = typeof context.filename === "string" ? context.filename : undefined;
            options.plugins = configChain.plugins.map(function (descriptor) {
              return createItemFromDescriptor(descriptor);
            });
            options.presets = configChain.presets.map(function (descriptor) {
              return createItemFromDescriptor(descriptor);
            });
            return _context2.abrupt("return", {
              options: options,
              context: context,
              ignore: configChain.ignore,
              babelrc: configChain.babelrc,
              config: configChain.config
            });

          case 24:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2$3);
  }
  var loadPartialConfig = gensync(regenerator.mark(function _callee(inputOpts) {
    var result, options, babelrc, ignore, config;
    return regenerator.wrap(function _callee$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.delegateYield(loadPrivatePartialConfig(inputOpts), "t0", 1);

          case 1:
            result = _context3.t0;

            if (result) {
              _context3.next = 4;
              break;
            }

            return _context3.abrupt("return", null);

          case 4:
            options = result.options, babelrc = result.babelrc, ignore = result.ignore, config = result.config;
            (options.plugins || []).forEach(function (item) {
              if (item.value instanceof Plugin) {
                throw new Error("Passing cached plugin instances is not supported in " + "babel.loadPartialConfig()");
              }
            });
            return _context3.abrupt("return", new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config ? config.filepath : undefined));

          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee);
  }));

  var PartialConfig = function () {
    function PartialConfig(options, babelrc, ignore, config) {
      this.options = options;
      this.babelignore = ignore;
      this.babelrc = babelrc;
      this.config = config;
      Object.freeze(this);
    }

    var _proto = PartialConfig.prototype;

    _proto.hasFilesystemConfig = function hasFilesystemConfig() {
      return this.babelrc !== undefined || this.config !== undefined;
    };

    return PartialConfig;
  }();

  Object.freeze(PartialConfig.prototype);

  var _marked$4 = regenerator.mark(loadPluginDescriptor),
      _marked2$4 = regenerator.mark(loadPresetDescriptor);
  var loadConfig$1 = gensync(regenerator.mark(function loadFullConfig(inputOpts) {
    var result, options, context, optionDefaults, passes, plugins, presets, ignored, opts;
    return regenerator.wrap(function loadFullConfig$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.delegateYield(loadPrivatePartialConfig(inputOpts), "t0", 1);

          case 1:
            result = _context2.t0;

            if (result) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", null);

          case 4:
            options = result.options, context = result.context;
            optionDefaults = {};
            passes = [[]];
            _context2.prev = 7;
            plugins = options.plugins, presets = options.presets;

            if (!(!plugins || !presets)) {
              _context2.next = 11;
              break;
            }

            throw new Error("Assertion failure - plugins and presets exist");

          case 11:
            return _context2.delegateYield(regenerator.mark(function recurseDescriptors(config, pass) {
              var plugins, i, descriptor, presets, _i, _descriptor, _iterator, _isArray, _i2, _ref, _ref2, preset, _pass, _ignored;

              return regenerator.wrap(function recurseDescriptors$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      plugins = [];
                      i = 0;

                    case 2:
                      if (!(i < config.plugins.length)) {
                        _context.next = 19;
                        break;
                      }

                      descriptor = config.plugins[i];

                      if (!(descriptor.options !== false)) {
                        _context.next = 16;
                        break;
                      }

                      _context.prev = 5;
                      _context.t0 = plugins;
                      return _context.delegateYield(loadPluginDescriptor(descriptor, context), "t1", 8);

                    case 8:
                      _context.t2 = _context.t1;

                      _context.t0.push.call(_context.t0, _context.t2);

                      _context.next = 16;
                      break;

                    case 12:
                      _context.prev = 12;
                      _context.t3 = _context["catch"](5);

                      if (i > 0 && _context.t3.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY") {
                        checkNoUnwrappedItemOptionPairs(config.plugins[i - 1], descriptor, "plugin", i, _context.t3);
                      }

                      throw _context.t3;

                    case 16:
                      i++;
                      _context.next = 2;
                      break;

                    case 19:
                      presets = [];
                      _i = 0;

                    case 21:
                      if (!(_i < config.presets.length)) {
                        _context.next = 40;
                        break;
                      }

                      _descriptor = config.presets[_i];

                      if (!(_descriptor.options !== false)) {
                        _context.next = 37;
                        break;
                      }

                      _context.prev = 24;
                      _context.t4 = presets;
                      return _context.delegateYield(loadPresetDescriptor(_descriptor, context), "t5", 27);

                    case 27:
                      _context.t6 = _context.t5;
                      _context.t7 = _descriptor.ownPass ? [] : pass;
                      _context.t8 = {
                        preset: _context.t6,
                        pass: _context.t7
                      };

                      _context.t4.push.call(_context.t4, _context.t8);

                      _context.next = 37;
                      break;

                    case 33:
                      _context.prev = 33;
                      _context.t9 = _context["catch"](24);

                      if (_i > 0 && _context.t9.code === "BABEL_UNKNOWN_OPTION") {
                        checkNoUnwrappedItemOptionPairs(config.presets[_i - 1], _descriptor, "preset", _i, _context.t9);
                      }

                      throw _context.t9;

                    case 37:
                      _i++;
                      _context.next = 21;
                      break;

                    case 40:
                      if (!(presets.length > 0)) {
                        _context.next = 63;
                        break;
                      }

                      passes.splice.apply(passes, [1, 0].concat(presets.map(function (o) {
                        return o.pass;
                      }).filter(function (p) {
                        return p !== pass;
                      })));
                      _iterator = presets, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();

                    case 43:
                      if (!_isArray) {
                        _context.next = 49;
                        break;
                      }

                      if (!(_i2 >= _iterator.length)) {
                        _context.next = 46;
                        break;
                      }

                      return _context.abrupt("break", 63);

                    case 46:
                      _ref = _iterator[_i2++];
                      _context.next = 53;
                      break;

                    case 49:
                      _i2 = _iterator.next();

                      if (!_i2.done) {
                        _context.next = 52;
                        break;
                      }

                      return _context.abrupt("break", 63);

                    case 52:
                      _ref = _i2.value;

                    case 53:
                      _ref2 = _ref, preset = _ref2.preset, _pass = _ref2.pass;

                      if (preset) {
                        _context.next = 56;
                        break;
                      }

                      return _context.abrupt("return", true);

                    case 56:
                      return _context.delegateYield(recurseDescriptors({
                        plugins: preset.plugins,
                        presets: preset.presets
                      }, _pass), "t10", 57);

                    case 57:
                      _ignored = _context.t10;

                      if (!_ignored) {
                        _context.next = 60;
                        break;
                      }

                      return _context.abrupt("return", true);

                    case 60:
                      preset.options.forEach(function (opts) {
                        mergeOptions(optionDefaults, opts);
                      });

                    case 61:
                      _context.next = 43;
                      break;

                    case 63:
                      if (plugins.length > 0) {
                        pass.unshift.apply(pass, plugins);
                      }

                    case 64:
                    case "end":
                      return _context.stop();
                  }
                }
              }, recurseDescriptors, null, [[5, 12], [24, 33]]);
            })({
              plugins: plugins.map(function (item) {
                var desc = getItemDescriptor(item);

                if (!desc) {
                  throw new Error("Assertion failure - must be config item");
                }

                return desc;
              }),
              presets: presets.map(function (item) {
                var desc = getItemDescriptor(item);

                if (!desc) {
                  throw new Error("Assertion failure - must be config item");
                }

                return desc;
              })
            }, passes[0]), "t1", 12);

          case 12:
            ignored = _context2.t1;

            if (!ignored) {
              _context2.next = 15;
              break;
            }

            return _context2.abrupt("return", null);

          case 15:
            _context2.next = 21;
            break;

          case 17:
            _context2.prev = 17;
            _context2.t2 = _context2["catch"](7);

            if (!/^\[BABEL\]/.test(_context2.t2.message)) {
              _context2.t2.message = "[BABEL] " + (context.filename || "unknown") + ": " + _context2.t2.message;
            }

            throw _context2.t2;

          case 21:
            opts = optionDefaults;
            mergeOptions(opts, options);
            opts.plugins = passes[0];
            opts.presets = passes.slice(1).filter(function (plugins) {
              return plugins.length > 0;
            }).map(function (plugins) {
              return {
                plugins: plugins
              };
            });
            opts.passPerPreset = opts.presets.length > 0;
            return _context2.abrupt("return", {
              options: opts,
              passes: passes
            });

          case 27:
          case "end":
            return _context2.stop();
        }
      }
    }, loadFullConfig, null, [[7, 17]]);
  }));
  var loadDescriptor = makeWeakCache(regenerator.mark(function _callee(_ref3, cache) {
    var value, options, dirname, alias, item, api;
    return regenerator.wrap(function _callee$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            value = _ref3.value, options = _ref3.options, dirname = _ref3.dirname, alias = _ref3.alias;

            if (!(options === false)) {
              _context3.next = 3;
              break;
            }

            throw new Error("Assertion failure");

          case 3:
            options = options || {};
            item = value;

            if (!(typeof value === "function")) {
              _context3.next = 15;
              break;
            }

            api = Object.assign({}, context, {}, makeAPI(cache));
            _context3.prev = 7;
            item = value(api, options, dirname);
            _context3.next = 15;
            break;

          case 11:
            _context3.prev = 11;
            _context3.t0 = _context3["catch"](7);

            if (alias) {
              _context3.t0.message += " (While processing: " + JSON.stringify(alias) + ")";
            }

            throw _context3.t0;

          case 15:
            if (!(!item || typeof item !== "object")) {
              _context3.next = 17;
              break;
            }

            throw new Error("Plugin/Preset did not return an object.");

          case 17:
            if (!(typeof item.then === "function")) {
              _context3.next = 20;
              break;
            }

            return _context3.delegateYield([], "t1", 19);

          case 19:
            throw new Error("You appear to be using an async plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version.");

          case 20:
            return _context3.abrupt("return", {
              value: item,
              options: options,
              dirname: dirname,
              alias: alias
            });

          case 21:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee, null, [[7, 11]]);
  }));

  function loadPluginDescriptor(descriptor, context) {
    return regenerator.wrap(function loadPluginDescriptor$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(descriptor.value instanceof Plugin)) {
              _context4.next = 4;
              break;
            }

            if (!descriptor.options) {
              _context4.next = 3;
              break;
            }

            throw new Error("Passed options to an existing Plugin instance will not work.");

          case 3:
            return _context4.abrupt("return", descriptor.value);

          case 4:
            _context4.t0 = instantiatePlugin;
            return _context4.delegateYield(loadDescriptor(descriptor, context), "t1", 6);

          case 6:
            _context4.t2 = _context4.t1;
            _context4.t3 = context;
            return _context4.delegateYield((0, _context4.t0)(_context4.t2, _context4.t3), "t4", 9);

          case 9:
            return _context4.abrupt("return", _context4.t4);

          case 10:
          case "end":
            return _context4.stop();
        }
      }
    }, _marked$4);
  }

  var instantiatePlugin = makeWeakCache(regenerator.mark(function _callee2(_ref4, cache) {
    var value, options, dirname, alias, pluginObj, plugin, inheritsDescriptor, inherits;
    return regenerator.wrap(function _callee2$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            value = _ref4.value, options = _ref4.options, dirname = _ref4.dirname, alias = _ref4.alias;
            pluginObj = validatePluginObject(value);
            plugin = Object.assign({}, pluginObj);

            if (plugin.visitor) {
              plugin.visitor = traverse$1.explode(Object.assign({}, plugin.visitor));
            }

            if (!plugin.inherits) {
              _context5.next = 12;
              break;
            }

            inheritsDescriptor = {
              name: undefined,
              alias: alias + "$inherits",
              value: plugin.inherits,
              options: options,
              dirname: dirname
            };
            return _context5.delegateYield(forwardAsync(loadPluginDescriptor, function (run) {
              return cache.invalidate(function (data) {
                return run(inheritsDescriptor, data);
              });
            }), "t0", 7);

          case 7:
            inherits = _context5.t0;
            plugin.pre = chain$1(inherits.pre, plugin.pre);
            plugin.post = chain$1(inherits.post, plugin.post);
            plugin.manipulateOptions = chain$1(inherits.manipulateOptions, plugin.manipulateOptions);
            plugin.visitor = traverse$1.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);

          case 12:
            return _context5.abrupt("return", new Plugin(plugin, options, alias));

          case 13:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee2);
  }));

  var validateIfOptionNeedsFilename = function validateIfOptionNeedsFilename(options, descriptor) {
    if (options.test || options.include || options.exclude) {
      var formattedPresetName = descriptor.name ? "\"" + descriptor.name + "\"" : "/* your preset */";
      throw new Error(["Preset " + formattedPresetName + " requires a filename to be set when babel is called directly,", "```", "babel.transform(code, { filename: 'file.ts', presets: [" + formattedPresetName + "] });", "```", "See https://babeljs.io/docs/en/options#filename for more information."].join("\n"));
    }
  };

  var validatePreset = function validatePreset(preset, context, descriptor) {
    if (!context.filename) {
      var options = preset.options;
      validateIfOptionNeedsFilename(options, descriptor);

      if (options.overrides) {
        options.overrides.forEach(function (overrideOptions) {
          return validateIfOptionNeedsFilename(overrideOptions, descriptor);
        });
      }
    }
  };

  function loadPresetDescriptor(descriptor, context) {
    var preset;
    return regenerator.wrap(function loadPresetDescriptor$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.t0 = instantiatePreset;
            return _context6.delegateYield(loadDescriptor(descriptor, context), "t1", 2);

          case 2:
            _context6.t2 = _context6.t1;
            preset = (0, _context6.t0)(_context6.t2);
            validatePreset(preset, context, descriptor);
            return _context6.delegateYield(buildPresetChain(preset, context), "t3", 6);

          case 6:
            return _context6.abrupt("return", _context6.t3);

          case 7:
          case "end":
            return _context6.stop();
        }
      }
    }, _marked2$4);
  }

  var instantiatePreset = makeWeakCacheSync(function (_ref5) {
    var value = _ref5.value,
        dirname = _ref5.dirname,
        alias = _ref5.alias;
    return {
      options: validate$3("preset", value),
      alias: alias,
      dirname: dirname
    };
  });

  function chain$1(a, b) {
    var fns = [a, b].filter(Boolean);
    if (fns.length <= 1) return fns[0];
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      for (var _iterator2 = fns, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref6;

        if (_isArray2) {
          if (_i3 >= _iterator2.length) break;
          _ref6 = _iterator2[_i3++];
        } else {
          _i3 = _iterator2.next();
          if (_i3.done) break;
          _ref6 = _i3.value;
        }

        var fn = _ref6;
        fn.apply(this, args);
      }
    };
  }

  var loadOptionsRunner = gensync(regenerator.mark(function _callee(opts) {
    var config;
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(loadConfig$1(opts), "t0", 1);

          case 1:
            config = _context.t0;
            return _context.abrupt("return", config ? config.options : null);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  var maybeErrback = function maybeErrback(runner) {
    return function (opts, callback) {
      if (callback === undefined && typeof opts === "function") {
        callback = opts;
        opts = undefined;
      }

      return callback ? runner.errback(opts, callback) : runner.sync(opts);
    };
  };

  var loadPartialConfig$1 = maybeErrback(loadPartialConfig);
  var loadPartialConfigSync = loadPartialConfig.sync;
  var loadPartialConfigAsync = loadPartialConfig.async;
  var loadOptions = maybeErrback(loadOptionsRunner);
  var loadOptionsSync = loadOptionsRunner.sync;
  var loadOptionsAsync = loadOptionsRunner.async;

  var PluginPass = function () {
    function PluginPass(file, key, options) {
      this._map = new Map();
      this.key = key;
      this.file = file;
      this.opts = options || {};
      this.cwd = file.opts.cwd;
      this.filename = file.opts.filename;
    }

    var _proto = PluginPass.prototype;

    _proto.set = function set(key, val) {
      this._map.set(key, val);
    };

    _proto.get = function get(key) {
      return this._map.get(key);
    };

    _proto.availableHelper = function availableHelper(name, versionRange) {
      return this.file.availableHelper(name, versionRange);
    };

    _proto.addHelper = function addHelper(name) {
      return this.file.addHelper(name);
    };

    _proto.addImport = function addImport() {
      return this.file.addImport();
    };

    _proto.getModuleName = function getModuleName() {
      return this.file.getModuleName();
    };

    _proto.buildCodeFrameError = function buildCodeFrameError(node, msg, Error) {
      return this.file.buildCodeFrameError(node, msg, Error);
    };

    return PluginPass;
  }();

  var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

  function isFlattenable(value) {
    return isArray_1(value) || isArguments_1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  var _isFlattenable = isFlattenable;

  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;
    predicate || (predicate = _isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];

      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          _arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }

    return result;
  }

  var _baseFlatten = baseFlatten;

  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  var _arraySome = arraySome;

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }

    var stacked = stack.get(array);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array);

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      }

      if (seen) {
        if (!_arraySome(other, function (othValue, othIndex) {
          if (!_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  var _equalArrays = equalArrays;

  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray;

  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;
  var boolTag$3 = '[object Boolean]',
      dateTag$3 = '[object Date]',
      errorTag$2 = '[object Error]',
      mapTag$5 = '[object Map]',
      numberTag$3 = '[object Number]',
      regexpTag$4 = '[object RegExp]',
      setTag$5 = '[object Set]',
      stringTag$4 = '[object String]',
      symbolTag$3 = '[object Symbol]';
  var arrayBufferTag$3 = '[object ArrayBuffer]',
      dataViewTag$4 = '[object DataView]';
  var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$4:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$3:
        if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag$3:
      case dateTag$3:
      case numberTag$3:
        return eq_1(+object, +other);

      case errorTag$2:
        return object.name == other.name && object.message == other.message;

      case regexpTag$4:
      case stringTag$4:
        return object == other + '';

      case mapTag$5:
        var convert = _mapToArray;

      case setTag$5:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
        convert || (convert = _setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }

        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG$1;
        stack.set(object, other);
        var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag$3:
        if (symbolValueOf$1) {
          return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
        }

    }

    return false;
  }

  var _equalByTag = equalByTag;

  var COMPARE_PARTIAL_FLAG$2 = 1;
  var objectProto$f = Object.prototype;
  var hasOwnProperty$e = objectProto$f.hasOwnProperty;

  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
        objProps = _getAllKeys(object),
        objLength = objProps.length,
        othProps = _getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty$e.call(other, key))) {
        return false;
      }
    }

    var stacked = stack.get(object);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }

      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  var _equalObjects = equalObjects;

  var COMPARE_PARTIAL_FLAG$3 = 1;
  var argsTag$3 = '[object Arguments]',
      arrayTag$2 = '[object Array]',
      objectTag$4 = '[object Object]';
  var objectProto$g = Object.prototype;
  var hasOwnProperty$f = objectProto$g.hasOwnProperty;

  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_1(object),
        othIsArr = isArray_1(other),
        objTag = objIsArr ? arrayTag$2 : _getTag(object),
        othTag = othIsArr ? arrayTag$2 : _getTag(other);
    objTag = objTag == argsTag$3 ? objectTag$4 : objTag;
    othTag = othTag == argsTag$3 ? objectTag$4 : othTag;
    var objIsObj = objTag == objectTag$4,
        othIsObj = othTag == objectTag$4,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer_1(object)) {
      if (!isBuffer_1(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new _Stack());
      return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
      var objIsWrapped = objIsObj && hasOwnProperty$f.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$f.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new _Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new _Stack());
    return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep;

  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike_1(value) && !isObjectLike_1(other)) {
      return value !== value && other !== other;
    }

    return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var _baseIsEqual = baseIsEqual;

  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;

  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }

    object = Object(object);

    while (index--) {
      var data = matchData[index];

      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }

    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new _Stack();

        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }

        if (!(result === undefined ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
          return false;
        }
      }
    }

    return true;
  }

  var _baseIsMatch = baseIsMatch;

  function isStrictComparable(value) {
    return value === value && !isObject_1(value);
  }

  var _isStrictComparable = isStrictComparable;

  function getMatchData(object) {
    var result = keys_1(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];
      result[length] = [key, value, _isStrictComparable(value)];
    }

    return result;
  }

  var _getMatchData = getMatchData;

  function matchesStrictComparable(key, srcValue) {
    return function (object) {
      if (object == null) {
        return false;
      }

      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
  }

  var _matchesStrictComparable = matchesStrictComparable;

  function baseMatches(source) {
    var matchData = _getMatchData(source);

    if (matchData.length == 1 && matchData[0][2]) {
      return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }

    return function (object) {
      return object === source || _baseIsMatch(object, source, matchData);
    };
  }

  var _baseMatches = baseMatches;

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }

    var type = typeof value;

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol_1(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  var _isKey = isKey;

  var FUNC_ERROR_TEXT = 'Expected a function';

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };

    memoized.cache = new (memoize.Cache || _MapCache)();
    return memoized;
  }

  memoize.Cache = _MapCache;
  var memoize_1 = memoize;

  var MAX_MEMOIZE_SIZE = 500;

  function memoizeCapped(func) {
    var result = memoize_1(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }

      return key;
    });
    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;

  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = _memoizeCapped(function (string) {
    var result = [];

    if (string.charCodeAt(0) === 46) {
        result.push('');
      }

    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });
  var _stringToPath = stringToPath;

  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }

    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;

  var INFINITY$3 = 1 / 0;

  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$3 ? '-0' : result;
  }

  var _toKey = toKey;

  function baseGet(object, path) {
    path = _castPath(path, object);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[_toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  var _baseGet = baseGet;

  function get$2(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  var get_1 = get$2;

  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  var _baseHasIn = baseHasIn;

  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);
    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result || ++index != length) {
      return result;
    }

    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;

  function hasIn(object, path) {
    return object != null && _hasPath(object, path, _baseHasIn);
  }

  var hasIn_1 = hasIn;

  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;

  function baseMatchesProperty(path, srcValue) {
    if (_isKey(path) && _isStrictComparable(srcValue)) {
      return _matchesStrictComparable(_toKey(path), srcValue);
    }

    return function (object) {
      var objValue = get_1(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn_1(object, path) : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
    };
  }

  var _baseMatchesProperty = baseMatchesProperty;

  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }

  var _baseProperty = baseProperty;

  function basePropertyDeep(path) {
    return function (object) {
      return _baseGet(object, path);
    };
  }

  var _basePropertyDeep = basePropertyDeep;

  function property(path) {
    return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
  }

  var property_1 = property;

  function baseIteratee(value) {
    if (typeof value == 'function') {
      return value;
    }

    if (value == null) {
      return identity_1;
    }

    if (typeof value == 'object') {
      return isArray_1(value) ? _baseMatchesProperty(value[0], value[1]) : _baseMatches(value);
    }

    return property_1(value);
  }

  var _baseIteratee = baseIteratee;

  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];

        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }

      return object;
    };
  }

  var _createBaseFor = createBaseFor;

  var baseFor = _createBaseFor();
  var _baseFor = baseFor;

  function baseForOwn(object, iteratee) {
    return object && _baseFor(object, iteratee, keys_1);
  }

  var _baseForOwn = baseForOwn;

  function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
      if (collection == null) {
        return collection;
      }

      if (!isArrayLike_1(collection)) {
        return eachFunc(collection, iteratee);
      }

      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }

      return collection;
    };
  }

  var _createBaseEach = createBaseEach;

  var baseEach = _createBaseEach(_baseForOwn);
  var _baseEach = baseEach;

  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike_1(collection) ? Array(collection.length) : [];
    _baseEach(collection, function (value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }

  var _baseMap = baseMap;

  function baseSortBy(array, comparer) {
    var length = array.length;
    array.sort(comparer);

    while (length--) {
      array[length] = array[length].value;
    }

    return array;
  }

  var _baseSortBy = baseSortBy;

  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== undefined,
          valIsNull = value === null,
          valIsReflexive = value === value,
          valIsSymbol = isSymbol_1(value);
      var othIsDefined = other !== undefined,
          othIsNull = other === null,
          othIsReflexive = other === other,
          othIsSymbol = isSymbol_1(other);

      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }

      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }

    return 0;
  }

  var _compareAscending = compareAscending;

  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = _compareAscending(objCriteria[index], othCriteria[index]);

      if (result) {
        if (index >= ordersLength) {
          return result;
        }

        var order = orders[index];
        return result * (order == 'desc' ? -1 : 1);
      }
    }

    return object.index - other.index;
  }

  var _compareMultiple = compareMultiple;

  function baseOrderBy(collection, iteratees, orders) {
    var index = -1;
    iteratees = _arrayMap(iteratees.length ? iteratees : [identity_1], _baseUnary(_baseIteratee));
    var result = _baseMap(collection, function (value, key, collection) {
      var criteria = _arrayMap(iteratees, function (iteratee) {
        return iteratee(value);
      });
      return {
        'criteria': criteria,
        'index': ++index,
        'value': value
      };
    });
    return _baseSortBy(result, function (object, other) {
      return _compareMultiple(object, other, orders);
    });
  }

  var _baseOrderBy = baseOrderBy;

  var sortBy = _baseRest(function (collection, iteratees) {
    if (collection == null) {
      return [];
    }

    var length = iteratees.length;

    if (length > 1 && _isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length > 2 && _isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }

    return _baseOrderBy(collection, _baseFlatten(iteratees, 1), []);
  });
  var sortBy_1 = sortBy;

  var LOADED_PLUGIN;
  function loadBlockHoistPlugin() {
    if (!LOADED_PLUGIN) {
      var config = loadConfig$1.sync({
        babelrc: false,
        configFile: false,
        plugins: [blockHoistPlugin]
      });
      LOADED_PLUGIN = config ? config.passes[0][0] : undefined;
      if (!LOADED_PLUGIN) throw new Error("Assertion failure");
    }

    return LOADED_PLUGIN;
  }
  var blockHoistPlugin = {
    name: "internal.blockHoist",
    visitor: {
      Block: {
        exit: function exit(_ref) {
          var node = _ref.node;
          var hasChange = false;

          for (var i = 0; i < node.body.length; i++) {
            var bodyNode = node.body[i];

            if (bodyNode && bodyNode._blockHoist != null) {
              hasChange = true;
              break;
            }
          }

          if (!hasChange) return;
          node.body = sortBy_1(node.body, function (bodyNode) {
            var priority = bodyNode && bodyNode._blockHoist;
            if (priority == null) priority = 1;
            if (priority === true) priority = 2;
            return -1 * priority;
          });
        }
      }
    }
  };

  function normalizeOptions$2(config) {
    var _config$options = config.options,
        filename = _config$options.filename,
        cwd = _config$options.cwd,
        _config$options$filen = _config$options.filenameRelative,
        filenameRelative = _config$options$filen === void 0 ? typeof filename === "string" ? path$1.relative(cwd, filename) : "unknown" : _config$options$filen,
        _config$options$sourc = _config$options.sourceType,
        sourceType = _config$options$sourc === void 0 ? "module" : _config$options$sourc,
        inputSourceMap = _config$options.inputSourceMap,
        _config$options$sourc2 = _config$options.sourceMaps,
        sourceMaps = _config$options$sourc2 === void 0 ? !!inputSourceMap : _config$options$sourc2,
        moduleRoot = _config$options.moduleRoot,
        _config$options$sourc3 = _config$options.sourceRoot,
        sourceRoot = _config$options$sourc3 === void 0 ? moduleRoot : _config$options$sourc3,
        _config$options$sourc4 = _config$options.sourceFileName,
        sourceFileName = _config$options$sourc4 === void 0 ? path$1.basename(filenameRelative) : _config$options$sourc4,
        _config$options$comme = _config$options.comments,
        comments = _config$options$comme === void 0 ? true : _config$options$comme,
        _config$options$compa = _config$options.compact,
        compact = _config$options$compa === void 0 ? "auto" : _config$options$compa;
    var opts = config.options;
    var options = Object.assign({}, opts, {
      parserOpts: Object.assign({
        sourceType: path$1.extname(filenameRelative) === ".mjs" ? "module" : sourceType,
        sourceFileName: filename,
        plugins: []
      }, opts.parserOpts),
      generatorOpts: Object.assign({
        filename: filename,
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        retainLines: opts.retainLines,
        comments: comments,
        shouldPrintComment: opts.shouldPrintComment,
        compact: compact,
        minified: opts.minified,
        sourceMaps: sourceMaps,
        sourceRoot: sourceRoot,
        sourceFileName: sourceFileName
      }, opts.generatorOpts)
    });

    for (var _iterator = config.passes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var plugins = _ref;

      for (var _iterator2 = plugins, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var plugin = _ref2;

        if (plugin.manipulateOptions) {
          plugin.manipulateOptions(options, options.parserOpts);
        }
      }
    }

    return options;
  }

  var fs = {};

  var CLONE_DEEP_FLAG$1 = 1,
      CLONE_SYMBOLS_FLAG$2 = 4;

  function cloneDeep$1(value) {
    return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$2);
  }

  var cloneDeep_1 = cloneDeep$1;

  var _nodeResolve_empty = {};

  var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _nodeResolve_empty
  });

  var safeBuffer = createCommonjsModule(function (module, exports) {
  var Buffer = bufferEs6.Buffer;

  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }

  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = bufferEs6;
  } else {
    copyProps(bufferEs6, exports);
    exports.Buffer = SafeBuffer;
  }

  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
  }

  copyProps(Buffer, SafeBuffer);

  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number');
    }

    return Buffer(arg, encodingOrOffset, length);
  };

  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }

    var buf = Buffer(size);

    if (fill !== undefined) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }

    return buf;
  };

  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }

    return Buffer(size);
  };

  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }

    return bufferEs6.SlowBuffer(size);
  };
  });
  var safeBuffer_1 = safeBuffer.Buffer;

  var path$2 = getCjsExportFromNamespace(_nodeResolve_empty$1);

  var convertSourceMap = createCommonjsModule(function (module, exports) {







  Object.defineProperty(exports, 'commentRegex', {
    get: function getCommentRegex() {
      return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
    }
  });
  Object.defineProperty(exports, 'mapFileCommentRegex', {
    get: function getMapFileCommentRegex() {
      return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
    }
  });

  function decodeBase64(base64) {
    return safeBuffer.Buffer.from(base64, 'base64').toString();
  }

  function stripComment(sm) {
    return sm.split(',').pop();
  }

  function readFromFileMap(sm, dir) {
    var r = exports.mapFileCommentRegex.exec(sm);
    var filename = r[1] || r[2];
    var filepath = path$1.resolve(dir, filename);

    try {
      return path$2.readFileSync(filepath, 'utf8');
    } catch (e) {
      throw new Error('An error occurred while trying to read the map file at ' + filepath + '\n' + e);
    }
  }

  function Converter(sm, opts) {
    opts = opts || {};
    if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);
    if (opts.hasComment) sm = stripComment(sm);
    if (opts.isEncoded) sm = decodeBase64(sm);
    if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);
    this.sourcemap = sm;
  }

  Converter.prototype.toJSON = function (space) {
    return JSON.stringify(this.sourcemap, null, space);
  };

  Converter.prototype.toBase64 = function () {
    var json = this.toJSON();
    return safeBuffer.Buffer.from(json, 'utf8').toString('base64');
  };

  Converter.prototype.toComment = function (options) {
    var base64 = this.toBase64();
    var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
    return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
  };

  Converter.prototype.toObject = function () {
    return JSON.parse(this.toJSON());
  };

  Converter.prototype.addProperty = function (key, value) {
    if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
    return this.setProperty(key, value);
  };

  Converter.prototype.setProperty = function (key, value) {
    this.sourcemap[key] = value;
    return this;
  };

  Converter.prototype.getProperty = function (key) {
    return this.sourcemap[key];
  };

  exports.fromObject = function (obj) {
    return new Converter(obj);
  };

  exports.fromJSON = function (json) {
    return new Converter(json, {
      isJSON: true
    });
  };

  exports.fromBase64 = function (base64) {
    return new Converter(base64, {
      isEncoded: true
    });
  };

  exports.fromComment = function (comment) {
    comment = comment.replace(/^\/\*/g, '//').replace(/\*\/$/g, '');
    return new Converter(comment, {
      isEncoded: true,
      hasComment: true
    });
  };

  exports.fromMapFileComment = function (comment, dir) {
    return new Converter(comment, {
      commentFileDir: dir,
      isFileComment: true,
      isJSON: true
    });
  };

  exports.fromSource = function (content) {
    var m = content.match(exports.commentRegex);
    return m ? exports.fromComment(m.pop()) : null;
  };

  exports.fromMapFileSource = function (content, dir) {
    var m = content.match(exports.mapFileCommentRegex);
    return m ? exports.fromMapFileComment(m.pop(), dir) : null;
  };

  exports.removeComments = function (src) {
    return src.replace(exports.commentRegex, '');
  };

  exports.removeMapFileComments = function (src) {
    return src.replace(exports.mapFileCommentRegex, '');
  };

  exports.generateMapFileComment = function (file, options) {
    var data = 'sourceMappingURL=' + file;
    return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
  };
  });
  var convertSourceMap_1 = convertSourceMap.fromObject;
  var convertSourceMap_2 = convertSourceMap.fromJSON;
  var convertSourceMap_3 = convertSourceMap.fromBase64;
  var convertSourceMap_4 = convertSourceMap.fromComment;
  var convertSourceMap_5 = convertSourceMap.fromMapFileComment;
  var convertSourceMap_6 = convertSourceMap.fromSource;
  var convertSourceMap_7 = convertSourceMap.fromMapFileSource;
  var convertSourceMap_8 = convertSourceMap.removeComments;
  var convertSourceMap_9 = convertSourceMap.removeMapFileComments;
  var convertSourceMap_10 = convertSourceMap.generateMapFileComment;

  var pluginNameMap = {
    classProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://git.io/vb4yQ"
      },
      transform: {
        name: "@babel/plugin-proposal-class-properties",
        url: "https://git.io/vb4SL"
      }
    },
    decorators: {
      syntax: {
        name: "@babel/plugin-syntax-decorators",
        url: "https://git.io/vb4y9"
      },
      transform: {
        name: "@babel/plugin-proposal-decorators",
        url: "https://git.io/vb4ST"
      }
    },
    doExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-do-expressions",
        url: "https://git.io/vb4yh"
      },
      transform: {
        name: "@babel/plugin-proposal-do-expressions",
        url: "https://git.io/vb4S3"
      }
    },
    dynamicImport: {
      syntax: {
        name: "@babel/plugin-syntax-dynamic-import",
        url: "https://git.io/vb4Sv"
      }
    },
    exportDefaultFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-default-from",
        url: "https://git.io/vb4SO"
      },
      transform: {
        name: "@babel/plugin-proposal-export-default-from",
        url: "https://git.io/vb4yH"
      }
    },
    exportNamespaceFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-namespace-from",
        url: "https://git.io/vb4Sf"
      },
      transform: {
        name: "@babel/plugin-proposal-export-namespace-from",
        url: "https://git.io/vb4SG"
      }
    },
    flow: {
      syntax: {
        name: "@babel/plugin-syntax-flow",
        url: "https://git.io/vb4yb"
      },
      transform: {
        name: "@babel/plugin-transform-flow-strip-types",
        url: "https://git.io/vb49g"
      }
    },
    functionBind: {
      syntax: {
        name: "@babel/plugin-syntax-function-bind",
        url: "https://git.io/vb4y7"
      },
      transform: {
        name: "@babel/plugin-proposal-function-bind",
        url: "https://git.io/vb4St"
      }
    },
    functionSent: {
      syntax: {
        name: "@babel/plugin-syntax-function-sent",
        url: "https://git.io/vb4yN"
      },
      transform: {
        name: "@babel/plugin-proposal-function-sent",
        url: "https://git.io/vb4SZ"
      }
    },
    importMeta: {
      syntax: {
        name: "@babel/plugin-syntax-import-meta",
        url: "https://git.io/vbKK6"
      }
    },
    jsx: {
      syntax: {
        name: "@babel/plugin-syntax-jsx",
        url: "https://git.io/vb4yA"
      },
      transform: {
        name: "@babel/plugin-transform-react-jsx",
        url: "https://git.io/vb4yd"
      }
    },
    logicalAssignment: {
      syntax: {
        name: "@babel/plugin-syntax-logical-assignment-operators",
        url: "https://git.io/vAlBp"
      },
      transform: {
        name: "@babel/plugin-proposal-logical-assignment-operators",
        url: "https://git.io/vAlRe"
      }
    },
    numericSeparator: {
      syntax: {
        name: "@babel/plugin-syntax-numeric-separator",
        url: "https://git.io/vb4Sq"
      },
      transform: {
        name: "@babel/plugin-proposal-numeric-separator",
        url: "https://git.io/vb4yS"
      }
    },
    optionalChaining: {
      syntax: {
        name: "@babel/plugin-syntax-optional-chaining",
        url: "https://git.io/vb4Sc"
      },
      transform: {
        name: "@babel/plugin-proposal-optional-chaining",
        url: "https://git.io/vb4Sk"
      }
    },
    pipelineOperator: {
      syntax: {
        name: "@babel/plugin-syntax-pipeline-operator",
        url: "https://git.io/vb4yj"
      },
      transform: {
        name: "@babel/plugin-proposal-pipeline-operator",
        url: "https://git.io/vb4SU"
      }
    },
    recordAndTuple: {
      syntax: {
        name: "@babel/plugin-syntax-record-and-tuple",
        url: "https://git.io/JvKp3"
      }
    },
    throwExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-throw-expressions",
        url: "https://git.io/vb4SJ"
      },
      transform: {
        name: "@babel/plugin-proposal-throw-expressions",
        url: "https://git.io/vb4yF"
      }
    },
    typescript: {
      syntax: {
        name: "@babel/plugin-syntax-typescript",
        url: "https://git.io/vb4SC"
      },
      transform: {
        name: "@babel/plugin-transform-typescript",
        url: "https://git.io/vb4Sm"
      }
    },
    asyncGenerators: {
      syntax: {
        name: "@babel/plugin-syntax-async-generators",
        url: "https://git.io/vb4SY"
      },
      transform: {
        name: "@babel/plugin-proposal-async-generator-functions",
        url: "https://git.io/vb4yp"
      }
    },
    nullishCoalescingOperator: {
      syntax: {
        name: "@babel/plugin-syntax-nullish-coalescing-operator",
        url: "https://git.io/vb4yx"
      },
      transform: {
        name: "@babel/plugin-proposal-nullish-coalescing-operator",
        url: "https://git.io/vb4Se"
      }
    },
    objectRestSpread: {
      syntax: {
        name: "@babel/plugin-syntax-object-rest-spread",
        url: "https://git.io/vb4y5"
      },
      transform: {
        name: "@babel/plugin-proposal-object-rest-spread",
        url: "https://git.io/vb4Ss"
      }
    },
    optionalCatchBinding: {
      syntax: {
        name: "@babel/plugin-syntax-optional-catch-binding",
        url: "https://git.io/vb4Sn"
      },
      transform: {
        name: "@babel/plugin-proposal-optional-catch-binding",
        url: "https://git.io/vb4SI"
      }
    }
  };

  var getNameURLCombination = function getNameURLCombination(_ref) {
    var name = _ref.name,
        url = _ref.url;
    return name + " (" + url + ")";
  };

  function generateMissingPluginMessage(missingPluginName, loc, codeFrame) {
    var helpMessage = "Support for the experimental syntax '" + missingPluginName + "' isn't currently enabled " + ("(" + loc.line + ":" + (loc.column + 1) + "):\n\n") + codeFrame;
    var pluginInfo = pluginNameMap[missingPluginName];

    if (pluginInfo) {
      var syntaxPlugin = pluginInfo.syntax,
          transformPlugin = pluginInfo.transform;

      if (syntaxPlugin) {
        if (transformPlugin) {
          var transformPluginInfo = getNameURLCombination(transformPlugin);
          helpMessage += "\n\nAdd " + transformPluginInfo + " to the 'plugins' section of your Babel config " + "to enable transformation.";
        } else {
          var syntaxPluginInfo = getNameURLCombination(syntaxPlugin);
          helpMessage += "\n\nAdd " + syntaxPluginInfo + " to the 'plugins' section of your Babel config " + "to enable parsing.";
        }
      }
    }

    return helpMessage;
  }

  var _marked$5 = regenerator.mark(parser);
  function parser(pluginPasses, _ref, code) {
    var parserOpts, _ref$highlightCode, highlightCode, _ref$filename, filename, results, _iterator, _isArray, _i, _ref2, plugins, _iterator2, _isArray2, _i2, _ref3, plugin, parserOverride, ast, loc, missingPlugin, codeFrame;

    return regenerator.wrap(function parser$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            parserOpts = _ref.parserOpts, _ref$highlightCode = _ref.highlightCode, highlightCode = _ref$highlightCode === void 0 ? true : _ref$highlightCode, _ref$filename = _ref.filename, filename = _ref$filename === void 0 ? "unknown" : _ref$filename;
            _context.prev = 1;
            results = [];
            _iterator = pluginPasses, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();

          case 4:
            if (!_isArray) {
              _context.next = 10;
              break;
            }

            if (!(_i >= _iterator.length)) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("break", 33);

          case 7:
            _ref2 = _iterator[_i++];
            _context.next = 14;
            break;

          case 10:
            _i = _iterator.next();

            if (!_i.done) {
              _context.next = 13;
              break;
            }

            return _context.abrupt("break", 33);

          case 13:
            _ref2 = _i.value;

          case 14:
            plugins = _ref2;
            _iterator2 = plugins, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();

          case 16:
            if (!_isArray2) {
              _context.next = 22;
              break;
            }

            if (!(_i2 >= _iterator2.length)) {
              _context.next = 19;
              break;
            }

            return _context.abrupt("break", 31);

          case 19:
            _ref3 = _iterator2[_i2++];
            _context.next = 26;
            break;

          case 22:
            _i2 = _iterator2.next();

            if (!_i2.done) {
              _context.next = 25;
              break;
            }

            return _context.abrupt("break", 31);

          case 25:
            _ref3 = _i2.value;

          case 26:
            plugin = _ref3;
            parserOverride = plugin.parserOverride;

            if (parserOverride) {
              ast = parserOverride(code, parserOpts, parse$1);
              if (ast !== undefined) results.push(ast);
            }

          case 29:
            _context.next = 16;
            break;

          case 31:
            _context.next = 4;
            break;

          case 33:
            if (!(results.length === 0)) {
              _context.next = 37;
              break;
            }

            return _context.abrupt("return", parse$1(code, parserOpts));

          case 37:
            if (!(results.length === 1)) {
              _context.next = 42;
              break;
            }

            return _context.delegateYield([], "t0", 39);

          case 39:
            if (!(typeof results[0].then === "function")) {
              _context.next = 41;
              break;
            }

            throw new Error("You appear to be using an async parser plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

          case 41:
            return _context.abrupt("return", results[0]);

          case 42:
            throw new Error("More than one plugin attempted to override parsing.");

          case 45:
            _context.prev = 45;
            _context.t1 = _context["catch"](1);

            if (_context.t1.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
              _context.t1.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module " + "or sourceType:unambiguous in your Babel config for this file.";
            }

            loc = _context.t1.loc, missingPlugin = _context.t1.missingPlugin;

            if (loc) {
              codeFrame = codeFrameColumns(code, {
                start: {
                  line: loc.line,
                  column: loc.column + 1
                }
              }, {
                highlightCode: highlightCode
              });

              if (missingPlugin) {
                _context.t1.message = filename + ": " + generateMissingPluginMessage(missingPlugin[0], loc, codeFrame);
              } else {
                _context.t1.message = filename + ": " + _context.t1.message + "\n\n" + codeFrame;
              }

              _context.t1.code = "BABEL_PARSE_ERROR";
            }

            throw _context.t1;

          case 51:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$5, null, [[1, 45]]);
  }

  var _marked$6 = regenerator.mark(normalizeFile);
  var debug$1 = browser$4("babel:transform:file");
  var LARGE_INPUT_SOURCEMAP_THRESHOLD = 1000000;
  function normalizeFile(pluginPasses, options, code, ast) {
    var inputMap, lastComment, _lastComment, match, inputMapContent;

    return regenerator.wrap(function normalizeFile$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            code = "" + (code || "");

            if (!ast) {
              _context.next = 11;
              break;
            }

            if (!(ast.type === "Program")) {
              _context.next = 6;
              break;
            }

            ast = File(ast, [], []);
            _context.next = 8;
            break;

          case 6:
            if (!(ast.type !== "File")) {
              _context.next = 8;
              break;
            }

            throw new Error("AST root must be a Program or File node");

          case 8:
            ast = cloneDeep_1(ast);
            _context.next = 13;
            break;

          case 11:
            return _context.delegateYield(parser(pluginPasses, options, code), "t0", 12);

          case 12:
            ast = _context.t0;

          case 13:
            inputMap = null;

            if (options.inputSourceMap !== false) {
              if (typeof options.inputSourceMap === "object") {
                inputMap = convertSourceMap.fromObject(options.inputSourceMap);
              }

              if (!inputMap) {
                lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);

                if (lastComment) {
                  try {
                    inputMap = convertSourceMap.fromComment(lastComment);
                  } catch (err) {
                    debug$1("discarding unknown inline input sourcemap", err);
                  }
                }
              }

              if (!inputMap) {
                _lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);

                if (typeof options.filename === "string" && _lastComment) {
                  try {
                    match = EXTERNAL_SOURCEMAP_REGEX.exec(_lastComment);
                    inputMapContent = fs.readFileSync(path$1.resolve(path$1.dirname(options.filename), match[1]));

                    if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {
                      debug$1("skip merging input map > 1 MB");
                    } else {
                      inputMap = convertSourceMap.fromJSON(inputMapContent);
                    }
                  } catch (err) {
                    debug$1("discarding unknown file input sourcemap", err);
                  }
                } else if (_lastComment) {
                  debug$1("discarding un-loadable file input sourcemap");
                }
              }
            }

            return _context.abrupt("return", new File$2(options, {
              code: code,
              ast: ast,
              inputMap: inputMap
            }));

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$6);
  }
  var INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/;
  var EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;

  function extractCommentsFromList(regex, comments, lastComment) {
    if (comments) {
      comments = comments.filter(function (_ref) {
        var value = _ref.value;

        if (regex.test(value)) {
          lastComment = value;
          return false;
        }

        return true;
      });
    }

    return [comments, lastComment];
  }

  function extractComments(regex, ast) {
    var lastComment = null;
    traverseFast(ast, function (node) {
      var _extractCommentsFromL = extractCommentsFromList(regex, node.leadingComments, lastComment);

      node.leadingComments = _extractCommentsFromL[0];
      lastComment = _extractCommentsFromL[1];

      var _extractCommentsFromL2 = extractCommentsFromList(regex, node.innerComments, lastComment);

      node.innerComments = _extractCommentsFromL2[0];
      lastComment = _extractCommentsFromL2[1];

      var _extractCommentsFromL3 = extractCommentsFromList(regex, node.trailingComments, lastComment);

      node.trailingComments = _extractCommentsFromL3[0];
      lastComment = _extractCommentsFromL3[1];
    });
    return lastComment;
  }

  function mergeSourceMap(inputMap, map) {
    var input = buildMappingData(inputMap);
    var output = buildMappingData(map);
    var mergedGenerator = new sourceMap.SourceMapGenerator();

    for (var _iterator = input.sources, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var _ref3 = _ref,
          source = _ref3.source;

      if (typeof source.content === "string") {
        mergedGenerator.setSourceContent(source.path, source.content);
      }
    }

    if (output.sources.length === 1) {
      var defaultSource = output.sources[0];
      var insertedMappings = new Map();
      eachInputGeneratedRange(input, function (generated, original, source) {
        eachOverlappingGeneratedOutputRange(defaultSource, generated, function (item) {
          var key = makeMappingKey(item);
          if (insertedMappings.has(key)) return;
          insertedMappings.set(key, item);
          mergedGenerator.addMapping({
            source: source.path,
            original: {
              line: original.line,
              column: original.columnStart
            },
            generated: {
              line: item.line,
              column: item.columnStart
            },
            name: original.name
          });
        });
      });

      for (var _iterator2 = insertedMappings.values(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var item = _ref2;

        if (item.columnEnd === Infinity) {
          continue;
        }

        var clearItem = {
          line: item.line,
          columnStart: item.columnEnd
        };
        var key = makeMappingKey(clearItem);

        if (insertedMappings.has(key)) {
          continue;
        }

        mergedGenerator.addMapping({
          generated: {
            line: clearItem.line,
            column: clearItem.columnStart
          }
        });
      }
    }

    var result = mergedGenerator.toJSON();

    if (typeof input.sourceRoot === "string") {
      result.sourceRoot = input.sourceRoot;
    }

    return result;
  }

  function makeMappingKey(item) {
    return item.line + "/" + item.columnStart;
  }

  function eachOverlappingGeneratedOutputRange(outputFile, inputGeneratedRange, callback) {
    var overlappingOriginal = filterApplicableOriginalRanges(outputFile, inputGeneratedRange);

    for (var _iterator3 = overlappingOriginal, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref4;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref4 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref4 = _i3.value;
      }

      var _ref5 = _ref4,
          generated = _ref5.generated;

      for (var _iterator4 = generated, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref6;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref6 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref6 = _i4.value;
        }

        var item = _ref6;
        callback(item);
      }
    }
  }

  function filterApplicableOriginalRanges(_ref7, _ref8) {
    var mappings = _ref7.mappings;
    var line = _ref8.line,
        columnStart = _ref8.columnStart,
        columnEnd = _ref8.columnEnd;
    return filterSortedArray(mappings, function (_ref9) {
      var outOriginal = _ref9.original;
      if (line > outOriginal.line) return -1;
      if (line < outOriginal.line) return 1;
      if (columnStart >= outOriginal.columnEnd) return -1;
      if (columnEnd <= outOriginal.columnStart) return 1;
      return 0;
    });
  }

  function eachInputGeneratedRange(map, callback) {
    for (var _iterator5 = map.sources, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
      var _ref10;

      if (_isArray5) {
        if (_i5 >= _iterator5.length) break;
        _ref10 = _iterator5[_i5++];
      } else {
        _i5 = _iterator5.next();
        if (_i5.done) break;
        _ref10 = _i5.value;
      }

      var _ref11 = _ref10,
          source = _ref11.source,
          mappings = _ref11.mappings;

      for (var _iterator6 = mappings, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
        var _ref12;

        if (_isArray6) {
          if (_i6 >= _iterator6.length) break;
          _ref12 = _iterator6[_i6++];
        } else {
          _i6 = _iterator6.next();
          if (_i6.done) break;
          _ref12 = _i6.value;
        }

        var _ref13 = _ref12,
            original = _ref13.original,
            generated = _ref13.generated;

        for (var _iterator7 = generated, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
          var _ref14;

          if (_isArray7) {
            if (_i7 >= _iterator7.length) break;
            _ref14 = _iterator7[_i7++];
          } else {
            _i7 = _iterator7.next();
            if (_i7.done) break;
            _ref14 = _i7.value;
          }

          var item = _ref14;
          callback(item, original, source);
        }
      }
    }
  }

  function buildMappingData(map) {
    var consumer = new sourceMap.SourceMapConsumer(Object.assign({}, map, {
      sourceRoot: null
    }));
    var sources = new Map();
    var mappings = new Map();
    var last = null;
    consumer.computeColumnSpans();
    consumer.eachMapping(function (m) {
      if (m.originalLine === null) return;
      var source = sources.get(m.source);

      if (!source) {
        source = {
          path: m.source,
          content: consumer.sourceContentFor(m.source, true)
        };
        sources.set(m.source, source);
      }

      var sourceData = mappings.get(source);

      if (!sourceData) {
        sourceData = {
          source: source,
          mappings: []
        };
        mappings.set(source, sourceData);
      }

      var obj = {
        line: m.originalLine,
        columnStart: m.originalColumn,
        columnEnd: Infinity,
        name: m.name
      };

      if (last && last.source === source && last.mapping.line === m.originalLine) {
        last.mapping.columnEnd = m.originalColumn;
      }

      last = {
        source: source,
        mapping: obj
      };
      sourceData.mappings.push({
        original: obj,
        generated: consumer.allGeneratedPositionsFor({
          source: m.source,
          line: m.originalLine,
          column: m.originalColumn
        }).map(function (item) {
          return {
            line: item.line,
            columnStart: item.column,
            columnEnd: item.lastColumn + 1
          };
        })
      });
    }, null, sourceMap.SourceMapConsumer.ORIGINAL_ORDER);
    return {
      file: map.file,
      sourceRoot: map.sourceRoot,
      sources: Array.from(mappings.values())
    };
  }

  function findInsertionLocation(array, callback) {
    var left = 0;
    var right = array.length;

    while (left < right) {
      var mid = Math.floor((left + right) / 2);
      var item = array[mid];
      var result = callback(item);

      if (result === 0) {
        left = mid;
        break;
      }

      if (result >= 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }

    var i = left;

    if (i < array.length) {
      while (i >= 0 && callback(array[i]) >= 0) {
        i--;
      }

      return i + 1;
    }

    return i;
  }

  function filterSortedArray(array, callback) {
    var start = findInsertionLocation(array, callback);
    var results = [];

    for (var i = start; i < array.length && callback(array[i]) === 0; i++) {
      results.push(array[i]);
    }

    return results;
  }

  function generateCode$1(pluginPasses, file) {
    var opts = file.opts,
        ast = file.ast,
        code = file.code,
        inputMap = file.inputMap;
    var results = [];

    for (var _iterator = pluginPasses, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var plugins = _ref;

      for (var _iterator2 = plugins, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var plugin = _ref2;
        var generatorOverride = plugin.generatorOverride;

        if (generatorOverride) {
          var _result2 = generatorOverride(ast, opts.generatorOpts, code, generateCode);

          if (_result2 !== undefined) results.push(_result2);
        }
      }
    }

    var result;

    if (results.length === 0) {
      result = generateCode(ast, opts.generatorOpts, code);
    } else if (results.length === 1) {
      result = results[0];

      if (typeof result.then === "function") {
        throw new Error("You appear to be using an async codegen plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version.");
      }
    } else {
      throw new Error("More than one plugin attempted to override codegen.");
    }

    var _result = result,
        outputCode = _result.code,
        outputMap = _result.map;

    if (outputMap && inputMap) {
      outputMap = mergeSourceMap(inputMap.toObject(), outputMap);
    }

    if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
      outputCode += "\n" + convertSourceMap.fromObject(outputMap).toComment();
    }

    if (opts.sourceMaps === "inline") {
      outputMap = null;
    }

    return {
      outputCode: outputCode,
      outputMap: outputMap
    };
  }

  var _marked$7 = regenerator.mark(run),
      _marked2$5 = regenerator.mark(transformFile);
  function run(config, code, ast) {
    var file, opts, _opts$filename, outputCode, outputMap, _generateCode, _opts$filename2;

    return regenerator.wrap(function run$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(normalizeFile(config.passes, normalizeOptions$2(config), code, ast), "t0", 1);

          case 1:
            file = _context.t0;
            opts = file.opts;
            _context.prev = 3;
            return _context.delegateYield(transformFile(file, config.passes), "t1", 5);

          case 5:
            _context.next = 12;
            break;

          case 7:
            _context.prev = 7;
            _context.t2 = _context["catch"](3);
            _context.t2.message = ((_opts$filename = opts.filename) != null ? _opts$filename : "unknown") + ": " + _context.t2.message;

            if (!_context.t2.code) {
              _context.t2.code = "BABEL_TRANSFORM_ERROR";
            }

            throw _context.t2;

          case 12:
            _context.prev = 12;

            if (opts.code !== false) {
              _generateCode = generateCode$1(config.passes, file);
              outputCode = _generateCode.outputCode;
              outputMap = _generateCode.outputMap;
            }

            _context.next = 21;
            break;

          case 16:
            _context.prev = 16;
            _context.t3 = _context["catch"](12);
            _context.t3.message = ((_opts$filename2 = opts.filename) != null ? _opts$filename2 : "unknown") + ": " + _context.t3.message;

            if (!_context.t3.code) {
              _context.t3.code = "BABEL_GENERATE_ERROR";
            }

            throw _context.t3;

          case 21:
            return _context.abrupt("return", {
              metadata: file.metadata,
              options: opts,
              ast: opts.ast === true ? file.ast : null,
              code: outputCode === undefined ? null : outputCode,
              map: outputMap === undefined ? null : outputMap,
              sourceType: file.ast.program.sourceType
            });

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$7, null, [[3, 7], [12, 16]]);
  }

  function transformFile(file, pluginPasses) {
    var _iterator, _isArray, _i, _ref, pluginPairs, passPairs, passes, visitors, _iterator2, _isArray2, _i2, _ref2, plugin, pass, _i3, _passPairs, _passPairs$_i, _plugin, _pass, fn, result, visitor, _i4, _passPairs2, _passPairs2$_i, _plugin2, _pass2, _fn, _result;

    return regenerator.wrap(function transformFile$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _iterator = pluginPasses, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();

          case 1:
            if (!_isArray) {
              _context2.next = 7;
              break;
            }

            if (!(_i >= _iterator.length)) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("break", 61);

          case 4:
            _ref = _iterator[_i++];
            _context2.next = 11;
            break;

          case 7:
            _i = _iterator.next();

            if (!_i.done) {
              _context2.next = 10;
              break;
            }

            return _context2.abrupt("break", 61);

          case 10:
            _ref = _i.value;

          case 11:
            pluginPairs = _ref;
            passPairs = [];
            passes = [];
            visitors = [];
            _iterator2 = pluginPairs.concat([loadBlockHoistPlugin()]), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();

          case 16:
            if (!_isArray2) {
              _context2.next = 22;
              break;
            }

            if (!(_i2 >= _iterator2.length)) {
              _context2.next = 19;
              break;
            }

            return _context2.abrupt("break", 33);

          case 19:
            _ref2 = _iterator2[_i2++];
            _context2.next = 26;
            break;

          case 22:
            _i2 = _iterator2.next();

            if (!_i2.done) {
              _context2.next = 25;
              break;
            }

            return _context2.abrupt("break", 33);

          case 25:
            _ref2 = _i2.value;

          case 26:
            plugin = _ref2;
            pass = new PluginPass(file, plugin.key, plugin.options);
            passPairs.push([plugin, pass]);
            passes.push(pass);
            visitors.push(plugin.visitor);

          case 31:
            _context2.next = 16;
            break;

          case 33:
            _i3 = 0, _passPairs = passPairs;

          case 34:
            if (!(_i3 < _passPairs.length)) {
              _context2.next = 45;
              break;
            }

            _passPairs$_i = _passPairs[_i3], _plugin = _passPairs$_i[0], _pass = _passPairs$_i[1];
            fn = _plugin.pre;

            if (!fn) {
              _context2.next = 42;
              break;
            }

            result = fn.call(_pass, file);
            return _context2.delegateYield([], "t0", 40);

          case 40:
            if (!isThenable$1(result)) {
              _context2.next = 42;
              break;
            }

            throw new Error("You appear to be using an plugin with an async .pre, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

          case 42:
            _i3++;
            _context2.next = 34;
            break;

          case 45:
            visitor = traverse$1.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);
            traverse$1(file.ast, visitor, file.scope);
            _i4 = 0, _passPairs2 = passPairs;

          case 48:
            if (!(_i4 < _passPairs2.length)) {
              _context2.next = 59;
              break;
            }

            _passPairs2$_i = _passPairs2[_i4], _plugin2 = _passPairs2$_i[0], _pass2 = _passPairs2$_i[1];
            _fn = _plugin2.post;

            if (!_fn) {
              _context2.next = 56;
              break;
            }

            _result = _fn.call(_pass2, file);
            return _context2.delegateYield([], "t1", 54);

          case 54:
            if (!isThenable$1(_result)) {
              _context2.next = 56;
              break;
            }

            throw new Error("You appear to be using an plugin with an async .post, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

          case 56:
            _i4++;
            _context2.next = 48;
            break;

          case 59:
            _context2.next = 1;
            break;

          case 61:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2$5);
  }

  function isThenable$1(val) {
    return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
  }

  var transformRunner = gensync(regenerator.mark(function transform(code, opts) {
    var config;
    return regenerator.wrap(function transform$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(loadConfig$1(opts), "t0", 1);

          case 1:
            config = _context.t0;

            if (!(config === null)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", null);

          case 4:
            return _context.delegateYield(run(config, code), "t1", 5);

          case 5:
            return _context.abrupt("return", _context.t1);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, transform);
  }));
  var transform = function transform(code, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = undefined;
    }

    if (callback === undefined) return transformRunner.sync(code, opts);
    transformRunner.errback(code, opts, callback);
  };
  var transformSync = transformRunner.sync;
  var transformAsync = transformRunner.async;

  var transformFile$1 = function transformFile(filename, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
    }

    callback(new Error("Transforming files is not supported in browsers"), null);
  };
  function transformFileSync() {
    throw new Error("Transforming files is not supported in browsers");
  }
  function transformFileAsync() {
    return Promise.reject(new Error("Transforming files is not supported in browsers"));
  }

  var transformFromAstRunner = gensync(regenerator.mark(function _callee(ast, code, opts) {
    var config;
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(loadConfig$1(opts), "t0", 1);

          case 1:
            config = _context.t0;

            if (!(config === null)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", null);

          case 4:
            if (ast) {
              _context.next = 6;
              break;
            }

            throw new Error("No AST given");

          case 6:
            return _context.delegateYield(run(config, code, ast), "t1", 7);

          case 7:
            return _context.abrupt("return", _context.t1);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  var transformFromAst = function transformFromAst(ast, code, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = undefined;
    }

    if (callback === undefined) {
      return transformFromAstRunner.sync(ast, code, opts);
    }

    transformFromAstRunner.errback(ast, code, opts, callback);
  };
  var transformFromAstSync = transformFromAstRunner.sync;
  var transformFromAstAsync = transformFromAstRunner.async;

  var parseRunner = gensync(regenerator.mark(function parse(code, opts) {
    var config;
    return regenerator.wrap(function parse$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(loadConfig$1(opts), "t0", 1);

          case 1:
            config = _context.t0;

            if (!(config === null)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", null);

          case 4:
            return _context.delegateYield(parser(config.passes, normalizeOptions$2(config), code), "t1", 5);

          case 5:
            return _context.abrupt("return", _context.t1);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, parse);
  }));
  var parse$3 = function parse(code, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = undefined;
    }

    if (callback === undefined) return parseRunner.sync(code, opts);
    parseRunner.errback(code, opts, callback);
  };
  var parseSync = parseRunner.sync;
  var parseAsync = parseRunner.async;

  var DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs"]);
  var OptionManager = function () {
    function OptionManager() {}

    var _proto = OptionManager.prototype;

    _proto.init = function init(opts) {
      return loadOptions(opts);
    };

    return OptionManager;
  }();
  function Plugin$1(alias) {
    throw new Error("The (" + alias + ") Babel 5 plugin is being run with an unsupported Babel version.");
  }

  function declare(builder) {
    return function (api, options, dirname) {
      if (!api.assertVersion) {
        api = Object.assign(copyApiObject(api), {
          assertVersion: function assertVersion(range) {
            throwVersionError(range, api.version);
          }
        });
      }

      return builder(api, options || {}, dirname);
    };
  }

  function copyApiObject(api) {
    var proto = null;

    if (typeof api.version === "string" && /^7\./.test(api.version)) {
      proto = Object.getPrototypeOf(api);

      if (proto && (!has$4(proto, "version") || !has$4(proto, "transform") || !has$4(proto, "template") || !has$4(proto, "types"))) {
        proto = null;
      }
    }

    return Object.assign({}, proto, {}, api);
  }

  function has$4(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  function throwVersionError(range, version) {
    if (typeof range === "number") {
      if (!Number.isInteger(range)) {
        throw new Error("Expected string or integer value.");
      }

      range = "^" + range + ".0.0-0";
    }

    if (typeof range !== "string") {
      throw new Error("Expected string or integer value.");
    }

    var limit = Error.stackTraceLimit;

    if (typeof limit === "number" && limit < 25) {
      Error.stackTraceLimit = 25;
    }

    var err;

    if (version.slice(0, 2) === "7.") {
      err = new Error("Requires Babel \"^7.0.0-beta.41\", but was loaded with \"" + version + "\". " + "You'll need to update your @babel/core version.");
    } else {
      err = new Error("Requires Babel \"" + range + "\", but was loaded with \"" + version + "\". " + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + "the first entry that doesn't mention \"@babel/core\" or \"babel-core\" " + "to see what is calling Babel.");
    }

    if (typeof limit === "number") {
      Error.stackTraceLimit = limit;
    }

    throw Object.assign(err, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: version,
      range: range
    });
  }

  var src = /*#__PURE__*/Object.freeze({
    __proto__: null,
    declare: declare
  });

  var externalHelpers = declare(function (api, options) {
    api.assertVersion(7);
    var _options$helperVersio = options.helperVersion,
        helperVersion = _options$helperVersio === void 0 ? "7.0.0-beta.0" : _options$helperVersio,
        _options$whitelist = options.whitelist,
        whitelist = _options$whitelist === void 0 ? false : _options$whitelist;

    if (whitelist !== false && (!Array.isArray(whitelist) || whitelist.some(function (w) {
      return typeof w !== "string";
    }))) {
      throw new Error(".whitelist must be undefined, false, or an array of strings");
    }

    var helperWhitelist = whitelist ? new Set(whitelist) : null;
    return {
      name: "external-helpers",
      pre: function pre(file) {
        file.set("helperGenerator", function (name) {
          if (file.availableHelper && !file.availableHelper(name, helperVersion)) {
            return;
          }

          if (helperWhitelist && !helperWhitelist.has(name)) return;
          return MemberExpression(Identifier("babelHelpers"), Identifier(name));
        });
      }
    };
  });

  var _helperPluginUtils = getCjsExportFromNamespace(src);

  var lib = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-async-generators",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("asyncGenerators");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxAsyncGenerators = unwrapExports(lib);

  var syntaxClassProperties = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-class-properties",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
      }
    };
  });

  var syntaxDecorators = declare(function (api, options) {
    api.assertVersion(7);
    var _options$legacy = options.legacy,
        legacy = _options$legacy === void 0 ? false : _options$legacy;

    if (typeof legacy !== "boolean") {
      throw new Error("'legacy' must be a boolean.");
    }

    var decoratorsBeforeExport = options.decoratorsBeforeExport;

    if (decoratorsBeforeExport === undefined) {
      if (!legacy) {
        throw new Error("The '@babel/plugin-syntax-decorators' plugin requires a" + " 'decoratorsBeforeExport' option, whose value must be a boolean." + " If you want to use the legacy decorators semantics, you can set" + " the 'legacy: true' option.");
      }
    } else {
      if (legacy) {
        throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");
      }

      if (typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }

    return {
      name: "syntax-decorators",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push(legacy ? "decorators-legacy" : ["decorators", {
          decoratorsBeforeExport: decoratorsBeforeExport
        }]);
      }
    };
  });

  var syntaxDoExpressions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-do-expressions",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("doExpressions");
      }
    };
  });

  var lib$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-dynamic-import",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("dynamicImport");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxDynamicImport = unwrapExports(lib$1);

  var syntaxExportDefaultFrom = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-export-default-from",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("exportDefaultFrom");
      }
    };
  });

  var lib$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-export-namespace-from",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("exportNamespaceFrom");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxExportNamespaceFrom = unwrapExports(lib$2);

  var syntaxFlow = declare(function (api, options) {
    api.assertVersion(7);
    var all = options.all,
        enums = options.enums;

    if (typeof all !== "boolean" && typeof all !== "undefined") {
      throw new Error(".all must be a boolean, or undefined");
    }

    if (typeof enums !== "boolean" && typeof enums !== "undefined") {
      throw new Error(".enums must be a boolean, or undefined");
    }

    return {
      name: "syntax-flow",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        if (parserOpts.plugins.some(function (p) {
          return (Array.isArray(p) ? p[0] : p) === "typescript";
        })) {
          return;
        }

        parserOpts.plugins.push(["flow", {
          all: all,
          enums: enums
        }]);
      }
    };
  });

  var syntaxFunctionBind = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-function-bind",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("functionBind");
      }
    };
  });

  var syntaxFunctionSent = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-function-sent",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("functionSent");
      }
    };
  });

  var syntaxImportMeta = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-import-meta",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("importMeta");
      }
    };
  });

  var syntaxJsx = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-jsx",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        if (parserOpts.plugins.some(function (p) {
          return (Array.isArray(p) ? p[0] : p) === "typescript";
        })) {
          return;
        }

        parserOpts.plugins.push("jsx");
      }
    };
  });

  var lib$3 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-object-rest-spread",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("objectRestSpread");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxObjectRestSpread = unwrapExports(lib$3);

  var lib$4 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-optional-catch-binding",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("optionalCatchBinding");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxOptionalCatchBinding = unwrapExports(lib$4);

  var proposals = ["minimal", "smart", "fsharp"];
  var syntaxPipelineOperator = declare(function (api, _ref) {
    var proposal = _ref.proposal;
    api.assertVersion(7);

    if (typeof proposal !== "string" || !proposals.includes(proposal)) {
      throw new Error("The pipeline operator plugin requires a 'proposal' option." + "'proposal' must be one of: " + proposals.join(", ") + ". More details: https://babeljs.io/docs/en/next/babel-plugin-proposal-pipeline-operator");
    }

    return {
      name: "syntax-pipeline-operator",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push(["pipelineOperator", {
          proposal: proposal
        }]);
      }
    };
  });

  var syntaxTopLevelAwait = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-top-level-await",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("topLevelAwait");
      }
    };
  });

  function removePlugin(plugins, name) {
    var indices = [];
    plugins.forEach(function (plugin, i) {
      var n = Array.isArray(plugin) ? plugin[0] : plugin;

      if (n === name) {
        indices.unshift(i);
      }
    });

    for (var _i = 0, _indices = indices; _i < _indices.length; _i++) {
      var i = _indices[_i];
      plugins.splice(i, 1);
    }
  }

  var syntaxTypescript = declare(function (api, _ref) {
    var isTSX = _ref.isTSX;
    api.assertVersion(7);
    return {
      name: "syntax-typescript",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        var plugins = parserOpts.plugins;
        removePlugin(plugins, "flow");
        removePlugin(plugins, "jsx");
        parserOpts.plugins.push("typescript", "classProperties", "objectRestSpread");

        if (isTSX) {
          parserOpts.plugins.push("jsx");
        }
      }
    };
  });

  var buildAnonymousExpressionWrapper = template.expression("\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n");
  var buildNamedExpressionWrapper = template.expression("\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n");
  var buildDeclarationWrapper = template("\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n");

  function classOrObjectMethod(path, callId) {
    var node = path.node;
    var body = node.body;
    var container = FunctionExpression(null, [], BlockStatement(body.body), true);
    body.body = [ReturnStatement(CallExpression(CallExpression(callId, [container]), []))];
    node.async = false;
    node.generator = false;
    path.get("body.body.0.argument.callee.arguments.0").unwrapFunctionEnvironment();
  }

  function plainFunction(path, callId) {
    var node = path.node;
    var isDeclaration = path.isFunctionDeclaration();
    var functionId = node.id;
    var wrapper = isDeclaration ? buildDeclarationWrapper : functionId ? buildNamedExpressionWrapper : buildAnonymousExpressionWrapper;

    if (path.isArrowFunctionExpression()) {
      path.arrowFunctionToExpression();
    }

    node.id = null;

    if (isDeclaration) {
      node.type = "FunctionExpression";
    }

    var built = CallExpression(callId, [node]);
    var container = wrapper({
      NAME: functionId || null,
      REF: path.scope.generateUidIdentifier(functionId ? functionId.name : "ref"),
      FUNCTION: built,
      PARAMS: node.params.reduce(function (acc, param) {
        acc.done = acc.done || isAssignmentPattern(param) || isRestElement(param);

        if (!acc.done) {
          acc.params.push(path.scope.generateUidIdentifier("x"));
        }

        return acc;
      }, {
        params: [],
        done: false
      }).params
    });

    if (isDeclaration) {
      path.replaceWith(container[0]);
      path.insertAfter(container[1]);
    } else {
      var retFunction = container.callee.body.body[1].argument;

      if (!functionId) {
        nameFunction({
          node: retFunction,
          parent: path.parent,
          scope: path.scope
        });
      }

      if (!retFunction || retFunction.id || node.params.length) {
        path.replaceWith(container);
      } else {
        path.replaceWith(built);
      }
    }
  }

  function wrapFunction(path, callId) {
    if (path.isClassMethod() || path.isObjectMethod()) {
      classOrObjectMethod(path, callId);
    } else {
      plainFunction(path, callId);
    }
  }

  var PURE_ANNOTATION = "#__PURE__";

  var isPureAnnotated = function isPureAnnotated(_ref) {
    var leadingComments = _ref.leadingComments;
    return !!leadingComments && leadingComments.some(function (comment) {
      return /[@#]__PURE__/.test(comment.value);
    });
  };

  function annotateAsPure(pathOrNode) {
    var node = pathOrNode.node || pathOrNode;

    if (isPureAnnotated(node)) {
      return;
    }

    addComment(node, "leading", PURE_ANNOTATION);
  }

  var awaitVisitor = {
    Function: function Function(path) {
      path.skip();
    },
    AwaitExpression: function AwaitExpression(path, _ref) {
      var wrapAwait = _ref.wrapAwait;
      var argument = path.get("argument");

      if (path.parentPath.isYieldExpression()) {
        path.replaceWith(argument.node);
        return;
      }

      path.replaceWith(YieldExpression(wrapAwait ? CallExpression(cloneNode(wrapAwait), [argument.node]) : argument.node));
    }
  };
  function remapAsyncToGenerator (path, helpers) {
    path.traverse(awaitVisitor, {
      wrapAwait: helpers.wrapAwait
    });
    var isIIFE = checkIsIIFE(path);
    path.node.async = false;
    path.node.generator = true;
    wrapFunction(path, cloneNode(helpers.wrapAsync));
    var isProperty = path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty();

    if (!isProperty && !isIIFE && path.isExpression()) {
      annotateAsPure(path);
    }

    function checkIsIIFE(path) {
      if (path.parentPath.isCallExpression({
        callee: path.node
      })) {
        return true;
      }

      var parentPath = path.parentPath;

      if (parentPath.isMemberExpression() && isIdentifier(parentPath.node.property, {
        name: "bind"
      })) {
        var bindCall = parentPath.parentPath;
        return bindCall.isCallExpression() && bindCall.node.arguments.length === 1 && isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({
          callee: bindCall.node
        });
      }

      return false;
    }
  }

  var lib$5 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-async-generators",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("asyncGenerators");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxAsyncGenerators$1 = unwrapExports(lib$5);

  var buildForAwait = template("\n  async function wrapper() {\n    var ITERATOR_COMPLETION = true;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY, STEP_VALUE;\n        (\n          STEP_KEY = await ITERATOR_KEY.next(),\n          ITERATOR_COMPLETION = STEP_KEY.done,\n          STEP_VALUE = await STEP_KEY.value,\n          !ITERATOR_COMPLETION\n        );\n        ITERATOR_COMPLETION = true) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n");
  function rewriteForAwait (path, _ref) {
    var getAsyncIterator = _ref.getAsyncIterator;
    var node = path.node,
        scope = path.scope,
        parent = path.parent;
    var stepKey = scope.generateUidIdentifier("step");
    var stepValue = scope.generateUidIdentifier("value");
    var left = node.left;
    var declar;

    if (isIdentifier(left) || isPattern(left) || isMemberExpression(left)) {
      declar = ExpressionStatement(AssignmentExpression("=", left, stepValue));
    } else if (isVariableDeclaration(left)) {
      declar = VariableDeclaration(left.kind, [VariableDeclarator(left.declarations[0].id, stepValue)]);
    }

    var template = buildForAwait({
      ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
      ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
      ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
      ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
      GET_ITERATOR: getAsyncIterator,
      OBJECT: node.right,
      STEP_VALUE: stepValue,
      STEP_KEY: stepKey
    });
    template = template.body.body;
    var isLabeledParent = isLabeledStatement(parent);
    var tryBody = template[3].block.body;
    var loop = tryBody[0];

    if (isLabeledParent) {
      tryBody[0] = LabeledStatement(parent.label, loop);
    }

    return {
      replaceParent: isLabeledParent,
      node: template,
      declar: declar,
      loop: loop
    };
  }

  var proposalAsyncGeneratorFunctions = declare(function (api) {
    api.assertVersion(7);
    var yieldStarVisitor = {
      Function: function Function(path) {
        path.skip();
      },
      YieldExpression: function YieldExpression(_ref, state) {
        var node = _ref.node;
        if (!node.delegate) return;
        var callee = state.addHelper("asyncGeneratorDelegate");
        node.argument = CallExpression(callee, [CallExpression(state.addHelper("asyncIterator"), [node.argument]), state.addHelper("awaitAsyncGenerator")]);
      }
    };
    var forAwaitVisitor = {
      Function: function Function(path) {
        path.skip();
      },
      ForOfStatement: function ForOfStatement(path, _ref2) {
        var file = _ref2.file;
        var node = path.node;
        if (!node["await"]) return;
        var build = rewriteForAwait(path, {
          getAsyncIterator: file.addHelper("asyncIterator")
        });
        var declar = build.declar,
            loop = build.loop;
        var block = loop.body;
        path.ensureBlock();

        if (declar) {
          block.body.push(declar);
        }

        block.body = block.body.concat(node.body.body);
        inherits(loop, node);
        inherits(loop.body, node.body);

        if (build.replaceParent) {
          path.parentPath.replaceWithMultiple(build.node);
        } else {
          path.replaceWithMultiple(build.node);
        }
      }
    };
    var visitor = {
      Function: function Function(path, state) {
        if (!path.node.async) return;
        path.traverse(forAwaitVisitor, state);
        if (!path.node.generator) return;
        path.traverse(yieldStarVisitor, state);
        remapAsyncToGenerator(path, {
          wrapAsync: state.addHelper("wrapAsyncGenerator"),
          wrapAwait: state.addHelper("awaitAsyncGenerator")
        });
      }
    };
    return {
      name: "proposal-async-generator-functions",
      inherits: syntaxAsyncGenerators$1,
      visitor: {
        Program: function Program(path, state) {
          path.traverse(visitor, state);
        }
      }
    };
  });

  function assertFieldTransformed(path) {
    if (path.node.declare) {
      throw path.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by " + "@babel/plugin-transform-typescript.\n" + "If you have already enabled that plugin (or '@babel/preset-typescript'), make sure " + "that it runs before any plugin related to additional class features:\n" + " - @babel/plugin-proposal-class-properties\n" + " - @babel/plugin-proposal-private-methods\n" + " - @babel/plugin-proposal-decorators");
    }
  }

  function _templateObject15$1() {
    var data = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(", ", ", ", {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ", "\n    });\n  "]);

    _templateObject15$1 = function _templateObject15() {
      return data;
    };

    return data;
  }

  function _templateObject14$1() {
    var data = _taggedTemplateLiteralLoose(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      })\n    "]);

    _templateObject14$1 = function _templateObject14() {
      return data;
    };

    return data;
  }

  function _templateObject13$1() {
    var data = _taggedTemplateLiteralLoose(["", ".add(", ")"]);

    _templateObject13$1 = function _templateObject13() {
      return data;
    };

    return data;
  }

  function _templateObject12$1() {
    var data = _taggedTemplateLiteralLoose(["\n      ", ".set(", ", {\n        get: ", ",\n        set: ", "\n      });\n    "]);

    _templateObject12$1 = function _templateObject12() {
      return data;
    };

    return data;
  }

  function _templateObject11$2() {
    var data = _taggedTemplateLiteralLoose(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      });\n    "]);

    _templateObject11$2 = function _templateObject11() {
      return data;
    };

    return data;
  }

  function _templateObject10$2() {
    var data = _taggedTemplateLiteralLoose(["\n        Object.defineProperty(", ", ", ", {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ", "\n        });\n      "]);

    _templateObject10$2 = function _templateObject10() {
      return data;
    };

    return data;
  }

  function _templateObject9$2() {
    var data = _taggedTemplateLiteralLoose(["\n    var ", " = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ", "\n    };\n  "]);

    _templateObject9$2 = function _templateObject9() {
      return data;
    };

    return data;
  }

  function _templateObject8$2() {
    var data = _taggedTemplateLiteralLoose(["\n      var ", " = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      }\n    "]);

    _templateObject8$2 = function _templateObject8() {
      return data;
    };

    return data;
  }

  function _templateObject7$2() {
    var data = _taggedTemplateLiteralLoose(["", ".set(", ", {\n    // configurable is always false for private elements\n    // enumerable is always false for private elements\n    writable: true,\n    value: ", ",\n  })"]);

    _templateObject7$2 = function _templateObject7() {
      return data;
    };

    return data;
  }

  function _templateObject6$2() {
    var data = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(", ", ", ", {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ", "\n    });\n  "]);

    _templateObject6$2 = function _templateObject6() {
      return data;
    };

    return data;
  }

  function _templateObject5$2() {
    var data = _taggedTemplateLiteralLoose(["BASE(REF, PROP)[PROP]"]);

    _templateObject5$2 = function _templateObject5() {
      return data;
    };

    return data;
  }

  function _templateObject4$2() {
    var data = _taggedTemplateLiteralLoose(["var ", " = new WeakMap();"]);

    _templateObject4$2 = function _templateObject4() {
      return data;
    };

    return data;
  }

  function _templateObject3$2() {
    var data = _taggedTemplateLiteralLoose(["var ", " = new WeakSet();"]);

    _templateObject3$2 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2$2() {
    var data = _taggedTemplateLiteralLoose(["var ", " = new WeakMap();"]);

    _templateObject2$2 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$4() {
    var data = _taggedTemplateLiteralLoose(["\n          var ", " = ", "(\"", "\")\n        "]);

    _templateObject$4 = function _templateObject() {
      return data;
    };

    return data;
  }
  function buildPrivateNamesMap(props) {
    var privateNamesMap = new Map();

    for (var _iterator = props, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var prop = _ref;
      var isPrivate = prop.isPrivate();
      var isMethod = !prop.isProperty();
      var isInstance = !prop.node["static"];

      if (isPrivate) {
        var name = prop.node.key.id.name;
        var update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {
          id: prop.scope.generateUidIdentifier(name),
          "static": !isInstance,
          method: isMethod
        };

        if (prop.node.kind === "get") {
          update.getId = prop.scope.generateUidIdentifier("get_" + name);
        } else if (prop.node.kind === "set") {
          update.setId = prop.scope.generateUidIdentifier("set_" + name);
        } else if (prop.node.kind === "method") {
          update.methodId = prop.scope.generateUidIdentifier(name);
        }

        privateNamesMap.set(name, update);
      }
    }

    return privateNamesMap;
  }
  function buildPrivateNamesNodes(privateNamesMap, loose, state) {
    var initNodes = [];

    for (var _iterator2 = privateNamesMap, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var _ref3 = _ref2,
          name = _ref3[0],
          value = _ref3[1];
      var id = value.id,
          isStatic = value["static"],
          isMethod = value.method,
          getId = value.getId,
          setId = value.setId;
      var isAccessor = getId || setId;

      if (loose) {
        initNodes.push(template.statement.ast(_templateObject$4(), id, state.addHelper("classPrivateFieldLooseKey"), name));
      } else if (isMethod && !isStatic) {
        if (isAccessor) {
          initNodes.push(template.statement.ast(_templateObject2$2(), id));
        } else {
          initNodes.push(template.statement.ast(_templateObject3$2(), id));
        }
      } else if (!isStatic) {
        initNodes.push(template.statement.ast(_templateObject4$2(), id));
      }
    }

    return initNodes;
  }
  var privateNameVisitor = {
    PrivateName: function PrivateName(path) {
      var privateNamesMap = this.privateNamesMap;
      var node = path.node,
          parentPath = path.parentPath;
      if (!parentPath.isMemberExpression({
        property: node
      })) return;
      if (!privateNamesMap.has(node.id.name)) return;
      this.handle(parentPath);
    },
    Class: function Class(path) {
      var privateNamesMap = this.privateNamesMap;
      var body = path.get("body.body");

      for (var _iterator3 = body, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref4;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref4 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref4 = _i3.value;
        }

        var prop = _ref4;

        if (!prop.isPrivate()) {
          continue;
        }

        if (!privateNamesMap.has(prop.node.key.id.name)) continue;
        path.traverse(privateNameInnerVisitor, this);
        path.skip();
        break;
      }
    }
  };
  var privateNameInnerVisitor = traverse$1.visitors.merge([{
    PrivateName: privateNameVisitor.PrivateName
  }, environmentVisitor]);
  var privateNameHandlerSpec = {
    memoise: function memoise(member, count) {
      var scope = member.scope;
      var object = member.node.object;
      var memo = scope.maybeGenerateMemoised(object);

      if (!memo) {
        return;
      }

      this.memoiser.set(object, memo, count);
    },
    receiver: function receiver(member) {
      var object = member.node.object;

      if (this.memoiser.has(object)) {
        return cloneNode(this.memoiser.get(object));
      }

      return cloneNode(object);
    },
    get: function get(member) {
      var classRef = this.classRef,
          privateNamesMap = this.privateNamesMap,
          file = this.file;
      var name = member.node.property.id.name;

      var _privateNamesMap$get = privateNamesMap.get(name),
          id = _privateNamesMap$get.id,
          isStatic = _privateNamesMap$get["static"],
          isMethod = _privateNamesMap$get.method,
          methodId = _privateNamesMap$get.methodId,
          getId = _privateNamesMap$get.getId,
          setId = _privateNamesMap$get.setId;

      var isAccessor = getId || setId;

      if (isStatic) {
        var helperName = isMethod && !isAccessor ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
        return CallExpression(file.addHelper(helperName), [this.receiver(member), cloneNode(classRef), cloneNode(id)]);
      }

      if (isMethod) {
        if (isAccessor) {
          return CallExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneNode(id)]);
        }

        return CallExpression(file.addHelper("classPrivateMethodGet"), [this.receiver(member), cloneNode(id), cloneNode(methodId)]);
      }

      return CallExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneNode(id)]);
    },
    set: function set(member, value) {
      var classRef = this.classRef,
          privateNamesMap = this.privateNamesMap,
          file = this.file;
      var name = member.node.property.id.name;

      var _privateNamesMap$get2 = privateNamesMap.get(name),
          id = _privateNamesMap$get2.id,
          isStatic = _privateNamesMap$get2["static"],
          isMethod = _privateNamesMap$get2.method,
          setId = _privateNamesMap$get2.setId,
          getId = _privateNamesMap$get2.getId;

      var isAccessor = getId || setId;

      if (isStatic) {
        var helperName = isMethod && !isAccessor ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
        return CallExpression(file.addHelper(helperName), [this.receiver(member), cloneNode(classRef), cloneNode(id), value]);
      }

      if (isMethod) {
        if (setId) {
          return CallExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneNode(id), value]);
        }

        return CallExpression(file.addHelper("classPrivateMethodSet"), []);
      }

      return CallExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneNode(id), value]);
    },
    destructureSet: function destructureSet(member) {
      var privateNamesMap = this.privateNamesMap,
          file = this.file;
      var name = member.node.property.id.name;

      var _privateNamesMap$get3 = privateNamesMap.get(name),
          id = _privateNamesMap$get3.id;

      return MemberExpression(CallExpression(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), cloneNode(id)]), Identifier("value"));
    },
    call: function call(member, args) {
      this.memoise(member, 1);
      return optimiseCall(this.get(member), this.receiver(member), args);
    }
  };
  var privateNameHandlerLoose = {
    handle: function handle(member) {
      var privateNamesMap = this.privateNamesMap,
          file = this.file;
      var object = member.node.object;
      var name = member.node.property.id.name;
      member.replaceWith(template.expression(_templateObject5$2())({
        BASE: file.addHelper("classPrivateFieldLooseBase"),
        REF: object,
        PROP: privateNamesMap.get(name).id
      }));
    }
  };
  function transformPrivateNamesUsage(ref, path, privateNamesMap, loose, state) {
    var body = path.get("body");

    if (loose) {
      body.traverse(privateNameVisitor, Object.assign({
        privateNamesMap: privateNamesMap,
        file: state
      }, privateNameHandlerLoose));
    } else {
      memberExpressionToFunctions(body, privateNameVisitor, Object.assign({
        privateNamesMap: privateNamesMap,
        classRef: ref,
        file: state
      }, privateNameHandlerSpec));
    }
  }

  function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
    var _privateNamesMap$get4 = privateNamesMap.get(prop.node.key.id.name),
        id = _privateNamesMap$get4.id;

    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return template.statement.ast(_templateObject6$2(), ref, id, value);
  }

  function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap) {
    var _privateNamesMap$get5 = privateNamesMap.get(prop.node.key.id.name),
        id = _privateNamesMap$get5.id;

    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return template.statement.ast(_templateObject7$2(), id, ref, value);
  }

  function buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
        getId = privateName.getId,
        setId = privateName.setId,
        initAdded = privateName.initAdded;
    var isAccessor = getId || setId;
    if (!prop.isProperty() && (initAdded || !isAccessor)) return;

    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return template.statement.ast(_templateObject8$2(), id.name, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }

    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return template.statement.ast(_templateObject9$2(), id, value);
  }

  function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var methodId = privateName.methodId,
        id = privateName.id,
        getId = privateName.getId,
        setId = privateName.setId,
        initAdded = privateName.initAdded;
    if (initAdded) return;

    if (methodId) {
      return template.statement.ast(_templateObject10$2(), ref, id, methodId.name);
    }

    var isAccessor = getId || setId;

    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return template.statement.ast(_templateObject11$2(), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }
  }

  function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
        getId = privateName.getId,
        setId = privateName.setId,
        initAdded = privateName.initAdded;
    if (initAdded) return;
    var isAccessor = getId || setId;

    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return template.statement.ast(_templateObject12$1(), id, ref, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }

    return template.statement.ast(_templateObject13$1(), id, ref);
  }

  function buildPublicFieldInitLoose(ref, prop) {
    var _prop$node = prop.node,
        key = _prop$node.key,
        computed = _prop$node.computed;
    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return ExpressionStatement(AssignmentExpression("=", MemberExpression(ref, key, computed || isLiteral(key)), value));
  }

  function buildPublicFieldInitSpec(ref, prop, state) {
    var _prop$node2 = prop.node,
        key = _prop$node2.key,
        computed = _prop$node2.computed;
    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return ExpressionStatement(CallExpression(state.addHelper("defineProperty"), [ref, computed || isLiteral(key) ? key : StringLiteral(key.name), value]));
  }

  function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
        methodId = privateName.methodId,
        getId = privateName.getId,
        setId = privateName.setId,
        initAdded = privateName.initAdded;
    if (initAdded) return;
    var isAccessor = getId || setId;

    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return template.statement.ast(_templateObject14$1(), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }

    return template.statement.ast(_templateObject15$1(), ref, id, methodId.name);
  }

  function buildPrivateMethodDeclaration(prop, privateNamesMap, loose) {
    if (loose === void 0) {
      loose = false;
    }

    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
        methodId = privateName.methodId,
        getId = privateName.getId,
        setId = privateName.setId,
        getterDeclared = privateName.getterDeclared,
        setterDeclared = privateName.setterDeclared,
        isStatic = privateName["static"];
    var _prop$node3 = prop.node,
        params = _prop$node3.params,
        body = _prop$node3.body,
        generator = _prop$node3.generator,
        async = _prop$node3.async;
    var methodValue = FunctionExpression(methodId, params, body, generator, async);
    var isGetter = getId && !getterDeclared && params.length === 0;
    var isSetter = setId && !setterDeclared && params.length > 0;

    if (isGetter) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        getterDeclared: true
      }));
      return VariableDeclaration("var", [VariableDeclarator(getId, methodValue)]);
    }

    if (isSetter) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        setterDeclared: true
      }));
      return VariableDeclaration("var", [VariableDeclarator(setId, methodValue)]);
    }

    if (isStatic && !loose) {
      return VariableDeclaration("var", [VariableDeclarator(id, FunctionExpression(id, params, body, generator, async))]);
    }

    return VariableDeclaration("var", [VariableDeclarator(methodId, methodValue)]);
  }

  var thisContextVisitor = traverse$1.visitors.merge([{
    ThisExpression: function ThisExpression(path, state) {
      state.needsClassRef = true;
      path.replaceWith(cloneNode(state.classRef));
    }
  }, environmentVisitor]);

  function replaceThisContext(path, ref, superRef, file, loose) {
    var state = {
      classRef: ref,
      needsClassRef: false
    };
    var replacer = new ReplaceSupers({
      methodPath: path,
      isLoose: loose,
      superRef: superRef,
      file: file,
      getObjectRef: function getObjectRef() {
        state.needsClassRef = true;
        return path.node["static"] ? ref : MemberExpression(ref, Identifier("prototype"));
      }
    });
    replacer.replace();

    if (path.isProperty()) {
      path.traverse(thisContextVisitor, state);
    }

    return state.needsClassRef;
  }

  function buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, loose) {
    var staticNodes = [];
    var instanceNodes = [];
    var needsClassRef = false;

    for (var _iterator4 = props, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref5 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref5 = _i4.value;
      }

      var prop = _ref5;
      assertFieldTransformed(prop);
      var isStatic = prop.node["static"];
      var isInstance = !isStatic;
      var isPrivate = prop.isPrivate();
      var isPublic = !isPrivate;
      var isField = prop.isProperty();
      var isMethod = !isField;

      if (isStatic || isMethod && isPrivate) {
        var replaced = replaceThisContext(prop, ref, superRef, state, loose);
        needsClassRef = needsClassRef || replaced;
      }

      switch (true) {
        case isStatic && isPrivate && isField && loose:
          needsClassRef = true;
          staticNodes.push(buildPrivateFieldInitLoose(cloneNode(ref), prop, privateNamesMap));
          break;

        case isStatic && isPrivate && isField && !loose:
          needsClassRef = true;
          staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
          break;

        case isStatic && isPublic && isField && loose:
          needsClassRef = true;
          staticNodes.push(buildPublicFieldInitLoose(cloneNode(ref), prop));
          break;

        case isStatic && isPublic && isField && !loose:
          needsClassRef = true;
          staticNodes.push(buildPublicFieldInitSpec(cloneNode(ref), prop, state));
          break;

        case isInstance && isPrivate && isField && loose:
          instanceNodes.push(buildPrivateFieldInitLoose(ThisExpression(), prop, privateNamesMap));
          break;

        case isInstance && isPrivate && isField && !loose:
          instanceNodes.push(buildPrivateInstanceFieldInitSpec(ThisExpression(), prop, privateNamesMap));
          break;

        case isInstance && isPrivate && isMethod && loose:
          instanceNodes.unshift(buildPrivateMethodInitLoose(ThisExpression(), prop, privateNamesMap));
          staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
          break;

        case isInstance && isPrivate && isMethod && !loose:
          instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(ThisExpression(), prop, privateNamesMap));
          staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
          break;

        case isStatic && isPrivate && isMethod && !loose:
          needsClassRef = true;
          staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
          staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
          break;

        case isStatic && isPrivate && isMethod && loose:
          needsClassRef = true;
          staticNodes.push(buildPrivateStaticMethodInitLoose(cloneNode(ref), prop, state, privateNamesMap));
          staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
          break;

        case isInstance && isPublic && isField && loose:
          instanceNodes.push(buildPublicFieldInitLoose(ThisExpression(), prop));
          break;

        case isInstance && isPublic && isField && !loose:
          instanceNodes.push(buildPublicFieldInitSpec(ThisExpression(), prop, state));
          break;

        default:
          throw new Error("Unreachable.");
      }
    }

    return {
      staticNodes: staticNodes.filter(Boolean),
      instanceNodes: instanceNodes.filter(Boolean),
      wrapClass: function wrapClass(path) {
        for (var _iterator5 = props, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
          var _ref6;

          if (_isArray5) {
            if (_i5 >= _iterator5.length) break;
            _ref6 = _iterator5[_i5++];
          } else {
            _i5 = _iterator5.next();
            if (_i5.done) break;
            _ref6 = _i5.value;
          }

          var prop = _ref6;
          prop.remove();
        }

        if (!needsClassRef) return path;

        if (path.isClassExpression()) {
          path.scope.push({
            id: ref
          });
          path.replaceWith(AssignmentExpression("=", cloneNode(ref), path.node));
        } else if (!path.node.id) {
          path.node.id = ref;
        }

        return path;
      }
    };
  }

  function _templateObject4$3() {
    var data = _taggedTemplateLiteralLoose(["", "(this)"]);

    _templateObject4$3 = function _templateObject4() {
      return data;
    };

    return data;
  }

  function _templateObject3$3() {
    var data = _taggedTemplateLiteralLoose(["let ", " = ", ""]);

    _templateObject3$3 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2$3() {
    var data = _taggedTemplateLiteralLoose(["\n    ", "(\n      ", ",\n      function (", ", ", ") {\n        ", "\n        return { F: ", ", d: ", " };\n      },\n      ", "\n    )\n  "]);

    _templateObject2$3 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$5() {
    var data = _taggedTemplateLiteralLoose(["return ", ""]);

    _templateObject$5 = function _templateObject() {
      return data;
    };

    return data;
  }
  function hasOwnDecorators(node) {
    return !!(node.decorators && node.decorators.length);
  }
  function hasDecorators(node) {
    return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
  }

  function prop(key, value) {
    if (!value) return null;
    return ObjectProperty(Identifier(key), value);
  }

  function method(key, body) {
    return ObjectMethod("method", Identifier(key), [], BlockStatement(body));
  }

  function takeDecorators(node) {
    var result;

    if (node.decorators && node.decorators.length > 0) {
      result = ArrayExpression(node.decorators.map(function (decorator) {
        return decorator.expression;
      }));
    }

    node.decorators = undefined;
    return result;
  }

  function getKey(node) {
    if (node.computed) {
      return node.key;
    } else if (isIdentifier(node.key)) {
      return StringLiteral(node.key.name);
    } else {
      return StringLiteral(String(node.key.value));
    }
  }

  function extractElementDescriptor(classRef, superRef, path) {
    var node = path.node,
        scope = path.scope;
    var isMethod = path.isClassMethod();

    if (path.isPrivate()) {
      throw path.buildCodeFrameError("Private " + (isMethod ? "methods" : "fields") + " in decorated classes are not supported yet.");
    }

    new ReplaceSupers({
      methodPath: path,
      methodNode: node,
      objectRef: classRef,
      isStatic: node["static"],
      superRef: superRef,
      scope: scope,
      file: this
    }, true).replace();
    var properties = [prop("kind", StringLiteral(isMethod ? node.kind : "field")), prop("decorators", takeDecorators(node)), prop("static", node["static"] && BooleanLiteral(true)), prop("key", getKey(node))].filter(Boolean);

    if (isMethod) {
      var id = node.computed ? null : node.key;
      toExpression(node);
      properties.push(prop("value", nameFunction({
        node: node,
        id: id,
        scope: scope
      }) || node));
    } else if (node.value) {
      properties.push(method("value", template.statements.ast(_templateObject$5(), node.value)));
    } else {
      properties.push(prop("value", scope.buildUndefinedNode()));
    }

    path.remove();
    return ObjectExpression(properties);
  }

  function addDecorateHelper(file) {
    try {
      return file.addHelper("decorate");
    } catch (err) {
      if (err.code === "BABEL_HELPER_UNKNOWN") {
        err.message += "\n  '@babel/plugin-transform-decorators' in non-legacy mode" + " requires '@babel/core' version ^7.0.2 and you appear to be using" + " an older version.";
      }

      throw err;
    }
  }

  function buildDecoratedClass(ref, path, elements, file) {
    var node = path.node,
        scope = path.scope;
    var initializeId = scope.generateUidIdentifier("initialize");
    var isDeclaration = node.id && path.isDeclaration();
    var isStrict = path.isInStrictMode();
    var superClass = node.superClass;
    node.type = "ClassDeclaration";
    if (!node.id) node.id = cloneNode(ref);
    var superId;

    if (superClass) {
      superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super");
      node.superClass = superId;
    }

    var classDecorators = takeDecorators(node);
    var definitions = ArrayExpression(elements.map(extractElementDescriptor.bind(file, node.id, superId)));
    var replacement = template.expression.ast(_templateObject2$3(), addDecorateHelper(file), classDecorators || NullLiteral(), initializeId, superClass ? superId : null, node, cloneNode(node.id), definitions, superClass);
    var classPathDesc = "arguments.1.body.body.0";

    if (!isStrict) {
      replacement.arguments[1].body.directives.push(Directive(DirectiveLiteral("use strict")));
    }

    if (isDeclaration) {
      replacement = template.ast(_templateObject3$3(), ref, replacement);
      classPathDesc = "declarations.0.init." + classPathDesc;
    }

    return {
      instanceNodes: [template.statement.ast(_templateObject4$3(), initializeId)],
      wrapClass: function wrapClass(path) {
        path.replaceWith(replacement);
        return path.get(classPathDesc);
      }
    };
  }

  function _templateObject$6() {
    var data = _taggedTemplateLiteralLoose(["super(...args)"]);

    _templateObject$6 = function _templateObject() {
      return data;
    };

    return data;
  }
  var findBareSupers = traverse$1.visitors.merge([{
    Super: function Super(path) {
      var node = path.node,
          parentPath = path.parentPath;

      if (parentPath.isCallExpression({
        callee: node
      })) {
        this.push(parentPath);
      }
    }
  }, environmentVisitor]);
  var referenceVisitor$1 = {
    "TSTypeAnnotation|TypeAnnotation": function TSTypeAnnotationTypeAnnotation(path) {
      path.skip();
    },
    ReferencedIdentifier: function ReferencedIdentifier(path) {
      if (this.scope.hasOwnBinding(path.node.name)) {
        this.scope.rename(path.node.name);
        path.skip();
      }
    }
  };

  function handleClassTDZ(path, state) {
    if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {
      var classNameTDZError = state.file.addHelper("classNameTDZError");
      var throwNode = CallExpression(classNameTDZError, [StringLiteral(path.node.name)]);
      path.replaceWith(SequenceExpression([throwNode, path.node]));
      path.skip();
    }
  }

  var classFieldDefinitionEvaluationTDZVisitor = {
    ReferencedIdentifier: handleClassTDZ
  };
  function injectInitialization(path, constructor, nodes, renamer) {
    if (!nodes.length) return;
    var isDerived = !!path.node.superClass;

    if (!constructor) {
      var newConstructor = ClassMethod("constructor", Identifier("constructor"), [], BlockStatement([]));

      if (isDerived) {
        newConstructor.params = [RestElement(Identifier("args"))];
        newConstructor.body.body.push(template.statement.ast(_templateObject$6()));
      }

      var _path$get$unshiftCont = path.get("body").unshiftContainer("body", newConstructor);

      constructor = _path$get$unshiftCont[0];
    }

    if (renamer) {
      renamer(referenceVisitor$1, {
        scope: constructor.scope
      });
    }

    if (isDerived) {
      var bareSupers = [];
      constructor.traverse(findBareSupers, bareSupers);

      for (var _i = 0, _bareSupers = bareSupers; _i < _bareSupers.length; _i++) {
        var bareSuper = _bareSupers[_i];
        bareSuper.insertAfter(nodes);
      }
    } else {
      constructor.get("body").unshiftContainer("body", nodes);
    }
  }
  function extractComputedKeys(ref, path, computedPaths, file) {
    var declarations = [];
    var state = {
      classBinding: path.node.id && path.scope.getBinding(path.node.id.name),
      file: file
    };

    for (var _iterator = computedPaths, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i2 >= _iterator.length) break;
        _ref = _iterator[_i2++];
      } else {
        _i2 = _iterator.next();
        if (_i2.done) break;
        _ref = _i2.value;
      }

      var computedPath = _ref;
      var computedKey = computedPath.get("key");

      if (computedKey.isReferencedIdentifier()) {
        handleClassTDZ(computedKey, state);
      } else {
        computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);
      }

      var computedNode = computedPath.node;

      if (!computedKey.isConstantExpression()) {
        var ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);
        path.scope.push({
          id: ident,
          kind: "let"
        });
        declarations.push(ExpressionStatement(AssignmentExpression("=", cloneNode(ident), computedNode.key)));
        computedNode.key = cloneNode(ident);
      }
    }

    return declarations;
  }

  var FEATURES = Object.freeze({
    fields: 1 << 1,
    privateMethods: 1 << 2,
    decorators: 1 << 3
  });
  var featuresKey = "@babel/plugin-class-features/featuresKey";
  var looseKey = "@babel/plugin-class-features/looseKey";
  function enableFeature(file, feature, loose) {
    if (!hasFeature(file, feature)) {
      file.set(featuresKey, file.get(featuresKey) | feature);
      if (loose) file.set(looseKey, file.get(looseKey) | feature);
    }
  }

  function hasFeature(file, feature) {
    return !!(file.get(featuresKey) & feature);
  }

  function isLoose(file, feature) {
    return !!(file.get(looseKey) & feature);
  }
  function verifyUsedFeatures(path, file) {
    if (hasOwnDecorators(path.node)) {
      if (!hasFeature(file, FEATURES.decorators)) {
        throw path.buildCodeFrameError("Decorators are not enabled." + "\nIf you are using " + '["@babel/plugin-proposal-decorators", { "legacy": true }], ' + 'make sure it comes *before* "@babel/plugin-proposal-class-properties" ' + "and enable loose mode, like so:\n" + '\t["@babel/plugin-proposal-decorators", { "legacy": true }]\n' + '\t["@babel/plugin-proposal-class-properties", { "loose": true }]');
      }

      if (path.isPrivate()) {
        throw path.buildCodeFrameError("Private " + (path.isClassMethod() ? "methods" : "fields") + " in decorated classes are not supported yet.");
      }
    }

    if (path.isPrivate() && path.isMethod()) {
      if (!hasFeature(file, FEATURES.privateMethods)) {
        throw path.buildCodeFrameError("Class private methods are not enabled.");
      }
    }

    if (hasFeature(file, FEATURES.privateMethods) && hasFeature(file, FEATURES.fields) && isLoose(file, FEATURES.privateMethods) !== isLoose(file, FEATURES.fields)) {
      throw path.buildCodeFrameError("'loose' mode configuration must be the same for both @babel/plugin-proposal-class-properties " + "and @babel/plugin-proposal-private-methods");
    }

    if (path.isProperty()) {
      if (!hasFeature(file, FEATURES.fields)) {
        throw path.buildCodeFrameError("Class fields are not enabled.");
      }
    }
  }

  var name = "@babel/helper-create-class-features-plugin";
  var version$2 = "7.8.6";
  var author = "The Babel Team (https://babeljs.io/team)";
  var license = "MIT";
  var description = "Compile class public and private fields, private methods and decorators to ES6";
  var repository = "https://github.com/babel/babel/tree/master/packages/babel-helper-create-class-features-plugin";
  var main = "lib/index.js";
  var publishConfig = {
    access: "public"
  };
  var keywords$2 = [
    "babel",
    "babel-plugin"
  ];
  var dependencies = {
    "@babel/helper-function-name": "^7.8.3",
    "@babel/helper-member-expression-to-functions": "^7.8.3",
    "@babel/helper-optimise-call-expression": "^7.8.3",
    "@babel/helper-plugin-utils": "^7.8.3",
    "@babel/helper-replace-supers": "^7.8.6",
    "@babel/helper-split-export-declaration": "^7.8.3"
  };
  var peerDependencies = {
    "@babel/core": "^7.0.0"
  };
  var devDependencies = {
    "@babel/core": "^7.8.6",
    "@babel/helper-plugin-test-runner": "^7.8.3"
  };
  var pkg = {
    name: name,
    version: version$2,
    author: author,
    license: license,
    description: description,
    repository: repository,
    main: main,
    publishConfig: publishConfig,
    keywords: keywords$2,
    dependencies: dependencies,
    peerDependencies: peerDependencies,
    devDependencies: devDependencies
  };

  var version$3 = pkg.version.split(".").reduce(function (v, x) {
    return v * 1e5 + +x;
  }, 0);
  var versionKey = "@babel/plugin-class-features/version";
  function createClassFeaturePlugin(_ref) {
    var name = _ref.name,
        feature = _ref.feature,
        loose = _ref.loose,
        manipulateOptions = _ref.manipulateOptions;
    return {
      name: name,
      manipulateOptions: manipulateOptions,
      pre: function pre() {
        enableFeature(this.file, feature, loose);

        if (!this.file.get(versionKey) || this.file.get(versionKey) < version$3) {
          this.file.set(versionKey, version$3);
        }
      },
      visitor: {
        Class: function Class(path, state) {
          if (this.file.get(versionKey) !== version$3) return;
          verifyUsedFeatures(path, this.file);
          var loose = isLoose(this.file, feature);
          var constructor;
          var isDecorated = hasOwnDecorators(path.node);
          var props = [];
          var elements = [];
          var computedPaths = [];
          var privateNames = new Set();
          var body = path.get("body");

          for (var _iterator = body.get("body"), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref2 = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref2 = _i.value;
            }

            var _path = _ref2;
            verifyUsedFeatures(_path, this.file);

            if (_path.node.computed) {
              computedPaths.push(_path);
            }

            if (_path.isPrivate()) {
              var _name = _path.node.key.id.name;
              var getName = "get " + _name;
              var setName = "set " + _name;

              if (_path.node.kind === "get") {
                if (privateNames.has(getName) || privateNames.has(_name) && !privateNames.has(setName)) {
                  throw _path.buildCodeFrameError("Duplicate private field");
                }

                privateNames.add(getName).add(_name);
              } else if (_path.node.kind === "set") {
                if (privateNames.has(setName) || privateNames.has(_name) && !privateNames.has(getName)) {
                  throw _path.buildCodeFrameError("Duplicate private field");
                }

                privateNames.add(setName).add(_name);
              } else {
                if (privateNames.has(_name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(_name) && (privateNames.has(getName) || privateNames.has(setName))) {
                  throw _path.buildCodeFrameError("Duplicate private field");
                }

                privateNames.add(_name);
              }
            }

            if (_path.isClassMethod({
              kind: "constructor"
            })) {
              constructor = _path;
            } else {
              elements.push(_path);

              if (_path.isProperty() || _path.isPrivate()) {
                props.push(_path);
              }
            }

            if (!isDecorated) isDecorated = hasOwnDecorators(_path.node);
          }

          if (!props.length && !isDecorated) return;
          var ref;

          if (path.isClassExpression() || !path.node.id) {
            nameFunction(path);
            ref = path.scope.generateUidIdentifier("class");
          } else {
            ref = path.node.id;
          }

          var privateNamesMap = buildPrivateNamesMap(props);
          var privateNamesNodes = buildPrivateNamesNodes(privateNamesMap, loose, state);
          transformPrivateNamesUsage(ref, path, privateNamesMap, loose, state);
          var keysNodes, staticNodes, instanceNodes, wrapClass;

          if (isDecorated) {
            staticNodes = keysNodes = [];

            var _buildDecoratedClass = buildDecoratedClass(ref, path, elements, this.file);

            instanceNodes = _buildDecoratedClass.instanceNodes;
            wrapClass = _buildDecoratedClass.wrapClass;
          } else {
            keysNodes = extractComputedKeys(ref, path, computedPaths, this.file);

            var _buildFieldsInitNodes = buildFieldsInitNodes(ref, path.node.superClass, props, privateNamesMap, state, loose);

            staticNodes = _buildFieldsInitNodes.staticNodes;
            instanceNodes = _buildFieldsInitNodes.instanceNodes;
            wrapClass = _buildFieldsInitNodes.wrapClass;
          }

          if (instanceNodes.length > 0) {
            injectInitialization(path, constructor, instanceNodes, function (referenceVisitor, state) {
              if (isDecorated) return;

              for (var _iterator2 = props, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                var _ref3;

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break;
                  _ref3 = _iterator2[_i2++];
                } else {
                  _i2 = _iterator2.next();
                  if (_i2.done) break;
                  _ref3 = _i2.value;
                }

                var prop = _ref3;
                if (prop.node["static"]) continue;
                prop.traverse(referenceVisitor, state);
              }
            });
          }

          path = wrapClass(path);
          path.insertBefore(keysNodes);
          path.insertAfter([].concat(privateNamesNodes, staticNodes));
        },
        PrivateName: function PrivateName(path) {
          if (this.file.get(versionKey) !== version$3) return;
          throw path.buildCodeFrameError("Unknown PrivateName \"" + path + "\"");
        },
        ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
          if (this.file.get(versionKey) !== version$3) return;
          var decl = path.get("declaration");

          if (decl.isClassDeclaration() && hasDecorators(decl.node)) {
            if (decl.node.id) {
              splitExportDeclaration(path);
            } else {
              decl.node.type = "ClassExpression";
            }
          }
        }
      }
    };
  }

  var proposalClassProperties = declare(function (api, options) {
    api.assertVersion(7);
    return createClassFeaturePlugin({
      name: "proposal-class-properties",
      feature: FEATURES.fields,
      loose: options.loose,
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("classProperties", "classPrivateProperties");
      }
    });
  });

  var buildClassDecorator = template("\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n");
  var buildClassPrototype = template("\n  CLASS_REF.prototype;\n");
  var buildGetDescriptor = template("\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n");
  var buildGetObjectInitializer = template("\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n");
  var WARNING_CALLS = new WeakSet();

  function applyEnsureOrdering(path) {
    var decorators = (path.isClass() ? [path].concat(path.get("body.body")) : path.get("properties")).reduce(function (acc, prop) {
      return acc.concat(prop.node.decorators || []);
    }, []);
    var identDecorators = decorators.filter(function (decorator) {
      return !isIdentifier(decorator.expression);
    });
    if (identDecorators.length === 0) return;
    return SequenceExpression(identDecorators.map(function (decorator) {
      var expression = decorator.expression;
      var id = decorator.expression = path.scope.generateDeclaredUidIdentifier("dec");
      return AssignmentExpression("=", id, expression);
    }).concat([path.node]));
  }

  function applyClassDecorators(classPath) {
    if (!hasClassDecorators(classPath.node)) return;
    var decorators = classPath.node.decorators || [];
    classPath.node.decorators = null;
    var name = classPath.scope.generateDeclaredUidIdentifier("class");
    return decorators.map(function (dec) {
      return dec.expression;
    }).reverse().reduce(function (acc, decorator) {
      return buildClassDecorator({
        CLASS_REF: cloneNode(name),
        DECORATOR: cloneNode(decorator),
        INNER: acc
      }).expression;
    }, classPath.node);
  }

  function hasClassDecorators(classNode) {
    return !!(classNode.decorators && classNode.decorators.length);
  }

  function applyMethodDecorators(path, state) {
    if (!hasMethodDecorators(path.node.body.body)) return;
    return applyTargetDecorators(path, state, path.node.body.body);
  }

  function hasMethodDecorators(body) {
    return body.some(function (node) {
      return node.decorators && node.decorators.length;
    });
  }

  function applyObjectDecorators(path, state) {
    if (!hasMethodDecorators(path.node.properties)) return;
    return applyTargetDecorators(path, state, path.node.properties);
  }

  function applyTargetDecorators(path, state, decoratedProps) {
    var name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? "class" : "obj");
    var exprs = decoratedProps.reduce(function (acc, node) {
      var decorators = node.decorators || [];
      node.decorators = null;
      if (decorators.length === 0) return acc;

      if (node.computed) {
        throw path.buildCodeFrameError("Computed method/property decorators are not yet supported.");
      }

      var property = isLiteral(node.key) ? node.key : StringLiteral(node.key.name);
      var target = path.isClass() && !node["static"] ? buildClassPrototype({
        CLASS_REF: name
      }).expression : name;

      if (isClassProperty(node, {
        "static": false
      })) {
        var descriptor = path.scope.generateDeclaredUidIdentifier("descriptor");
        var initializer = node.value ? FunctionExpression(null, [], BlockStatement([ReturnStatement(node.value)])) : NullLiteral();
        node.value = CallExpression(state.addHelper("initializerWarningHelper"), [descriptor, ThisExpression()]);
        WARNING_CALLS.add(node.value);
        acc = acc.concat([AssignmentExpression("=", descriptor, CallExpression(state.addHelper("applyDecoratedDescriptor"), [cloneNode(target), cloneNode(property), ArrayExpression(decorators.map(function (dec) {
          return cloneNode(dec.expression);
        })), ObjectExpression([ObjectProperty(Identifier("configurable"), BooleanLiteral(true)), ObjectProperty(Identifier("enumerable"), BooleanLiteral(true)), ObjectProperty(Identifier("writable"), BooleanLiteral(true)), ObjectProperty(Identifier("initializer"), initializer)])]))]);
      } else {
        acc = acc.concat(CallExpression(state.addHelper("applyDecoratedDescriptor"), [cloneNode(target), cloneNode(property), ArrayExpression(decorators.map(function (dec) {
          return cloneNode(dec.expression);
        })), isObjectProperty(node) || isClassProperty(node, {
          "static": true
        }) ? buildGetObjectInitializer({
          TEMP: path.scope.generateDeclaredUidIdentifier("init"),
          TARGET: cloneNode(target),
          PROPERTY: cloneNode(property)
        }).expression : buildGetDescriptor({
          TARGET: cloneNode(target),
          PROPERTY: cloneNode(property)
        }).expression, cloneNode(target)]));
      }

      return acc;
    }, []);
    return SequenceExpression([AssignmentExpression("=", cloneNode(name), path.node), SequenceExpression(exprs), cloneNode(name)]);
  }

  function decoratedClassToExpression(_ref) {
    var node = _ref.node,
        scope = _ref.scope;

    if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {
      return;
    }

    var ref = node.id ? cloneNode(node.id) : scope.generateUidIdentifier("class");
    return VariableDeclaration("let", [VariableDeclarator(ref, toExpression(node))]);
  }

  var legacyVisitor = {
    ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
      var decl = path.get("declaration");
      if (!decl.isClassDeclaration()) return;
      var replacement = decoratedClassToExpression(decl);

      if (replacement) {
        var _path$replaceWithMult = path.replaceWithMultiple([replacement, ExportNamedDeclaration(null, [ExportSpecifier(cloneNode(replacement.declarations[0].id), Identifier("default"))])]),
            varDeclPath = _path$replaceWithMult[0];

        if (!decl.node.id) {
          path.scope.registerDeclaration(varDeclPath);
        }
      }
    },
    ClassDeclaration: function ClassDeclaration(path) {
      var replacement = decoratedClassToExpression(path);

      if (replacement) {
        path.replaceWith(replacement);
      }
    },
    ClassExpression: function ClassExpression(path, state) {
      var decoratedClass = applyEnsureOrdering(path) || applyClassDecorators(path) || applyMethodDecorators(path, state);
      if (decoratedClass) path.replaceWith(decoratedClass);
    },
    ObjectExpression: function ObjectExpression(path, state) {
      var decoratedObject = applyEnsureOrdering(path) || applyObjectDecorators(path, state);
      if (decoratedObject) path.replaceWith(decoratedObject);
    },
    AssignmentExpression: function AssignmentExpression(path, state) {
      if (!WARNING_CALLS.has(path.node.right)) return;
      path.replaceWith(CallExpression(state.addHelper("initializerDefineProperty"), [cloneNode(path.get("left.object").node), StringLiteral(path.get("left.property").node.name || path.get("left.property").node.value), cloneNode(path.get("right.arguments")[0].node), cloneNode(path.get("right.arguments")[1].node)]));
    },
    CallExpression: function CallExpression$1(path, state) {
      if (path.node.arguments.length !== 3) return;
      if (!WARNING_CALLS.has(path.node.arguments[2])) return;

      if (path.node.callee.name !== state.addHelper("defineProperty").name) {
        return;
      }

      path.replaceWith(CallExpression(state.addHelper("initializerDefineProperty"), [cloneNode(path.get("arguments")[0].node), cloneNode(path.get("arguments")[1].node), cloneNode(path.get("arguments.2.arguments")[0].node), cloneNode(path.get("arguments.2.arguments")[1].node)]));
    }
  };

  var proposalDecorators = declare(function (api, options) {
    api.assertVersion(7);
    var _options$legacy = options.legacy,
        legacy = _options$legacy === void 0 ? false : _options$legacy;

    if (typeof legacy !== "boolean") {
      throw new Error("'legacy' must be a boolean.");
    }

    var decoratorsBeforeExport = options.decoratorsBeforeExport;

    if (decoratorsBeforeExport === undefined) {
      if (!legacy) {
        throw new Error("The decorators plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you want to use the legacy" + " decorators semantics, you can set the 'legacy: true' option.");
      }
    } else {
      if (legacy) {
        throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");
      }

      if (typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }

    if (legacy) {
      return {
        name: "proposal-decorators",
        inherits: syntaxDecorators,
        manipulateOptions: function manipulateOptions(_ref) {
          var generatorOpts = _ref.generatorOpts;
          generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
        },
        visitor: legacyVisitor
      };
    }

    return createClassFeaturePlugin({
      name: "proposal-decorators",
      feature: FEATURES.decorators,
      manipulateOptions: function manipulateOptions(_ref2) {
        var generatorOpts = _ref2.generatorOpts,
            parserOpts = _ref2.parserOpts;
        parserOpts.plugins.push(["decorators", {
          decoratorsBeforeExport: decoratorsBeforeExport
        }]);
        generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
      }
    });
  });

  var proposalDoExpressions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-do-expressions",
      inherits: syntaxDoExpressions,
      visitor: {
        DoExpression: {
          exit: function exit(path) {
            var body = path.node.body.body;

            if (body.length) {
              path.replaceExpressionWithStatements(body);
            } else {
              path.replaceWith(path.scope.buildUndefinedNode());
            }
          }
        }
      }
    };
  });

  var lib$6 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-dynamic-import",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("dynamicImport");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxDynamicImport$1 = unwrapExports(lib$6);

  var version$4 = "7.8.3";

  var SUPPORTED_MODULES = ["commonjs", "amd", "systemjs"];
  var MODULES_NOT_FOUND = "@babel/plugin-proposal-dynamic-import depends on a modules\ntransform plugin. Supported plugins are:\n - @babel/plugin-transform-modules-commonjs ^7.4.0\n - @babel/plugin-transform-modules-amd ^7.4.0\n - @babel/plugin-transform-modules-systemjs ^7.4.0\n\nIf you are using Webpack or Rollup and thus don't want\nBabel to transpile your imports and exports, you can use\nthe @babel/plugin-syntax-dynamic-import plugin and let your\nbundler handle dynamic imports.\n";
  var proposalDynamicImport = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-dynamic-import",
      inherits: syntaxDynamicImport$1,
      pre: function pre() {
        this.file.set("@babel/plugin-proposal-dynamic-import", version$4);
      },
      visitor: {
        Program: function Program() {
          var modules = this.file.get("@babel/plugin-transform-modules-*");

          if (!SUPPORTED_MODULES.includes(modules)) {
            throw new Error(MODULES_NOT_FOUND);
          }
        }
      }
    };
  });

  var proposalExportDefaultFrom = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-export-default-from",
      inherits: syntaxExportDefaultFrom,
      visitor: {
        ExportNamedDeclaration: function ExportNamedDeclaration$1(path) {
          var node = path.node,
              scope = path.scope;
          var specifiers = node.specifiers;
          if (!isExportDefaultSpecifier(specifiers[0])) return;
          var specifier = specifiers.shift();
          var exported = specifier.exported;
          var uid = scope.generateUidIdentifier(exported.name);
          var nodes = [ImportDeclaration([ImportDefaultSpecifier(uid)], cloneNode(node.source)), ExportNamedDeclaration(null, [ExportSpecifier(cloneNode(uid), exported)])];

          if (specifiers.length >= 1) {
            nodes.push(node);
          }

          var _path$replaceWithMult = path.replaceWithMultiple(nodes),
              importDeclaration = _path$replaceWithMult[0];

          path.scope.registerDeclaration(importDeclaration);
        }
      }
    };
  });

  var lib$7 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-export-namespace-from",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("exportNamespaceFrom");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxExportNamespaceFrom$1 = unwrapExports(lib$7);

  var proposalExportNamespaceFrom = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-export-namespace-from",
      inherits: syntaxExportNamespaceFrom$1,
      visitor: {
        ExportNamedDeclaration: function ExportNamedDeclaration$1(path) {
          var node = path.node,
              scope = path.scope;
          var specifiers = node.specifiers;
          var index = isExportDefaultSpecifier(specifiers[0]) ? 1 : 0;
          if (!isExportNamespaceSpecifier(specifiers[index])) return;
          var nodes = [];

          if (index === 1) {
            nodes.push(ExportNamedDeclaration(null, [specifiers.shift()], node.source));
          }

          var specifier = specifiers.shift();
          var exported = specifier.exported;
          var uid = scope.generateUidIdentifier(exported.name);
          nodes.push(ImportDeclaration([ImportNamespaceSpecifier(uid)], cloneNode(node.source)), ExportNamedDeclaration(null, [ExportSpecifier(cloneNode(uid), exported)]));

          if (node.specifiers.length >= 1) {
            nodes.push(node);
          }

          var _path$replaceWithMult = path.replaceWithMultiple(nodes),
              importDeclaration = _path$replaceWithMult[0];

          path.scope.registerDeclaration(importDeclaration);
        }
      }
    };
  });

  var proposalFunctionBind = declare(function (api) {
    api.assertVersion(7);

    function getTempId(scope) {
      var id = scope.path.getData("functionBind");
      if (id) return id;
      id = scope.generateDeclaredUidIdentifier("context");
      return scope.path.setData("functionBind", id);
    }

    function getStaticContext(bind, scope) {
      var object = bind.object || bind.callee.object;
      return scope.isStatic(object) && object;
    }

    function inferBindContext(bind, scope) {
      var staticContext = getStaticContext(bind, scope);
      if (staticContext) return cloneNode(staticContext);
      var tempId = getTempId(scope);

      if (bind.object) {
        bind.callee = SequenceExpression([AssignmentExpression("=", tempId, bind.object), bind.callee]);
      } else {
        bind.callee.object = AssignmentExpression("=", tempId, bind.callee.object);
      }

      return tempId;
    }

    return {
      name: "proposal-function-bind",
      inherits: syntaxFunctionBind,
      visitor: {
        CallExpression: function CallExpression(_ref) {
          var node = _ref.node,
              scope = _ref.scope;
          var bind = node.callee;
          if (!isBindExpression(bind)) return;
          var context = inferBindContext(bind, scope);
          node.callee = MemberExpression(bind.callee, Identifier("call"));
          node.arguments.unshift(context);
        },
        BindExpression: function BindExpression(path) {
          var node = path.node,
              scope = path.scope;
          var context = inferBindContext(node, scope);
          path.replaceWith(CallExpression(MemberExpression(node.callee, Identifier("bind")), [context]));
        }
      }
    };
  });

  var proposalFunctionSent = declare(function (api) {
    api.assertVersion(7);

    var isFunctionSent = function isFunctionSent(node) {
      return isIdentifier(node.meta, {
        name: "function"
      }) && isIdentifier(node.property, {
        name: "sent"
      });
    };

    var hasBeenReplaced = function hasBeenReplaced(node, sentId) {
      return isAssignmentExpression(node) && isIdentifier(node.left, {
        name: sentId
      });
    };

    var yieldVisitor = {
      Function: function Function(path) {
        path.skip();
      },
      YieldExpression: function YieldExpression(path) {
        if (!hasBeenReplaced(path.parent, this.sentId)) {
          path.replaceWith(AssignmentExpression("=", Identifier(this.sentId), path.node));
        }
      },
      MetaProperty: function MetaProperty(path) {
        if (isFunctionSent(path.node)) {
          path.replaceWith(Identifier(this.sentId));
        }
      }
    };
    return {
      name: "proposal-function-sent",
      inherits: syntaxFunctionSent,
      visitor: {
        MetaProperty: function MetaProperty(path, state) {
          if (!isFunctionSent(path.node)) return;
          var fnPath = path.getFunctionParent();

          if (!fnPath.node.generator) {
            throw new Error("Parent generator function not found");
          }

          var sentId = path.scope.generateUid("function.sent");
          fnPath.traverse(yieldVisitor, {
            sentId: sentId
          });
          fnPath.node.body.body.unshift(VariableDeclaration("let", [VariableDeclarator(Identifier(sentId), YieldExpression())]));
          wrapFunction(fnPath, state.addHelper("skipFirstGeneratorNext"));
        }
      }
    };
  });

  var lib$8 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-json-strings",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("jsonStrings");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxJsonStrings = unwrapExports(lib$8);

  var proposalJsonStrings = declare(function (api) {
    api.assertVersion(7);
    var regex = /(\\*)([\u2028\u2029])/g;

    function replace(match, escapes, separator) {
      var isEscaped = escapes.length % 2 === 1;
      if (isEscaped) return match;
      return escapes + "\\u" + separator.charCodeAt(0).toString(16);
    }

    return {
      name: "proposal-json-strings",
      inherits: syntaxJsonStrings,
      visitor: {
        "DirectiveLiteral|StringLiteral": function DirectiveLiteralStringLiteral(_ref) {
          var node = _ref.node;
          var extra = node.extra;
          if (!extra || !extra.raw) return;
          extra.raw = extra.raw.replace(regex, replace);
        }
      }
    };
  });

  var syntaxLogicalAssignmentOperators = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-logical-assignment-operators",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("logicalAssignment");
      }
    };
  });

  var proposalLogicalAssignmentOperators = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-logical-assignment-operators",
      inherits: syntaxLogicalAssignmentOperators,
      visitor: {
        AssignmentExpression: function AssignmentExpression$1(path) {
          var node = path.node,
              scope = path.scope;
          var operator = node.operator,
              left = node.left,
              right = node.right;

          if (operator !== "||=" && operator !== "&&=" && operator !== "??=") {
            return;
          }

          var lhs = cloneNode(left);

          if (isMemberExpression(left)) {
            var object = left.object,
                property = left.property,
                computed = left.computed;
            var memo = scope.maybeGenerateMemoised(object);

            if (memo) {
              left.object = memo;
              lhs.object = AssignmentExpression("=", cloneNode(memo), object);
            }

            if (computed) {
              var _memo = scope.maybeGenerateMemoised(property);

              if (_memo) {
                left.property = _memo;
                lhs.property = AssignmentExpression("=", cloneNode(_memo), property);
              }
            }
          }

          path.replaceWith(LogicalExpression(operator.slice(0, -1), lhs, AssignmentExpression("=", left, right)));
        }
      }
    };
  });

  var lib$9 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-nullish-coalescing-operator",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("nullishCoalescingOperator");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxNullishCoalescingOperator = unwrapExports(lib$9);

  var proposalNullishCoalescingOperator = declare(function (api, _ref) {
    var _ref$loose = _ref.loose,
        loose = _ref$loose === void 0 ? false : _ref$loose;
    api.assertVersion(7);
    return {
      name: "proposal-nullish-coalescing-operator",
      inherits: syntaxNullishCoalescingOperator,
      visitor: {
        LogicalExpression: function LogicalExpression$1(path) {
          var node = path.node,
              scope = path.scope;

          if (node.operator !== "??") {
            return;
          }

          var ref = scope.maybeGenerateMemoised(node.left);
          var assignment;

          if (ref === null) {
            ref = node.left;
            assignment = cloneNode(node.left);
          } else {
            assignment = AssignmentExpression("=", ref, node.left);
          }

          path.replaceWith(ConditionalExpression(loose ? BinaryExpression("!=", assignment, NullLiteral()) : LogicalExpression("&&", BinaryExpression("!==", assignment, NullLiteral()), BinaryExpression("!==", cloneNode(ref), scope.buildUndefinedNode())), cloneNode(ref), node.right));
        }
      }
    };
  });

  var syntaxNumericSeparator = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-numeric-separator",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("numericSeparator");
      }
    };
  });

  var proposalNumericSeparator = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-numeric-separator",
      inherits: syntaxNumericSeparator,
      visitor: {
        NumericLiteral: function NumericLiteral(_ref) {
          var node = _ref.node;
          var extra = node.extra;

          if (extra && /_/.test(extra.raw)) {
            extra.raw = extra.raw.replace(/_/g, "");
          }
        }
      }
    };
  });

  var lib$a = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-object-rest-spread",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("objectRestSpread");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxObjectRestSpread$1 = unwrapExports(lib$a);

  var ZERO_REFS = function () {
    var node = Identifier("a");
    var property = ObjectProperty(Identifier("key"), node);
    var pattern = ObjectPattern([property]);
    return isReferenced(node, property, pattern) ? 1 : 0;
  }();

  var proposalObjectRestSpread = declare(function (api, opts) {
    api.assertVersion(7);
    var _opts$useBuiltIns = opts.useBuiltIns,
        useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
        _opts$loose = opts.loose,
        loose = _opts$loose === void 0 ? false : _opts$loose;

    if (typeof loose !== "boolean") {
      throw new Error(".loose must be a boolean, or undefined");
    }

    function getExtendsHelper(file) {
      return useBuiltIns ? MemberExpression(Identifier("Object"), Identifier("assign")) : file.addHelper("extends");
    }

    function hasRestElement(path) {
      var foundRestElement = false;
      visitRestElements(path, function (restElement) {
        foundRestElement = true;
        restElement.stop();
      });
      return foundRestElement;
    }

    function hasObjectPatternRestElement(path) {
      var foundRestElement = false;
      visitRestElements(path, function (restElement) {
        if (restElement.parentPath.isObjectPattern()) {
          foundRestElement = true;
          restElement.stop();
        }
      });
      return foundRestElement;
    }

    function visitRestElements(path, visitor) {
      path.traverse({
        Expression: function Expression(path) {
          var parentType = path.parent.type;

          if (parentType === "AssignmentPattern" && path.key === "right" || parentType === "ObjectProperty" && path.parent.computed && path.key === "key") {
            path.skip();
          }
        },
        RestElement: visitor
      });
    }

    function hasSpread(node) {
      for (var _iterator = node.properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var prop = _ref;

        if (isSpreadElement(prop)) {
          return true;
        }
      }

      return false;
    }

    function extractNormalizedKeys(path) {
      var props = path.node.properties;
      var keys = [];
      var allLiteral = true;

      for (var _iterator2 = props, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var prop = _ref2;

        if (isIdentifier(prop.key) && !prop.computed) {
          keys.push(StringLiteral(prop.key.name));
        } else if (isTemplateLiteral(prop.key)) {
          keys.push(cloneNode(prop.key));
        } else if (isLiteral(prop.key)) {
          keys.push(StringLiteral(String(prop.key.value)));
        } else {
          keys.push(cloneNode(prop.key));
          allLiteral = false;
        }
      }

      return {
        keys: keys,
        allLiteral: allLiteral
      };
    }

    function replaceImpureComputedKeys(properties, scope) {
      var impureComputedPropertyDeclarators = [];

      for (var _iterator3 = properties, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var propPath = _ref3;
        var key = propPath.get("key");

        if (propPath.node.computed && !key.isPure()) {
          var name = scope.generateUidBasedOnNode(key.node);
          var declarator = VariableDeclarator(Identifier(name), key.node);
          impureComputedPropertyDeclarators.push(declarator);
          key.replaceWith(Identifier(name));
        }
      }

      return impureComputedPropertyDeclarators;
    }

    function removeUnusedExcludedKeys(path) {
      var bindings = path.getOuterBindingIdentifierPaths();
      Object.keys(bindings).forEach(function (bindingName) {
        var bindingParentPath = bindings[bindingName].parentPath;

        if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {
          return;
        }

        bindingParentPath.remove();
      });
    }

    function createObjectSpread(path, file, objRef) {
      var props = path.get("properties");
      var last = props[props.length - 1];
      assertRestElement(last.node);
      var restElement = cloneNode(last.node);
      last.remove();
      var impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get("properties"), path.scope);

      var _extractNormalizedKey = extractNormalizedKeys(path),
          keys = _extractNormalizedKey.keys,
          allLiteral = _extractNormalizedKey.allLiteral;

      if (keys.length === 0) {
        return [impureComputedPropertyDeclarators, restElement.argument, CallExpression(getExtendsHelper(file), [ObjectExpression([]), cloneNode(objRef)])];
      }

      var keyExpression;

      if (!allLiteral) {
        keyExpression = CallExpression(MemberExpression(ArrayExpression(keys), Identifier("map")), [file.addHelper("toPropertyKey")]);
      } else {
        keyExpression = ArrayExpression(keys);
      }

      return [impureComputedPropertyDeclarators, restElement.argument, CallExpression(file.addHelper("objectWithoutProperties" + (loose ? "Loose" : "")), [cloneNode(objRef), keyExpression])];
    }

    function replaceRestElement(parentPath, paramPath) {
      if (paramPath.isAssignmentPattern()) {
        replaceRestElement(parentPath, paramPath.get("left"));
        return;
      }

      if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
        var elements = paramPath.get("elements");

        for (var i = 0; i < elements.length; i++) {
          replaceRestElement(parentPath, elements[i]);
        }
      }

      if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
        var uid = parentPath.scope.generateUidIdentifier("ref");
        var declar = VariableDeclaration("let", [VariableDeclarator(paramPath.node, uid)]);
        parentPath.ensureBlock();
        parentPath.get("body").unshiftContainer("body", declar);
        paramPath.replaceWith(cloneNode(uid));
      }
    }

    return {
      name: "proposal-object-rest-spread",
      inherits: syntaxObjectRestSpread$1,
      visitor: {
        Function: function Function(path) {
          var params = path.get("params");

          for (var i = params.length - 1; i >= 0; i--) {
            replaceRestElement(params[i].parentPath, params[i]);
          }
        },
        VariableDeclarator: function VariableDeclarator$1(path, file) {
          if (!path.get("id").isObjectPattern()) {
            return;
          }

          var insertionPath = path;
          var originalPath = path;
          visitRestElements(path.get("id"), function (path) {
            if (!path.parentPath.isObjectPattern()) {
              return;
            }

            if (originalPath.node.id.properties.length > 1 && !isIdentifier(originalPath.node.init)) {
              var initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
              originalPath.insertBefore(VariableDeclarator(initRef, originalPath.node.init));
              originalPath.replaceWith(VariableDeclarator(originalPath.node.id, cloneNode(initRef)));
              return;
            }

            var ref = originalPath.node.init;
            var refPropertyPath = [];
            var kind;
            path.findParent(function (path) {
              if (path.isObjectProperty()) {
                refPropertyPath.unshift(path);
              } else if (path.isVariableDeclarator()) {
                kind = path.parentPath.node.kind;
                return true;
              }
            });
            var impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);
            refPropertyPath.forEach(function (prop) {
              var node = prop.node;
              ref = MemberExpression(ref, cloneNode(node.key), node.computed);
            });
            var objectPatternPath = path.findParent(function (path) {
              return path.isObjectPattern();
            });

            var _createObjectSpread = createObjectSpread(objectPatternPath, file, ref),
                impureComputedPropertyDeclarators = _createObjectSpread[0],
                argument = _createObjectSpread[1],
                callExpression = _createObjectSpread[2];

            if (loose) {
              removeUnusedExcludedKeys(objectPatternPath);
            }

            assertIdentifier(argument);
            insertionPath.insertBefore(impureComputedPropertyDeclarators);
            insertionPath.insertBefore(impureObjRefComputedDeclarators);
            insertionPath.insertAfter(VariableDeclarator(argument, callExpression));
            insertionPath = insertionPath.getSibling(insertionPath.key + 1);
            path.scope.registerBinding(kind, insertionPath);

            if (objectPatternPath.node.properties.length === 0) {
              objectPatternPath.findParent(function (path) {
                return path.isObjectProperty() || path.isVariableDeclarator();
              }).remove();
            }
          });
        },
        ExportNamedDeclaration: function ExportNamedDeclaration$1(path) {
          var declaration = path.get("declaration");
          if (!declaration.isVariableDeclaration()) return;
          var hasRest = declaration.get("declarations").some(function (path) {
            return hasObjectPatternRestElement(path.get("id"));
          });
          if (!hasRest) return;
          var specifiers = [];

          for (var _i4 = 0, _Object$keys = Object.keys(path.getOuterBindingIdentifiers(path)); _i4 < _Object$keys.length; _i4++) {
            var name = _Object$keys[_i4];
            specifiers.push(ExportSpecifier(Identifier(name), Identifier(name)));
          }

          path.replaceWith(declaration.node);
          path.insertAfter(ExportNamedDeclaration(null, specifiers));
        },
        CatchClause: function CatchClause(path) {
          var paramPath = path.get("param");
          replaceRestElement(paramPath.parentPath, paramPath);
        },
        AssignmentExpression: function AssignmentExpression$1(path, file) {
          var leftPath = path.get("left");

          if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
            var nodes = [];
            var refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
            nodes.push(VariableDeclaration("var", [VariableDeclarator(Identifier(refName), path.node.right)]));

            var _createObjectSpread2 = createObjectSpread(leftPath, file, Identifier(refName)),
                impureComputedPropertyDeclarators = _createObjectSpread2[0],
                argument = _createObjectSpread2[1],
                callExpression = _createObjectSpread2[2];

            if (impureComputedPropertyDeclarators.length > 0) {
              nodes.push(VariableDeclaration("var", impureComputedPropertyDeclarators));
            }

            var nodeWithoutSpread = cloneNode(path.node);
            nodeWithoutSpread.right = Identifier(refName);
            nodes.push(ExpressionStatement(nodeWithoutSpread));
            nodes.push(toStatement(AssignmentExpression("=", argument, callExpression)));
            nodes.push(ExpressionStatement(Identifier(refName)));
            path.replaceWithMultiple(nodes);
          }
        },
        ForXStatement: function ForXStatement(path) {
          var node = path.node,
              scope = path.scope;
          var leftPath = path.get("left");
          var left = node.left;

          if (!hasObjectPatternRestElement(leftPath)) {
            return;
          }

          if (!isVariableDeclaration(left)) {
            var temp = scope.generateUidIdentifier("ref");
            node.left = VariableDeclaration("var", [VariableDeclarator(temp)]);
            path.ensureBlock();

            if (node.body.body.length === 0 && path.isCompletionRecord()) {
              node.body.body.unshift(ExpressionStatement(scope.buildUndefinedNode()));
            }

            node.body.body.unshift(ExpressionStatement(AssignmentExpression("=", left, cloneNode(temp))));
          } else {
            var pattern = left.declarations[0].id;
            var key = scope.generateUidIdentifier("ref");
            node.left = VariableDeclaration(left.kind, [VariableDeclarator(key, null)]);
            path.ensureBlock();
            node.body.body.unshift(VariableDeclaration(node.left.kind, [VariableDeclarator(pattern, cloneNode(key))]));
          }
        },
        ArrayPattern: function ArrayPattern(path) {
          var objectPatterns = [];
          visitRestElements(path, function (path) {
            if (!path.parentPath.isObjectPattern()) {
              return;
            }

            var objectPattern = path.parentPath;
            var uid = path.scope.generateUidIdentifier("ref");
            objectPatterns.push(VariableDeclarator(objectPattern.node, uid));
            objectPattern.replaceWith(cloneNode(uid));
            path.skip();
          });

          if (objectPatterns.length > 0) {
            var statementPath = path.getStatementParent();
            statementPath.insertAfter(VariableDeclaration(statementPath.node.kind || "var", objectPatterns));
          }
        },
        ObjectExpression: function ObjectExpression$1(path, file) {
          if (!hasSpread(path.node)) return;
          var args = [];
          var props = [];

          function push() {
            args.push(ObjectExpression(props));
            props = [];
          }

          for (var _i5 = 0, _arr = path.node.properties; _i5 < _arr.length; _i5++) {
            var prop = _arr[_i5];

            if (isSpreadElement(prop)) {
              push();
              args.push(prop.argument);
            } else {
              props.push(prop);
            }
          }

          if (props.length) {
            push();
          }

          var helper;

          if (loose) {
            helper = getExtendsHelper(file);
          } else {
            try {
              helper = file.addHelper("objectSpread2");
            } catch (_unused) {
              this.file.declarations["objectSpread2"] = null;
              helper = file.addHelper("objectSpread");
            }
          }

          path.replaceWith(CallExpression(helper, args));
        }
      }
    };
  });

  var lib$b = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-optional-catch-binding",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("optionalCatchBinding");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxOptionalCatchBinding$1 = unwrapExports(lib$b);

  var proposalOptionalCatchBinding = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-optional-catch-binding",
      inherits: syntaxOptionalCatchBinding$1,
      visitor: {
        CatchClause: function CatchClause(path) {
          if (!path.node.param) {
            var uid = path.scope.generateUidIdentifier("unused");
            var paramPath = path.get("param");
            paramPath.replaceWith(uid);
          }
        }
      }
    };
  });

  var lib$c = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-optional-chaining",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("optionalChaining");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxOptionalChaining = unwrapExports(lib$c);

  var proposalOptionalChaining = declare(function (api, options) {
    api.assertVersion(7);
    var _options$loose = options.loose,
        loose = _options$loose === void 0 ? false : _options$loose;

    function isSimpleMemberExpression(expression) {
      return isIdentifier(expression) || isSuper(expression) || isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
    }

    return {
      name: "proposal-optional-chaining",
      inherits: syntaxOptionalChaining,
      visitor: {
        "OptionalCallExpression|OptionalMemberExpression": function OptionalCallExpressionOptionalMemberExpression(path) {
          var parentPath = path.parentPath,
              scope = path.scope;
          var isDeleteOperation = false;
          var optionals = [];
          var optionalPath = path;

          while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
            var _optionalPath = optionalPath,
                node = _optionalPath.node;

            if (node.optional) {
              optionals.push(node);
            }

            if (optionalPath.isOptionalMemberExpression()) {
              optionalPath.node.type = "MemberExpression";
              optionalPath = optionalPath.get("object");
            } else if (optionalPath.isOptionalCallExpression()) {
              optionalPath.node.type = "CallExpression";
              optionalPath = optionalPath.get("callee");
            }
          }

          var replacementPath = path;

          if (parentPath.isUnaryExpression({
            operator: "delete"
          })) {
            replacementPath = parentPath;
            isDeleteOperation = true;
          }

          for (var i = optionals.length - 1; i >= 0; i--) {
            var _node = optionals[i];
            var isCall = isCallExpression(_node);
            var replaceKey = isCall ? "callee" : "object";
            var chain = _node[replaceKey];
            var ref = void 0;
            var check = void 0;

            if (loose && isCall && isSimpleMemberExpression(chain)) {
              check = ref = chain;
            } else {
              ref = scope.maybeGenerateMemoised(chain);

              if (ref) {
                check = AssignmentExpression("=", cloneNode(ref), chain);
                _node[replaceKey] = ref;
              } else {
                check = ref = chain;
              }
            }

            if (isCall && isMemberExpression(chain)) {
              if (loose && isSimpleMemberExpression(chain)) {
                _node.callee = chain;
              } else {
                var object = chain.object;
                var context = scope.maybeGenerateMemoised(object);

                if (context) {
                  chain.object = AssignmentExpression("=", context, object);
                } else if (isSuper(object)) {
                  context = ThisExpression();
                } else {
                  context = object;
                }

                _node.arguments.unshift(cloneNode(context));

                _node.callee = MemberExpression(_node.callee, Identifier("call"));
              }
            }

            replacementPath.replaceWith(ConditionalExpression(loose ? BinaryExpression("==", cloneNode(check), NullLiteral()) : LogicalExpression("||", BinaryExpression("===", cloneNode(check), NullLiteral()), BinaryExpression("===", cloneNode(ref), scope.buildUndefinedNode())), isDeleteOperation ? BooleanLiteral(true) : scope.buildUndefinedNode(), replacementPath.node));
            replacementPath = replacementPath.get("alternate");
          }
        }
      }
    };
  });

  var buildOptimizedSequenceExpression = function buildOptimizedSequenceExpression(_ref) {
    var assign = _ref.assign,
        call = _ref.call,
        path = _ref.path;
    var placeholderNode = assign.left,
        pipelineLeft = assign.right;
    var calledExpression = call.callee;
    var optimizeArrow = isArrowFunctionExpression(calledExpression) && isExpression(calledExpression.body) && !calledExpression.async && !calledExpression.generator;
    var param;

    if (optimizeArrow) {
      var params = calledExpression.params;

      if (params.length === 1 && isIdentifier(params[0])) {
        param = params[0];
      } else if (params.length > 0) {
        optimizeArrow = false;
      }
    } else if (isIdentifier(calledExpression, {
      name: "eval"
    })) {
      var evalSequence = SequenceExpression([NumericLiteral(0), calledExpression]);
      call.callee = evalSequence;
      path.scope.push({
        id: placeholderNode
      });
      return SequenceExpression([assign, call]);
    }

    if (optimizeArrow && !param) {
      return SequenceExpression([pipelineLeft, calledExpression.body]);
    }

    path.scope.push({
      id: placeholderNode
    });

    if (param) {
      path.get("right").scope.rename(param.name, placeholderNode.name);
      return SequenceExpression([assign, calledExpression.body]);
    }

    return SequenceExpression([assign, call]);
  };

  var minimalVisitor = {
    BinaryExpression: function BinaryExpression(path) {
      var scope = path.scope,
          node = path.node;
      var operator = node.operator,
          left = node.left,
          right = node.right;
      if (operator !== "|>") return;
      var placeholder = scope.generateUidIdentifierBasedOnNode(left);
      var call = CallExpression(right, [cloneNode(placeholder)]);
      path.replaceWith(buildOptimizedSequenceExpression({
        assign: AssignmentExpression("=", cloneNode(placeholder), left),
        call: call,
        path: path
      }));
    }
  };

  var updateTopicReferenceVisitor = {
    PipelinePrimaryTopicReference: function PipelinePrimaryTopicReference(path) {
      path.replaceWith(this.topicId);
    },
    PipelineTopicExpression: function PipelineTopicExpression(path) {
      path.skip();
    }
  };
  var smartVisitor = {
    BinaryExpression: function BinaryExpression(path) {
      var scope = path.scope;
      var node = path.node;
      var operator = node.operator,
          left = node.left,
          right = node.right;
      if (operator !== "|>") return;
      var placeholder = scope.generateUidIdentifierBasedOnNode(left);
      scope.push({
        id: placeholder
      });
      var call;

      if (isPipelineTopicExpression(right)) {
        path.get("right").traverse(updateTopicReferenceVisitor, {
          topicId: placeholder
        });
        call = right.expression;
      } else {
        var callee = right.callee;

        if (isIdentifier(callee, {
          name: "eval"
        })) {
          callee = SequenceExpression([NumericLiteral(0), callee]);
        }

        call = CallExpression(callee, [cloneNode(placeholder)]);
      }

      path.replaceWith(SequenceExpression([AssignmentExpression("=", cloneNode(placeholder), left), call]));
    }
  };

  var fsharpVisitor = {
    BinaryExpression: function BinaryExpression(path) {
      var scope = path.scope,
          node = path.node;
      var operator = node.operator,
          left = node.left,
          right = node.right;
      if (operator !== "|>") return;
      var placeholder = scope.generateUidIdentifierBasedOnNode(left);
      var call = right.type === "AwaitExpression" ? AwaitExpression(cloneNode(placeholder)) : CallExpression(right, [cloneNode(placeholder)]);
      var sequence = buildOptimizedSequenceExpression({
        assign: AssignmentExpression("=", cloneNode(placeholder), left),
        call: call,
        path: path
      });
      path.replaceWith(sequence);
    }
  };

  var visitorsPerProposal = {
    minimal: minimalVisitor,
    smart: smartVisitor,
    fsharp: fsharpVisitor
  };
  var proposalPipelineOperator = declare(function (api, options) {
    api.assertVersion(7);
    return {
      name: "proposal-pipeline-operator",
      inherits: syntaxPipelineOperator,
      visitor: visitorsPerProposal[options.proposal]
    };
  });

  var proposalPrivateMethods = declare(function (api, options) {
    api.assertVersion(7);
    return createClassFeaturePlugin({
      name: "proposal-private-methods",
      feature: FEATURES.privateMethods,
      loose: options.loose,
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("classPrivateMethods");
      }
    });
  });

  var syntaxThrowExpressions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-throw-expressions",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("throwExpressions");
      }
    };
  });

  var proposalThrowExpressions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-throw-expressions",
      inherits: syntaxThrowExpressions,
      visitor: {
        UnaryExpression: function UnaryExpression(path) {
          var _path$node = path.node,
              operator = _path$node.operator,
              argument = _path$node.argument;
          if (operator !== "throw") return;
          var arrow = FunctionExpression(null, [Identifier("e")], BlockStatement([ThrowStatement(Identifier("e"))]));
          path.replaceWith(CallExpression(arrow, [argument]));
        }
      }
    };
  });

  var regjsgen = createCommonjsModule(function (module, exports) {
  (function () {

    var objectTypes = {
      'function': true,
      'object': true
    };
    var root = objectTypes[typeof window] && window || this;
    var freeExports = objectTypes['object'] && exports && !exports.nodeType && exports;
    var hasFreeModule = objectTypes['object'] && module && !module.nodeType;
    var freeGlobal = freeExports && hasFreeModule && typeof commonjsGlobal == 'object' && commonjsGlobal;

    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
      root = freeGlobal;
    }

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function fromCodePoint() {
      var codePoint = Number(arguments[0]);

      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || Math.floor(codePoint) != codePoint) {
          throw RangeError('Invalid code point: ' + codePoint);
        }

      if (codePoint <= 0xFFFF) {
        return String.fromCharCode(codePoint);
      } else {
        codePoint -= 0x10000;
        var highSurrogate = (codePoint >> 10) + 0xD800;
        var lowSurrogate = codePoint % 0x400 + 0xDC00;
        return String.fromCharCode(highSurrogate, lowSurrogate);
      }
    }

    var assertTypeRegexMap = {};

    function assertType(type, expected) {
      if (expected.indexOf('|') == -1) {
        if (type == expected) {
          return;
        }

        throw Error('Invalid node type: ' + type + '; expected type: ' + expected);
      }

      expected = hasOwnProperty.call(assertTypeRegexMap, expected) ? assertTypeRegexMap[expected] : assertTypeRegexMap[expected] = RegExp('^(?:' + expected + ')$');

      if (expected.test(type)) {
        return;
      }

      throw Error('Invalid node type: ' + type + '; expected types: ' + expected);
    }

    function generate(node) {
      var type = node.type;

      if (hasOwnProperty.call(generators, type)) {
        return generators[type](node);
      }

      throw Error('Invalid node type: ' + type);
    }

    function generateAlternative(node) {
      assertType(node.type, 'alternative');
      var terms = node.body,
          i = -1,
          length = terms.length,
          result = '';

      while (++i < length) {
        result += generateTerm(terms[i]);
      }

      return result;
    }

    function generateAnchor(node) {
      assertType(node.type, 'anchor');

      switch (node.kind) {
        case 'start':
          return '^';

        case 'end':
          return '$';

        case 'boundary':
          return '\\b';

        case 'not-boundary':
          return '\\B';

        default:
          throw Error('Invalid assertion');
      }
    }

    function generateAtom(node) {
      assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');
      return generate(node);
    }

    function generateCharacterClass(node) {
      assertType(node.type, 'characterClass');
      var classRanges = node.body,
          i = -1,
          length = classRanges.length,
          result = '';

      if (node.negative) {
        result += '^';
      }

      while (++i < length) {
        result += generateClassAtom(classRanges[i]);
      }

      return '[' + result + ']';
    }

    function generateCharacterClassEscape(node) {
      assertType(node.type, 'characterClassEscape');
      return '\\' + node.value;
    }

    function generateUnicodePropertyEscape(node) {
      assertType(node.type, 'unicodePropertyEscape');
      return '\\' + (node.negative ? 'P' : 'p') + '{' + node.value + '}';
    }

    function generateCharacterClassRange(node) {
      assertType(node.type, 'characterClassRange');
      var min = node.min,
          max = node.max;

      if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {
        throw Error('Invalid character class range');
      }

      return generateClassAtom(min) + '-' + generateClassAtom(max);
    }

    function generateClassAtom(node) {
      assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');
      return generate(node);
    }

    function generateDisjunction(node) {
      assertType(node.type, 'disjunction');
      var body = node.body,
          i = -1,
          length = body.length,
          result = '';

      while (++i < length) {
        if (i != 0) {
          result += '|';
        }

        result += generate(body[i]);
      }

      return result;
    }

    function generateDot(node) {
      assertType(node.type, 'dot');
      return '.';
    }

    function generateGroup(node) {
      assertType(node.type, 'group');
      var result = '';

      switch (node.behavior) {
        case 'normal':
          if (node.name) {
            result += '?<' + generateIdentifier(node.name) + '>';
          }

          break;

        case 'ignore':
          result += '?:';
          break;

        case 'lookahead':
          result += '?=';
          break;

        case 'negativeLookahead':
          result += '?!';
          break;

        case 'lookbehind':
          result += '?<=';
          break;

        case 'negativeLookbehind':
          result += '?<!';
          break;

        default:
          throw Error('Invalid behaviour: ' + node.behaviour);
      }

      var body = node.body,
          i = -1,
          length = body.length;

      while (++i < length) {
        result += generate(body[i]);
      }

      return '(' + result + ')';
    }

    function generateIdentifier(node) {
      assertType(node.type, 'identifier');
      return node.value;
    }

    function generateQuantifier(node) {
      assertType(node.type, 'quantifier');
      var quantifier = '',
          min = node.min,
          max = node.max;

      if (max == null) {
        if (min == 0) {
          quantifier = '*';
        } else if (min == 1) {
          quantifier = '+';
        } else {
          quantifier = '{' + min + ',}';
        }
      } else if (min == max) {
        quantifier = '{' + min + '}';
      } else if (min == 0 && max == 1) {
        quantifier = '?';
      } else {
        quantifier = '{' + min + ',' + max + '}';
      }

      if (!node.greedy) {
        quantifier += '?';
      }

      return generateAtom(node.body[0]) + quantifier;
    }

    function generateReference(node) {
      assertType(node.type, 'reference');

      if (node.matchIndex) {
        return '\\' + node.matchIndex;
      }

      if (node.name) {
        return '\\k<' + generateIdentifier(node.name) + '>';
      }

      throw new Error('Unknown reference type');
    }

    function generateTerm(node) {
      assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|unicodePropertyEscape|value|dot');
      return generate(node);
    }

    function generateValue(node) {
      assertType(node.type, 'value');
      var kind = node.kind,
          codePoint = node.codePoint;

      if (typeof codePoint != 'number') {
        throw new Error('Invalid code point: ' + codePoint);
      }

      switch (kind) {
        case 'controlLetter':
          return '\\c' + fromCodePoint(codePoint + 64);

        case 'hexadecimalEscape':
          return '\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);

        case 'identifier':
          return '\\' + fromCodePoint(codePoint);

        case 'null':
          return '\\' + codePoint;

        case 'octal':
          return '\\' + codePoint.toString(8);

        case 'singleEscape':
          switch (codePoint) {
            case 0x0008:
              return '\\b';

            case 0x0009:
              return '\\t';

            case 0x000A:
              return '\\n';

            case 0x000B:
              return '\\v';

            case 0x000C:
              return '\\f';

            case 0x000D:
              return '\\r';

            default:
              throw Error('Invalid code point: ' + codePoint);
          }

        case 'symbol':
          return fromCodePoint(codePoint);

        case 'unicodeEscape':
          return "\\u" + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);

        case 'unicodeCodePointEscape':
          return "\\u{" + codePoint.toString(16).toUpperCase() + '}';

        default:
          throw Error('Unsupported node kind: ' + kind);
      }
    }

    var generators = {
      'alternative': generateAlternative,
      'anchor': generateAnchor,
      'characterClass': generateCharacterClass,
      'characterClassEscape': generateCharacterClassEscape,
      'characterClassRange': generateCharacterClassRange,
      'unicodePropertyEscape': generateUnicodePropertyEscape,
      'disjunction': generateDisjunction,
      'dot': generateDot,
      'group': generateGroup,
      'quantifier': generateQuantifier,
      'reference': generateReference,
      'value': generateValue
    };
    var regjsgen = {
      'generate': generate
    };

    if (freeExports && hasFreeModule) {
        freeExports.generate = generate;
      } else {
        root.regjsgen = regjsgen;
      }
  }).call(commonjsGlobal);
  });

  var parser$1 = createCommonjsModule(function (module) {
  (function () {
    var fromCodePoint = String.fromCodePoint || function () {
      var stringFromCharCode = String.fromCharCode;
      var floor = Math.floor;
      return function fromCodePoint() {
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = arguments.length;

        if (!length) {
          return '';
        }

        var result = '';

        while (++index < length) {
          var codePoint = Number(arguments[index]);

          if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
              throw RangeError('Invalid code point: ' + codePoint);
            }

          if (codePoint <= 0xFFFF) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 0x10000;
            highSurrogate = (codePoint >> 10) + 0xD800;
            lowSurrogate = codePoint % 0x400 + 0xDC00;
            codeUnits.push(highSurrogate, lowSurrogate);
          }

          if (index + 1 == length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }

        return result;
      };
    }();

    function parse(str, flags, features) {
      if (!features) {
        features = {};
      }

      function addRaw(node) {
        node.raw = str.substring(node.range[0], node.range[1]);
        return node;
      }

      function updateRawStart(node, start) {
        node.range[0] = start;
        return addRaw(node);
      }

      function createAnchor(kind, rawLength) {
        return addRaw({
          type: 'anchor',
          kind: kind,
          range: [pos - rawLength, pos]
        });
      }

      function createValue(kind, codePoint, from, to) {
        return addRaw({
          type: 'value',
          kind: kind,
          codePoint: codePoint,
          range: [from, to]
        });
      }

      function createEscaped(kind, codePoint, value, fromOffset) {
        fromOffset = fromOffset || 0;
        return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
      }

      function createCharacter(matches) {
        var _char = matches[0];

        var first = _char.charCodeAt(0);

        if (hasUnicodeFlag) {
          var second;

          if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
            second = lookahead().charCodeAt(0);

            if (second >= 0xDC00 && second <= 0xDFFF) {
              pos++;
              return createValue('symbol', (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000, pos - 2, pos);
            }
          }
        }

        return createValue('symbol', first, pos - 1, pos);
      }

      function createDisjunction(alternatives, from, to) {
        return addRaw({
          type: 'disjunction',
          body: alternatives,
          range: [from, to]
        });
      }

      function createDot() {
        return addRaw({
          type: 'dot',
          range: [pos - 1, pos]
        });
      }

      function createCharacterClassEscape(value) {
        return addRaw({
          type: 'characterClassEscape',
          value: value,
          range: [pos - 2, pos]
        });
      }

      function createReference(matchIndex) {
        return addRaw({
          type: 'reference',
          matchIndex: parseInt(matchIndex, 10),
          range: [pos - 1 - matchIndex.length, pos]
        });
      }

      function createNamedReference(name) {
        return addRaw({
          type: 'reference',
          name: name,
          range: [name.range[0] - 3, pos]
        });
      }

      function createGroup(behavior, disjunction, from, to) {
        return addRaw({
          type: 'group',
          behavior: behavior,
          body: disjunction,
          range: [from, to]
        });
      }

      function createAlternative(terms, from, to) {
        return addRaw({
          type: 'alternative',
          body: terms,
          range: [from, to]
        });
      }

      function createCharacterClass(classRanges, negative, from, to) {
        return addRaw({
          type: 'characterClass',
          body: classRanges,
          negative: negative,
          range: [from, to]
        });
      }

      function createClassRange(min, max, from, to) {
        if (min.codePoint > max.codePoint) {
          bail('invalid range in character class', min.raw + '-' + max.raw, from, to);
        }

        return addRaw({
          type: 'characterClassRange',
          min: min,
          max: max,
          range: [from, to]
        });
      }

      function flattenBody(body) {
        if (body.type === 'alternative') {
          return body.body;
        } else {
          return [body];
        }
      }

      function incr(amount) {
        amount = amount || 1;
        var res = str.substring(pos, pos + amount);
        pos += amount || 1;
        return res;
      }

      function skip(value) {
        if (!match(value)) {
          bail('character', value);
        }
      }

      function match(value) {
        if (str.indexOf(value, pos) === pos) {
          return incr(value.length);
        }
      }

      function lookahead() {
        return str[pos];
      }

      function current(value) {
        return str.indexOf(value, pos) === pos;
      }

      function next(value) {
        return str[pos + 1] === value;
      }

      function matchReg(regExp) {
        var subStr = str.substring(pos);
        var res = subStr.match(regExp);

        if (res) {
          res.range = [];
          res.range[0] = pos;
          incr(res[0].length);
          res.range[1] = pos;
        }

        return res;
      }

      function parseDisjunction() {
        var res = [],
            from = pos;
        res.push(parseAlternative());

        while (match('|')) {
          res.push(parseAlternative());
        }

        if (res.length === 1) {
          return res[0];
        }

        return createDisjunction(res, from, pos);
      }

      function parseAlternative() {
        var res = [],
            from = pos;
        var term;

        while (term = parseTerm()) {
          res.push(term);
        }

        if (res.length === 1) {
          return res[0];
        }

        return createAlternative(res, from, pos);
      }

      function parseTerm() {
        if (pos >= str.length || current('|') || current(')')) {
          return null;
        }

        var anchor = parseAnchor();

        if (anchor) {
          return anchor;
        }

        var atom = parseAtomAndExtendedAtom();

        if (!atom) {
          bail('Expected atom');
        }

        return atom;
      }

      function parseGroup(matchA, typeA, matchB, typeB) {
        var type = null,
            from = pos;

        if (match(matchA)) {
          type = typeA;
        } else if (match(matchB)) {
          type = typeB;
        } else {
          return false;
        }

        return finishGroup(type, from);
      }

      function finishGroup(type, from) {
        var body = parseDisjunction();

        if (!body) {
          bail('Expected disjunction');
        }

        skip(')');
        var group = createGroup(type, flattenBody(body), from, pos);

        if (type == 'normal') {
          if (firstIteration) {
            closedCaptureCounter++;
          }
        }

        return group;
      }

      function parseAnchor() {

        if (match('^')) {
          return createAnchor('start', 1);
        } else if (match('$')) {
          return createAnchor('end', 1);
        } else if (match('\\b')) {
          return createAnchor('boundary', 2);
        } else if (match('\\B')) {
          return createAnchor('not-boundary', 2);
        } else {
          return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
        }
      }

      function parseAtomAndExtendedAtom() {
        var res;

        if (res = matchReg(/^[^^$\\.*+?()[\]{}|]/)) {
          return createCharacter(res);
        } else if (!hasUnicodeFlag && (res = matchReg(/^(?:]|})/))) {
          return createCharacter(res);
        } else if (match('.')) {
          return createDot();
        } else if (match('\\')) {
          res = parseAtomEscape();

          if (!res) {
            if (!hasUnicodeFlag && lookahead() == 'c') {
              return createValue('symbol', 92, pos - 1, pos);
            }

            bail('atomEscape');
          }

          return res;
        } else if (res = parseCharacterClass()) {
          return res;
        } else if (features.lookbehind && (res = parseGroup('(?<=', 'lookbehind', '(?<!', 'negativeLookbehind'))) {
          return res;
        } else if (features.namedGroups && match("(?<")) {
          var name = parseIdentifier();
          skip(">");
          var group = finishGroup("normal", name.range[0] - 3);
          group.name = name;
          return group;
        } else {
          return parseGroup('(?:', 'ignore', '(', 'normal');
        }
      }

      function parseUnicodeSurrogatePairEscape(firstEscape) {
        if (hasUnicodeFlag) {
          var first, second;

          if (firstEscape.kind == 'unicodeEscape' && (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF && current('\\') && next('u')) {
            var prevPos = pos;
            pos++;
            var secondEscape = parseClassEscape();

            if (secondEscape.kind == 'unicodeEscape' && (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
              firstEscape.range[1] = secondEscape.range[1];
              firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
              firstEscape.type = 'value';
              firstEscape.kind = 'unicodeCodePointEscape';
              addRaw(firstEscape);
            } else {
              pos = prevPos;
            }
          }
        }

        return firstEscape;
      }

      function parseClassEscape() {
        return parseAtomEscape(true);
      }

      function parseAtomEscape(insideCharacterClass) {
        var res,
            from = pos;
        res = parseDecimalEscape() || parseNamedReference();

        if (res) {
          return res;
        }

        if (insideCharacterClass) {
          if (match('b')) {
            return createEscaped('singleEscape', 0x0008, '\\b');
          } else if (match('B')) {
            bail('\\B not possible inside of CharacterClass', '', from);
          } else if (!hasUnicodeFlag && (res = matchReg(/^c([0-9])/))) {
            return createEscaped('controlLetter', res[1] + 16, res[1], 2);
          }

          if (match('-') && hasUnicodeFlag) {
            return createEscaped('singleEscape', 0x002d, '\\-');
          }
        }

        res = parseCharacterEscape();
        return res;
      }

      function parseDecimalEscape() {
        var res, match;

        if (res = matchReg(/^(?!0)\d+/)) {
          match = res[0];
          var refIdx = parseInt(res[0], 10);

          if (refIdx <= closedCaptureCounter) {
            return createReference(res[0]);
          } else {
            backrefDenied.push(refIdx);
            incr(-res[0].length);

            if (res = matchReg(/^[0-7]{1,3}/)) {
              return createEscaped('octal', parseInt(res[0], 8), res[0], 1);
            } else {
              res = createCharacter(matchReg(/^[89]/));
              return updateRawStart(res, res.range[0] - 1);
            }
          }
        } else if (res = matchReg(/^[0-7]{1,3}/)) {
            match = res[0];

            if (/^0{1,3}$/.test(match)) {
              return createEscaped('null', 0x0000, '0', match.length + 1);
            } else {
              return createEscaped('octal', parseInt(match, 8), match, 1);
            }
          } else if (res = matchReg(/^[dDsSwW]/)) {
            return createCharacterClassEscape(res[0]);
          }

        return false;
      }

      function parseNamedReference() {
        if (features.namedGroups && matchReg(/^k<(?=.*?>)/)) {
          var name = parseIdentifier();
          skip('>');
          return createNamedReference(name);
        }
      }

      function parseRegExpUnicodeEscapeSequence() {
        var res;

        if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
          return parseUnicodeSurrogatePairEscape(createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2));
        } else if (hasUnicodeFlag && (res = matchReg(/^u\{([0-9a-fA-F]+)\}/))) {
          return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);
        }
      }

      function parseCharacterEscape() {
        var res;
        var from = pos;

        if (res = matchReg(/^[fnrtv]/)) {
          var codePoint = 0;

          switch (res[0]) {
            case 't':
              codePoint = 0x009;
              break;

            case 'n':
              codePoint = 0x00A;
              break;

            case 'v':
              codePoint = 0x00B;
              break;

            case 'f':
              codePoint = 0x00C;
              break;

            case 'r':
              codePoint = 0x00D;
              break;
          }

          return createEscaped('singleEscape', codePoint, '\\' + res[0]);
        } else if (res = matchReg(/^c([a-zA-Z])/)) {
          return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);
        } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
          return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);
        } else if (res = parseRegExpUnicodeEscapeSequence()) {
          if (!res || res.codePoint > 0x10FFFF) {
            bail('Invalid escape sequence', null, from, pos);
          }

          return res;
        } else if (features.unicodePropertyEscape && hasUnicodeFlag && (res = matchReg(/^([pP])\{([^\}]+)\}/))) {
          return addRaw({
            type: 'unicodePropertyEscape',
            negative: res[1] === 'P',
            value: res[2],
            range: [res.range[0] - 1, res.range[1]],
            raw: res[0]
          });
        } else {
          return parseIdentityEscape();
        }
      }

      function parseIdentifierAtom(check) {
        var ch = lookahead();
        var from = pos;

        if (ch === '\\') {
          incr();
          var esc = parseRegExpUnicodeEscapeSequence();

          if (!esc || !check(esc.codePoint)) {
            bail('Invalid escape sequence', null, from, pos);
          }

          return fromCodePoint(esc.codePoint);
        }

        var code = ch.charCodeAt(0);

        if (code >= 0xD800 && code <= 0xDBFF) {
          ch += str[pos + 1];
          var second = ch.charCodeAt(1);

          if (second >= 0xDC00 && second <= 0xDFFF) {
            code = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
          }
        }

        if (!check(code)) return;
        incr();
        if (code > 0xFFFF) incr();
        return ch;
      }

      function parseIdentifier() {
        var start = pos;
        var res = parseIdentifierAtom(isIdentifierStart);

        if (!res) {
          bail('Invalid identifier');
        }

        var ch;

        while (ch = parseIdentifierAtom(isIdentifierPart)) {
          res += ch;
        }

        return addRaw({
          type: 'identifier',
          value: res,
          range: [start, pos]
        });
      }

      function isIdentifierStart(ch) {
        var NonAsciiIdentifierStart = /[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7B9\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFF1]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
        return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 0x80 && NonAsciiIdentifierStart.test(fromCodePoint(ch));
      }

      function isIdentifierPart(ch) {
        var NonAsciiIdentifierPartOnly = /[0-9_\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDD30-\uDD39\uDF46-\uDF50]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC66-\uDC6F\uDC7F-\uDC82\uDCB0-\uDCBA\uDCF0-\uDCF9\uDD00-\uDD02\uDD27-\uDD34\uDD36-\uDD3F\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDD0-\uDDD9\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC50-\uDC59\uDC5E\uDCB0-\uDCC3\uDCD0-\uDCD9\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDE50-\uDE59\uDEAB-\uDEB7\uDEC0-\uDEC9\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDC2C-\uDC3A\uDCE0-\uDCE9\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC50-\uDC59\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD50-\uDD59\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDDA0-\uDDA9\uDEF3-\uDEF6]|\uD81A[\uDE60-\uDE69\uDEF0-\uDEF4\uDF30-\uDF36\uDF50-\uDF59]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A\uDD50-\uDD59]|\uDB40[\uDD00-\uDDEF]/;
        return isIdentifierStart(ch) || ch >= 48 && ch <= 57 || ch >= 0x80 && NonAsciiIdentifierPartOnly.test(fromCodePoint(ch));
      }

      function parseIdentityEscape() {
        var tmp;
        var l = lookahead();

        if (hasUnicodeFlag && /[\^\$\.\*\+\?\(\)\\\[\]\{\}\|\/]/.test(l) || !hasUnicodeFlag && l !== "c") {
          if (l === "k" && features.lookbehind) {
            return null;
          }

          tmp = incr();
          return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);
        }

        return null;
      }

      function parseCharacterClass() {
        var res,
            from = pos;

        if (res = matchReg(/^\[\^/)) {
          res = parseClassRanges();
          skip(']');
          return createCharacterClass(res, true, from, pos);
        } else if (match('[')) {
          res = parseClassRanges();
          skip(']');
          return createCharacterClass(res, false, from, pos);
        }

        return null;
      }

      function parseClassRanges() {
        var res;

        if (current(']')) {
          return [];
        } else {
          res = parseNonemptyClassRanges();

          if (!res) {
            bail('nonEmptyClassRanges');
          }

          return res;
        }
      }

      function parseHelperClassRanges(atom) {
        var from, to, res;

        if (current('-') && !next(']')) {
          skip('-');
          res = parseClassAtom();

          if (!res) {
            bail('classAtom');
          }

          to = pos;
          var classRanges = parseClassRanges();

          if (!classRanges) {
            bail('classRanges');
          }

          from = atom.range[0];

          if (classRanges.type === 'empty') {
            return [createClassRange(atom, res, from, to)];
          }

          return [createClassRange(atom, res, from, to)].concat(classRanges);
        }

        res = parseNonemptyClassRangesNoDash();

        if (!res) {
          bail('nonEmptyClassRangesNoDash');
        }

        return [atom].concat(res);
      }

      function parseNonemptyClassRanges() {
        var atom = parseClassAtom();

        if (!atom) {
          bail('classAtom');
        }

        if (current(']')) {
          return [atom];
        }

        return parseHelperClassRanges(atom);
      }

      function parseNonemptyClassRangesNoDash() {
        var res = parseClassAtom();

        if (!res) {
          bail('classAtom');
        }

        if (current(']')) {
          return res;
        }

        return parseHelperClassRanges(res);
      }

      function parseClassAtom() {
        if (match('-')) {
          return createCharacter('-');
        } else {
          return parseClassAtomNoDash();
        }
      }

      function parseClassAtomNoDash() {
        var res;

        if (res = matchReg(/^[^\\\]-]/)) {
          return createCharacter(res[0]);
        } else if (match('\\')) {
          res = parseClassEscape();

          if (!res) {
            bail('classEscape');
          }

          return parseUnicodeSurrogatePairEscape(res);
        }
      }

      function bail(message, details, from, to) {
        from = from == null ? pos : from;
        to = to == null ? from : to;
        var contextStart = Math.max(0, from - 10);
        var contextEnd = Math.min(to + 10, str.length);
        var context = '    ' + str.substring(contextStart, contextEnd);
        var pointer = '    ' + new Array(from - contextStart + 1).join(' ') + '^';
        throw SyntaxError(message + ' at position ' + from + (details ? ': ' + details : '') + '\n' + context + '\n' + pointer);
      }

      var backrefDenied = [];
      var closedCaptureCounter = 0;
      var firstIteration = true;
      var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
      var pos = 0;
      str = String(str);

      if (str === '') {
        str = '(?:)';
      }

      var result = parseDisjunction();

      if (result.range[1] !== str.length) {
        bail('Could not parse entire input - got stuck', '', result.range[1]);
      }

      for (var i = 0; i < backrefDenied.length; i++) {
        if (backrefDenied[i] <= closedCaptureCounter) {
          pos = 0;
          firstIteration = false;
          return parseDisjunction();
        }
      }

      return result;
    }

    var regjsparser = {
      parse: parse
    };

    if ( module.exports) {
      module.exports = regjsparser;
    } else {
      window.regjsparser = regjsparser;
    }
  })();
  });

  var regenerate = createCommonjsModule(function (module, exports) {

  (function (root) {
    var freeExports =  exports;
    var freeModule =  module && module.exports == freeExports && module;
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;

    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
      root = freeGlobal;
    }

    var ERRORS = {
      'rangeOrder': "A range\u2019s `stop` value must be greater than or equal " + 'to the `start` value.',
      'codePointRange': 'Invalid code point value. Code points range from ' + 'U+000000 to U+10FFFF.'
    };
    var HIGH_SURROGATE_MIN = 0xD800;
    var HIGH_SURROGATE_MAX = 0xDBFF;
    var LOW_SURROGATE_MIN = 0xDC00;
    var LOW_SURROGATE_MAX = 0xDFFF;
    var regexNull = /\\x00([^0123456789]|$)/g;
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;

    var extend = function extend(destination, source) {
      var key;

      for (key in source) {
        if (hasOwnProperty.call(source, key)) {
          destination[key] = source[key];
        }
      }

      return destination;
    };

    var forEach = function forEach(array, callback) {
      var index = -1;
      var length = array.length;

      while (++index < length) {
        callback(array[index], index);
      }
    };

    var toString = object.toString;

    var isArray = function isArray(value) {
      return toString.call(value) == '[object Array]';
    };

    var isNumber = function isNumber(value) {
      return typeof value == 'number' || toString.call(value) == '[object Number]';
    };

    var zeroes = '0000';

    var pad = function pad(number, totalCharacters) {
      var string = String(number);
      return string.length < totalCharacters ? (zeroes + string).slice(-totalCharacters) : string;
    };

    var hex = function hex(number) {
      return Number(number).toString(16).toUpperCase();
    };

    var slice = [].slice;

    var dataFromCodePoints = function dataFromCodePoints(codePoints) {
      var index = -1;
      var length = codePoints.length;
      var max = length - 1;
      var result = [];
      var isStart = true;
      var tmp;
      var previous = 0;

      while (++index < length) {
        tmp = codePoints[index];

        if (isStart) {
          result.push(tmp);
          previous = tmp;
          isStart = false;
        } else {
          if (tmp == previous + 1) {
            if (index != max) {
              previous = tmp;
              continue;
            } else {
              isStart = true;
              result.push(tmp + 1);
            }
          } else {
            result.push(previous + 1, tmp);
            previous = tmp;
          }
        }
      }

      if (!isStart) {
        result.push(tmp + 1);
      }

      return result;
    };

    var dataRemove = function dataRemove(data, codePoint) {
      var index = 0;
      var start;
      var end;
      var length = data.length;

      while (index < length) {
        start = data[index];
        end = data[index + 1];

        if (codePoint >= start && codePoint < end) {
          if (codePoint == start) {
            if (end == start + 1) {
              data.splice(index, 2);
              return data;
            } else {
              data[index] = codePoint + 1;
              return data;
            }
          } else if (codePoint == end - 1) {
            data[index + 1] = codePoint;
            return data;
          } else {
            data.splice(index, 2, start, codePoint, codePoint + 1, end);
            return data;
          }
        }

        index += 2;
      }

      return data;
    };

    var dataRemoveRange = function dataRemoveRange(data, rangeStart, rangeEnd) {
      if (rangeEnd < rangeStart) {
        throw Error(ERRORS.rangeOrder);
      }

      var index = 0;
      var start;
      var end;

      while (index < data.length) {
        start = data[index];
        end = data[index + 1] - 1;

        if (start > rangeEnd) {
          return data;
        }

        if (rangeStart <= start && rangeEnd >= end) {
          data.splice(index, 2);
          continue;
        }

        if (rangeStart >= start && rangeEnd < end) {
          if (rangeStart == start) {
            data[index] = rangeEnd + 1;
            data[index + 1] = end + 1;
            return data;
          }

          data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);
          return data;
        }

        if (rangeStart >= start && rangeStart <= end) {
          data[index + 1] = rangeStart;
        } else if (rangeEnd >= start && rangeEnd <= end) {
            data[index] = rangeEnd + 1;
            return data;
          }

        index += 2;
      }

      return data;
    };

    var dataAdd = function dataAdd(data, codePoint) {
      var index = 0;
      var start;
      var end;
      var lastIndex = null;
      var length = data.length;

      if (codePoint < 0x0 || codePoint > 0x10FFFF) {
        throw RangeError(ERRORS.codePointRange);
      }

      while (index < length) {
        start = data[index];
        end = data[index + 1];

        if (codePoint >= start && codePoint < end) {
          return data;
        }

        if (codePoint == start - 1) {
          data[index] = codePoint;
          return data;
        }

        if (start > codePoint) {
          data.splice(lastIndex != null ? lastIndex + 2 : 0, 0, codePoint, codePoint + 1);
          return data;
        }

        if (codePoint == end) {
          if (codePoint + 1 == data[index + 2]) {
            data.splice(index, 4, start, data[index + 3]);
            return data;
          }

          data[index + 1] = codePoint + 1;
          return data;
        }

        lastIndex = index;
        index += 2;
      }

      data.push(codePoint, codePoint + 1);
      return data;
    };

    var dataAddData = function dataAddData(dataA, dataB) {
      var index = 0;
      var start;
      var end;
      var data = dataA.slice();
      var length = dataB.length;

      while (index < length) {
        start = dataB[index];
        end = dataB[index + 1] - 1;

        if (start == end) {
          data = dataAdd(data, start);
        } else {
          data = dataAddRange(data, start, end);
        }

        index += 2;
      }

      return data;
    };

    var dataRemoveData = function dataRemoveData(dataA, dataB) {
      var index = 0;
      var start;
      var end;
      var data = dataA.slice();
      var length = dataB.length;

      while (index < length) {
        start = dataB[index];
        end = dataB[index + 1] - 1;

        if (start == end) {
          data = dataRemove(data, start);
        } else {
          data = dataRemoveRange(data, start, end);
        }

        index += 2;
      }

      return data;
    };

    var dataAddRange = function dataAddRange(data, rangeStart, rangeEnd) {
      if (rangeEnd < rangeStart) {
        throw Error(ERRORS.rangeOrder);
      }

      if (rangeStart < 0x0 || rangeStart > 0x10FFFF || rangeEnd < 0x0 || rangeEnd > 0x10FFFF) {
        throw RangeError(ERRORS.codePointRange);
      }

      var index = 0;
      var start;
      var end;
      var added = false;
      var length = data.length;

      while (index < length) {
        start = data[index];
        end = data[index + 1];

        if (added) {
          if (start == rangeEnd + 1) {
            data.splice(index - 1, 2);
            return data;
          }

          if (start > rangeEnd) {
            return data;
          }

          if (start >= rangeStart && start <= rangeEnd) {
            if (end > rangeStart && end - 1 <= rangeEnd) {
              data.splice(index, 2);
              index -= 2;
            } else {
              data.splice(index - 1, 2);
              index -= 2;
            }
          }
        } else if (start == rangeEnd + 1) {
          data[index] = rangeStart;
          return data;
        } else if (start > rangeEnd) {
            data.splice(index, 0, rangeStart, rangeEnd + 1);
            return data;
          } else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {
            return data;
          } else if (rangeStart >= start && rangeStart < end || end == rangeStart) {
            data[index + 1] = rangeEnd + 1;
            added = true;
          } else if (rangeStart <= start && rangeEnd + 1 >= end) {
            data[index] = rangeStart;
            data[index + 1] = rangeEnd + 1;
            added = true;
          }

        index += 2;
      }

      if (!added) {
        data.push(rangeStart, rangeEnd + 1);
      }

      return data;
    };

    var dataContains = function dataContains(data, codePoint) {
      var index = 0;
      var length = data.length;
      var start = data[index];
      var end = data[length - 1];

      if (length >= 2) {
        if (codePoint < start || codePoint > end) {
          return false;
        }
      }

      while (index < length) {
        start = data[index];
        end = data[index + 1];

        if (codePoint >= start && codePoint < end) {
          return true;
        }

        index += 2;
      }

      return false;
    };

    var dataIntersection = function dataIntersection(data, codePoints) {
      var index = 0;
      var length = codePoints.length;
      var codePoint;
      var result = [];

      while (index < length) {
        codePoint = codePoints[index];

        if (dataContains(data, codePoint)) {
          result.push(codePoint);
        }

        ++index;
      }

      return dataFromCodePoints(result);
    };

    var dataIsEmpty = function dataIsEmpty(data) {
      return !data.length;
    };

    var dataIsSingleton = function dataIsSingleton(data) {
      return data.length == 2 && data[0] + 1 == data[1];
    };

    var dataToArray = function dataToArray(data) {
      var index = 0;
      var start;
      var end;
      var result = [];
      var length = data.length;

      while (index < length) {
        start = data[index];
        end = data[index + 1];

        while (start < end) {
          result.push(start);
          ++start;
        }

        index += 2;
      }

      return result;
    };

    var floor = Math.floor;

    var highSurrogate = function highSurrogate(codePoint) {
      return parseInt(floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN, 10);
    };

    var lowSurrogate = function lowSurrogate(codePoint) {
      return parseInt((codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN, 10);
    };

    var stringFromCharCode = String.fromCharCode;

    var codePointToString = function codePointToString(codePoint) {
      var string;

      if (codePoint == 0x09) {
        string = '\\t';
      } else if (codePoint == 0x0A) {
          string = '\\n';
        } else if (codePoint == 0x0C) {
          string = '\\f';
        } else if (codePoint == 0x0D) {
          string = '\\r';
        } else if (codePoint == 0x2D) {
          string = '\\x2D';
        } else if (codePoint == 0x5C) {
          string = '\\\\';
        } else if (codePoint == 0x24 || codePoint >= 0x28 && codePoint <= 0x2B || codePoint == 0x2E || codePoint == 0x2F || codePoint == 0x3F || codePoint >= 0x5B && codePoint <= 0x5E || codePoint >= 0x7B && codePoint <= 0x7D) {
          string = '\\' + stringFromCharCode(codePoint);
        } else if (codePoint >= 0x20 && codePoint <= 0x7E) {
          string = stringFromCharCode(codePoint);
        } else if (codePoint <= 0xFF) {
          string = '\\x' + pad(hex(codePoint), 2);
        } else {
          string = "\\u" + pad(hex(codePoint), 4);
        }

      return string;
    };

    var codePointToStringUnicode = function codePointToStringUnicode(codePoint) {
      if (codePoint <= 0xFFFF) {
        return codePointToString(codePoint);
      }

      return "\\u{" + codePoint.toString(16).toUpperCase() + '}';
    };

    var symbolToCodePoint = function symbolToCodePoint(symbol) {
      var length = symbol.length;
      var first = symbol.charCodeAt(0);
      var second;

      if (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > 1) {
          second = symbol.charCodeAt(1);
          return (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;
        }

      return first;
    };

    var createBMPCharacterClasses = function createBMPCharacterClasses(data) {
      var result = '';
      var index = 0;
      var start;
      var end;
      var length = data.length;

      if (dataIsSingleton(data)) {
        return codePointToString(data[0]);
      }

      while (index < length) {
        start = data[index];
        end = data[index + 1] - 1;

        if (start == end) {
          result += codePointToString(start);
        } else if (start + 1 == end) {
          result += codePointToString(start) + codePointToString(end);
        } else {
          result += codePointToString(start) + '-' + codePointToString(end);
        }

        index += 2;
      }

      return '[' + result + ']';
    };

    var createUnicodeCharacterClasses = function createUnicodeCharacterClasses(data) {
      var result = '';
      var index = 0;
      var start;
      var end;
      var length = data.length;

      if (dataIsSingleton(data)) {
        return codePointToStringUnicode(data[0]);
      }

      while (index < length) {
        start = data[index];
        end = data[index + 1] - 1;

        if (start == end) {
          result += codePointToStringUnicode(start);
        } else if (start + 1 == end) {
          result += codePointToStringUnicode(start) + codePointToStringUnicode(end);
        } else {
          result += codePointToStringUnicode(start) + '-' + codePointToStringUnicode(end);
        }

        index += 2;
      }

      return '[' + result + ']';
    };

    var splitAtBMP = function splitAtBMP(data) {
      var loneHighSurrogates = [];
      var loneLowSurrogates = [];
      var bmp = [];
      var astral = [];
      var index = 0;
      var start;
      var end;
      var length = data.length;

      while (index < length) {
        start = data[index];
        end = data[index + 1] - 1;

        if (start < HIGH_SURROGATE_MIN) {
          if (end < HIGH_SURROGATE_MIN) {
            bmp.push(start, end + 1);
          }

          if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
            bmp.push(start, HIGH_SURROGATE_MIN);
            loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);
          }

          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
            bmp.push(start, HIGH_SURROGATE_MIN);
            loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
            loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
          }

          if (end > LOW_SURROGATE_MAX) {
            bmp.push(start, HIGH_SURROGATE_MIN);
            loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
            loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);

            if (end <= 0xFFFF) {
              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
            } else {
              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
              astral.push(0xFFFF + 1, end + 1);
            }
          }
        } else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {
          if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
            loneHighSurrogates.push(start, end + 1);
          }

          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
            loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
            loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
          }

          if (end > LOW_SURROGATE_MAX) {
            loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
            loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);

            if (end <= 0xFFFF) {
              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
            } else {
              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
              astral.push(0xFFFF + 1, end + 1);
            }
          }
        } else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {
          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
            loneLowSurrogates.push(start, end + 1);
          }

          if (end > LOW_SURROGATE_MAX) {
            loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);

            if (end <= 0xFFFF) {
              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
            } else {
              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
              astral.push(0xFFFF + 1, end + 1);
            }
          }
        } else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {
          if (end <= 0xFFFF) {
            bmp.push(start, end + 1);
          } else {
            bmp.push(start, 0xFFFF + 1);
            astral.push(0xFFFF + 1, end + 1);
          }
        } else {
          astral.push(start, end + 1);
        }

        index += 2;
      }

      return {
        'loneHighSurrogates': loneHighSurrogates,
        'loneLowSurrogates': loneLowSurrogates,
        'bmp': bmp,
        'astral': astral
      };
    };

    var optimizeSurrogateMappings = function optimizeSurrogateMappings(surrogateMappings) {
      var result = [];
      var tmpLow = [];
      var addLow = false;
      var mapping;
      var nextMapping;
      var highSurrogates;
      var lowSurrogates;
      var nextHighSurrogates;
      var nextLowSurrogates;
      var index = -1;
      var length = surrogateMappings.length;

      while (++index < length) {
        mapping = surrogateMappings[index];
        nextMapping = surrogateMappings[index + 1];

        if (!nextMapping) {
          result.push(mapping);
          continue;
        }

        highSurrogates = mapping[0];
        lowSurrogates = mapping[1];
        nextHighSurrogates = nextMapping[0];
        nextLowSurrogates = nextMapping[1];
        tmpLow = lowSurrogates;

        while (nextHighSurrogates && highSurrogates[0] == nextHighSurrogates[0] && highSurrogates[1] == nextHighSurrogates[1]) {
          if (dataIsSingleton(nextLowSurrogates)) {
            tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);
          } else {
            tmpLow = dataAddRange(tmpLow, nextLowSurrogates[0], nextLowSurrogates[1] - 1);
          }

          ++index;
          mapping = surrogateMappings[index];
          highSurrogates = mapping[0];
          lowSurrogates = mapping[1];
          nextMapping = surrogateMappings[index + 1];
          nextHighSurrogates = nextMapping && nextMapping[0];
          nextLowSurrogates = nextMapping && nextMapping[1];
          addLow = true;
        }

        result.push([highSurrogates, addLow ? tmpLow : lowSurrogates]);
        addLow = false;
      }

      return optimizeByLowSurrogates(result);
    };

    var optimizeByLowSurrogates = function optimizeByLowSurrogates(surrogateMappings) {
      if (surrogateMappings.length == 1) {
        return surrogateMappings;
      }

      var index = -1;
      var innerIndex = -1;

      while (++index < surrogateMappings.length) {
        var mapping = surrogateMappings[index];
        var lowSurrogates = mapping[1];
        var lowSurrogateStart = lowSurrogates[0];
        var lowSurrogateEnd = lowSurrogates[1];
        innerIndex = index;

        while (++innerIndex < surrogateMappings.length) {
          var otherMapping = surrogateMappings[innerIndex];
          var otherLowSurrogates = otherMapping[1];
          var otherLowSurrogateStart = otherLowSurrogates[0];
          var otherLowSurrogateEnd = otherLowSurrogates[1];

          if (lowSurrogateStart == otherLowSurrogateStart && lowSurrogateEnd == otherLowSurrogateEnd) {
            if (dataIsSingleton(otherMapping[0])) {
              mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);
            } else {
              mapping[0] = dataAddRange(mapping[0], otherMapping[0][0], otherMapping[0][1] - 1);
            }

            surrogateMappings.splice(innerIndex, 1);
            --innerIndex;
          }
        }
      }

      return surrogateMappings;
    };

    var surrogateSet = function surrogateSet(data) {
      if (!data.length) {
        return [];
      }

      var index = 0;
      var start;
      var end;
      var startHigh;
      var startLow;
      var endHigh;
      var endLow;
      var surrogateMappings = [];
      var length = data.length;

      while (index < length) {
        start = data[index];
        end = data[index + 1] - 1;
        startHigh = highSurrogate(start);
        startLow = lowSurrogate(start);
        endHigh = highSurrogate(end);
        endLow = lowSurrogate(end);
        var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;
        var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;
        var complete = false;

        if (startHigh == endHigh || startsWithLowestLowSurrogate && endsWithHighestLowSurrogate) {
          surrogateMappings.push([[startHigh, endHigh + 1], [startLow, endLow + 1]]);
          complete = true;
        } else {
          surrogateMappings.push([[startHigh, startHigh + 1], [startLow, LOW_SURROGATE_MAX + 1]]);
        }

        if (!complete && startHigh + 1 < endHigh) {
          if (endsWithHighestLowSurrogate) {
            surrogateMappings.push([[startHigh + 1, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
            complete = true;
          } else {
            surrogateMappings.push([[startHigh + 1, endHigh], [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]]);
          }
        }

        if (!complete) {
          surrogateMappings.push([[endHigh, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
        }

        index += 2;
      }

      return optimizeSurrogateMappings(surrogateMappings);
    };

    var createSurrogateCharacterClasses = function createSurrogateCharacterClasses(surrogateMappings) {
      var result = [];
      forEach(surrogateMappings, function (surrogateMapping) {
        var highSurrogates = surrogateMapping[0];
        var lowSurrogates = surrogateMapping[1];
        result.push(createBMPCharacterClasses(highSurrogates) + createBMPCharacterClasses(lowSurrogates));
      });
      return result.join('|');
    };

    var createCharacterClassesFromData = function createCharacterClassesFromData(data, bmpOnly, hasUnicodeFlag) {
      if (hasUnicodeFlag) {
        return createUnicodeCharacterClasses(data);
      }

      var result = [];
      var parts = splitAtBMP(data);
      var loneHighSurrogates = parts.loneHighSurrogates;
      var loneLowSurrogates = parts.loneLowSurrogates;
      var bmp = parts.bmp;
      var astral = parts.astral;
      var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);
      var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);
      var surrogateMappings = surrogateSet(astral);

      if (bmpOnly) {
        bmp = dataAddData(bmp, loneHighSurrogates);
        hasLoneHighSurrogates = false;
        bmp = dataAddData(bmp, loneLowSurrogates);
        hasLoneLowSurrogates = false;
      }

      if (!dataIsEmpty(bmp)) {
        result.push(createBMPCharacterClasses(bmp));
      }

      if (surrogateMappings.length) {
        result.push(createSurrogateCharacterClasses(surrogateMappings));
      }

      if (hasLoneHighSurrogates) {
        result.push(createBMPCharacterClasses(loneHighSurrogates) + "(?![\\uDC00-\\uDFFF])");
      }

      if (hasLoneLowSurrogates) {
        result.push("(?:[^\\uD800-\\uDBFF]|^)" + createBMPCharacterClasses(loneLowSurrogates));
      }

      return result.join('|');
    };

    var regenerate = function regenerate(value) {
      if (arguments.length > 1) {
        value = slice.call(arguments);
      }

      if (this instanceof regenerate) {
        this.data = [];
        return value ? this.add(value) : this;
      }

      return new regenerate().add(value);
    };

    regenerate.version = '1.3.3';
    var proto = regenerate.prototype;
    extend(proto, {
      'add': function add(value) {
        var $this = this;

        if (value == null) {
          return $this;
        }

        if (value instanceof regenerate) {
          $this.data = dataAddData($this.data, value.data);
          return $this;
        }

        if (arguments.length > 1) {
          value = slice.call(arguments);
        }

        if (isArray(value)) {
          forEach(value, function (item) {
            $this.add(item);
          });
          return $this;
        }

        $this.data = dataAdd($this.data, isNumber(value) ? value : symbolToCodePoint(value));
        return $this;
      },
      'remove': function remove(value) {
        var $this = this;

        if (value == null) {
          return $this;
        }

        if (value instanceof regenerate) {
          $this.data = dataRemoveData($this.data, value.data);
          return $this;
        }

        if (arguments.length > 1) {
          value = slice.call(arguments);
        }

        if (isArray(value)) {
          forEach(value, function (item) {
            $this.remove(item);
          });
          return $this;
        }

        $this.data = dataRemove($this.data, isNumber(value) ? value : symbolToCodePoint(value));
        return $this;
      },
      'addRange': function addRange(start, end) {
        var $this = this;
        $this.data = dataAddRange($this.data, isNumber(start) ? start : symbolToCodePoint(start), isNumber(end) ? end : symbolToCodePoint(end));
        return $this;
      },
      'removeRange': function removeRange(start, end) {
        var $this = this;
        var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);
        var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);
        $this.data = dataRemoveRange($this.data, startCodePoint, endCodePoint);
        return $this;
      },
      'intersection': function intersection(argument) {
        var $this = this;
        var array = argument instanceof regenerate ? dataToArray(argument.data) : argument;
        $this.data = dataIntersection($this.data, array);
        return $this;
      },
      'contains': function contains(codePoint) {
        return dataContains(this.data, isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint));
      },
      'clone': function clone() {
        var set = new regenerate();
        set.data = this.data.slice(0);
        return set;
      },
      'toString': function toString(options) {
        var result = createCharacterClassesFromData(this.data, options ? options.bmpOnly : false, options ? options.hasUnicodeFlag : false);

        if (!result) {
          return '[]';
        }

        return result.replace(regexNull, '\\0$1');
      },
      'toRegExp': function toRegExp(flags) {
        var pattern = this.toString(flags && flags.indexOf('u') != -1 ? {
          'hasUnicodeFlag': true
        } : null);
        return RegExp(pattern, flags || '');
      },
      'valueOf': function valueOf() {
        return dataToArray(this.data);
      }
    });
    proto.toArray = proto.valueOf;

    if (freeExports && !freeExports.nodeType) {
      if (freeModule) {
        freeModule.exports = regenerate;
      } else {
        freeExports.regenerate = regenerate;
      }
    } else {
      root.regenerate = regenerate;
    }
  })(commonjsGlobal);
  });

  var unicodeCanonicalPropertyNamesEcmascript = new Set(['General_Category', 'Script', 'Script_Extensions', 'Alphabetic', 'Any', 'ASCII', 'ASCII_Hex_Digit', 'Assigned', 'Bidi_Control', 'Bidi_Mirrored', 'Case_Ignorable', 'Cased', 'Changes_When_Casefolded', 'Changes_When_Casemapped', 'Changes_When_Lowercased', 'Changes_When_NFKC_Casefolded', 'Changes_When_Titlecased', 'Changes_When_Uppercased', 'Dash', 'Default_Ignorable_Code_Point', 'Deprecated', 'Diacritic', 'Emoji', 'Emoji_Component', 'Emoji_Modifier', 'Emoji_Modifier_Base', 'Emoji_Presentation', 'Extended_Pictographic', 'Extender', 'Grapheme_Base', 'Grapheme_Extend', 'Hex_Digit', 'ID_Continue', 'ID_Start', 'Ideographic', 'IDS_Binary_Operator', 'IDS_Trinary_Operator', 'Join_Control', 'Logical_Order_Exception', 'Lowercase', 'Math', 'Noncharacter_Code_Point', 'Pattern_Syntax', 'Pattern_White_Space', 'Quotation_Mark', 'Radical', 'Regional_Indicator', 'Sentence_Terminal', 'Soft_Dotted', 'Terminal_Punctuation', 'Unified_Ideograph', 'Uppercase', 'Variation_Selector', 'White_Space', 'XID_Continue', 'XID_Start']);

  var unicodePropertyAliasesEcmascript = new Map([['scx', 'Script_Extensions'], ['sc', 'Script'], ['gc', 'General_Category'], ['AHex', 'ASCII_Hex_Digit'], ['Alpha', 'Alphabetic'], ['Bidi_C', 'Bidi_Control'], ['Bidi_M', 'Bidi_Mirrored'], ['Cased', 'Cased'], ['CI', 'Case_Ignorable'], ['CWCF', 'Changes_When_Casefolded'], ['CWCM', 'Changes_When_Casemapped'], ['CWKCF', 'Changes_When_NFKC_Casefolded'], ['CWL', 'Changes_When_Lowercased'], ['CWT', 'Changes_When_Titlecased'], ['CWU', 'Changes_When_Uppercased'], ['Dash', 'Dash'], ['Dep', 'Deprecated'], ['DI', 'Default_Ignorable_Code_Point'], ['Dia', 'Diacritic'], ['EBase', 'Emoji_Modifier_Base'], ['EComp', 'Emoji_Component'], ['EMod', 'Emoji_Modifier'], ['Emoji', 'Emoji'], ['EPres', 'Emoji_Presentation'], ['Ext', 'Extender'], ['ExtPict', 'Extended_Pictographic'], ['Gr_Base', 'Grapheme_Base'], ['Gr_Ext', 'Grapheme_Extend'], ['Hex', 'Hex_Digit'], ['IDC', 'ID_Continue'], ['Ideo', 'Ideographic'], ['IDS', 'ID_Start'], ['IDSB', 'IDS_Binary_Operator'], ['IDST', 'IDS_Trinary_Operator'], ['Join_C', 'Join_Control'], ['LOE', 'Logical_Order_Exception'], ['Lower', 'Lowercase'], ['Math', 'Math'], ['NChar', 'Noncharacter_Code_Point'], ['Pat_Syn', 'Pattern_Syntax'], ['Pat_WS', 'Pattern_White_Space'], ['QMark', 'Quotation_Mark'], ['Radical', 'Radical'], ['RI', 'Regional_Indicator'], ['SD', 'Soft_Dotted'], ['STerm', 'Sentence_Terminal'], ['Term', 'Terminal_Punctuation'], ['UIdeo', 'Unified_Ideograph'], ['Upper', 'Uppercase'], ['VS', 'Variation_Selector'], ['WSpace', 'White_Space'], ['space', 'White_Space'], ['XIDC', 'XID_Continue'], ['XIDS', 'XID_Start']]);

  var matchProperty = function matchProperty(property) {
    if (unicodeCanonicalPropertyNamesEcmascript.has(property)) {
      return property;
    }

    if (unicodePropertyAliasesEcmascript.has(property)) {
      return unicodePropertyAliasesEcmascript.get(property);
    }

    throw new Error("Unknown property: " + property);
  };

  var unicodeMatchPropertyEcmascript = matchProperty;

  var mappings = new Map([['General_Category', new Map([['C', 'Other'], ['Cc', 'Control'], ['cntrl', 'Control'], ['Cf', 'Format'], ['Cn', 'Unassigned'], ['Co', 'Private_Use'], ['Cs', 'Surrogate'], ['L', 'Letter'], ['LC', 'Cased_Letter'], ['Ll', 'Lowercase_Letter'], ['Lm', 'Modifier_Letter'], ['Lo', 'Other_Letter'], ['Lt', 'Titlecase_Letter'], ['Lu', 'Uppercase_Letter'], ['M', 'Mark'], ['Combining_Mark', 'Mark'], ['Mc', 'Spacing_Mark'], ['Me', 'Enclosing_Mark'], ['Mn', 'Nonspacing_Mark'], ['N', 'Number'], ['Nd', 'Decimal_Number'], ['digit', 'Decimal_Number'], ['Nl', 'Letter_Number'], ['No', 'Other_Number'], ['P', 'Punctuation'], ['punct', 'Punctuation'], ['Pc', 'Connector_Punctuation'], ['Pd', 'Dash_Punctuation'], ['Pe', 'Close_Punctuation'], ['Pf', 'Final_Punctuation'], ['Pi', 'Initial_Punctuation'], ['Po', 'Other_Punctuation'], ['Ps', 'Open_Punctuation'], ['S', 'Symbol'], ['Sc', 'Currency_Symbol'], ['Sk', 'Modifier_Symbol'], ['Sm', 'Math_Symbol'], ['So', 'Other_Symbol'], ['Z', 'Separator'], ['Zl', 'Line_Separator'], ['Zp', 'Paragraph_Separator'], ['Zs', 'Space_Separator'], ['Other', 'Other'], ['Control', 'Control'], ['Format', 'Format'], ['Unassigned', 'Unassigned'], ['Private_Use', 'Private_Use'], ['Surrogate', 'Surrogate'], ['Letter', 'Letter'], ['Cased_Letter', 'Cased_Letter'], ['Lowercase_Letter', 'Lowercase_Letter'], ['Modifier_Letter', 'Modifier_Letter'], ['Other_Letter', 'Other_Letter'], ['Titlecase_Letter', 'Titlecase_Letter'], ['Uppercase_Letter', 'Uppercase_Letter'], ['Mark', 'Mark'], ['Spacing_Mark', 'Spacing_Mark'], ['Enclosing_Mark', 'Enclosing_Mark'], ['Nonspacing_Mark', 'Nonspacing_Mark'], ['Number', 'Number'], ['Decimal_Number', 'Decimal_Number'], ['Letter_Number', 'Letter_Number'], ['Other_Number', 'Other_Number'], ['Punctuation', 'Punctuation'], ['Connector_Punctuation', 'Connector_Punctuation'], ['Dash_Punctuation', 'Dash_Punctuation'], ['Close_Punctuation', 'Close_Punctuation'], ['Final_Punctuation', 'Final_Punctuation'], ['Initial_Punctuation', 'Initial_Punctuation'], ['Other_Punctuation', 'Other_Punctuation'], ['Open_Punctuation', 'Open_Punctuation'], ['Symbol', 'Symbol'], ['Currency_Symbol', 'Currency_Symbol'], ['Modifier_Symbol', 'Modifier_Symbol'], ['Math_Symbol', 'Math_Symbol'], ['Other_Symbol', 'Other_Symbol'], ['Separator', 'Separator'], ['Line_Separator', 'Line_Separator'], ['Paragraph_Separator', 'Paragraph_Separator'], ['Space_Separator', 'Space_Separator']])], ['Script', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Chrs', 'Chorasmian'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Diak', 'Dives_Akuru'], ['Dogr', 'Dogra'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Elym', 'Elymaic'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gong', 'Gunjala_Gondi'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hmnp', 'Nyiakeng_Puachue_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Kits', 'Khitan_Small_Script'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Maka', 'Makasar'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Medf', 'Medefaidrin'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Nand', 'Nandinagari'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Rohg', 'Hanifi_Rohingya'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sogd', 'Sogdian'], ['Sogo', 'Old_Sogdian'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Wara', 'Warang_Citi'], ['Wcho', 'Wancho'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yezi', 'Yezidi'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Chorasmian', 'Chorasmian'], ['Coptic', 'Coptic'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Dives_Akuru', 'Dives_Akuru'], ['Dogra', 'Dogra'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Elymaic', 'Elymaic'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Gunjala_Gondi', 'Gunjala_Gondi'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Nyiakeng_Puachue_Hmong', 'Nyiakeng_Puachue_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Khitan_Small_Script', 'Khitan_Small_Script'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Makasar', 'Makasar'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Medefaidrin', 'Medefaidrin'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Nandinagari', 'Nandinagari'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Hanifi_Rohingya', 'Hanifi_Rohingya'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sogdian', 'Sogdian'], ['Old_Sogdian', 'Old_Sogdian'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Warang_Citi', 'Warang_Citi'], ['Wancho', 'Wancho'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yezidi', 'Yezidi'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])], ['Script_Extensions', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Chrs', 'Chorasmian'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Diak', 'Dives_Akuru'], ['Dogr', 'Dogra'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Elym', 'Elymaic'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gong', 'Gunjala_Gondi'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hmnp', 'Nyiakeng_Puachue_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Kits', 'Khitan_Small_Script'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Maka', 'Makasar'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Medf', 'Medefaidrin'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Nand', 'Nandinagari'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Rohg', 'Hanifi_Rohingya'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sogd', 'Sogdian'], ['Sogo', 'Old_Sogdian'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Wara', 'Warang_Citi'], ['Wcho', 'Wancho'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yezi', 'Yezidi'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Chorasmian', 'Chorasmian'], ['Coptic', 'Coptic'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Dives_Akuru', 'Dives_Akuru'], ['Dogra', 'Dogra'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Elymaic', 'Elymaic'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Gunjala_Gondi', 'Gunjala_Gondi'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Nyiakeng_Puachue_Hmong', 'Nyiakeng_Puachue_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Khitan_Small_Script', 'Khitan_Small_Script'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Makasar', 'Makasar'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Medefaidrin', 'Medefaidrin'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Nandinagari', 'Nandinagari'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Hanifi_Rohingya', 'Hanifi_Rohingya'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sogdian', 'Sogdian'], ['Old_Sogdian', 'Old_Sogdian'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Warang_Citi', 'Warang_Citi'], ['Wancho', 'Wancho'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yezidi', 'Yezidi'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])]]);

  var matchPropertyValue = function matchPropertyValue(property, value) {
    var aliasToValue = mappings.get(property);

    if (!aliasToValue) {
      throw new Error("Unknown property `" + property + "`.");
    }

    var canonicalValue = aliasToValue.get(value);

    if (canonicalValue) {
      return canonicalValue;
    }

    throw new Error("Unknown value `" + value + "` for property `" + property + "`.");
  };

  var unicodeMatchPropertyValueEcmascript = matchPropertyValue;

  var iuMappings = new Map([[0x4B, 0x212A], [0x53, 0x17F], [0x6B, 0x212A], [0x73, 0x17F], [0xB5, 0x39C], [0xC5, 0x212B], [0xDF, 0x1E9E], [0xE5, 0x212B], [0x17F, 0x53], [0x1C4, 0x1C5], [0x1C5, 0x1C4], [0x1C7, 0x1C8], [0x1C8, 0x1C7], [0x1CA, 0x1CB], [0x1CB, 0x1CA], [0x1F1, 0x1F2], [0x1F2, 0x1F1], [0x26A, 0xA7AE], [0x282, 0xA7C5], [0x29D, 0xA7B2], [0x345, 0x1FBE], [0x392, 0x3D0], [0x395, 0x3F5], [0x398, 0x3F4], [0x399, 0x1FBE], [0x39A, 0x3F0], [0x39C, 0xB5], [0x3A0, 0x3D6], [0x3A1, 0x3F1], [0x3A3, 0x3C2], [0x3A6, 0x3D5], [0x3A9, 0x2126], [0x3B8, 0x3F4], [0x3C2, 0x3A3], [0x3C9, 0x2126], [0x3D0, 0x392], [0x3D1, 0x3F4], [0x3D5, 0x3A6], [0x3D6, 0x3A0], [0x3F0, 0x39A], [0x3F1, 0x3A1], [0x3F4, [0x398, 0x3D1, 0x3B8]], [0x3F5, 0x395], [0x412, 0x1C80], [0x414, 0x1C81], [0x41E, 0x1C82], [0x421, 0x1C83], [0x422, 0x1C85], [0x42A, 0x1C86], [0x432, 0x1C80], [0x434, 0x1C81], [0x43E, 0x1C82], [0x441, 0x1C83], [0x442, [0x1C84, 0x1C85]], [0x44A, 0x1C86], [0x462, 0x1C87], [0x463, 0x1C87], [0x10D0, 0x1C90], [0x10D1, 0x1C91], [0x10D2, 0x1C92], [0x10D3, 0x1C93], [0x10D4, 0x1C94], [0x10D5, 0x1C95], [0x10D6, 0x1C96], [0x10D7, 0x1C97], [0x10D8, 0x1C98], [0x10D9, 0x1C99], [0x10DA, 0x1C9A], [0x10DB, 0x1C9B], [0x10DC, 0x1C9C], [0x10DD, 0x1C9D], [0x10DE, 0x1C9E], [0x10DF, 0x1C9F], [0x10E0, 0x1CA0], [0x10E1, 0x1CA1], [0x10E2, 0x1CA2], [0x10E3, 0x1CA3], [0x10E4, 0x1CA4], [0x10E5, 0x1CA5], [0x10E6, 0x1CA6], [0x10E7, 0x1CA7], [0x10E8, 0x1CA8], [0x10E9, 0x1CA9], [0x10EA, 0x1CAA], [0x10EB, 0x1CAB], [0x10EC, 0x1CAC], [0x10ED, 0x1CAD], [0x10EE, 0x1CAE], [0x10EF, 0x1CAF], [0x10F0, 0x1CB0], [0x10F1, 0x1CB1], [0x10F2, 0x1CB2], [0x10F3, 0x1CB3], [0x10F4, 0x1CB4], [0x10F5, 0x1CB5], [0x10F6, 0x1CB6], [0x10F7, 0x1CB7], [0x10F8, 0x1CB8], [0x10F9, 0x1CB9], [0x10FA, 0x1CBA], [0x10FD, 0x1CBD], [0x10FE, 0x1CBE], [0x10FF, 0x1CBF], [0x13A0, 0xAB70], [0x13A1, 0xAB71], [0x13A2, 0xAB72], [0x13A3, 0xAB73], [0x13A4, 0xAB74], [0x13A5, 0xAB75], [0x13A6, 0xAB76], [0x13A7, 0xAB77], [0x13A8, 0xAB78], [0x13A9, 0xAB79], [0x13AA, 0xAB7A], [0x13AB, 0xAB7B], [0x13AC, 0xAB7C], [0x13AD, 0xAB7D], [0x13AE, 0xAB7E], [0x13AF, 0xAB7F], [0x13B0, 0xAB80], [0x13B1, 0xAB81], [0x13B2, 0xAB82], [0x13B3, 0xAB83], [0x13B4, 0xAB84], [0x13B5, 0xAB85], [0x13B6, 0xAB86], [0x13B7, 0xAB87], [0x13B8, 0xAB88], [0x13B9, 0xAB89], [0x13BA, 0xAB8A], [0x13BB, 0xAB8B], [0x13BC, 0xAB8C], [0x13BD, 0xAB8D], [0x13BE, 0xAB8E], [0x13BF, 0xAB8F], [0x13C0, 0xAB90], [0x13C1, 0xAB91], [0x13C2, 0xAB92], [0x13C3, 0xAB93], [0x13C4, 0xAB94], [0x13C5, 0xAB95], [0x13C6, 0xAB96], [0x13C7, 0xAB97], [0x13C8, 0xAB98], [0x13C9, 0xAB99], [0x13CA, 0xAB9A], [0x13CB, 0xAB9B], [0x13CC, 0xAB9C], [0x13CD, 0xAB9D], [0x13CE, 0xAB9E], [0x13CF, 0xAB9F], [0x13D0, 0xABA0], [0x13D1, 0xABA1], [0x13D2, 0xABA2], [0x13D3, 0xABA3], [0x13D4, 0xABA4], [0x13D5, 0xABA5], [0x13D6, 0xABA6], [0x13D7, 0xABA7], [0x13D8, 0xABA8], [0x13D9, 0xABA9], [0x13DA, 0xABAA], [0x13DB, 0xABAB], [0x13DC, 0xABAC], [0x13DD, 0xABAD], [0x13DE, 0xABAE], [0x13DF, 0xABAF], [0x13E0, 0xABB0], [0x13E1, 0xABB1], [0x13E2, 0xABB2], [0x13E3, 0xABB3], [0x13E4, 0xABB4], [0x13E5, 0xABB5], [0x13E6, 0xABB6], [0x13E7, 0xABB7], [0x13E8, 0xABB8], [0x13E9, 0xABB9], [0x13EA, 0xABBA], [0x13EB, 0xABBB], [0x13EC, 0xABBC], [0x13ED, 0xABBD], [0x13EE, 0xABBE], [0x13EF, 0xABBF], [0x13F0, 0x13F8], [0x13F1, 0x13F9], [0x13F2, 0x13FA], [0x13F3, 0x13FB], [0x13F4, 0x13FC], [0x13F5, 0x13FD], [0x13F8, 0x13F0], [0x13F9, 0x13F1], [0x13FA, 0x13F2], [0x13FB, 0x13F3], [0x13FC, 0x13F4], [0x13FD, 0x13F5], [0x1C80, [0x412, 0x432]], [0x1C81, [0x414, 0x434]], [0x1C82, [0x41E, 0x43E]], [0x1C83, [0x421, 0x441]], [0x1C84, [0x1C85, 0x442]], [0x1C85, [0x422, 0x1C84, 0x442]], [0x1C86, [0x42A, 0x44A]], [0x1C87, [0x462, 0x463]], [0x1C88, [0xA64A, 0xA64B]], [0x1C90, 0x10D0], [0x1C91, 0x10D1], [0x1C92, 0x10D2], [0x1C93, 0x10D3], [0x1C94, 0x10D4], [0x1C95, 0x10D5], [0x1C96, 0x10D6], [0x1C97, 0x10D7], [0x1C98, 0x10D8], [0x1C99, 0x10D9], [0x1C9A, 0x10DA], [0x1C9B, 0x10DB], [0x1C9C, 0x10DC], [0x1C9D, 0x10DD], [0x1C9E, 0x10DE], [0x1C9F, 0x10DF], [0x1CA0, 0x10E0], [0x1CA1, 0x10E1], [0x1CA2, 0x10E2], [0x1CA3, 0x10E3], [0x1CA4, 0x10E4], [0x1CA5, 0x10E5], [0x1CA6, 0x10E6], [0x1CA7, 0x10E7], [0x1CA8, 0x10E8], [0x1CA9, 0x10E9], [0x1CAA, 0x10EA], [0x1CAB, 0x10EB], [0x1CAC, 0x10EC], [0x1CAD, 0x10ED], [0x1CAE, 0x10EE], [0x1CAF, 0x10EF], [0x1CB0, 0x10F0], [0x1CB1, 0x10F1], [0x1CB2, 0x10F2], [0x1CB3, 0x10F3], [0x1CB4, 0x10F4], [0x1CB5, 0x10F5], [0x1CB6, 0x10F6], [0x1CB7, 0x10F7], [0x1CB8, 0x10F8], [0x1CB9, 0x10F9], [0x1CBA, 0x10FA], [0x1CBD, 0x10FD], [0x1CBE, 0x10FE], [0x1CBF, 0x10FF], [0x1D8E, 0xA7C6], [0x1E60, 0x1E9B], [0x1E9B, 0x1E60], [0x1E9E, 0xDF], [0x1F80, 0x1F88], [0x1F81, 0x1F89], [0x1F82, 0x1F8A], [0x1F83, 0x1F8B], [0x1F84, 0x1F8C], [0x1F85, 0x1F8D], [0x1F86, 0x1F8E], [0x1F87, 0x1F8F], [0x1F88, 0x1F80], [0x1F89, 0x1F81], [0x1F8A, 0x1F82], [0x1F8B, 0x1F83], [0x1F8C, 0x1F84], [0x1F8D, 0x1F85], [0x1F8E, 0x1F86], [0x1F8F, 0x1F87], [0x1F90, 0x1F98], [0x1F91, 0x1F99], [0x1F92, 0x1F9A], [0x1F93, 0x1F9B], [0x1F94, 0x1F9C], [0x1F95, 0x1F9D], [0x1F96, 0x1F9E], [0x1F97, 0x1F9F], [0x1F98, 0x1F90], [0x1F99, 0x1F91], [0x1F9A, 0x1F92], [0x1F9B, 0x1F93], [0x1F9C, 0x1F94], [0x1F9D, 0x1F95], [0x1F9E, 0x1F96], [0x1F9F, 0x1F97], [0x1FA0, 0x1FA8], [0x1FA1, 0x1FA9], [0x1FA2, 0x1FAA], [0x1FA3, 0x1FAB], [0x1FA4, 0x1FAC], [0x1FA5, 0x1FAD], [0x1FA6, 0x1FAE], [0x1FA7, 0x1FAF], [0x1FA8, 0x1FA0], [0x1FA9, 0x1FA1], [0x1FAA, 0x1FA2], [0x1FAB, 0x1FA3], [0x1FAC, 0x1FA4], [0x1FAD, 0x1FA5], [0x1FAE, 0x1FA6], [0x1FAF, 0x1FA7], [0x1FB3, 0x1FBC], [0x1FBC, 0x1FB3], [0x1FBE, [0x345, 0x399]], [0x1FC3, 0x1FCC], [0x1FCC, 0x1FC3], [0x1FF3, 0x1FFC], [0x1FFC, 0x1FF3], [0x2126, [0x3A9, 0x3C9]], [0x212A, 0x4B], [0x212B, [0xC5, 0xE5]], [0xA64A, 0x1C88], [0xA64B, 0x1C88], [0xA794, 0xA7C4], [0xA7AE, 0x26A], [0xA7B2, 0x29D], [0xA7B3, 0xAB53], [0xA7B4, 0xA7B5], [0xA7B5, 0xA7B4], [0xA7B6, 0xA7B7], [0xA7B7, 0xA7B6], [0xA7B8, 0xA7B9], [0xA7B9, 0xA7B8], [0xA7BA, 0xA7BB], [0xA7BB, 0xA7BA], [0xA7BC, 0xA7BD], [0xA7BD, 0xA7BC], [0xA7BE, 0xA7BF], [0xA7BF, 0xA7BE], [0xA7C2, 0xA7C3], [0xA7C3, 0xA7C2], [0xA7C4, 0xA794], [0xA7C5, 0x282], [0xA7C6, 0x1D8E], [0xAB53, 0xA7B3], [0xAB70, 0x13A0], [0xAB71, 0x13A1], [0xAB72, 0x13A2], [0xAB73, 0x13A3], [0xAB74, 0x13A4], [0xAB75, 0x13A5], [0xAB76, 0x13A6], [0xAB77, 0x13A7], [0xAB78, 0x13A8], [0xAB79, 0x13A9], [0xAB7A, 0x13AA], [0xAB7B, 0x13AB], [0xAB7C, 0x13AC], [0xAB7D, 0x13AD], [0xAB7E, 0x13AE], [0xAB7F, 0x13AF], [0xAB80, 0x13B0], [0xAB81, 0x13B1], [0xAB82, 0x13B2], [0xAB83, 0x13B3], [0xAB84, 0x13B4], [0xAB85, 0x13B5], [0xAB86, 0x13B6], [0xAB87, 0x13B7], [0xAB88, 0x13B8], [0xAB89, 0x13B9], [0xAB8A, 0x13BA], [0xAB8B, 0x13BB], [0xAB8C, 0x13BC], [0xAB8D, 0x13BD], [0xAB8E, 0x13BE], [0xAB8F, 0x13BF], [0xAB90, 0x13C0], [0xAB91, 0x13C1], [0xAB92, 0x13C2], [0xAB93, 0x13C3], [0xAB94, 0x13C4], [0xAB95, 0x13C5], [0xAB96, 0x13C6], [0xAB97, 0x13C7], [0xAB98, 0x13C8], [0xAB99, 0x13C9], [0xAB9A, 0x13CA], [0xAB9B, 0x13CB], [0xAB9C, 0x13CC], [0xAB9D, 0x13CD], [0xAB9E, 0x13CE], [0xAB9F, 0x13CF], [0xABA0, 0x13D0], [0xABA1, 0x13D1], [0xABA2, 0x13D2], [0xABA3, 0x13D3], [0xABA4, 0x13D4], [0xABA5, 0x13D5], [0xABA6, 0x13D6], [0xABA7, 0x13D7], [0xABA8, 0x13D8], [0xABA9, 0x13D9], [0xABAA, 0x13DA], [0xABAB, 0x13DB], [0xABAC, 0x13DC], [0xABAD, 0x13DD], [0xABAE, 0x13DE], [0xABAF, 0x13DF], [0xABB0, 0x13E0], [0xABB1, 0x13E1], [0xABB2, 0x13E2], [0xABB3, 0x13E3], [0xABB4, 0x13E4], [0xABB5, 0x13E5], [0xABB6, 0x13E6], [0xABB7, 0x13E7], [0xABB8, 0x13E8], [0xABB9, 0x13E9], [0xABBA, 0x13EA], [0xABBB, 0x13EB], [0xABBC, 0x13EC], [0xABBD, 0x13ED], [0xABBE, 0x13EE], [0xABBF, 0x13EF], [0x10400, 0x10428], [0x10401, 0x10429], [0x10402, 0x1042A], [0x10403, 0x1042B], [0x10404, 0x1042C], [0x10405, 0x1042D], [0x10406, 0x1042E], [0x10407, 0x1042F], [0x10408, 0x10430], [0x10409, 0x10431], [0x1040A, 0x10432], [0x1040B, 0x10433], [0x1040C, 0x10434], [0x1040D, 0x10435], [0x1040E, 0x10436], [0x1040F, 0x10437], [0x10410, 0x10438], [0x10411, 0x10439], [0x10412, 0x1043A], [0x10413, 0x1043B], [0x10414, 0x1043C], [0x10415, 0x1043D], [0x10416, 0x1043E], [0x10417, 0x1043F], [0x10418, 0x10440], [0x10419, 0x10441], [0x1041A, 0x10442], [0x1041B, 0x10443], [0x1041C, 0x10444], [0x1041D, 0x10445], [0x1041E, 0x10446], [0x1041F, 0x10447], [0x10420, 0x10448], [0x10421, 0x10449], [0x10422, 0x1044A], [0x10423, 0x1044B], [0x10424, 0x1044C], [0x10425, 0x1044D], [0x10426, 0x1044E], [0x10427, 0x1044F], [0x10428, 0x10400], [0x10429, 0x10401], [0x1042A, 0x10402], [0x1042B, 0x10403], [0x1042C, 0x10404], [0x1042D, 0x10405], [0x1042E, 0x10406], [0x1042F, 0x10407], [0x10430, 0x10408], [0x10431, 0x10409], [0x10432, 0x1040A], [0x10433, 0x1040B], [0x10434, 0x1040C], [0x10435, 0x1040D], [0x10436, 0x1040E], [0x10437, 0x1040F], [0x10438, 0x10410], [0x10439, 0x10411], [0x1043A, 0x10412], [0x1043B, 0x10413], [0x1043C, 0x10414], [0x1043D, 0x10415], [0x1043E, 0x10416], [0x1043F, 0x10417], [0x10440, 0x10418], [0x10441, 0x10419], [0x10442, 0x1041A], [0x10443, 0x1041B], [0x10444, 0x1041C], [0x10445, 0x1041D], [0x10446, 0x1041E], [0x10447, 0x1041F], [0x10448, 0x10420], [0x10449, 0x10421], [0x1044A, 0x10422], [0x1044B, 0x10423], [0x1044C, 0x10424], [0x1044D, 0x10425], [0x1044E, 0x10426], [0x1044F, 0x10427], [0x104B0, 0x104D8], [0x104B1, 0x104D9], [0x104B2, 0x104DA], [0x104B3, 0x104DB], [0x104B4, 0x104DC], [0x104B5, 0x104DD], [0x104B6, 0x104DE], [0x104B7, 0x104DF], [0x104B8, 0x104E0], [0x104B9, 0x104E1], [0x104BA, 0x104E2], [0x104BB, 0x104E3], [0x104BC, 0x104E4], [0x104BD, 0x104E5], [0x104BE, 0x104E6], [0x104BF, 0x104E7], [0x104C0, 0x104E8], [0x104C1, 0x104E9], [0x104C2, 0x104EA], [0x104C3, 0x104EB], [0x104C4, 0x104EC], [0x104C5, 0x104ED], [0x104C6, 0x104EE], [0x104C7, 0x104EF], [0x104C8, 0x104F0], [0x104C9, 0x104F1], [0x104CA, 0x104F2], [0x104CB, 0x104F3], [0x104CC, 0x104F4], [0x104CD, 0x104F5], [0x104CE, 0x104F6], [0x104CF, 0x104F7], [0x104D0, 0x104F8], [0x104D1, 0x104F9], [0x104D2, 0x104FA], [0x104D3, 0x104FB], [0x104D8, 0x104B0], [0x104D9, 0x104B1], [0x104DA, 0x104B2], [0x104DB, 0x104B3], [0x104DC, 0x104B4], [0x104DD, 0x104B5], [0x104DE, 0x104B6], [0x104DF, 0x104B7], [0x104E0, 0x104B8], [0x104E1, 0x104B9], [0x104E2, 0x104BA], [0x104E3, 0x104BB], [0x104E4, 0x104BC], [0x104E5, 0x104BD], [0x104E6, 0x104BE], [0x104E7, 0x104BF], [0x104E8, 0x104C0], [0x104E9, 0x104C1], [0x104EA, 0x104C2], [0x104EB, 0x104C3], [0x104EC, 0x104C4], [0x104ED, 0x104C5], [0x104EE, 0x104C6], [0x104EF, 0x104C7], [0x104F0, 0x104C8], [0x104F1, 0x104C9], [0x104F2, 0x104CA], [0x104F3, 0x104CB], [0x104F4, 0x104CC], [0x104F5, 0x104CD], [0x104F6, 0x104CE], [0x104F7, 0x104CF], [0x104F8, 0x104D0], [0x104F9, 0x104D1], [0x104FA, 0x104D2], [0x104FB, 0x104D3], [0x10C80, 0x10CC0], [0x10C81, 0x10CC1], [0x10C82, 0x10CC2], [0x10C83, 0x10CC3], [0x10C84, 0x10CC4], [0x10C85, 0x10CC5], [0x10C86, 0x10CC6], [0x10C87, 0x10CC7], [0x10C88, 0x10CC8], [0x10C89, 0x10CC9], [0x10C8A, 0x10CCA], [0x10C8B, 0x10CCB], [0x10C8C, 0x10CCC], [0x10C8D, 0x10CCD], [0x10C8E, 0x10CCE], [0x10C8F, 0x10CCF], [0x10C90, 0x10CD0], [0x10C91, 0x10CD1], [0x10C92, 0x10CD2], [0x10C93, 0x10CD3], [0x10C94, 0x10CD4], [0x10C95, 0x10CD5], [0x10C96, 0x10CD6], [0x10C97, 0x10CD7], [0x10C98, 0x10CD8], [0x10C99, 0x10CD9], [0x10C9A, 0x10CDA], [0x10C9B, 0x10CDB], [0x10C9C, 0x10CDC], [0x10C9D, 0x10CDD], [0x10C9E, 0x10CDE], [0x10C9F, 0x10CDF], [0x10CA0, 0x10CE0], [0x10CA1, 0x10CE1], [0x10CA2, 0x10CE2], [0x10CA3, 0x10CE3], [0x10CA4, 0x10CE4], [0x10CA5, 0x10CE5], [0x10CA6, 0x10CE6], [0x10CA7, 0x10CE7], [0x10CA8, 0x10CE8], [0x10CA9, 0x10CE9], [0x10CAA, 0x10CEA], [0x10CAB, 0x10CEB], [0x10CAC, 0x10CEC], [0x10CAD, 0x10CED], [0x10CAE, 0x10CEE], [0x10CAF, 0x10CEF], [0x10CB0, 0x10CF0], [0x10CB1, 0x10CF1], [0x10CB2, 0x10CF2], [0x10CC0, 0x10C80], [0x10CC1, 0x10C81], [0x10CC2, 0x10C82], [0x10CC3, 0x10C83], [0x10CC4, 0x10C84], [0x10CC5, 0x10C85], [0x10CC6, 0x10C86], [0x10CC7, 0x10C87], [0x10CC8, 0x10C88], [0x10CC9, 0x10C89], [0x10CCA, 0x10C8A], [0x10CCB, 0x10C8B], [0x10CCC, 0x10C8C], [0x10CCD, 0x10C8D], [0x10CCE, 0x10C8E], [0x10CCF, 0x10C8F], [0x10CD0, 0x10C90], [0x10CD1, 0x10C91], [0x10CD2, 0x10C92], [0x10CD3, 0x10C93], [0x10CD4, 0x10C94], [0x10CD5, 0x10C95], [0x10CD6, 0x10C96], [0x10CD7, 0x10C97], [0x10CD8, 0x10C98], [0x10CD9, 0x10C99], [0x10CDA, 0x10C9A], [0x10CDB, 0x10C9B], [0x10CDC, 0x10C9C], [0x10CDD, 0x10C9D], [0x10CDE, 0x10C9E], [0x10CDF, 0x10C9F], [0x10CE0, 0x10CA0], [0x10CE1, 0x10CA1], [0x10CE2, 0x10CA2], [0x10CE3, 0x10CA3], [0x10CE4, 0x10CA4], [0x10CE5, 0x10CA5], [0x10CE6, 0x10CA6], [0x10CE7, 0x10CA7], [0x10CE8, 0x10CA8], [0x10CE9, 0x10CA9], [0x10CEA, 0x10CAA], [0x10CEB, 0x10CAB], [0x10CEC, 0x10CAC], [0x10CED, 0x10CAD], [0x10CEE, 0x10CAE], [0x10CEF, 0x10CAF], [0x10CF0, 0x10CB0], [0x10CF1, 0x10CB1], [0x10CF2, 0x10CB2], [0x118A0, 0x118C0], [0x118A1, 0x118C1], [0x118A2, 0x118C2], [0x118A3, 0x118C3], [0x118A4, 0x118C4], [0x118A5, 0x118C5], [0x118A6, 0x118C6], [0x118A7, 0x118C7], [0x118A8, 0x118C8], [0x118A9, 0x118C9], [0x118AA, 0x118CA], [0x118AB, 0x118CB], [0x118AC, 0x118CC], [0x118AD, 0x118CD], [0x118AE, 0x118CE], [0x118AF, 0x118CF], [0x118B0, 0x118D0], [0x118B1, 0x118D1], [0x118B2, 0x118D2], [0x118B3, 0x118D3], [0x118B4, 0x118D4], [0x118B5, 0x118D5], [0x118B6, 0x118D6], [0x118B7, 0x118D7], [0x118B8, 0x118D8], [0x118B9, 0x118D9], [0x118BA, 0x118DA], [0x118BB, 0x118DB], [0x118BC, 0x118DC], [0x118BD, 0x118DD], [0x118BE, 0x118DE], [0x118BF, 0x118DF], [0x118C0, 0x118A0], [0x118C1, 0x118A1], [0x118C2, 0x118A2], [0x118C3, 0x118A3], [0x118C4, 0x118A4], [0x118C5, 0x118A5], [0x118C6, 0x118A6], [0x118C7, 0x118A7], [0x118C8, 0x118A8], [0x118C9, 0x118A9], [0x118CA, 0x118AA], [0x118CB, 0x118AB], [0x118CC, 0x118AC], [0x118CD, 0x118AD], [0x118CE, 0x118AE], [0x118CF, 0x118AF], [0x118D0, 0x118B0], [0x118D1, 0x118B1], [0x118D2, 0x118B2], [0x118D3, 0x118B3], [0x118D4, 0x118B4], [0x118D5, 0x118B5], [0x118D6, 0x118B6], [0x118D7, 0x118B7], [0x118D8, 0x118B8], [0x118D9, 0x118B9], [0x118DA, 0x118BA], [0x118DB, 0x118BB], [0x118DC, 0x118BC], [0x118DD, 0x118BD], [0x118DE, 0x118BE], [0x118DF, 0x118BF], [0x16E40, 0x16E60], [0x16E41, 0x16E61], [0x16E42, 0x16E62], [0x16E43, 0x16E63], [0x16E44, 0x16E64], [0x16E45, 0x16E65], [0x16E46, 0x16E66], [0x16E47, 0x16E67], [0x16E48, 0x16E68], [0x16E49, 0x16E69], [0x16E4A, 0x16E6A], [0x16E4B, 0x16E6B], [0x16E4C, 0x16E6C], [0x16E4D, 0x16E6D], [0x16E4E, 0x16E6E], [0x16E4F, 0x16E6F], [0x16E50, 0x16E70], [0x16E51, 0x16E71], [0x16E52, 0x16E72], [0x16E53, 0x16E73], [0x16E54, 0x16E74], [0x16E55, 0x16E75], [0x16E56, 0x16E76], [0x16E57, 0x16E77], [0x16E58, 0x16E78], [0x16E59, 0x16E79], [0x16E5A, 0x16E7A], [0x16E5B, 0x16E7B], [0x16E5C, 0x16E7C], [0x16E5D, 0x16E7D], [0x16E5E, 0x16E7E], [0x16E5F, 0x16E7F], [0x16E60, 0x16E40], [0x16E61, 0x16E41], [0x16E62, 0x16E42], [0x16E63, 0x16E43], [0x16E64, 0x16E44], [0x16E65, 0x16E45], [0x16E66, 0x16E46], [0x16E67, 0x16E47], [0x16E68, 0x16E48], [0x16E69, 0x16E49], [0x16E6A, 0x16E4A], [0x16E6B, 0x16E4B], [0x16E6C, 0x16E4C], [0x16E6D, 0x16E4D], [0x16E6E, 0x16E4E], [0x16E6F, 0x16E4F], [0x16E70, 0x16E50], [0x16E71, 0x16E51], [0x16E72, 0x16E52], [0x16E73, 0x16E53], [0x16E74, 0x16E54], [0x16E75, 0x16E55], [0x16E76, 0x16E56], [0x16E77, 0x16E57], [0x16E78, 0x16E58], [0x16E79, 0x16E59], [0x16E7A, 0x16E5A], [0x16E7B, 0x16E5B], [0x16E7C, 0x16E5C], [0x16E7D, 0x16E5D], [0x16E7E, 0x16E5E], [0x16E7F, 0x16E5F], [0x1E900, 0x1E922], [0x1E901, 0x1E923], [0x1E902, 0x1E924], [0x1E903, 0x1E925], [0x1E904, 0x1E926], [0x1E905, 0x1E927], [0x1E906, 0x1E928], [0x1E907, 0x1E929], [0x1E908, 0x1E92A], [0x1E909, 0x1E92B], [0x1E90A, 0x1E92C], [0x1E90B, 0x1E92D], [0x1E90C, 0x1E92E], [0x1E90D, 0x1E92F], [0x1E90E, 0x1E930], [0x1E90F, 0x1E931], [0x1E910, 0x1E932], [0x1E911, 0x1E933], [0x1E912, 0x1E934], [0x1E913, 0x1E935], [0x1E914, 0x1E936], [0x1E915, 0x1E937], [0x1E916, 0x1E938], [0x1E917, 0x1E939], [0x1E918, 0x1E93A], [0x1E919, 0x1E93B], [0x1E91A, 0x1E93C], [0x1E91B, 0x1E93D], [0x1E91C, 0x1E93E], [0x1E91D, 0x1E93F], [0x1E91E, 0x1E940], [0x1E91F, 0x1E941], [0x1E920, 0x1E942], [0x1E921, 0x1E943], [0x1E922, 0x1E900], [0x1E923, 0x1E901], [0x1E924, 0x1E902], [0x1E925, 0x1E903], [0x1E926, 0x1E904], [0x1E927, 0x1E905], [0x1E928, 0x1E906], [0x1E929, 0x1E907], [0x1E92A, 0x1E908], [0x1E92B, 0x1E909], [0x1E92C, 0x1E90A], [0x1E92D, 0x1E90B], [0x1E92E, 0x1E90C], [0x1E92F, 0x1E90D], [0x1E930, 0x1E90E], [0x1E931, 0x1E90F], [0x1E932, 0x1E910], [0x1E933, 0x1E911], [0x1E934, 0x1E912], [0x1E935, 0x1E913], [0x1E936, 0x1E914], [0x1E937, 0x1E915], [0x1E938, 0x1E916], [0x1E939, 0x1E917], [0x1E93A, 0x1E918], [0x1E93B, 0x1E919], [0x1E93C, 0x1E91A], [0x1E93D, 0x1E91B], [0x1E93E, 0x1E91C], [0x1E93F, 0x1E91D], [0x1E940, 0x1E91E], [0x1E941, 0x1E91F], [0x1E942, 0x1E920], [0x1E943, 0x1E921]]);

  var REGULAR = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0xFFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0xFFFF)], ['w', regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0xFFFF)]]);
  var UNICODE = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF)], ['w', regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)]]);
  var UNICODE_IGNORE_CASE = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF)], ['w', regenerate(0x5F, 0x17F, 0x212A).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x17E).addRange(0x180, 0x2129).addRange(0x212B, 0x10FFFF)]]);

  var characterClassEscapeSets = {
    REGULAR: REGULAR,
    UNICODE: UNICODE,
    UNICODE_IGNORE_CASE: UNICODE_IGNORE_CASE
  };

  var generate = regjsgen.generate;

  var parse$4 = parser$1.parse;











  var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);
  var BMP_SET = regenerate().addRange(0x0, 0xFFFF);
  var DOT_SET_UNICODE = UNICODE_SET.clone().remove(0x000A, 0x000D, 0x2028, 0x2029);

  var getCharacterClassEscapeSet = function getCharacterClassEscapeSet(character, unicode, ignoreCase) {
    if (unicode) {
      if (ignoreCase) {
        return characterClassEscapeSets.UNICODE_IGNORE_CASE.get(character);
      }

      return characterClassEscapeSets.UNICODE.get(character);
    }

    return characterClassEscapeSets.REGULAR.get(character);
  };

  var getUnicodeDotSet = function getUnicodeDotSet(dotAll) {
    return dotAll ? UNICODE_SET : DOT_SET_UNICODE;
  };

  var getUnicodePropertyValueSet = function getUnicodePropertyValueSet(property, value) {
    var path = value ? property + "/" + value : "Binary_Property/" + property;

    try {
      return commonjsRequire("regenerate-unicode-properties/" + path + ".js");
    } catch (exception) {
      throw new Error("Failed to recognize value `" + value + "` for property " + ("`" + property + "`."));
    }
  };

  var handleLoneUnicodePropertyNameOrValue = function handleLoneUnicodePropertyNameOrValue(value) {
    try {
      var _property = 'General_Category';
      var category = unicodeMatchPropertyValueEcmascript(_property, value);
      return getUnicodePropertyValueSet(_property, category);
    } catch (exception) {}

    var property = unicodeMatchPropertyEcmascript(value);
    return getUnicodePropertyValueSet(property);
  };

  var getUnicodePropertyEscapeSet = function getUnicodePropertyEscapeSet(value, isNegative) {
    var parts = value.split('=');
    var firstPart = parts[0];
    var set;

    if (parts.length == 1) {
      set = handleLoneUnicodePropertyNameOrValue(firstPart);
    } else {
      var property = unicodeMatchPropertyEcmascript(firstPart);

      var _value = unicodeMatchPropertyValueEcmascript(property, parts[1]);

      set = getUnicodePropertyValueSet(property, _value);
    }

    if (isNegative) {
      return UNICODE_SET.clone().remove(set);
    }

    return set.clone();
  };

  regenerate.prototype.iuAddRange = function (min, max) {
    var $this = this;

    do {
      var folded = caseFold(min);

      if (folded) {
        $this.add(folded);
      }
    } while (++min <= max);

    return $this;
  };

  var update = function update(item, pattern) {
    var tree = parse$4(pattern, config$1.useUnicodeFlag ? 'u' : '');

    switch (tree.type) {
      case 'characterClass':
      case 'group':
      case 'value':
        break;

      default:
        tree = wrap$1(tree, pattern);
    }

    Object.assign(item, tree);
  };

  var wrap$1 = function wrap(tree, pattern) {
    return {
      'type': 'group',
      'behavior': 'ignore',
      'body': [tree],
      'raw': "(?:" + pattern + ")"
    };
  };

  var caseFold = function caseFold(codePoint) {
    return iuMappings.get(codePoint) || false;
  };

  var processCharacterClass = function processCharacterClass(characterClassItem, regenerateOptions) {
    var set = regenerate();

    for (var _iterator = characterClassItem.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var item = _ref;

      switch (item.type) {
        case 'value':
          set.add(item.codePoint);

          if (config$1.ignoreCase && config$1.unicode && !config$1.useUnicodeFlag) {
            var folded = caseFold(item.codePoint);

            if (folded) {
              set.add(folded);
            }
          }

          break;

        case 'characterClassRange':
          var min = item.min.codePoint;
          var max = item.max.codePoint;
          set.addRange(min, max);

          if (config$1.ignoreCase && config$1.unicode && !config$1.useUnicodeFlag) {
            set.iuAddRange(min, max);
          }

          break;

        case 'characterClassEscape':
          set.add(getCharacterClassEscapeSet(item.value, config$1.unicode, config$1.ignoreCase));
          break;

        case 'unicodePropertyEscape':
          set.add(getUnicodePropertyEscapeSet(item.value, item.negative));
          break;

        default:
          throw new Error("Unknown term type: " + item.type);
      }
    }

    if (characterClassItem.negative) {
      set = (config$1.unicode ? UNICODE_SET : BMP_SET).clone().remove(set);
    }

    update(characterClassItem, set.toString(regenerateOptions));
    return characterClassItem;
  };

  var updateNamedReference = function updateNamedReference(item, index) {
    delete item.name;
    item.matchIndex = index;
  };

  var assertNoUnmatchedReferences = function assertNoUnmatchedReferences(groups) {
    var unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);

    if (unmatchedReferencesNames.length > 0) {
      throw new Error("Unknown group names: " + unmatchedReferencesNames);
    }
  };

  var processTerm = function processTerm(item, regenerateOptions, groups) {
    switch (item.type) {
      case 'dot':
        if (config$1.unicode) {
          update(item, getUnicodeDotSet(config$1.dotAll).toString(regenerateOptions));
        } else if (config$1.dotAll) {
          update(item, '[\\s\\S]');
        }

        break;

      case 'characterClass':
        item = processCharacterClass(item, regenerateOptions);
        break;

      case 'unicodePropertyEscape':
        if (config$1.unicodePropertyEscape) {
          update(item, getUnicodePropertyEscapeSet(item.value, item.negative).toString(regenerateOptions));
        }

        break;

      case 'characterClassEscape':
        update(item, getCharacterClassEscapeSet(item.value, config$1.unicode, config$1.ignoreCase).toString(regenerateOptions));
        break;

      case 'group':
        if (item.behavior == 'normal') {
          groups.lastIndex++;
        }

        if (item.name && config$1.namedGroup) {
          var name = item.name.value;

          if (groups.names[name]) {
            throw new Error("Multiple groups with the same name (" + name + ") are not allowed.");
          }

          var index = groups.lastIndex;
          delete item.name;
          groups.names[name] = index;

          if (groups.onNamedGroup) {
            groups.onNamedGroup.call(null, name, index);
          }

          if (groups.unmatchedReferences[name]) {
            groups.unmatchedReferences[name].forEach(function (reference) {
              updateNamedReference(reference, index);
            });
            delete groups.unmatchedReferences[name];
          }
        }

      case 'alternative':
      case 'disjunction':
      case 'quantifier':
        item.body = item.body.map(function (term) {
          return processTerm(term, regenerateOptions, groups);
        });
        break;

      case 'value':
        var codePoint = item.codePoint;
        var set = regenerate(codePoint);

        if (config$1.ignoreCase && config$1.unicode && !config$1.useUnicodeFlag) {
          var folded = caseFold(codePoint);

          if (folded) {
            set.add(folded);
          }
        }

        update(item, set.toString(regenerateOptions));
        break;

      case 'reference':
        if (item.name) {
          var _name = item.name.value;
          var _index = groups.names[_name];

          if (_index) {
            updateNamedReference(item, _index);
            break;
          }

          if (!groups.unmatchedReferences[_name]) {
            groups.unmatchedReferences[_name] = [];
          }

          groups.unmatchedReferences[_name].push(item);
        }

        break;

      case 'anchor':
      case 'empty':
      case 'group':
        break;

      default:
        throw new Error("Unknown term type: " + item.type);
    }

    return item;
  };

  var config$1 = {
    'ignoreCase': false,
    'unicode': false,
    'dotAll': false,
    'useUnicodeFlag': false,
    'unicodePropertyEscape': false,
    'namedGroup': false
  };

  var rewritePattern = function rewritePattern(pattern, flags, options) {
    config$1.unicode = flags && flags.includes('u');
    var regjsparserFeatures = {
      'unicodePropertyEscape': config$1.unicode,
      'namedGroups': true,
      'lookbehind': options && options.lookbehind
    };
    config$1.ignoreCase = flags && flags.includes('i');
    var supportDotAllFlag = options && options.dotAllFlag;
    config$1.dotAll = supportDotAllFlag && flags && flags.includes('s');
    config$1.namedGroup = options && options.namedGroup;
    config$1.useUnicodeFlag = options && options.useUnicodeFlag;
    config$1.unicodePropertyEscape = options && options.unicodePropertyEscape;
    var regenerateOptions = {
      'hasUnicodeFlag': config$1.useUnicodeFlag,
      'bmpOnly': !config$1.unicode
    };
    var groups = {
      'onNamedGroup': options && options.onNamedGroup,
      'lastIndex': 0,
      'names': Object.create(null),
      'unmatchedReferences': Object.create(null)
    };
    var tree = parse$4(pattern, flags, regjsparserFeatures);
    processTerm(tree, regenerateOptions, groups);
    assertNoUnmatchedReferences(groups);
    return generate(tree);
  };

  var rewritePattern_1 = rewritePattern;

  var FEATURES$1 = Object.freeze({
    unicodeFlag: 1 << 0,
    dotAllFlag: 1 << 1,
    unicodePropertyEscape: 1 << 2,
    namedCaptureGroups: 1 << 3
  });
  var featuresKey$1 = "@babel/plugin-regexp-features/featuresKey";
  var runtimeKey = "@babel/plugin-regexp-features/runtimeKey";
  function enableFeature$1(features, feature) {
    return features | feature;
  }
  function hasFeature$1(features, feature) {
    return !!(features & feature);
  }

  function generateRegexpuOptions(node, features) {
    var useUnicodeFlag = false,
        dotAllFlag = false,
        unicodePropertyEscape = false,
        namedGroup = false;
    var flags = node.flags,
        pattern = node.pattern;
    var flagsIncludesU = flags.includes("u");

    if (flagsIncludesU) {
      if (!hasFeature$1(features, FEATURES$1.unicodeFlag)) {
        useUnicodeFlag = true;
      }

      if (hasFeature$1(features, FEATURES$1.unicodePropertyEscape) && /\\[pP]{/.test(pattern)) {
        unicodePropertyEscape = true;
      }
    }

    if (hasFeature$1(features, FEATURES$1.dotAllFlag) && flags.indexOf("s") >= 0) {
      dotAllFlag = true;
    }

    if (hasFeature$1(features, FEATURES$1.namedCaptureGroups) && /\(\?<(?![=!])/.test(pattern)) {
      namedGroup = true;
    }

    if (!namedGroup && !unicodePropertyEscape && !dotAllFlag && (!flagsIncludesU || useUnicodeFlag)) {
      return null;
    }

    if (flagsIncludesU && flags.indexOf("s") >= 0) {
      dotAllFlag = true;
    }

    return {
      useUnicodeFlag: useUnicodeFlag,
      onNamedGroup: function onNamedGroup() {},
      namedGroup: namedGroup,
      unicodePropertyEscape: unicodePropertyEscape,
      dotAllFlag: dotAllFlag,
      lookbehind: true
    };
  }

  var name$1 = "@babel/helper-create-regexp-features-plugin";
  var version$5 = "7.8.8";
  var author$1 = "The Babel Team (https://babeljs.io/team)";
  var license$1 = "MIT";
  var description$1 = "Compile ESNext Regular Expressions to ES5";
  var repository$1 = {
    type: "git",
    url: "https://github.com/babel/babel",
    directory: "packages/babel-helper-create-regexp-features-plugin"
  };
  var main$1 = "lib/index.js";
  var publishConfig$1 = {
    access: "public"
  };
  var keywords$3 = [
    "babel",
    "babel-plugin"
  ];
  var dependencies$1 = {
    "@babel/helper-annotate-as-pure": "^7.8.3",
    "@babel/helper-regex": "^7.8.3",
    "regexpu-core": "^4.7.0"
  };
  var peerDependencies$1 = {
    "@babel/core": "^7.0.0"
  };
  var devDependencies$1 = {
    "@babel/core": "^7.8.6",
    "@babel/helper-plugin-test-runner": "^7.8.3"
  };
  var pkg$1 = {
    name: name$1,
    version: version$5,
    author: author$1,
    license: license$1,
    description: description$1,
    repository: repository$1,
    main: main$1,
    publishConfig: publishConfig$1,
    keywords: keywords$3,
    dependencies: dependencies$1,
    peerDependencies: peerDependencies$1,
    devDependencies: devDependencies$1
  };

  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }

    return -1;
  }

  var _baseIndexOfWith = baseIndexOfWith;

  var arrayProto$1 = Array.prototype;
  var splice$1 = arrayProto$1.splice;

  function basePullAll(array, values, iteratee, comparator) {
    var indexOf = comparator ? _baseIndexOfWith : _baseIndexOf,
        index = -1,
        length = values.length,
        seen = array;

    if (array === values) {
      values = _copyArray(values);
    }

    if (iteratee) {
      seen = _arrayMap(array, _baseUnary(iteratee));
    }

    while (++index < length) {
      var fromIndex = 0,
          value = values[index],
          computed = iteratee ? iteratee(value) : value;

      while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
        if (seen !== array) {
          splice$1.call(seen, fromIndex, 1);
        }

        splice$1.call(array, fromIndex, 1);
      }
    }

    return array;
  }

  var _basePullAll = basePullAll;

  function pullAll(array, values) {
    return array && array.length && values && values.length ? _basePullAll(array, values) : array;
  }

  var pullAll_1 = pullAll;

  var pull = _baseRest(pullAll_1);
  var pull_1 = pull;

  function is$2(node, flag) {
    return node.type === "RegExpLiteral" && node.flags.indexOf(flag) >= 0;
  }
  function pullFlag(node, flag) {
    var flags = node.flags.split("");
    if (node.flags.indexOf(flag) < 0) return;
    pull_1(flags, flag);
    node.flags = flags.join("");
  }

  var version$6 = pkg$1.version.split(".").reduce(function (v, x) {
    return v * 1e5 + +x;
  }, 0);
  var versionKey$1 = "@babel/plugin-regexp-features/version";
  function createRegExpFeaturePlugin(_ref) {
    var name = _ref.name,
        feature = _ref.feature,
        _ref$options = _ref.options,
        options = _ref$options === void 0 ? {} : _ref$options;
    return {
      name: name,
      pre: function pre() {
        var _file$get;

        var file = this.file;
        var features = (_file$get = file.get(featuresKey$1)) != null ? _file$get : 0;
        var newFeatures = enableFeature$1(features, FEATURES$1[feature]);
        var useUnicodeFlag = options.useUnicodeFlag,
            _options$runtime = options.runtime,
            runtime = _options$runtime === void 0 ? true : _options$runtime;

        if (useUnicodeFlag === false) {
          newFeatures = enableFeature$1(newFeatures, FEATURES$1.unicodeFlag);
        }

        if (newFeatures !== features) {
          file.set(featuresKey$1, newFeatures);
        }

        if (!runtime) {
          file.set(runtimeKey, false);
        }

        if (!file.has(versionKey$1) || file.get(versionKey$1) < version$6) {
          file.set(versionKey$1, version$6);
        }
      },
      visitor: {
        RegExpLiteral: function RegExpLiteral(path) {
          var _file$get2;

          var node = path.node;
          var file = this.file;
          var features = file.get(featuresKey$1);
          var runtime = (_file$get2 = file.get(runtimeKey)) != null ? _file$get2 : true;
          var regexpuOptions = generateRegexpuOptions(node, features);

          if (regexpuOptions === null) {
            return;
          }

          var namedCaptureGroups = {};

          if (regexpuOptions.namedGroup) {
            regexpuOptions.onNamedGroup = function (name, index) {
              namedCaptureGroups[name] = index;
            };
          }

          node.pattern = rewritePattern_1(node.pattern, node.flags, regexpuOptions);

          if (regexpuOptions.namedGroup && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {
            var call = CallExpression(this.addHelper("wrapRegExp"), [node, valueToNode(namedCaptureGroups)]);
            annotateAsPure(call);
            path.replaceWith(call);
          }

          if (hasFeature$1(features, FEATURES$1.unicodeFlag)) {
            pullFlag(node, "u");
          }

          if (hasFeature$1(features, FEATURES$1.dotAllFlag)) {
            pullFlag(node, "s");
          }
        }
      }
    };
  }

  function isRegExpTest(path) {
    return path.parentPath.isMemberExpression({
      object: path.node,
      computed: false
    }) && path.parentPath.get("property").isIdentifier({
      name: "test"
    });
  }

  var proposalUnicodePropertyRegex = declare(function (api, options) {
    api.assertVersion(7);
    var _options$useUnicodeFl = options.useUnicodeFlag,
        useUnicodeFlag = _options$useUnicodeFl === void 0 ? true : _options$useUnicodeFl;

    if (typeof useUnicodeFlag !== "boolean") {
      throw new Error(".useUnicodeFlag must be a boolean, or undefined");
    }

    return createRegExpFeaturePlugin({
      name: "proposal-unicode-property-regex",
      feature: "unicodePropertyEscape",
      options: {
        useUnicodeFlag: useUnicodeFlag
      }
    });
  });

  var transformAsyncToGenerator = declare(function (api, options) {
    api.assertVersion(7);
    var method = options.method,
        module = options.module;

    if (method && module) {
      return {
        name: "transform-async-to-generator",
        visitor: {
          Function: function Function(path, state) {
            if (!path.node.async || path.node.generator) return;
            var wrapAsync = state.methodWrapper;

            if (wrapAsync) {
              wrapAsync = cloneNode(wrapAsync);
            } else {
              wrapAsync = state.methodWrapper = addNamed(path, method, module);
            }

            remapAsyncToGenerator(path, {
              wrapAsync: wrapAsync
            });
          }
        }
      };
    }

    return {
      name: "transform-async-to-generator",
      visitor: {
        Function: function Function(path, state) {
          if (!path.node.async || path.node.generator) return;
          remapAsyncToGenerator(path, {
            wrapAsync: state.addHelper("asyncToGenerator")
          });
        }
      }
    };
  });

  var transformArrowFunctions = declare(function (api, options) {
    api.assertVersion(7);
    var spec = options.spec;
    return {
      name: "transform-arrow-functions",
      visitor: {
        ArrowFunctionExpression: function ArrowFunctionExpression(path) {
          if (!path.isArrowFunctionExpression()) return;
          path.arrowFunctionToExpression({
            allowInsertArrow: false,
            specCompliant: !!spec
          });
        }
      }
    };
  });

  var transformBlockScopedFunctions = declare(function (api) {
    api.assertVersion(7);

    function statementList(key, path) {
      var paths = path.get(key);

      for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var _path = _ref;
        var func = _path.node;
        if (!_path.isFunctionDeclaration()) continue;
        var declar = VariableDeclaration("let", [VariableDeclarator(func.id, toExpression(func))]);
        declar._blockHoist = 2;
        func.id = null;

        _path.replaceWith(declar);
      }
    }

    return {
      name: "transform-block-scoped-functions",
      visitor: {
        BlockStatement: function BlockStatement(path) {
          var node = path.node,
              parent = path.parent;

          if (isFunction(parent, {
            body: node
          }) || isExportDeclaration(parent)) {
            return;
          }

          statementList("body", path);
        },
        SwitchCase: function SwitchCase(path) {
          statementList("consequent", path);
        }
      }
    };
  });

  function _templateObject$7() {
    var data = _taggedTemplateLiteralLoose(["", "(\"", "\")"]);

    _templateObject$7 = function _templateObject() {
      return data;
    };

    return data;
  }

  function getTDZStatus(refPath, bindingPath) {
    var executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);

    if (executionStatus === "before") {
      return "outside";
    } else if (executionStatus === "after") {
      return "inside";
    } else {
      return "maybe";
    }
  }

  function buildTDZAssert(node, state) {
    return CallExpression(state.addHelper("temporalRef"), [node, StringLiteral(node.name)]);
  }

  function isReference(node, scope, state) {
    var declared = state.letReferences[node.name];
    if (!declared) return false;
    return scope.getBindingIdentifier(node.name) === declared;
  }

  var visitor$2 = {
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      if (!state.tdzEnabled) return;
      var node = path.node,
          parent = path.parent,
          scope = path.scope;
      if (path.parentPath.isFor({
        left: node
      })) return;
      if (!isReference(node, scope, state)) return;
      var bindingPath = scope.getBinding(node.name).path;
      if (bindingPath.isFunctionDeclaration()) return;
      var status = getTDZStatus(path, bindingPath);
      if (status === "outside") return;

      if (status === "maybe") {
        var assert = buildTDZAssert(node, state);
        bindingPath.parent._tdzThis = true;
        path.skip();

        if (path.parentPath.isUpdateExpression()) {
          if (parent._ignoreBlockScopingTDZ) return;
          path.parentPath.replaceWith(SequenceExpression([assert, parent]));
        } else {
          path.replaceWith(assert);
        }
      } else if (status === "inside") {
        path.replaceWith(template.ast(_templateObject$7(), state.addHelper("tdz"), node.name));
      }
    },
    AssignmentExpression: {
      exit: function exit(path, state) {
        if (!state.tdzEnabled) return;
        var node = path.node;
        if (node._ignoreBlockScopingTDZ) return;
        var nodes = [];
        var ids = path.getBindingIdentifiers();

        for (var _i = 0, _Object$keys = Object.keys(ids); _i < _Object$keys.length; _i++) {
          var name = _Object$keys[_i];
          var id = ids[name];

          if (isReference(id, path.scope, state)) {
            nodes.push(id);
          }
        }

        if (nodes.length) {
          node._ignoreBlockScopingTDZ = true;
          nodes.push(node);
          path.replaceWithMultiple(nodes.map(function (n) {
            return ExpressionStatement(n);
          }));
        }
      }
    }
  };

  function createAssigner(assigner) {
    return _baseRest(function (object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

      if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }

      object = Object(object);

      while (++index < length) {
        var source = sources[index];

        if (source) {
          assigner(object, source, index, customizer);
        }
      }

      return object;
    });
  }

  var _createAssigner = createAssigner;

  var assignIn = _createAssigner(function (object, source) {
    _copyObject(source, keysIn_1(source), object);
  });
  var assignIn_1 = assignIn;

  var extend$1 = assignIn_1;

  var DONE = new WeakSet();
  var transformBlockScoping = declare(function (api, opts) {
    api.assertVersion(7);
    var _opts$throwIfClosureR = opts.throwIfClosureRequired,
        throwIfClosureRequired = _opts$throwIfClosureR === void 0 ? false : _opts$throwIfClosureR,
        _opts$tdz = opts.tdz,
        tdzEnabled = _opts$tdz === void 0 ? false : _opts$tdz;

    if (typeof throwIfClosureRequired !== "boolean") {
      throw new Error(".throwIfClosureRequired must be a boolean, or undefined");
    }

    if (typeof tdzEnabled !== "boolean") {
      throw new Error(".tdz must be a boolean, or undefined");
    }

    return {
      name: "transform-block-scoping",
      visitor: {
        VariableDeclaration: function VariableDeclaration(path) {
          var node = path.node,
              parent = path.parent,
              scope = path.scope;
          if (!isBlockScoped$1(node)) return;
          convertBlockScopedToVar(path, null, parent, scope, true);

          if (node._tdzThis) {
            var nodes = [node];

            for (var i = 0; i < node.declarations.length; i++) {
              var decl = node.declarations[i];
              var assign = AssignmentExpression("=", decl.id, decl.init || scope.buildUndefinedNode());
              assign._ignoreBlockScopingTDZ = true;
              nodes.push(ExpressionStatement(assign));
              decl.init = this.addHelper("temporalUndefined");
            }

            node._blockHoist = 2;

            if (path.isCompletionRecord()) {
              nodes.push(ExpressionStatement(scope.buildUndefinedNode()));
            }

            path.replaceWithMultiple(nodes);
          }
        },
        Loop: function Loop(path, state) {
          var parent = path.parent,
              scope = path.scope;
          path.ensureBlock();
          var blockScoping = new BlockScoping(path, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state);
          var replace = blockScoping.run();
          if (replace) path.replaceWith(replace);
        },
        CatchClause: function CatchClause(path, state) {
          var parent = path.parent,
              scope = path.scope;
          var blockScoping = new BlockScoping(null, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state);
          blockScoping.run();
        },
        "BlockStatement|SwitchStatement|Program": function BlockStatementSwitchStatementProgram(path, state) {
          if (!ignoreBlock(path)) {
            var blockScoping = new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state);
            blockScoping.run();
          }
        }
      }
    };
  });

  function ignoreBlock(path) {
    return isLoop(path.parent) || isCatchClause(path.parent);
  }

  var buildRetCheck = template("\n  if (typeof RETURN === \"object\") return RETURN.v;\n");

  function isBlockScoped$1(node) {
    if (!isVariableDeclaration(node)) return false;
    if (node[BLOCK_SCOPED_SYMBOL]) return true;
    if (node.kind !== "let" && node.kind !== "const") return false;
    return true;
  }

  function isInLoop(path) {
    var loopOrFunctionParent = path.find(function (path) {
      return path.isLoop() || path.isFunction();
    });
    return loopOrFunctionParent && loopOrFunctionParent.isLoop();
  }

  function convertBlockScopedToVar(path, node, parent, scope, moveBindingsToParent) {
    if (moveBindingsToParent === void 0) {
      moveBindingsToParent = false;
    }

    if (!node) {
      node = path.node;
    }

    if (isInLoop(path) && !isFor(parent)) {
      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        declar.init = declar.init || scope.buildUndefinedNode();
      }
    }

    node[BLOCK_SCOPED_SYMBOL] = true;
    node.kind = "var";

    if (moveBindingsToParent) {
      var parentScope = scope.getFunctionParent() || scope.getProgramParent();

      for (var _i = 0, _Object$keys = Object.keys(path.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
        var name = _Object$keys[_i];
        var binding = scope.getOwnBinding(name);
        if (binding) binding.kind = "var";
        scope.moveBindingTo(name, parentScope);
      }
    }
  }

  function isVar$1(node) {
    return isVariableDeclaration(node, {
      kind: "var"
    }) && !isBlockScoped$1(node);
  }

  var letReferenceBlockVisitor = traverse$1.visitors.merge([{
    Loop: {
      enter: function enter(path, state) {
        state.loopDepth++;
      },
      exit: function exit(path, state) {
        state.loopDepth--;
      }
    },
    Function: function Function(path, state) {
      if (state.loopDepth > 0) {
        path.traverse(letReferenceFunctionVisitor, state);
      } else {
        path.traverse(visitor$2, state);
      }

      return path.skip();
    }
  }, visitor$2]);
  var letReferenceFunctionVisitor = traverse$1.visitors.merge([{
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      var ref = state.letReferences[path.node.name];
      if (!ref) return;
      var localBinding = path.scope.getBindingIdentifier(path.node.name);
      if (localBinding && localBinding !== ref) return;
      state.closurify = true;
    }
  }, visitor$2]);
  var hoistVarDeclarationsVisitor = {
    enter: function enter(path, self) {
      var node = path.node,
          parent = path.parent;

      if (path.isForStatement()) {
        if (isVar$1(node.init)) {
          var nodes = self.pushDeclar(node.init);

          if (nodes.length === 1) {
            node.init = nodes[0];
          } else {
            node.init = SequenceExpression(nodes);
          }
        }
      } else if (path.isFor()) {
        if (isVar$1(node.left)) {
          self.pushDeclar(node.left);
          node.left = node.left.declarations[0].id;
        }
      } else if (isVar$1(node)) {
        path.replaceWithMultiple(self.pushDeclar(node).map(function (expr) {
          return ExpressionStatement(expr);
        }));
      } else if (path.isFunction()) {
        return path.skip();
      }
    }
  };
  var loopLabelVisitor = {
    LabeledStatement: function LabeledStatement(_ref, state) {
      var node = _ref.node;
      state.innerLabels.push(node.label.name);
    }
  };
  var continuationVisitor = {
    enter: function enter(path, state) {
      if (path.isAssignmentExpression() || path.isUpdateExpression()) {
        for (var _i2 = 0, _Object$keys2 = Object.keys(path.getBindingIdentifiers()); _i2 < _Object$keys2.length; _i2++) {
          var name = _Object$keys2[_i2];

          if (state.outsideReferences[name] !== path.scope.getBindingIdentifier(name)) {
            continue;
          }

          state.reassignments[name] = true;
        }
      } else if (path.isReturnStatement()) {
        state.returnStatements.push(path);
      }
    }
  };

  function loopNodeTo(node) {
    if (isBreakStatement(node)) {
      return "break";
    } else if (isContinueStatement(node)) {
      return "continue";
    }
  }

  var loopVisitor = {
    Loop: function Loop(path, state) {
      var oldIgnoreLabeless = state.ignoreLabeless;
      state.ignoreLabeless = true;
      path.traverse(loopVisitor, state);
      state.ignoreLabeless = oldIgnoreLabeless;
      path.skip();
    },
    Function: function Function(path) {
      path.skip();
    },
    SwitchCase: function SwitchCase(path, state) {
      var oldInSwitchCase = state.inSwitchCase;
      state.inSwitchCase = true;
      path.traverse(loopVisitor, state);
      state.inSwitchCase = oldInSwitchCase;
      path.skip();
    },
    "BreakStatement|ContinueStatement|ReturnStatement": function BreakStatementContinueStatementReturnStatement(path, state) {
      var node = path.node,
          scope = path.scope;
      if (node[this.LOOP_IGNORE]) return;
      var replace;
      var loopText = loopNodeTo(node);

      if (loopText) {
        if (node.label) {
          if (state.innerLabels.indexOf(node.label.name) >= 0) {
            return;
          }

          loopText = loopText + "|" + node.label.name;
        } else {
          if (state.ignoreLabeless) return;
          if (isBreakStatement(node) && state.inSwitchCase) return;
        }

        state.hasBreakContinue = true;
        state.map[loopText] = node;
        replace = StringLiteral(loopText);
      }

      if (path.isReturnStatement()) {
        state.hasReturn = true;
        replace = ObjectExpression([ObjectProperty(Identifier("v"), node.argument || scope.buildUndefinedNode())]);
      }

      if (replace) {
        replace = ReturnStatement(replace);
        replace[this.LOOP_IGNORE] = true;
        path.skip();
        path.replaceWith(inherits(replace, node));
      }
    }
  };

  var BlockScoping = function () {
    function BlockScoping(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {
      this.parent = parent;
      this.scope = scope;
      this.state = state;
      this.throwIfClosureRequired = throwIfClosureRequired;
      this.tdzEnabled = tdzEnabled;
      this.blockPath = blockPath;
      this.block = blockPath.node;
      this.outsideLetReferences = Object.create(null);
      this.hasLetReferences = false;
      this.letReferences = Object.create(null);
      this.body = [];

      if (loopPath) {
        this.loopParent = loopPath.parent;
        this.loopLabel = isLabeledStatement(this.loopParent) && this.loopParent.label;
        this.loopPath = loopPath;
        this.loop = loopPath.node;
      }
    }

    var _proto = BlockScoping.prototype;

    _proto.run = function run() {
      var block = this.block;
      if (DONE.has(block)) return;
      DONE.add(block);
      var needsClosure = this.getLetReferences();
      this.checkConstants();

      if (isFunction(this.parent) || isProgram(this.block)) {
        this.updateScopeInfo();
        return;
      }

      if (!this.hasLetReferences) return;

      if (needsClosure) {
        this.wrapClosure();
      } else {
        this.remap();
      }

      this.updateScopeInfo(needsClosure);

      if (this.loopLabel && !isLabeledStatement(this.loopParent)) {
        return LabeledStatement(this.loopLabel, this.loop);
      }
    };

    _proto.checkConstants = function checkConstants() {
      var scope = this.scope;
      var state = this.state;

      for (var _i3 = 0, _Object$keys3 = Object.keys(scope.bindings); _i3 < _Object$keys3.length; _i3++) {
        var name = _Object$keys3[_i3];
        var binding = scope.bindings[name];
        if (binding.kind !== "const") continue;

        for (var _i4 = 0, _arr = binding.constantViolations; _i4 < _arr.length; _i4++) {
          var violation = _arr[_i4];
          var readOnlyError = state.addHelper("readOnlyError");
          var throwNode = CallExpression(readOnlyError, [StringLiteral(name)]);

          if (violation.isAssignmentExpression()) {
            violation.get("right").replaceWith(SequenceExpression([throwNode, violation.get("right").node]));
          } else if (violation.isUpdateExpression()) {
            violation.replaceWith(SequenceExpression([throwNode, violation.node]));
          } else if (violation.isForXStatement()) {
            violation.ensureBlock();
            violation.node.body.body.unshift(ExpressionStatement(throwNode));
          }
        }
      }
    };

    _proto.updateScopeInfo = function updateScopeInfo(wrappedInClosure) {
      var blockScope = this.blockPath.scope;
      var parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent();
      var letRefs = this.letReferences;

      for (var _i5 = 0, _Object$keys4 = Object.keys(letRefs); _i5 < _Object$keys4.length; _i5++) {
        var key = _Object$keys4[_i5];
        var ref = letRefs[key];
        var binding = blockScope.getBinding(ref.name);
        if (!binding) continue;

        if (binding.kind === "let" || binding.kind === "const") {
          binding.kind = "var";

          if (wrappedInClosure) {
            if (blockScope.hasOwnBinding(ref.name)) {
              blockScope.removeBinding(ref.name);
            }
          } else {
            blockScope.moveBindingTo(ref.name, parentScope);
          }
        }
      }
    };

    _proto.remap = function remap() {
      var letRefs = this.letReferences;
      var outsideLetRefs = this.outsideLetReferences;
      var scope = this.scope;
      var blockPathScope = this.blockPath.scope;

      for (var _i6 = 0, _Object$keys5 = Object.keys(letRefs); _i6 < _Object$keys5.length; _i6++) {
        var key = _Object$keys5[_i6];
        var ref = letRefs[key];

        if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {
          if (scope.hasOwnBinding(key)) {
            scope.rename(ref.name);
          }

          if (blockPathScope.hasOwnBinding(key)) {
            blockPathScope.rename(ref.name);
          }
        }
      }

      for (var _i7 = 0, _Object$keys6 = Object.keys(outsideLetRefs); _i7 < _Object$keys6.length; _i7++) {
        var _key = _Object$keys6[_i7];
        var _ref2 = letRefs[_key];

        if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(_key)) {
          blockPathScope.rename(_ref2.name);
        }
      }
    };

    _proto.wrapClosure = function wrapClosure() {
      if (this.throwIfClosureRequired) {
        throw this.blockPath.buildCodeFrameError("Compiling let/const in this block would add a closure " + "(throwIfClosureRequired).");
      }

      var block = this.block;
      var outsideRefs = this.outsideLetReferences;

      if (this.loop) {
        for (var _i8 = 0, _Object$keys7 = Object.keys(outsideRefs); _i8 < _Object$keys7.length; _i8++) {
          var name = _Object$keys7[_i8];
          var id = outsideRefs[name];

          if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {
            delete outsideRefs[id.name];
            delete this.letReferences[id.name];
            this.scope.rename(id.name);
            this.letReferences[id.name] = id;
            outsideRefs[id.name] = id;
          }
        }
      }

      this.has = this.checkLoop();
      this.hoistVarDeclarations();
      var args = values_1(outsideRefs).map(function (id) {
        return cloneNode(id);
      });
      var params = args.map(function (id) {
        return cloneNode(id);
      });
      var isSwitch = this.blockPath.isSwitchStatement();
      var fn = FunctionExpression(null, params, BlockStatement(isSwitch ? [block] : block.body));
      this.addContinuations(fn);
      var call = CallExpression(NullLiteral(), args);
      var basePath = ".callee";
      var hasYield = traverse$1.hasType(fn.body, "YieldExpression", FUNCTION_TYPES);

      if (hasYield) {
        fn.generator = true;
        call = YieldExpression(call, true);
        basePath = ".argument" + basePath;
      }

      var hasAsync = traverse$1.hasType(fn.body, "AwaitExpression", FUNCTION_TYPES);

      if (hasAsync) {
        fn.async = true;
        call = AwaitExpression(call);
        basePath = ".argument" + basePath;
      }

      var placeholderPath;
      var index;

      if (this.has.hasReturn || this.has.hasBreakContinue) {
        var ret = this.scope.generateUid("ret");
        this.body.push(VariableDeclaration("var", [VariableDeclarator(Identifier(ret), call)]));
        placeholderPath = "declarations.0.init" + basePath;
        index = this.body.length - 1;
        this.buildHas(ret);
      } else {
        this.body.push(ExpressionStatement(call));
        placeholderPath = "expression" + basePath;
        index = this.body.length - 1;
      }

      var callPath;

      if (isSwitch) {
        var _this$blockPath = this.blockPath,
            parentPath = _this$blockPath.parentPath,
            listKey = _this$blockPath.listKey,
            key = _this$blockPath.key;
        this.blockPath.replaceWithMultiple(this.body);
        callPath = parentPath.get(listKey)[key + index];
      } else {
        block.body = this.body;
        callPath = this.blockPath.get("body")[index];
      }

      var placeholder = callPath.get(placeholderPath);
      var fnPath;

      if (this.loop) {
        var loopId = this.scope.generateUid("loop");
        var p = this.loopPath.insertBefore(VariableDeclaration("var", [VariableDeclarator(Identifier(loopId), fn)]));
        placeholder.replaceWith(Identifier(loopId));
        fnPath = p[0].get("declarations.0.init");
      } else {
        placeholder.replaceWith(fn);
        fnPath = placeholder;
      }

      fnPath.unwrapFunctionEnvironment();
    };

    _proto.addContinuations = function addContinuations(fn) {
      var _this = this;

      var state = {
        reassignments: {},
        returnStatements: [],
        outsideReferences: this.outsideLetReferences
      };
      this.scope.traverse(fn, continuationVisitor, state);

      var _loop = function _loop(i) {
        var param = fn.params[i];
        if (!state.reassignments[param.name]) return "continue";
        var paramName = param.name;

        var newParamName = _this.scope.generateUid(param.name);

        fn.params[i] = Identifier(newParamName);

        _this.scope.rename(paramName, newParamName, fn);

        state.returnStatements.forEach(function (returnStatement) {
          returnStatement.insertBefore(ExpressionStatement(AssignmentExpression("=", Identifier(paramName), Identifier(newParamName))));
        });
        fn.body.body.push(ExpressionStatement(AssignmentExpression("=", Identifier(paramName), Identifier(newParamName))));
      };

      for (var i = 0; i < fn.params.length; i++) {
        var _ret = _loop(i);

        if (_ret === "continue") continue;
      }
    };

    _proto.getLetReferences = function getLetReferences() {
      var _this2 = this;

      var block = this.block;
      var declarators = [];

      if (this.loop) {
        var init = this.loop.left || this.loop.init;

        if (isBlockScoped$1(init)) {
          declarators.push(init);
          extend$1(this.outsideLetReferences, getBindingIdentifiers(init));
        }
      }

      var addDeclarationsFromChild = function addDeclarationsFromChild(path, node) {
        node = node || path.node;

        if (isClassDeclaration(node) || isFunctionDeclaration(node) || isBlockScoped$1(node)) {
          if (isBlockScoped$1(node)) {
            convertBlockScopedToVar(path, node, block, _this2.scope);
          }

          declarators = declarators.concat(node.declarations || node);
        }

        if (isLabeledStatement(node)) {
          addDeclarationsFromChild(path.get("body"), node.body);
        }
      };

      if (block.body) {
        var declarPaths = this.blockPath.get("body");

        for (var i = 0; i < block.body.length; i++) {
          addDeclarationsFromChild(declarPaths[i]);
        }
      }

      if (block.cases) {
        var _declarPaths = this.blockPath.get("cases");

        for (var _i9 = 0; _i9 < block.cases.length; _i9++) {
          var consequents = block.cases[_i9].consequent;

          for (var j = 0; j < consequents.length; j++) {
            var declar = consequents[j];
            addDeclarationsFromChild(_declarPaths[_i9], declar);
          }
        }
      }

      for (var _i10 = 0; _i10 < declarators.length; _i10++) {
        var _declar = declarators[_i10];
        var keys = getBindingIdentifiers(_declar, false, true);
        extend$1(this.letReferences, keys);
        this.hasLetReferences = true;
      }

      if (!this.hasLetReferences) return;
      var state = {
        letReferences: this.letReferences,
        closurify: false,
        loopDepth: 0,
        tdzEnabled: this.tdzEnabled,
        addHelper: function addHelper(name) {
          return _this2.state.addHelper(name);
        }
      };

      if (isInLoop(this.blockPath)) {
        state.loopDepth++;
      }

      this.blockPath.traverse(letReferenceBlockVisitor, state);
      return state.closurify;
    };

    _proto.checkLoop = function checkLoop() {
      var state = {
        hasBreakContinue: false,
        ignoreLabeless: false,
        inSwitchCase: false,
        innerLabels: [],
        hasReturn: false,
        isLoop: !!this.loop,
        map: {},
        LOOP_IGNORE: Symbol()
      };
      this.blockPath.traverse(loopLabelVisitor, state);
      this.blockPath.traverse(loopVisitor, state);
      return state;
    };

    _proto.hoistVarDeclarations = function hoistVarDeclarations() {
      this.blockPath.traverse(hoistVarDeclarationsVisitor, this);
    };

    _proto.pushDeclar = function pushDeclar(node) {
      var declars = [];
      var names = getBindingIdentifiers(node);

      for (var _i11 = 0, _Object$keys8 = Object.keys(names); _i11 < _Object$keys8.length; _i11++) {
        var name = _Object$keys8[_i11];
        declars.push(VariableDeclarator(names[name]));
      }

      this.body.push(VariableDeclaration(node.kind, declars));
      var replace = [];

      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        if (!declar.init) continue;
        var expr = AssignmentExpression("=", cloneNode(declar.id), cloneNode(declar.init));
        replace.push(inherits(expr, declar));
      }

      return replace;
    };

    _proto.buildHas = function buildHas(ret) {
      var body = this.body;
      var retCheck;
      var has = this.has;
      var cases = [];

      if (has.hasReturn) {
        retCheck = buildRetCheck({
          RETURN: Identifier(ret)
        });
      }

      if (has.hasBreakContinue) {
        for (var _i12 = 0, _Object$keys9 = Object.keys(has.map); _i12 < _Object$keys9.length; _i12++) {
          var key = _Object$keys9[_i12];
          cases.push(SwitchCase(StringLiteral(key), [has.map[key]]));
        }

        if (has.hasReturn) {
          cases.push(SwitchCase(null, [retCheck]));
        }

        if (cases.length === 1) {
          var single = cases[0];
          body.push(IfStatement(BinaryExpression("===", Identifier(ret), single.test), single.consequent[0]));
        } else {
          if (this.loop) {
            for (var i = 0; i < cases.length; i++) {
              var caseConsequent = cases[i].consequent[0];

              if (isBreakStatement(caseConsequent) && !caseConsequent.label) {
                if (!this.loopLabel) {
                  this.loopLabel = this.scope.generateUidIdentifier("loop");
                }

                caseConsequent.label = cloneNode(this.loopLabel);
              }
            }
          }

          body.push(SwitchStatement(Identifier(ret), cases));
        }
      } else {
        if (has.hasReturn) {
          body.push(retCheck);
        }
      }
    };

    return BlockScoping;
  }();

  var builtin$1 = {
    "Array": false,
    "ArrayBuffer": false,
    Atomics: false,
    BigInt: false,
    BigInt64Array: false,
    BigUint64Array: false,
    "Boolean": false,
    constructor: false,
    "DataView": false,
    "Date": false,
    "decodeURI": false,
    "decodeURIComponent": false,
    "encodeURI": false,
    "encodeURIComponent": false,
    "Error": false,
    "escape": false,
    "eval": false,
    "EvalError": false,
    "Float32Array": false,
    "Float64Array": false,
    "Function": false,
    globalThis: false,
    hasOwnProperty: false,
    "Infinity": false,
    "Int16Array": false,
    "Int32Array": false,
    "Int8Array": false,
    "isFinite": false,
    "isNaN": false,
    isPrototypeOf: false,
    "JSON": false,
    "Map": false,
    "Math": false,
    "NaN": false,
    "Number": false,
    "Object": false,
    "parseFloat": false,
    "parseInt": false,
    "Promise": false,
    propertyIsEnumerable: false,
    "Proxy": false,
    "RangeError": false,
    "ReferenceError": false,
    "Reflect": false,
    "RegExp": false,
    "Set": false,
    SharedArrayBuffer: false,
    "String": false,
    "Symbol": false,
    "SyntaxError": false,
    toLocaleString: false,
    toString: false,
    "TypeError": false,
    "Uint16Array": false,
    "Uint32Array": false,
    "Uint8Array": false,
    "Uint8ClampedArray": false,
    "undefined": false,
    "unescape": false,
    "URIError": false,
    valueOf: false,
    "WeakMap": false,
    "WeakSet": false
  };
  var es5$1 = {
    "Array": false,
    "Boolean": false,
    constructor: false,
    "Date": false,
    "decodeURI": false,
    "decodeURIComponent": false,
    "encodeURI": false,
    "encodeURIComponent": false,
    "Error": false,
    "escape": false,
    "eval": false,
    "EvalError": false,
    "Function": false,
    hasOwnProperty: false,
    "Infinity": false,
    "isFinite": false,
    "isNaN": false,
    isPrototypeOf: false,
    "JSON": false,
    "Math": false,
    "NaN": false,
    "Number": false,
    "Object": false,
    "parseFloat": false,
    "parseInt": false,
    propertyIsEnumerable: false,
    "RangeError": false,
    "ReferenceError": false,
    "RegExp": false,
    "String": false,
    "SyntaxError": false,
    toLocaleString: false,
    toString: false,
    "TypeError": false,
    "undefined": false,
    "unescape": false,
    "URIError": false,
    valueOf: false
  };
  var es2015$1 = {
    "Array": false,
    "ArrayBuffer": false,
    "Boolean": false,
    constructor: false,
    "DataView": false,
    "Date": false,
    "decodeURI": false,
    "decodeURIComponent": false,
    "encodeURI": false,
    "encodeURIComponent": false,
    "Error": false,
    "escape": false,
    "eval": false,
    "EvalError": false,
    "Float32Array": false,
    "Float64Array": false,
    "Function": false,
    hasOwnProperty: false,
    "Infinity": false,
    "Int16Array": false,
    "Int32Array": false,
    "Int8Array": false,
    "isFinite": false,
    "isNaN": false,
    isPrototypeOf: false,
    "JSON": false,
    "Map": false,
    "Math": false,
    "NaN": false,
    "Number": false,
    "Object": false,
    "parseFloat": false,
    "parseInt": false,
    "Promise": false,
    propertyIsEnumerable: false,
    "Proxy": false,
    "RangeError": false,
    "ReferenceError": false,
    "Reflect": false,
    "RegExp": false,
    "Set": false,
    "String": false,
    "Symbol": false,
    "SyntaxError": false,
    toLocaleString: false,
    toString: false,
    "TypeError": false,
    "Uint16Array": false,
    "Uint32Array": false,
    "Uint8Array": false,
    "Uint8ClampedArray": false,
    "undefined": false,
    "unescape": false,
    "URIError": false,
    valueOf: false,
    "WeakMap": false,
    "WeakSet": false
  };
  var es2017$1 = {
    "Array": false,
    "ArrayBuffer": false,
    Atomics: false,
    "Boolean": false,
    constructor: false,
    "DataView": false,
    "Date": false,
    "decodeURI": false,
    "decodeURIComponent": false,
    "encodeURI": false,
    "encodeURIComponent": false,
    "Error": false,
    "escape": false,
    "eval": false,
    "EvalError": false,
    "Float32Array": false,
    "Float64Array": false,
    "Function": false,
    hasOwnProperty: false,
    "Infinity": false,
    "Int16Array": false,
    "Int32Array": false,
    "Int8Array": false,
    "isFinite": false,
    "isNaN": false,
    isPrototypeOf: false,
    "JSON": false,
    "Map": false,
    "Math": false,
    "NaN": false,
    "Number": false,
    "Object": false,
    "parseFloat": false,
    "parseInt": false,
    "Promise": false,
    propertyIsEnumerable: false,
    "Proxy": false,
    "RangeError": false,
    "ReferenceError": false,
    "Reflect": false,
    "RegExp": false,
    "Set": false,
    SharedArrayBuffer: false,
    "String": false,
    "Symbol": false,
    "SyntaxError": false,
    toLocaleString: false,
    toString: false,
    "TypeError": false,
    "Uint16Array": false,
    "Uint32Array": false,
    "Uint8Array": false,
    "Uint8ClampedArray": false,
    "undefined": false,
    "unescape": false,
    "URIError": false,
    valueOf: false,
    "WeakMap": false,
    "WeakSet": false
  };
  var browser$5 = {
    AbortController: false,
    AbortSignal: false,
    addEventListener: false,
    alert: false,
    AnalyserNode: false,
    Animation: false,
    AnimationEffectReadOnly: false,
    AnimationEffectTiming: false,
    AnimationEffectTimingReadOnly: false,
    AnimationEvent: false,
    AnimationPlaybackEvent: false,
    AnimationTimeline: false,
    applicationCache: false,
    ApplicationCache: false,
    ApplicationCacheErrorEvent: false,
    atob: false,
    Attr: false,
    Audio: false,
    AudioBuffer: false,
    AudioBufferSourceNode: false,
    AudioContext: false,
    AudioDestinationNode: false,
    AudioListener: false,
    AudioNode: false,
    AudioParam: false,
    AudioProcessingEvent: false,
    AudioScheduledSourceNode: false,
    "AudioWorkletGlobalScope ": false,
    AudioWorkletNode: false,
    AudioWorkletProcessor: false,
    BarProp: false,
    BaseAudioContext: false,
    BatteryManager: false,
    BeforeUnloadEvent: false,
    BiquadFilterNode: false,
    Blob: false,
    BlobEvent: false,
    blur: false,
    BroadcastChannel: false,
    btoa: false,
    BudgetService: false,
    ByteLengthQueuingStrategy: false,
    Cache: false,
    caches: false,
    CacheStorage: false,
    cancelAnimationFrame: false,
    cancelIdleCallback: false,
    CanvasCaptureMediaStreamTrack: false,
    CanvasGradient: false,
    CanvasPattern: false,
    CanvasRenderingContext2D: false,
    ChannelMergerNode: false,
    ChannelSplitterNode: false,
    CharacterData: false,
    clearInterval: false,
    clearTimeout: false,
    clientInformation: false,
    ClipboardEvent: false,
    close: false,
    closed: false,
    CloseEvent: false,
    Comment: false,
    CompositionEvent: false,
    confirm: false,
    console: false,
    ConstantSourceNode: false,
    ConvolverNode: false,
    CountQueuingStrategy: false,
    createImageBitmap: false,
    Credential: false,
    CredentialsContainer: false,
    crypto: false,
    Crypto: false,
    CryptoKey: false,
    CSS: false,
    CSSConditionRule: false,
    CSSFontFaceRule: false,
    CSSGroupingRule: false,
    CSSImportRule: false,
    CSSKeyframeRule: false,
    CSSKeyframesRule: false,
    CSSMediaRule: false,
    CSSNamespaceRule: false,
    CSSPageRule: false,
    CSSRule: false,
    CSSRuleList: false,
    CSSStyleDeclaration: false,
    CSSStyleRule: false,
    CSSStyleSheet: false,
    CSSSupportsRule: false,
    CustomElementRegistry: false,
    customElements: false,
    CustomEvent: false,
    DataTransfer: false,
    DataTransferItem: false,
    DataTransferItemList: false,
    defaultstatus: false,
    defaultStatus: false,
    DelayNode: false,
    DeviceMotionEvent: false,
    DeviceOrientationEvent: false,
    devicePixelRatio: false,
    dispatchEvent: false,
    document: false,
    Document: false,
    DocumentFragment: false,
    DocumentType: false,
    DOMError: false,
    DOMException: false,
    DOMImplementation: false,
    DOMMatrix: false,
    DOMMatrixReadOnly: false,
    DOMParser: false,
    DOMPoint: false,
    DOMPointReadOnly: false,
    DOMQuad: false,
    DOMRect: false,
    DOMRectReadOnly: false,
    DOMStringList: false,
    DOMStringMap: false,
    DOMTokenList: false,
    DragEvent: false,
    DynamicsCompressorNode: false,
    Element: false,
    ErrorEvent: false,
    event: false,
    Event: false,
    EventSource: false,
    EventTarget: false,
    external: false,
    fetch: false,
    File: false,
    FileList: false,
    FileReader: false,
    find: false,
    focus: false,
    FocusEvent: false,
    FontFace: false,
    FontFaceSetLoadEvent: false,
    FormData: false,
    frameElement: false,
    frames: false,
    GainNode: false,
    Gamepad: false,
    GamepadButton: false,
    GamepadEvent: false,
    getComputedStyle: false,
    getSelection: false,
    HashChangeEvent: false,
    Headers: false,
    history: false,
    History: false,
    HTMLAllCollection: false,
    HTMLAnchorElement: false,
    HTMLAreaElement: false,
    HTMLAudioElement: false,
    HTMLBaseElement: false,
    HTMLBodyElement: false,
    HTMLBRElement: false,
    HTMLButtonElement: false,
    HTMLCanvasElement: false,
    HTMLCollection: false,
    HTMLContentElement: false,
    HTMLDataElement: false,
    HTMLDataListElement: false,
    HTMLDetailsElement: false,
    HTMLDialogElement: false,
    HTMLDirectoryElement: false,
    HTMLDivElement: false,
    HTMLDListElement: false,
    HTMLDocument: false,
    HTMLElement: false,
    HTMLEmbedElement: false,
    HTMLFieldSetElement: false,
    HTMLFontElement: false,
    HTMLFormControlsCollection: false,
    HTMLFormElement: false,
    HTMLFrameElement: false,
    HTMLFrameSetElement: false,
    HTMLHeadElement: false,
    HTMLHeadingElement: false,
    HTMLHRElement: false,
    HTMLHtmlElement: false,
    HTMLIFrameElement: false,
    HTMLImageElement: false,
    HTMLInputElement: false,
    HTMLLabelElement: false,
    HTMLLegendElement: false,
    HTMLLIElement: false,
    HTMLLinkElement: false,
    HTMLMapElement: false,
    HTMLMarqueeElement: false,
    HTMLMediaElement: false,
    HTMLMenuElement: false,
    HTMLMetaElement: false,
    HTMLMeterElement: false,
    HTMLModElement: false,
    HTMLObjectElement: false,
    HTMLOListElement: false,
    HTMLOptGroupElement: false,
    HTMLOptionElement: false,
    HTMLOptionsCollection: false,
    HTMLOutputElement: false,
    HTMLParagraphElement: false,
    HTMLParamElement: false,
    HTMLPictureElement: false,
    HTMLPreElement: false,
    HTMLProgressElement: false,
    HTMLQuoteElement: false,
    HTMLScriptElement: false,
    HTMLSelectElement: false,
    HTMLShadowElement: false,
    HTMLSlotElement: false,
    HTMLSourceElement: false,
    HTMLSpanElement: false,
    HTMLStyleElement: false,
    HTMLTableCaptionElement: false,
    HTMLTableCellElement: false,
    HTMLTableColElement: false,
    HTMLTableElement: false,
    HTMLTableRowElement: false,
    HTMLTableSectionElement: false,
    HTMLTemplateElement: false,
    HTMLTextAreaElement: false,
    HTMLTimeElement: false,
    HTMLTitleElement: false,
    HTMLTrackElement: false,
    HTMLUListElement: false,
    HTMLUnknownElement: false,
    HTMLVideoElement: false,
    IDBCursor: false,
    IDBCursorWithValue: false,
    IDBDatabase: false,
    IDBFactory: false,
    IDBIndex: false,
    IDBKeyRange: false,
    IDBObjectStore: false,
    IDBOpenDBRequest: false,
    IDBRequest: false,
    IDBTransaction: false,
    IDBVersionChangeEvent: false,
    IdleDeadline: false,
    IIRFilterNode: false,
    Image: false,
    ImageBitmap: false,
    ImageBitmapRenderingContext: false,
    ImageCapture: false,
    ImageData: false,
    indexedDB: false,
    innerHeight: false,
    innerWidth: false,
    InputEvent: false,
    IntersectionObserver: false,
    IntersectionObserverEntry: false,
    "Intl": false,
    isSecureContext: false,
    KeyboardEvent: false,
    KeyframeEffect: false,
    KeyframeEffectReadOnly: false,
    length: false,
    localStorage: false,
    location: true,
    Location: false,
    locationbar: false,
    matchMedia: false,
    MediaDeviceInfo: false,
    MediaDevices: false,
    MediaElementAudioSourceNode: false,
    MediaEncryptedEvent: false,
    MediaError: false,
    MediaKeyMessageEvent: false,
    MediaKeySession: false,
    MediaKeyStatusMap: false,
    MediaKeySystemAccess: false,
    MediaList: false,
    MediaQueryList: false,
    MediaQueryListEvent: false,
    MediaRecorder: false,
    MediaSettingsRange: false,
    MediaSource: false,
    MediaStream: false,
    MediaStreamAudioDestinationNode: false,
    MediaStreamAudioSourceNode: false,
    MediaStreamEvent: false,
    MediaStreamTrack: false,
    MediaStreamTrackEvent: false,
    menubar: false,
    MessageChannel: false,
    MessageEvent: false,
    MessagePort: false,
    MIDIAccess: false,
    MIDIConnectionEvent: false,
    MIDIInput: false,
    MIDIInputMap: false,
    MIDIMessageEvent: false,
    MIDIOutput: false,
    MIDIOutputMap: false,
    MIDIPort: false,
    MimeType: false,
    MimeTypeArray: false,
    MouseEvent: false,
    moveBy: false,
    moveTo: false,
    MutationEvent: false,
    MutationObserver: false,
    MutationRecord: false,
    name: false,
    NamedNodeMap: false,
    NavigationPreloadManager: false,
    navigator: false,
    Navigator: false,
    NetworkInformation: false,
    Node: false,
    NodeFilter: false,
    NodeIterator: false,
    NodeList: false,
    Notification: false,
    OfflineAudioCompletionEvent: false,
    OfflineAudioContext: false,
    offscreenBuffering: false,
    OffscreenCanvas: true,
    onabort: true,
    onafterprint: true,
    onanimationend: true,
    onanimationiteration: true,
    onanimationstart: true,
    onappinstalled: true,
    onauxclick: true,
    onbeforeinstallprompt: true,
    onbeforeprint: true,
    onbeforeunload: true,
    onblur: true,
    oncancel: true,
    oncanplay: true,
    oncanplaythrough: true,
    onchange: true,
    onclick: true,
    onclose: true,
    oncontextmenu: true,
    oncuechange: true,
    ondblclick: true,
    ondevicemotion: true,
    ondeviceorientation: true,
    ondeviceorientationabsolute: true,
    ondrag: true,
    ondragend: true,
    ondragenter: true,
    ondragleave: true,
    ondragover: true,
    ondragstart: true,
    ondrop: true,
    ondurationchange: true,
    onemptied: true,
    onended: true,
    onerror: true,
    onfocus: true,
    ongotpointercapture: true,
    onhashchange: true,
    oninput: true,
    oninvalid: true,
    onkeydown: true,
    onkeypress: true,
    onkeyup: true,
    onlanguagechange: true,
    onload: true,
    onloadeddata: true,
    onloadedmetadata: true,
    onloadstart: true,
    onlostpointercapture: true,
    onmessage: true,
    onmessageerror: true,
    onmousedown: true,
    onmouseenter: true,
    onmouseleave: true,
    onmousemove: true,
    onmouseout: true,
    onmouseover: true,
    onmouseup: true,
    onmousewheel: true,
    onoffline: true,
    ononline: true,
    onpagehide: true,
    onpageshow: true,
    onpause: true,
    onplay: true,
    onplaying: true,
    onpointercancel: true,
    onpointerdown: true,
    onpointerenter: true,
    onpointerleave: true,
    onpointermove: true,
    onpointerout: true,
    onpointerover: true,
    onpointerup: true,
    onpopstate: true,
    onprogress: true,
    onratechange: true,
    onrejectionhandled: true,
    onreset: true,
    onresize: true,
    onscroll: true,
    onsearch: true,
    onseeked: true,
    onseeking: true,
    onselect: true,
    onstalled: true,
    onstorage: true,
    onsubmit: true,
    onsuspend: true,
    ontimeupdate: true,
    ontoggle: true,
    ontransitionend: true,
    onunhandledrejection: true,
    onunload: true,
    onvolumechange: true,
    onwaiting: true,
    onwheel: true,
    open: false,
    openDatabase: false,
    opener: false,
    Option: false,
    origin: false,
    OscillatorNode: false,
    outerHeight: false,
    outerWidth: false,
    PageTransitionEvent: false,
    pageXOffset: false,
    pageYOffset: false,
    PannerNode: false,
    parent: false,
    Path2D: false,
    PaymentAddress: false,
    PaymentRequest: false,
    PaymentRequestUpdateEvent: false,
    PaymentResponse: false,
    performance: false,
    Performance: false,
    PerformanceEntry: false,
    PerformanceLongTaskTiming: false,
    PerformanceMark: false,
    PerformanceMeasure: false,
    PerformanceNavigation: false,
    PerformanceNavigationTiming: false,
    PerformanceObserver: false,
    PerformanceObserverEntryList: false,
    PerformancePaintTiming: false,
    PerformanceResourceTiming: false,
    PerformanceTiming: false,
    PeriodicWave: false,
    Permissions: false,
    PermissionStatus: false,
    personalbar: false,
    PhotoCapabilities: false,
    Plugin: false,
    PluginArray: false,
    PointerEvent: false,
    PopStateEvent: false,
    postMessage: false,
    Presentation: false,
    PresentationAvailability: false,
    PresentationConnection: false,
    PresentationConnectionAvailableEvent: false,
    PresentationConnectionCloseEvent: false,
    PresentationConnectionList: false,
    PresentationReceiver: false,
    PresentationRequest: false,
    print: false,
    ProcessingInstruction: false,
    ProgressEvent: false,
    PromiseRejectionEvent: false,
    prompt: false,
    PushManager: false,
    PushSubscription: false,
    PushSubscriptionOptions: false,
    queueMicrotask: false,
    RadioNodeList: false,
    Range: false,
    ReadableStream: false,
    registerProcessor: false,
    RemotePlayback: false,
    removeEventListener: false,
    Request: false,
    requestAnimationFrame: false,
    requestIdleCallback: false,
    resizeBy: false,
    ResizeObserver: false,
    ResizeObserverEntry: false,
    resizeTo: false,
    Response: false,
    RTCCertificate: false,
    RTCDataChannel: false,
    RTCDataChannelEvent: false,
    RTCDtlsTransport: false,
    RTCIceCandidate: false,
    RTCIceGatherer: false,
    RTCIceTransport: false,
    RTCPeerConnection: false,
    RTCPeerConnectionIceEvent: false,
    RTCRtpContributingSource: false,
    RTCRtpReceiver: false,
    RTCRtpSender: false,
    RTCSctpTransport: false,
    RTCSessionDescription: false,
    RTCStatsReport: false,
    RTCTrackEvent: false,
    screen: false,
    Screen: false,
    screenLeft: false,
    ScreenOrientation: false,
    screenTop: false,
    screenX: false,
    screenY: false,
    ScriptProcessorNode: false,
    scroll: false,
    scrollbars: false,
    scrollBy: false,
    scrollTo: false,
    scrollX: false,
    scrollY: false,
    SecurityPolicyViolationEvent: false,
    Selection: false,
    self: false,
    ServiceWorker: false,
    ServiceWorkerContainer: false,
    ServiceWorkerRegistration: false,
    sessionStorage: false,
    setInterval: false,
    setTimeout: false,
    ShadowRoot: false,
    SharedWorker: false,
    SourceBuffer: false,
    SourceBufferList: false,
    speechSynthesis: false,
    SpeechSynthesisEvent: false,
    SpeechSynthesisUtterance: false,
    StaticRange: false,
    status: false,
    statusbar: false,
    StereoPannerNode: false,
    stop: false,
    Storage: false,
    StorageEvent: false,
    StorageManager: false,
    styleMedia: false,
    StyleSheet: false,
    StyleSheetList: false,
    SubtleCrypto: false,
    SVGAElement: false,
    SVGAngle: false,
    SVGAnimatedAngle: false,
    SVGAnimatedBoolean: false,
    SVGAnimatedEnumeration: false,
    SVGAnimatedInteger: false,
    SVGAnimatedLength: false,
    SVGAnimatedLengthList: false,
    SVGAnimatedNumber: false,
    SVGAnimatedNumberList: false,
    SVGAnimatedPreserveAspectRatio: false,
    SVGAnimatedRect: false,
    SVGAnimatedString: false,
    SVGAnimatedTransformList: false,
    SVGAnimateElement: false,
    SVGAnimateMotionElement: false,
    SVGAnimateTransformElement: false,
    SVGAnimationElement: false,
    SVGCircleElement: false,
    SVGClipPathElement: false,
    SVGComponentTransferFunctionElement: false,
    SVGDefsElement: false,
    SVGDescElement: false,
    SVGDiscardElement: false,
    SVGElement: false,
    SVGEllipseElement: false,
    SVGFEBlendElement: false,
    SVGFEColorMatrixElement: false,
    SVGFEComponentTransferElement: false,
    SVGFECompositeElement: false,
    SVGFEConvolveMatrixElement: false,
    SVGFEDiffuseLightingElement: false,
    SVGFEDisplacementMapElement: false,
    SVGFEDistantLightElement: false,
    SVGFEDropShadowElement: false,
    SVGFEFloodElement: false,
    SVGFEFuncAElement: false,
    SVGFEFuncBElement: false,
    SVGFEFuncGElement: false,
    SVGFEFuncRElement: false,
    SVGFEGaussianBlurElement: false,
    SVGFEImageElement: false,
    SVGFEMergeElement: false,
    SVGFEMergeNodeElement: false,
    SVGFEMorphologyElement: false,
    SVGFEOffsetElement: false,
    SVGFEPointLightElement: false,
    SVGFESpecularLightingElement: false,
    SVGFESpotLightElement: false,
    SVGFETileElement: false,
    SVGFETurbulenceElement: false,
    SVGFilterElement: false,
    SVGForeignObjectElement: false,
    SVGGElement: false,
    SVGGeometryElement: false,
    SVGGradientElement: false,
    SVGGraphicsElement: false,
    SVGImageElement: false,
    SVGLength: false,
    SVGLengthList: false,
    SVGLinearGradientElement: false,
    SVGLineElement: false,
    SVGMarkerElement: false,
    SVGMaskElement: false,
    SVGMatrix: false,
    SVGMetadataElement: false,
    SVGMPathElement: false,
    SVGNumber: false,
    SVGNumberList: false,
    SVGPathElement: false,
    SVGPatternElement: false,
    SVGPoint: false,
    SVGPointList: false,
    SVGPolygonElement: false,
    SVGPolylineElement: false,
    SVGPreserveAspectRatio: false,
    SVGRadialGradientElement: false,
    SVGRect: false,
    SVGRectElement: false,
    SVGScriptElement: false,
    SVGSetElement: false,
    SVGStopElement: false,
    SVGStringList: false,
    SVGStyleElement: false,
    SVGSVGElement: false,
    SVGSwitchElement: false,
    SVGSymbolElement: false,
    SVGTextContentElement: false,
    SVGTextElement: false,
    SVGTextPathElement: false,
    SVGTextPositioningElement: false,
    SVGTitleElement: false,
    SVGTransform: false,
    SVGTransformList: false,
    SVGTSpanElement: false,
    SVGUnitTypes: false,
    SVGUseElement: false,
    SVGViewElement: false,
    TaskAttributionTiming: false,
    Text: false,
    TextDecoder: false,
    TextEncoder: false,
    TextEvent: false,
    TextMetrics: false,
    TextTrack: false,
    TextTrackCue: false,
    TextTrackCueList: false,
    TextTrackList: false,
    TimeRanges: false,
    toolbar: false,
    top: false,
    Touch: false,
    TouchEvent: false,
    TouchList: false,
    TrackEvent: false,
    TransitionEvent: false,
    TreeWalker: false,
    UIEvent: false,
    URL: false,
    URLSearchParams: false,
    ValidityState: false,
    visualViewport: false,
    VisualViewport: false,
    VTTCue: false,
    WaveShaperNode: false,
    WebAssembly: false,
    WebGL2RenderingContext: false,
    WebGLActiveInfo: false,
    WebGLBuffer: false,
    WebGLContextEvent: false,
    WebGLFramebuffer: false,
    WebGLProgram: false,
    WebGLQuery: false,
    WebGLRenderbuffer: false,
    WebGLRenderingContext: false,
    WebGLSampler: false,
    WebGLShader: false,
    WebGLShaderPrecisionFormat: false,
    WebGLSync: false,
    WebGLTexture: false,
    WebGLTransformFeedback: false,
    WebGLUniformLocation: false,
    WebGLVertexArrayObject: false,
    WebSocket: false,
    WheelEvent: false,
    window: false,
    Window: false,
    Worker: false,
    WritableStream: false,
    XMLDocument: false,
    XMLHttpRequest: false,
    XMLHttpRequestEventTarget: false,
    XMLHttpRequestUpload: false,
    XMLSerializer: false,
    XPathEvaluator: false,
    XPathExpression: false,
    XPathResult: false,
    XSLTProcessor: false
  };
  var worker$1 = {
    addEventListener: false,
    applicationCache: false,
    atob: false,
    Blob: false,
    BroadcastChannel: false,
    btoa: false,
    Cache: false,
    caches: false,
    clearInterval: false,
    clearTimeout: false,
    close: true,
    console: false,
    fetch: false,
    FileReaderSync: false,
    FormData: false,
    Headers: false,
    IDBCursor: false,
    IDBCursorWithValue: false,
    IDBDatabase: false,
    IDBFactory: false,
    IDBIndex: false,
    IDBKeyRange: false,
    IDBObjectStore: false,
    IDBOpenDBRequest: false,
    IDBRequest: false,
    IDBTransaction: false,
    IDBVersionChangeEvent: false,
    ImageData: false,
    importScripts: true,
    indexedDB: false,
    location: false,
    MessageChannel: false,
    MessagePort: false,
    name: false,
    navigator: false,
    Notification: false,
    onclose: true,
    onconnect: true,
    onerror: true,
    onlanguagechange: true,
    onmessage: true,
    onoffline: true,
    ononline: true,
    onrejectionhandled: true,
    onunhandledrejection: true,
    performance: false,
    Performance: false,
    PerformanceEntry: false,
    PerformanceMark: false,
    PerformanceMeasure: false,
    PerformanceNavigation: false,
    PerformanceResourceTiming: false,
    PerformanceTiming: false,
    postMessage: true,
    "Promise": false,
    queueMicrotask: false,
    removeEventListener: false,
    Request: false,
    Response: false,
    self: true,
    ServiceWorkerRegistration: false,
    setInterval: false,
    setTimeout: false,
    TextDecoder: false,
    TextEncoder: false,
    URL: false,
    URLSearchParams: false,
    WebSocket: false,
    Worker: false,
    WorkerGlobalScope: false,
    XMLHttpRequest: false
  };
  var node$1 = {
    __dirname: false,
    __filename: false,
    Buffer: false,
    clearImmediate: false,
    clearInterval: false,
    clearTimeout: false,
    console: false,
    exports: true,
    global: false,
    "Intl": false,
    module: false,
    process: false,
    queueMicrotask: false,
    require: false,
    setImmediate: false,
    setInterval: false,
    setTimeout: false,
    TextDecoder: false,
    TextEncoder: false,
    URL: false,
    URLSearchParams: false
  };
  var commonjs$1 = {
    exports: true,
    global: false,
    module: false,
    require: false
  };
  var amd$1 = {
    define: false,
    require: false
  };
  var mocha$1 = {
    after: false,
    afterEach: false,
    before: false,
    beforeEach: false,
    context: false,
    describe: false,
    it: false,
    mocha: false,
    run: false,
    setup: false,
    specify: false,
    suite: false,
    suiteSetup: false,
    suiteTeardown: false,
    teardown: false,
    test: false,
    xcontext: false,
    xdescribe: false,
    xit: false,
    xspecify: false
  };
  var jasmine$1 = {
    afterAll: false,
    afterEach: false,
    beforeAll: false,
    beforeEach: false,
    describe: false,
    expect: false,
    fail: false,
    fdescribe: false,
    fit: false,
    it: false,
    jasmine: false,
    pending: false,
    runs: false,
    spyOn: false,
    spyOnProperty: false,
    waits: false,
    waitsFor: false,
    xdescribe: false,
    xit: false
  };
  var jest$1 = {
    afterAll: false,
    afterEach: false,
    beforeAll: false,
    beforeEach: false,
    describe: false,
    expect: false,
    fdescribe: false,
    fit: false,
    it: false,
    jest: false,
    pit: false,
    require: false,
    test: false,
    xdescribe: false,
    xit: false,
    xtest: false
  };
  var qunit$1 = {
    asyncTest: false,
    deepEqual: false,
    equal: false,
    expect: false,
    module: false,
    notDeepEqual: false,
    notEqual: false,
    notOk: false,
    notPropEqual: false,
    notStrictEqual: false,
    ok: false,
    propEqual: false,
    QUnit: false,
    raises: false,
    start: false,
    stop: false,
    strictEqual: false,
    test: false,
    throws: false
  };
  var phantomjs$1 = {
    console: true,
    exports: true,
    phantom: true,
    require: true,
    WebPage: true
  };
  var couch$1 = {
    emit: false,
    exports: false,
    getRow: false,
    log: false,
    module: false,
    provides: false,
    require: false,
    respond: false,
    send: false,
    start: false,
    sum: false
  };
  var rhino$1 = {
    defineClass: false,
    deserialize: false,
    gc: false,
    help: false,
    importClass: false,
    importPackage: false,
    java: false,
    load: false,
    loadClass: false,
    Packages: false,
    print: false,
    quit: false,
    readFile: false,
    readUrl: false,
    runCommand: false,
    seal: false,
    serialize: false,
    spawn: false,
    sync: false,
    toint32: false,
    version: false
  };
  var nashorn$1 = {
    __DIR__: false,
    __FILE__: false,
    __LINE__: false,
    com: false,
    edu: false,
    exit: false,
    java: false,
    Java: false,
    javafx: false,
    JavaImporter: false,
    javax: false,
    JSAdapter: false,
    load: false,
    loadWithNewGlobal: false,
    org: false,
    Packages: false,
    print: false,
    quit: false
  };
  var wsh$1 = {
    ActiveXObject: true,
    Enumerator: true,
    GetObject: true,
    ScriptEngine: true,
    ScriptEngineBuildVersion: true,
    ScriptEngineMajorVersion: true,
    ScriptEngineMinorVersion: true,
    VBArray: true,
    WScript: true,
    WSH: true,
    XDomainRequest: true
  };
  var jquery$1 = {
    $: false,
    jQuery: false
  };
  var yui$1 = {
    YAHOO: false,
    YAHOO_config: false,
    YUI: false,
    YUI_config: false
  };
  var shelljs$1 = {
    cat: false,
    cd: false,
    chmod: false,
    config: false,
    cp: false,
    dirs: false,
    echo: false,
    env: false,
    error: false,
    exec: false,
    exit: false,
    find: false,
    grep: false,
    ln: false,
    ls: false,
    mkdir: false,
    mv: false,
    popd: false,
    pushd: false,
    pwd: false,
    rm: false,
    sed: false,
    set: false,
    target: false,
    tempdir: false,
    test: false,
    touch: false,
    which: false
  };
  var prototypejs$1 = {
    $: false,
    $$: false,
    $A: false,
    $break: false,
    $continue: false,
    $F: false,
    $H: false,
    $R: false,
    $w: false,
    Abstract: false,
    Ajax: false,
    Autocompleter: false,
    Builder: false,
    Class: false,
    Control: false,
    Draggable: false,
    Draggables: false,
    Droppables: false,
    Effect: false,
    Element: false,
    Enumerable: false,
    Event: false,
    Field: false,
    Form: false,
    Hash: false,
    Insertion: false,
    ObjectRange: false,
    PeriodicalExecuter: false,
    Position: false,
    Prototype: false,
    Scriptaculous: false,
    Selector: false,
    Sortable: false,
    SortableObserver: false,
    Sound: false,
    Template: false,
    Toggle: false,
    Try: false
  };
  var meteor$1 = {
    _: false,
    $: false,
    Accounts: false,
    AccountsClient: false,
    AccountsCommon: false,
    AccountsServer: false,
    App: false,
    Assets: false,
    Blaze: false,
    check: false,
    Cordova: false,
    DDP: false,
    DDPRateLimiter: false,
    DDPServer: false,
    Deps: false,
    EJSON: false,
    Email: false,
    HTTP: false,
    Log: false,
    Match: false,
    Meteor: false,
    Mongo: false,
    MongoInternals: false,
    Npm: false,
    Package: false,
    Plugin: false,
    process: false,
    Random: false,
    ReactiveDict: false,
    ReactiveVar: false,
    Router: false,
    ServiceConfiguration: false,
    Session: false,
    share: false,
    Spacebars: false,
    Template: false,
    Tinytest: false,
    Tracker: false,
    UI: false,
    Utils: false,
    WebApp: false,
    WebAppInternals: false
  };
  var mongo$1 = {
    _isWindows: false,
    _rand: false,
    BulkWriteResult: false,
    cat: false,
    cd: false,
    connect: false,
    db: false,
    getHostName: false,
    getMemInfo: false,
    hostname: false,
    ISODate: false,
    listFiles: false,
    load: false,
    ls: false,
    md5sumFile: false,
    mkdir: false,
    Mongo: false,
    NumberInt: false,
    NumberLong: false,
    ObjectId: false,
    PlanCache: false,
    print: false,
    printjson: false,
    pwd: false,
    quit: false,
    removeFile: false,
    rs: false,
    sh: false,
    UUID: false,
    version: false,
    WriteResult: false
  };
  var applescript$1 = {
    $: false,
    Application: false,
    Automation: false,
    console: false,
    delay: false,
    Library: false,
    ObjC: false,
    ObjectSpecifier: false,
    Path: false,
    Progress: false,
    Ref: false
  };
  var serviceworker$1 = {
    addEventListener: false,
    applicationCache: false,
    atob: false,
    Blob: false,
    BroadcastChannel: false,
    btoa: false,
    Cache: false,
    caches: false,
    CacheStorage: false,
    clearInterval: false,
    clearTimeout: false,
    Client: false,
    clients: false,
    Clients: false,
    close: true,
    console: false,
    ExtendableEvent: false,
    ExtendableMessageEvent: false,
    fetch: false,
    FetchEvent: false,
    FileReaderSync: false,
    FormData: false,
    Headers: false,
    IDBCursor: false,
    IDBCursorWithValue: false,
    IDBDatabase: false,
    IDBFactory: false,
    IDBIndex: false,
    IDBKeyRange: false,
    IDBObjectStore: false,
    IDBOpenDBRequest: false,
    IDBRequest: false,
    IDBTransaction: false,
    IDBVersionChangeEvent: false,
    ImageData: false,
    importScripts: false,
    indexedDB: false,
    location: false,
    MessageChannel: false,
    MessagePort: false,
    name: false,
    navigator: false,
    Notification: false,
    onclose: true,
    onconnect: true,
    onerror: true,
    onfetch: true,
    oninstall: true,
    onlanguagechange: true,
    onmessage: true,
    onmessageerror: true,
    onnotificationclick: true,
    onnotificationclose: true,
    onoffline: true,
    ononline: true,
    onpush: true,
    onpushsubscriptionchange: true,
    onrejectionhandled: true,
    onsync: true,
    onunhandledrejection: true,
    performance: false,
    Performance: false,
    PerformanceEntry: false,
    PerformanceMark: false,
    PerformanceMeasure: false,
    PerformanceNavigation: false,
    PerformanceResourceTiming: false,
    PerformanceTiming: false,
    postMessage: true,
    "Promise": false,
    queueMicrotask: false,
    registration: false,
    removeEventListener: false,
    Request: false,
    Response: false,
    self: false,
    ServiceWorker: false,
    ServiceWorkerContainer: false,
    ServiceWorkerGlobalScope: false,
    ServiceWorkerMessageEvent: false,
    ServiceWorkerRegistration: false,
    setInterval: false,
    setTimeout: false,
    skipWaiting: false,
    TextDecoder: false,
    TextEncoder: false,
    URL: false,
    URLSearchParams: false,
    WebSocket: false,
    WindowClient: false,
    Worker: false,
    WorkerGlobalScope: false,
    XMLHttpRequest: false
  };
  var atomtest$1 = {
    advanceClock: false,
    fakeClearInterval: false,
    fakeClearTimeout: false,
    fakeSetInterval: false,
    fakeSetTimeout: false,
    resetTimeouts: false,
    waitsForPromise: false
  };
  var embertest$1 = {
    andThen: false,
    click: false,
    currentPath: false,
    currentRouteName: false,
    currentURL: false,
    fillIn: false,
    find: false,
    findAll: false,
    findWithAssert: false,
    keyEvent: false,
    pauseTest: false,
    resumeTest: false,
    triggerEvent: false,
    visit: false,
    wait: false
  };
  var protractor$1 = {
    $: false,
    $$: false,
    browser: false,
    by: false,
    By: false,
    DartObject: false,
    element: false,
    protractor: false
  };
  var webextensions$1 = {
    browser: false,
    chrome: false,
    opr: false
  };
  var greasemonkey$1 = {
    cloneInto: false,
    createObjectIn: false,
    exportFunction: false,
    GM: false,
    GM_addStyle: false,
    GM_deleteValue: false,
    GM_getResourceText: false,
    GM_getResourceURL: false,
    GM_getValue: false,
    GM_info: false,
    GM_listValues: false,
    GM_log: false,
    GM_openInTab: false,
    GM_registerMenuCommand: false,
    GM_setClipboard: false,
    GM_setValue: false,
    GM_xmlhttpRequest: false,
    unsafeWindow: false
  };
  var devtools$1 = {
    $: false,
    $_: false,
    $$: false,
    $0: false,
    $1: false,
    $2: false,
    $3: false,
    $4: false,
    $x: false,
    chrome: false,
    clear: false,
    copy: false,
    debug: false,
    dir: false,
    dirxml: false,
    getEventListeners: false,
    inspect: false,
    keys: false,
    monitor: false,
    monitorEvents: false,
    profile: false,
    profileEnd: false,
    queryObjects: false,
    table: false,
    undebug: false,
    unmonitor: false,
    unmonitorEvents: false,
    values: false
  };
  var globals$3 = {
    builtin: builtin$1,
    es5: es5$1,
    es2015: es2015$1,
    es2017: es2017$1,
    browser: browser$5,
    worker: worker$1,
    node: node$1,
    commonjs: commonjs$1,
    amd: amd$1,
    mocha: mocha$1,
    jasmine: jasmine$1,
    jest: jest$1,
    qunit: qunit$1,
    phantomjs: phantomjs$1,
    couch: couch$1,
    rhino: rhino$1,
    nashorn: nashorn$1,
    wsh: wsh$1,
    jquery: jquery$1,
    yui: yui$1,
    shelljs: shelljs$1,
    prototypejs: prototypejs$1,
    meteor: meteor$1,
    mongo: mongo$1,
    applescript: applescript$1,
    serviceworker: serviceworker$1,
    atomtest: atomtest$1,
    embertest: embertest$1,
    protractor: protractor$1,
    "shared-node-browser": {
    clearInterval: false,
    clearTimeout: false,
    console: false,
    setInterval: false,
    setTimeout: false,
    URL: false,
    URLSearchParams: false
  },
    webextensions: webextensions$1,
    greasemonkey: greasemonkey$1,
    devtools: devtools$1
  };

  var globals$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    builtin: builtin$1,
    es5: es5$1,
    es2015: es2015$1,
    es2017: es2017$1,
    browser: browser$5,
    worker: worker$1,
    node: node$1,
    commonjs: commonjs$1,
    amd: amd$1,
    mocha: mocha$1,
    jasmine: jasmine$1,
    jest: jest$1,
    qunit: qunit$1,
    phantomjs: phantomjs$1,
    couch: couch$1,
    rhino: rhino$1,
    nashorn: nashorn$1,
    wsh: wsh$1,
    jquery: jquery$1,
    yui: yui$1,
    shelljs: shelljs$1,
    prototypejs: prototypejs$1,
    meteor: meteor$1,
    mongo: mongo$1,
    applescript: applescript$1,
    serviceworker: serviceworker$1,
    atomtest: atomtest$1,
    embertest: embertest$1,
    protractor: protractor$1,
    webextensions: webextensions$1,
    greasemonkey: greasemonkey$1,
    devtools: devtools$1,
    'default': globals$3
  });

  var require$$0$1 = getCjsExportFromNamespace(globals$4);

  var globals$5 = require$$0$1;

  var objectProto$h = Object.prototype;
  var hasOwnProperty$g = objectProto$h.hasOwnProperty;

  function baseHas(object, key) {
    return object != null && hasOwnProperty$g.call(object, key);
  }

  var _baseHas = baseHas;

  function has$5(object, path) {
    return object != null && _hasPath(object, path, _baseHas);
  }

  var has_1 = has$5;

  function toKind(node) {
    if (isClassMethod(node) || isObjectMethod(node)) {
      if (node.kind === "get" || node.kind === "set") {
        return node.kind;
      }
    }

    return "value";
  }

  function push(mutatorMap, node, kind, file, scope) {
    var alias = toKeyAlias(node);
    var map = {};
    if (has_1(mutatorMap, alias)) map = mutatorMap[alias];
    mutatorMap[alias] = map;
    map._inherits = map._inherits || [];

    map._inherits.push(node);

    map._key = node.key;

    if (node.computed) {
      map._computed = true;
    }

    if (node.decorators) {
      var decorators = map.decorators = map.decorators || ArrayExpression([]);
      decorators.elements = decorators.elements.concat(node.decorators.map(function (dec) {
        return dec.expression;
      }).reverse());
    }

    if (map.value || map.initializer) {
      throw file.buildCodeFrameError(node, "Key conflict with sibling node");
    }

    var key, value;

    if (isObjectProperty(node) || isObjectMethod(node) || isClassMethod(node)) {
      key = toComputedKey(node, node.key);
    }

    if (isProperty(node)) {
      value = node.value;
    } else if (isObjectMethod(node) || isClassMethod(node)) {
      value = FunctionExpression(null, node.params, node.body, node.generator, node.async);
      value.returnType = node.returnType;
    }

    var inheritedKind = toKind(node);

    if (!kind || inheritedKind !== "value") {
      kind = inheritedKind;
    }

    if (scope && isStringLiteral(key) && (kind === "value" || kind === "initializer") && isFunctionExpression(value)) {
      value = nameFunction({
        id: key,
        node: value,
        scope: scope
      });
    }

    if (value) {
      inheritsComments(value, node);
      map[kind] = value;
    }

    return map;
  }
  function toComputedObjectFromClass(obj) {
    var objExpr = ArrayExpression([]);

    for (var i = 0; i < obj.properties.length; i++) {
      var prop = obj.properties[i];
      var val = prop.value;
      val.properties.unshift(ObjectProperty(Identifier("key"), toComputedKey(prop)));
      objExpr.elements.push(val);
    }

    return objExpr;
  }
  function toClassObject(mutatorMap) {
    var objExpr = ObjectExpression([]);
    Object.keys(mutatorMap).forEach(function (mutatorMapKey) {
      var map = mutatorMap[mutatorMapKey];
      var mapNode = ObjectExpression([]);
      var propNode = ObjectProperty(map._key, mapNode, map._computed);
      Object.keys(map).forEach(function (key) {
        var node = map[key];
        if (key[0] === "_") return;
        var prop = ObjectProperty(Identifier(key), node);
        inheritsComments(prop, node);
        removeComments(node);
        mapNode.properties.push(prop);
      });
      objExpr.properties.push(propNode);
    });
    return objExpr;
  }
  function toDefineObject(mutatorMap) {
    Object.keys(mutatorMap).forEach(function (key) {
      var map = mutatorMap[key];
      if (map.value) map.writable = BooleanLiteral(true);
      map.configurable = BooleanLiteral(true);
      map.enumerable = BooleanLiteral(true);
    });
    return toClassObject(mutatorMap);
  }

  function _templateObject$8() {
    var data = _taggedTemplateLiteralLoose(["\n  function CREATE_SUPER(Derived) {\n    function isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n      // core-js@3\n      if (Reflect.construct.sham) return false;\n\n      // Proxy can't be polyfilled. Every browser implemented\n      // proxies before or at the same time as Reflect.construct,\n      // so if they support Proxy they also support Reflect.construct.\n      if (typeof Proxy === \"function\") return true;\n\n      // Since Reflect.construct can't be properly polyfilled, some\n      // implementations (e.g. core-js@2) don't set the correct internal slots.\n      // Those polyfills don't allow us to subclass built-ins, so we need to\n      // use our fallback implementation.\n      try {\n        // If the internal slots aren't set, this throws an error similar to\n        //   TypeError: this is not a Date object.\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    return function () {\n      var Super = GET_PROTOTYPE_OF(Derived), result;\n      if (isNativeReflectConstruct()) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = GET_PROTOTYPE_OF(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return POSSIBLE_CONSTRUCTOR_RETURN(this, result);\n    }\n  }\n"]);

    _templateObject$8 = function _templateObject() {
      return data;
    };

    return data;
  }
  var helperIDs = new WeakMap();
  function addCreateSuperHelper(file) {
    try {
      return file.addHelper("createSuper");
    } catch (_unused) {}

    if (helperIDs.has(file)) {
      return (cloneNode || clone$1)(helperIDs.get(file));
    }

    var id = file.scope.generateUidIdentifier("createSuper");
    helperIDs.set(file, id);
    var fn = helper$1({
      CREATE_SUPER: id,
      GET_PROTOTYPE_OF: file.addHelper("getPrototypeOf"),
      POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper("possibleConstructorReturn")
    });
    file.path.unshiftContainer("body", [fn]);
    file.scope.registerDeclaration(file.path.get("body.0"));
    return cloneNode(id);
  }
  var helper$1 = template.statement(_templateObject$8());

  function _templateObject$9() {
    var data = _taggedTemplateLiteralLoose(["\n        (function () {\n          super(...arguments);\n        })\n      "]);

    _templateObject$9 = function _templateObject() {
      return data;
    };

    return data;
  }

  function buildConstructor(classRef, constructorBody, node) {
    var func = FunctionDeclaration(cloneNode(classRef), [], constructorBody);
    inherits(func, node);
    return func;
  }

  function transformClass(path, file, builtinClasses, isLoose) {
    var classState = {
      parent: undefined,
      scope: undefined,
      node: undefined,
      path: undefined,
      file: undefined,
      classId: undefined,
      classRef: undefined,
      superFnId: undefined,
      superName: undefined,
      superReturns: [],
      isDerived: false,
      extendsNative: false,
      construct: undefined,
      constructorBody: undefined,
      userConstructor: undefined,
      userConstructorPath: undefined,
      hasConstructor: false,
      instancePropBody: [],
      instancePropRefs: {},
      staticPropBody: [],
      body: [],
      superThises: [],
      pushedConstructor: false,
      pushedInherits: false,
      protoAlias: null,
      isLoose: false,
      hasInstanceDescriptors: false,
      hasStaticDescriptors: false,
      instanceMutatorMap: {},
      staticMutatorMap: {}
    };

    var setState = function setState(newState) {
      Object.assign(classState, newState);
    };

    var findThisesVisitor = traverse$1.visitors.merge([environmentVisitor, {
      ThisExpression: function ThisExpression(path) {
        classState.superThises.push(path);
      }
    }]);

    function pushToMap(node, enumerable, kind, scope) {
      if (kind === void 0) {
        kind = "value";
      }

      var mutatorMap;

      if (node["static"]) {
        setState({
          hasStaticDescriptors: true
        });
        mutatorMap = classState.staticMutatorMap;
      } else {
        setState({
          hasInstanceDescriptors: true
        });
        mutatorMap = classState.instanceMutatorMap;
      }

      var map = push(mutatorMap, node, kind, classState.file, scope);

      if (enumerable) {
        map.enumerable = BooleanLiteral(true);
      }

      return map;
    }

    function maybeCreateConstructor() {
      var hasConstructor = false;
      var paths = classState.path.get("body.body");

      for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var _path = _ref;
        hasConstructor = _path.equals("kind", "constructor");
        if (hasConstructor) break;
      }

      if (hasConstructor) return;
      var params, body;

      if (classState.isDerived) {
        var _constructor = template.expression.ast(_templateObject$9());

        params = _constructor.params;
        body = _constructor.body;
      } else {
        params = [];
        body = BlockStatement([]);
      }

      classState.path.get("body").unshiftContainer("body", ClassMethod("constructor", Identifier("constructor"), params, body));
    }

    function buildBody() {
      maybeCreateConstructor();
      pushBody();
      verifyConstructor();

      if (classState.userConstructor) {
        var constructorBody = classState.constructorBody,
            userConstructor = classState.userConstructor,
            construct = classState.construct;
        constructorBody.body = constructorBody.body.concat(userConstructor.body.body);
        inherits(construct, userConstructor);
        inherits(constructorBody, userConstructor.body);
      }

      pushDescriptors();
    }

    function pushBody() {
      var classBodyPaths = classState.path.get("body.body");

      for (var _iterator2 = classBodyPaths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var _path2 = _ref2;
        var node = _path2.node;

        if (_path2.isClassProperty()) {
          throw _path2.buildCodeFrameError("Missing class properties transform.");
        }

        if (node.decorators) {
          throw _path2.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
        }

        if (isClassMethod(node)) {
          (function () {
            var isConstructor = node.kind === "constructor";
            var replaceSupers = new ReplaceSupers({
              methodPath: _path2,
              objectRef: classState.classRef,
              superRef: classState.superName,
              isLoose: classState.isLoose,
              file: classState.file
            });
            replaceSupers.replace();
            var superReturns = [];

            _path2.traverse(traverse$1.visitors.merge([environmentVisitor, {
              ReturnStatement: function ReturnStatement(path) {
                if (!path.getFunctionParent().isArrowFunctionExpression()) {
                  superReturns.push(path);
                }
              }
            }]));

            if (isConstructor) {
              pushConstructor(superReturns, node, _path2);
            } else {
              pushMethod(node, _path2);
            }
          })();
        }
      }
    }

    function clearDescriptors() {
      setState({
        hasInstanceDescriptors: false,
        hasStaticDescriptors: false,
        instanceMutatorMap: {},
        staticMutatorMap: {}
      });
    }

    function pushDescriptors() {
      pushInheritsToBody();
      var body = classState.body;
      var instanceProps;
      var staticProps;

      if (classState.hasInstanceDescriptors) {
        instanceProps = toClassObject(classState.instanceMutatorMap);
      }

      if (classState.hasStaticDescriptors) {
        staticProps = toClassObject(classState.staticMutatorMap);
      }

      if (instanceProps || staticProps) {
        if (instanceProps) {
          instanceProps = toComputedObjectFromClass(instanceProps);
        }

        if (staticProps) {
          staticProps = toComputedObjectFromClass(staticProps);
        }

        var args = [cloneNode(classState.classRef), NullLiteral(), NullLiteral()];
        if (instanceProps) args[1] = instanceProps;
        if (staticProps) args[2] = staticProps;
        var lastNonNullIndex = 0;

        for (var i = 0; i < args.length; i++) {
          if (!isNullLiteral(args[i])) lastNonNullIndex = i;
        }

        args = args.slice(0, lastNonNullIndex + 1);
        body.push(ExpressionStatement(CallExpression(classState.file.addHelper("createClass"), args)));
      }

      clearDescriptors();
    }

    function wrapSuperCall(bareSuper, superRef, thisRef, body) {
      var bareSuperNode = bareSuper.node;
      var call;

      if (classState.isLoose) {
        bareSuperNode.arguments.unshift(ThisExpression());

        if (bareSuperNode.arguments.length === 2 && isSpreadElement(bareSuperNode.arguments[1]) && isIdentifier(bareSuperNode.arguments[1].argument, {
          name: "arguments"
        })) {
          bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
          bareSuperNode.callee = MemberExpression(cloneNode(superRef), Identifier("apply"));
        } else {
          bareSuperNode.callee = MemberExpression(cloneNode(superRef), Identifier("call"));
        }

        call = LogicalExpression("||", bareSuperNode, ThisExpression());
      } else {
        call = optimiseCall(cloneNode(classState.superFnId), ThisExpression(), bareSuperNode.arguments);
      }

      if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {
        if (classState.superThises.length) {
          call = AssignmentExpression("=", thisRef(), call);
        }

        bareSuper.parentPath.replaceWith(ReturnStatement(call));
      } else {
        bareSuper.replaceWith(AssignmentExpression("=", thisRef(), call));
      }
    }

    function verifyConstructor() {
      if (!classState.isDerived) return;
      var path = classState.userConstructorPath;
      var body = path.get("body");
      path.traverse(findThisesVisitor);

      var _thisRef = function thisRef() {
        var ref = path.scope.generateDeclaredUidIdentifier("this");

        _thisRef = function thisRef() {
          return cloneNode(ref);
        };

        return ref;
      };

      for (var _iterator3 = classState.superThises, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var thisPath = _ref3;
        var node = thisPath.node,
            parentPath = thisPath.parentPath;

        if (parentPath.isMemberExpression({
          object: node
        })) {
          thisPath.replaceWith(_thisRef());
          continue;
        }

        thisPath.replaceWith(CallExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]));
      }

      var bareSupers = new Set();
      path.traverse(traverse$1.visitors.merge([environmentVisitor, {
        Super: function Super(path) {
          var node = path.node,
              parentPath = path.parentPath;

          if (parentPath.isCallExpression({
            callee: node
          })) {
            bareSupers.add(parentPath);
          }
        }
      }]));
      var guaranteedSuperBeforeFinish = !!bareSupers.size;

      for (var _iterator4 = bareSupers, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref4;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref4 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref4 = _i4.value;
        }

        var bareSuper = _ref4;
        wrapSuperCall(bareSuper, classState.superName, _thisRef, body);

        if (guaranteedSuperBeforeFinish) {
          bareSuper.find(function (parentPath) {
            if (parentPath === path) {
              return true;
            }

            if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {
              guaranteedSuperBeforeFinish = false;
              return true;
            }
          });
        }
      }

      var wrapReturn;

      if (classState.isLoose) {
        wrapReturn = function wrapReturn(returnArg) {
          var thisExpr = CallExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]);
          return returnArg ? LogicalExpression("||", returnArg, thisExpr) : thisExpr;
        };
      } else {
        wrapReturn = function wrapReturn(returnArg) {
          return CallExpression(classState.file.addHelper("possibleConstructorReturn"), [_thisRef()].concat(returnArg || []));
        };
      }

      var bodyPaths = body.get("body");

      if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {
        body.pushContainer("body", ReturnStatement(guaranteedSuperBeforeFinish ? _thisRef() : wrapReturn()));
      }

      for (var _iterator5 = classState.superReturns, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
        var _ref5;

        if (_isArray5) {
          if (_i5 >= _iterator5.length) break;
          _ref5 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done) break;
          _ref5 = _i5.value;
        }

        var returnPath = _ref5;
        returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
      }
    }

    function pushMethod(node, path) {
      var scope = path ? path.scope : classState.scope;

      if (node.kind === "method") {
        if (processMethod(node, scope)) return;
      }

      pushToMap(node, false, null, scope);
    }

    function processMethod(node, scope) {
      if (classState.isLoose && !node.decorators) {
        var classRef = classState.classRef;

        if (!node["static"]) {
          insertProtoAliasOnce();
          classRef = classState.protoAlias;
        }

        var methodName = MemberExpression(cloneNode(classRef), node.key, node.computed || isLiteral(node.key));
        var func = FunctionExpression(null, node.params, node.body, node.generator, node.async);
        inherits(func, node);
        var key = toComputedKey(node, node.key);

        if (isStringLiteral(key)) {
          func = nameFunction({
            node: func,
            id: key,
            scope: scope
          });
        }

        var expr = ExpressionStatement(AssignmentExpression("=", methodName, func));
        inheritsComments(expr, node);
        classState.body.push(expr);
        return true;
      }

      return false;
    }

    function insertProtoAliasOnce() {
      if (classState.protoAlias === null) {
        setState({
          protoAlias: classState.scope.generateUidIdentifier("proto")
        });
        var classProto = MemberExpression(classState.classRef, Identifier("prototype"));
        var protoDeclaration = VariableDeclaration("var", [VariableDeclarator(classState.protoAlias, classProto)]);
        classState.body.push(protoDeclaration);
      }
    }

    function pushConstructor(superReturns, method, path) {
      if (path.scope.hasOwnBinding(classState.classRef.name)) {
        path.scope.rename(classState.classRef.name);
      }

      setState({
        userConstructorPath: path,
        userConstructor: method,
        hasConstructor: true,
        superReturns: superReturns
      });
      var construct = classState.construct;
      inheritsComments(construct, method);
      construct.params = method.params;
      inherits(construct.body, method.body);
      construct.body.directives = method.body.directives;
      pushConstructorToBody();
    }

    function pushConstructorToBody() {
      if (classState.pushedConstructor) return;
      classState.pushedConstructor = true;

      if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {
        pushDescriptors();
      }

      classState.body.push(classState.construct);
      pushInheritsToBody();
    }

    function pushInheritsToBody() {
      if (!classState.isDerived || classState.pushedInherits) return;
      var superFnId = path.scope.generateUidIdentifier("super");
      setState({
        pushedInherits: true,
        superFnId: superFnId
      });
      classState.body.unshift(ExpressionStatement(CallExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [cloneNode(classState.classRef), cloneNode(classState.superName)])), VariableDeclaration("var", [VariableDeclarator(superFnId, CallExpression(addCreateSuperHelper(classState.file), [cloneNode(classState.classRef)]))]));
    }

    function setupClosureParamsArgs() {
      var superName = classState.superName;
      var closureParams = [];
      var closureArgs = [];

      if (classState.isDerived) {
        var arg = cloneNode(superName);

        if (classState.extendsNative) {
          arg = CallExpression(classState.file.addHelper("wrapNativeSuper"), [arg]);
          annotateAsPure(arg);
        }

        var param = classState.scope.generateUidIdentifierBasedOnNode(superName);
        closureParams.push(param);
        closureArgs.push(arg);
        setState({
          superName: cloneNode(param)
        });
      }

      return {
        closureParams: closureParams,
        closureArgs: closureArgs
      };
    }

    function classTransformer(path, file, builtinClasses, isLoose) {
      setState({
        parent: path.parent,
        scope: path.scope,
        node: path.node,
        path: path,
        file: file,
        isLoose: isLoose
      });
      setState({
        classId: classState.node.id,
        classRef: classState.node.id ? Identifier(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
        superName: classState.node.superClass,
        isDerived: !!classState.node.superClass,
        constructorBody: BlockStatement([])
      });
      setState({
        extendsNative: classState.isDerived && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)
      });
      var classRef = classState.classRef,
          node = classState.node,
          constructorBody = classState.constructorBody;
      setState({
        construct: buildConstructor(classRef, constructorBody, node)
      });
      var body = classState.body;

      var _setupClosureParamsAr = setupClosureParamsArgs(),
          closureParams = _setupClosureParamsAr.closureParams,
          closureArgs = _setupClosureParamsAr.closureArgs;

      buildBody();

      if (!classState.isLoose) {
        constructorBody.body.unshift(ExpressionStatement(CallExpression(classState.file.addHelper("classCallCheck"), [ThisExpression(), cloneNode(classState.classRef)])));
      }

      body = body.concat(classState.staticPropBody.map(function (fn) {
        return fn(cloneNode(classState.classRef));
      }));
      var isStrict = path.isInStrictMode();
      var constructorOnly = classState.classId && body.length === 1;

      if (constructorOnly && !isStrict) {
        for (var _iterator6 = classState.construct.params, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
          var _ref6;

          if (_isArray6) {
            if (_i6 >= _iterator6.length) break;
            _ref6 = _iterator6[_i6++];
          } else {
            _i6 = _iterator6.next();
            if (_i6.done) break;
            _ref6 = _i6.value;
          }

          var param = _ref6;

          if (!isIdentifier(param)) {
            constructorOnly = false;
            break;
          }
        }
      }

      var directives = constructorOnly ? body[0].body.directives : [];

      if (!isStrict) {
        directives.push(Directive(DirectiveLiteral("use strict")));
      }

      if (constructorOnly) {
        return toExpression(body[0]);
      }

      body.push(ReturnStatement(cloneNode(classState.classRef)));
      var container = ArrowFunctionExpression(closureParams, BlockStatement(body, directives));
      return CallExpression(container, closureArgs);
    }

    return classTransformer(path, file, builtinClasses, isLoose);
  }

  var getBuiltinClasses = function getBuiltinClasses(category) {
    return Object.keys(globals$5[category]).filter(function (name) {
      return /^[A-Z]/.test(name);
    });
  };

  var builtinClasses = new Set([].concat(getBuiltinClasses("builtin"), getBuiltinClasses("browser")));
  var transformClasses = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose;
    var VISITED = Symbol();
    return {
      name: "transform-classes",
      visitor: {
        ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
          if (!path.get("declaration").isClassDeclaration()) return;
          splitExportDeclaration(path);
        },
        ClassDeclaration: function ClassDeclaration(path) {
          var node = path.node;
          var ref = node.id || path.scope.generateUidIdentifier("class");
          path.replaceWith(VariableDeclaration("let", [VariableDeclarator(ref, toExpression(node))]));
        },
        ClassExpression: function ClassExpression(path, state) {
          var node = path.node;
          if (node[VISITED]) return;
          var inferred = nameFunction(path);

          if (inferred && inferred !== node) {
            path.replaceWith(inferred);
            return;
          }

          node[VISITED] = true;
          path.replaceWith(transformClass(path, state.file, builtinClasses, loose));

          if (path.isCallExpression()) {
            annotateAsPure(path);

            if (path.get("callee").isArrowFunctionExpression()) {
              path.get("callee").arrowFunctionToExpression();
            }
          }
        }
      }
    };
  });

  var transformComputedProperties = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose;
    var pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
    var buildMutatorMapAssign = template("\n    MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};\n    MUTATOR_MAP_REF[KEY].KIND = VALUE;\n  ");

    function getValue(prop) {
      if (isObjectProperty(prop)) {
        return prop.value;
      } else if (isObjectMethod(prop)) {
        return FunctionExpression(null, prop.params, prop.body, prop.generator, prop.async);
      }
    }

    function pushAssign(objId, prop, body) {
      if (prop.kind === "get" && prop.kind === "set") {
        pushMutatorDefine(objId, prop);
      } else {
        body.push(ExpressionStatement(AssignmentExpression("=", MemberExpression(cloneNode(objId), prop.key, prop.computed || isLiteral(prop.key)), getValue(prop))));
      }
    }

    function pushMutatorDefine(_ref, prop) {
      var body = _ref.body,
          getMutatorId = _ref.getMutatorId,
          scope = _ref.scope;
      var key = !prop.computed && isIdentifier(prop.key) ? StringLiteral(prop.key.name) : prop.key;
      var maybeMemoise = scope.maybeGenerateMemoised(key);

      if (maybeMemoise) {
        body.push(ExpressionStatement(AssignmentExpression("=", maybeMemoise, key)));
        key = maybeMemoise;
      }

      body.push.apply(body, buildMutatorMapAssign({
        MUTATOR_MAP_REF: getMutatorId(),
        KEY: cloneNode(key),
        VALUE: getValue(prop),
        KIND: Identifier(prop.kind)
      }));
    }

    function pushComputedPropsLoose(info) {
      for (var _iterator = info.computedProps, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref2 = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref2 = _i.value;
        }

        var prop = _ref2;

        if (prop.kind === "get" || prop.kind === "set") {
          pushMutatorDefine(info, prop);
        } else {
          pushAssign(cloneNode(info.objId), prop, info.body);
        }
      }
    }

    function pushComputedPropsSpec(info) {
      var objId = info.objId,
          body = info.body,
          computedProps = info.computedProps,
          state = info.state;

      for (var _iterator2 = computedProps, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref3 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref3 = _i2.value;
        }

        var prop = _ref3;
        var key = toComputedKey(prop);

        if (prop.kind === "get" || prop.kind === "set") {
          pushMutatorDefine(info, prop);
        } else if (isStringLiteral(key, {
          value: "__proto__"
        })) {
          pushAssign(objId, prop, body);
        } else {
          if (computedProps.length === 1) {
            return CallExpression(state.addHelper("defineProperty"), [info.initPropExpression, key, getValue(prop)]);
          } else {
            body.push(ExpressionStatement(CallExpression(state.addHelper("defineProperty"), [cloneNode(objId), key, getValue(prop)])));
          }
        }
      }
    }

    return {
      name: "transform-computed-properties",
      visitor: {
        ObjectExpression: {
          exit: function exit(path, state) {
            var node = path.node,
                parent = path.parent,
                scope = path.scope;
            var hasComputed = false;

            for (var _i3 = 0, _arr = node.properties; _i3 < _arr.length; _i3++) {
              var prop = _arr[_i3];
              hasComputed = prop.computed === true;
              if (hasComputed) break;
            }

            if (!hasComputed) return;
            var initProps = [];
            var computedProps = [];
            var foundComputed = false;

            for (var _iterator3 = node.properties, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
              var _ref4;

              if (_isArray3) {
                if (_i4 >= _iterator3.length) break;
                _ref4 = _iterator3[_i4++];
              } else {
                _i4 = _iterator3.next();
                if (_i4.done) break;
                _ref4 = _i4.value;
              }

              var _prop = _ref4;

              if (_prop.computed) {
                foundComputed = true;
              }

              if (foundComputed) {
                computedProps.push(_prop);
              } else {
                initProps.push(_prop);
              }
            }

            var objId = scope.generateUidIdentifierBasedOnNode(parent);
            var initPropExpression = ObjectExpression(initProps);
            var body = [];
            body.push(VariableDeclaration("var", [VariableDeclarator(objId, initPropExpression)]));
            var mutatorRef;

            var getMutatorId = function getMutatorId() {
              if (!mutatorRef) {
                mutatorRef = scope.generateUidIdentifier("mutatorMap");
                body.push(VariableDeclaration("var", [VariableDeclarator(mutatorRef, ObjectExpression([]))]));
              }

              return cloneNode(mutatorRef);
            };

            var single = pushComputedProps({
              scope: scope,
              objId: objId,
              body: body,
              computedProps: computedProps,
              initPropExpression: initPropExpression,
              getMutatorId: getMutatorId,
              state: state
            });

            if (mutatorRef) {
              body.push(ExpressionStatement(CallExpression(state.addHelper("defineEnumerableProperties"), [cloneNode(objId), cloneNode(mutatorRef)])));
            }

            if (single) {
              path.replaceWith(single);
            } else {
              body.push(ExpressionStatement(cloneNode(objId)));
              path.replaceWithMultiple(body);
            }
          }
        }
      }
    };
  });

  var transformDestructuring = declare(function (api, options) {
    api.assertVersion(7);
    var _options$loose = options.loose,
        loose = _options$loose === void 0 ? false : _options$loose,
        _options$useBuiltIns = options.useBuiltIns,
        useBuiltIns = _options$useBuiltIns === void 0 ? false : _options$useBuiltIns;

    if (typeof loose !== "boolean") {
      throw new Error(".loose must be a boolean or undefined");
    }

    var arrayOnlySpread = loose;

    function getExtendsHelper(file) {
      return useBuiltIns ? MemberExpression(Identifier("Object"), Identifier("assign")) : file.addHelper("extends");
    }

    function variableDeclarationHasPattern(node) {
      for (var _i = 0, _arr = node.declarations; _i < _arr.length; _i++) {
        var declar = _arr[_i];

        if (isPattern(declar.id)) {
          return true;
        }
      }

      return false;
    }

    function hasRest(pattern) {
      for (var _i2 = 0, _arr2 = pattern.elements; _i2 < _arr2.length; _i2++) {
        var elem = _arr2[_i2];

        if (isRestElement(elem)) {
          return true;
        }
      }

      return false;
    }

    function hasObjectRest(pattern) {
      for (var _i3 = 0, _arr3 = pattern.properties; _i3 < _arr3.length; _i3++) {
        var elem = _arr3[_i3];

        if (isRestElement(elem)) {
          return true;
        }
      }

      return false;
    }

    var STOP_TRAVERSAL = {};

    var arrayUnpackVisitor = function arrayUnpackVisitor(node, ancestors, state) {
      if (!ancestors.length) {
        return;
      }

      if (isIdentifier(node) && isReferenced(node, ancestors[ancestors.length - 1]) && state.bindings[node.name]) {
        state.deopt = true;
        throw STOP_TRAVERSAL;
      }
    };

    var DestructuringTransformer = function () {
      function DestructuringTransformer(opts) {
        this.blockHoist = opts.blockHoist;
        this.operator = opts.operator;
        this.arrays = {};
        this.nodes = opts.nodes || [];
        this.scope = opts.scope;
        this.kind = opts.kind;
        this.arrayOnlySpread = opts.arrayOnlySpread;
        this.addHelper = opts.addHelper;
      }

      var _proto = DestructuringTransformer.prototype;

      _proto.buildVariableAssignment = function buildVariableAssignment(id, init) {
        var op = this.operator;
        if (isMemberExpression(id)) op = "=";
        var node;

        if (op) {
          node = ExpressionStatement(AssignmentExpression(op, id, cloneNode(init) || this.scope.buildUndefinedNode()));
        } else {
          node = VariableDeclaration(this.kind, [VariableDeclarator(id, cloneNode(init))]);
        }

        node._blockHoist = this.blockHoist;
        return node;
      };

      _proto.buildVariableDeclaration = function buildVariableDeclaration(id, init) {
        var declar = VariableDeclaration("var", [VariableDeclarator(cloneNode(id), cloneNode(init))]);
        declar._blockHoist = this.blockHoist;
        return declar;
      };

      _proto.push = function push(id, _init) {
        var init = cloneNode(_init);

        if (isObjectPattern(id)) {
          this.pushObjectPattern(id, init);
        } else if (isArrayPattern(id)) {
          this.pushArrayPattern(id, init);
        } else if (isAssignmentPattern(id)) {
          this.pushAssignmentPattern(id, init);
        } else {
          this.nodes.push(this.buildVariableAssignment(id, init));
        }
      };

      _proto.toArray = function toArray(node, count) {
        if (this.arrayOnlySpread || isIdentifier(node) && this.arrays[node.name]) {
          return node;
        } else {
          return this.scope.toArray(node, count);
        }
      };

      _proto.pushAssignmentPattern = function pushAssignmentPattern(_ref, valueRef) {
        var left = _ref.left,
            right = _ref.right;
        var tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
        this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
        var tempConditional = ConditionalExpression(BinaryExpression("===", cloneNode(tempId), this.scope.buildUndefinedNode()), right, cloneNode(tempId));

        if (isPattern(left)) {
          var patternId;
          var node;

          if (this.kind === "const") {
            patternId = this.scope.generateUidIdentifier(tempId.name);
            node = this.buildVariableDeclaration(patternId, tempConditional);
          } else {
            patternId = tempId;
            node = ExpressionStatement(AssignmentExpression("=", cloneNode(tempId), tempConditional));
          }

          this.nodes.push(node);
          this.push(left, patternId);
        } else {
          this.nodes.push(this.buildVariableAssignment(left, tempConditional));
        }
      };

      _proto.pushObjectRest = function pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
        var keys = [];
        var allLiteral = true;

        for (var i = 0; i < pattern.properties.length; i++) {
          var prop = pattern.properties[i];
          if (i >= spreadPropIndex) break;
          if (isRestElement(prop)) continue;
          var key = prop.key;

          if (isIdentifier(key) && !prop.computed) {
            keys.push(StringLiteral(key.name));
          } else if (isTemplateLiteral(prop.key)) {
            keys.push(cloneNode(prop.key));
          } else if (isLiteral(key)) {
            keys.push(StringLiteral(String(key.value)));
          } else {
            keys.push(cloneNode(key));
            allLiteral = false;
          }
        }

        var value;

        if (keys.length === 0) {
          value = CallExpression(getExtendsHelper(this), [ObjectExpression([]), cloneNode(objRef)]);
        } else {
          var keyExpression = ArrayExpression(keys);

          if (!allLiteral) {
            keyExpression = CallExpression(MemberExpression(keyExpression, Identifier("map")), [this.addHelper("toPropertyKey")]);
          }

          value = CallExpression(this.addHelper("objectWithoutProperties" + (loose ? "Loose" : "")), [cloneNode(objRef), keyExpression]);
        }

        this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
      };

      _proto.pushObjectProperty = function pushObjectProperty(prop, propRef) {
        if (isLiteral(prop.key)) prop.computed = true;
        var pattern = prop.value;
        var objRef = MemberExpression(cloneNode(propRef), prop.key, prop.computed);

        if (isPattern(pattern)) {
          this.push(pattern, objRef);
        } else {
          this.nodes.push(this.buildVariableAssignment(pattern, objRef));
        }
      };

      _proto.pushObjectPattern = function pushObjectPattern(pattern, objRef) {
        if (!pattern.properties.length) {
          this.nodes.push(ExpressionStatement(CallExpression(this.addHelper("objectDestructuringEmpty"), [objRef])));
        }

        if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
          var temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
          this.nodes.push(this.buildVariableDeclaration(temp, objRef));
          objRef = temp;
        }

        if (hasObjectRest(pattern)) {
          var copiedPattern;

          for (var i = 0; i < pattern.properties.length; i++) {
            var prop = pattern.properties[i];

            if (isRestElement(prop)) {
              break;
            }

            var key = prop.key;

            if (prop.computed && !this.scope.isPure(key)) {
              var name = this.scope.generateUidIdentifierBasedOnNode(key);
              this.nodes.push(this.buildVariableDeclaration(name, key));

              if (!copiedPattern) {
                copiedPattern = pattern = Object.assign({}, pattern, {
                  properties: pattern.properties.slice()
                });
              }

              copiedPattern.properties[i] = Object.assign({}, copiedPattern.properties[i], {
                key: name
              });
            }
          }
        }

        for (var _i4 = 0; _i4 < pattern.properties.length; _i4++) {
          var _prop = pattern.properties[_i4];

          if (isRestElement(_prop)) {
            this.pushObjectRest(pattern, objRef, _prop, _i4);
          } else {
            this.pushObjectProperty(_prop, objRef);
          }
        }
      };

      _proto.canUnpackArrayPattern = function canUnpackArrayPattern(pattern, arr) {
        if (!isArrayExpression(arr)) return false;
        if (pattern.elements.length > arr.elements.length) return;

        if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) {
          return false;
        }

        for (var _i5 = 0, _arr4 = pattern.elements; _i5 < _arr4.length; _i5++) {
          var elem = _arr4[_i5];
          if (!elem) return false;
          if (isMemberExpression(elem)) return false;
        }

        for (var _i6 = 0, _arr5 = arr.elements; _i6 < _arr5.length; _i6++) {
          var _elem = _arr5[_i6];
          if (isSpreadElement(_elem)) return false;
          if (isCallExpression(_elem)) return false;
          if (isMemberExpression(_elem)) return false;
        }

        var bindings = getBindingIdentifiers(pattern);
        var state = {
          deopt: false,
          bindings: bindings
        };

        try {
          traverse(arr, arrayUnpackVisitor, state);
        } catch (e) {
          if (e !== STOP_TRAVERSAL) throw e;
        }

        return !state.deopt;
      };

      _proto.pushUnpackedArrayPattern = function pushUnpackedArrayPattern(pattern, arr) {
        for (var i = 0; i < pattern.elements.length; i++) {
          var elem = pattern.elements[i];

          if (isRestElement(elem)) {
            this.push(elem.argument, ArrayExpression(arr.elements.slice(i)));
          } else {
            this.push(elem, arr.elements[i]);
          }
        }
      };

      _proto.pushArrayPattern = function pushArrayPattern(pattern, arrayRef) {
        if (!pattern.elements) return;

        if (this.canUnpackArrayPattern(pattern, arrayRef)) {
          return this.pushUnpackedArrayPattern(pattern, arrayRef);
        }

        var count = !hasRest(pattern) && pattern.elements.length;
        var toArray = this.toArray(arrayRef, count);

        if (isIdentifier(toArray)) {
          arrayRef = toArray;
        } else {
          arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
          this.arrays[arrayRef.name] = true;
          this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
        }

        for (var i = 0; i < pattern.elements.length; i++) {
          var elem = pattern.elements[i];
          if (!elem) continue;
          var elemRef = void 0;

          if (isRestElement(elem)) {
            elemRef = this.toArray(arrayRef);
            elemRef = CallExpression(MemberExpression(elemRef, Identifier("slice")), [NumericLiteral(i)]);
            elem = elem.argument;
          } else {
            elemRef = MemberExpression(arrayRef, NumericLiteral(i), true);
          }

          this.push(elem, elemRef);
        }
      };

      _proto.init = function init(pattern, ref) {
        if (!isArrayExpression(ref) && !isMemberExpression(ref)) {
          var memo = this.scope.maybeGenerateMemoised(ref, true);

          if (memo) {
            this.nodes.push(this.buildVariableDeclaration(memo, cloneNode(ref)));
            ref = memo;
          }
        }

        this.push(pattern, ref);
        return this.nodes;
      };

      return DestructuringTransformer;
    }();

    return {
      name: "transform-destructuring",
      visitor: {
        ExportNamedDeclaration: function ExportNamedDeclaration$1(path) {
          var declaration = path.get("declaration");
          if (!declaration.isVariableDeclaration()) return;
          if (!variableDeclarationHasPattern(declaration.node)) return;
          var specifiers = [];

          for (var _i7 = 0, _Object$keys = Object.keys(path.getOuterBindingIdentifiers(path)); _i7 < _Object$keys.length; _i7++) {
            var name = _Object$keys[_i7];
            specifiers.push(ExportSpecifier(Identifier(name), Identifier(name)));
          }

          path.replaceWith(declaration.node);
          path.insertAfter(ExportNamedDeclaration(null, specifiers));
        },
        ForXStatement: function ForXStatement(path) {
          var _this = this;

          var node = path.node,
              scope = path.scope;
          var left = node.left;

          if (isPattern(left)) {
            var temp = scope.generateUidIdentifier("ref");
            node.left = VariableDeclaration("var", [VariableDeclarator(temp)]);
            path.ensureBlock();

            if (node.body.body.length === 0 && path.isCompletionRecord()) {
              node.body.body.unshift(ExpressionStatement(scope.buildUndefinedNode()));
            }

            node.body.body.unshift(ExpressionStatement(AssignmentExpression("=", left, temp)));
            return;
          }

          if (!isVariableDeclaration(left)) return;
          var pattern = left.declarations[0].id;
          if (!isPattern(pattern)) return;
          var key = scope.generateUidIdentifier("ref");
          node.left = VariableDeclaration(left.kind, [VariableDeclarator(key, null)]);
          var nodes = [];
          var destructuring = new DestructuringTransformer({
            kind: left.kind,
            scope: scope,
            nodes: nodes,
            arrayOnlySpread: arrayOnlySpread,
            addHelper: function addHelper(name) {
              return _this.addHelper(name);
            }
          });
          destructuring.init(pattern, key);
          path.ensureBlock();
          var block = node.body;
          block.body = nodes.concat(block.body);
        },
        CatchClause: function CatchClause(_ref2) {
          var _this2 = this;

          var node = _ref2.node,
              scope = _ref2.scope;
          var pattern = node.param;
          if (!isPattern(pattern)) return;
          var ref = scope.generateUidIdentifier("ref");
          node.param = ref;
          var nodes = [];
          var destructuring = new DestructuringTransformer({
            kind: "let",
            scope: scope,
            nodes: nodes,
            arrayOnlySpread: arrayOnlySpread,
            addHelper: function addHelper(name) {
              return _this2.addHelper(name);
            }
          });
          destructuring.init(pattern, ref);
          node.body.body = nodes.concat(node.body.body);
        },
        AssignmentExpression: function AssignmentExpression(path) {
          var _this3 = this;

          var node = path.node,
              scope = path.scope;
          if (!isPattern(node.left)) return;
          var nodes = [];
          var destructuring = new DestructuringTransformer({
            operator: node.operator,
            scope: scope,
            nodes: nodes,
            arrayOnlySpread: arrayOnlySpread,
            addHelper: function addHelper(name) {
              return _this3.addHelper(name);
            }
          });
          var ref;

          if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {
            ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
            nodes.push(VariableDeclaration("var", [VariableDeclarator(ref, node.right)]));

            if (isArrayExpression(node.right)) {
              destructuring.arrays[ref.name] = true;
            }
          }

          destructuring.init(node.left, ref || node.right);

          if (ref) {
            if (path.parentPath.isArrowFunctionExpression()) {
              path.replaceWith(BlockStatement([]));
              nodes.push(ReturnStatement(cloneNode(ref)));
            } else {
              nodes.push(ExpressionStatement(cloneNode(ref)));
            }
          }

          path.replaceWithMultiple(nodes);
          path.scope.crawl();
        },
        VariableDeclaration: function VariableDeclaration(path) {
          var _this4 = this;

          var node = path.node,
              scope = path.scope,
              parent = path.parent;
          if (isForXStatement(parent)) return;
          if (!parent || !path.container) return;
          if (!variableDeclarationHasPattern(node)) return;
          var nodeKind = node.kind;
          var nodes = [];
          var declar;

          for (var i = 0; i < node.declarations.length; i++) {
            declar = node.declarations[i];
            var patternId = declar.init;
            var pattern = declar.id;
            var destructuring = new DestructuringTransformer({
              blockHoist: node._blockHoist,
              nodes: nodes,
              scope: scope,
              kind: node.kind,
              arrayOnlySpread: arrayOnlySpread,
              addHelper: function addHelper(name) {
                return _this4.addHelper(name);
              }
            });

            if (isPattern(pattern)) {
              destructuring.init(pattern, patternId);

              if (+i !== node.declarations.length - 1) {
                inherits(nodes[nodes.length - 1], declar);
              }
            } else {
              nodes.push(inherits(destructuring.buildVariableAssignment(declar.id, cloneNode(declar.init)), declar));
            }
          }

          var tail = null;
          var nodesOut = [];

          for (var _i8 = 0, _nodes = nodes; _i8 < _nodes.length; _i8++) {
            var _node = _nodes[_i8];

            if (tail !== null && isVariableDeclaration(_node)) {
              var _tail$declarations;

              (_tail$declarations = tail.declarations).push.apply(_tail$declarations, _node.declarations);
            } else {
              _node.kind = nodeKind;
              nodesOut.push(_node);
              tail = isVariableDeclaration(_node) ? _node : null;
            }
          }

          for (var _i9 = 0, _nodesOut = nodesOut; _i9 < _nodesOut.length; _i9++) {
            var nodeOut = _nodesOut[_i9];
            if (!nodeOut.declarations) continue;

            for (var _iterator = nodeOut.declarations, _isArray = Array.isArray(_iterator), _i10 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
              var _ref3;

              if (_isArray) {
                if (_i10 >= _iterator.length) break;
                _ref3 = _iterator[_i10++];
              } else {
                _i10 = _iterator.next();
                if (_i10.done) break;
                _ref3 = _i10.value;
              }

              var declaration = _ref3;
              var name = declaration.id.name;

              if (scope.bindings[name]) {
                scope.bindings[name].kind = nodeOut.kind;
              }
            }
          }

          if (nodesOut.length === 1) {
            path.replaceWith(nodesOut[0]);
          } else {
            path.replaceWithMultiple(nodesOut);
          }
        }
      }
    };
  });

  var transformDotallRegex = declare(function (api) {
    api.assertVersion(7);
    return createRegExpFeaturePlugin({
      name: "transform-dotall-regex",
      feature: "dotAllFlag"
    });
  });

  function getName$1(key) {
    if (isIdentifier(key)) {
      return key.name;
    }

    return key.value.toString();
  }

  var transformDuplicateKeys = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-duplicate-keys",
      visitor: {
        ObjectExpression: function ObjectExpression(path) {
          var node = path.node;
          var plainProps = node.properties.filter(function (prop) {
            return !isSpreadElement(prop) && !prop.computed;
          });
          var alreadySeenData = Object.create(null);
          var alreadySeenGetters = Object.create(null);
          var alreadySeenSetters = Object.create(null);

          for (var _iterator = plainProps, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var prop = _ref;
            var name = getName$1(prop.key);
            var isDuplicate = false;

            switch (prop.kind) {
              case "get":
                if (alreadySeenData[name] || alreadySeenGetters[name]) {
                  isDuplicate = true;
                }

                alreadySeenGetters[name] = true;
                break;

              case "set":
                if (alreadySeenData[name] || alreadySeenSetters[name]) {
                  isDuplicate = true;
                }

                alreadySeenSetters[name] = true;
                break;

              default:
                if (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) {
                  isDuplicate = true;
                }

                alreadySeenData[name] = true;
            }

            if (isDuplicate) {
              prop.computed = true;
              prop.key = StringLiteral(name);
            }
          }
        }
      }
    };
  });

  function getObjRef(node, nodes, file, scope) {
    var ref;

    if (isSuper(node)) {
      return node;
    } else if (isIdentifier(node)) {
      if (scope.hasBinding(node.name)) {
        return node;
      } else {
        ref = node;
      }
    } else if (isMemberExpression(node)) {
      ref = node.object;

      if (isSuper(ref) || isIdentifier(ref) && scope.hasBinding(ref.name)) {
        return ref;
      }
    } else {
      throw new Error("We can't explode this node type " + node.type);
    }

    var temp = scope.generateUidIdentifierBasedOnNode(ref);
    scope.push({
      id: temp
    });
    nodes.push(AssignmentExpression("=", cloneNode(temp), cloneNode(ref)));
    return temp;
  }

  function getPropRef(node, nodes, file, scope) {
    var prop = node.property;
    var key = toComputedKey(node, prop);
    if (isLiteral(key) && isPureish(key)) return key;
    var temp = scope.generateUidIdentifierBasedOnNode(prop);
    scope.push({
      id: temp
    });
    nodes.push(AssignmentExpression("=", cloneNode(temp), cloneNode(prop)));
    return temp;
  }

  function explode$1 (node, nodes, file, scope, allowedSingleIdent) {
    var obj;

    if (isIdentifier(node) && allowedSingleIdent) {
      obj = node;
    } else {
      obj = getObjRef(node, nodes, file, scope);
    }

    var ref, uid;

    if (isIdentifier(node)) {
      ref = cloneNode(node);
      uid = obj;
    } else {
      var prop = getPropRef(node, nodes, file, scope);
      var computed = node.computed || isLiteral(prop);
      uid = MemberExpression(cloneNode(obj), cloneNode(prop), computed);
      ref = MemberExpression(cloneNode(obj), cloneNode(prop), computed);
    }

    return {
      uid: uid,
      ref: ref
    };
  }

  function build (opts) {
    var build = opts.build,
        operator = opts.operator;
    return {
      AssignmentExpression: function AssignmentExpression$1(path) {
        var node = path.node,
            scope = path.scope;
        if (node.operator !== operator + "=") return;
        var nodes = [];
        var exploded = explode$1(node.left, nodes, this, scope);
        nodes.push(AssignmentExpression("=", exploded.ref, build(exploded.uid, node.right)));
        path.replaceWith(SequenceExpression(nodes));
      },
      BinaryExpression: function BinaryExpression(path) {
        var node = path.node;

        if (node.operator === operator) {
          path.replaceWith(build(node.left, node.right));
        }
      }
    };
  }

  var transformExponentialOperator = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-exponentiation-operator",
      visitor: build({
        operator: "**",
        build: function build(left, right) {
          return CallExpression(MemberExpression(Identifier("Math"), Identifier("pow")), [left, right]);
        }
      })
    };
  });

  var transformFlowComments = declare(function (api) {
    api.assertVersion(7);

    function commentFromString(comment) {
      return typeof comment === "string" ? {
        type: "CommentBlock",
        value: comment
      } : comment;
    }

    function attachComment(_ref) {
      var ofPath = _ref.ofPath,
          toPath = _ref.toPath,
          _ref$where = _ref.where,
          where = _ref$where === void 0 ? "trailing" : _ref$where,
          _ref$optional = _ref.optional,
          optional = _ref$optional === void 0 ? false : _ref$optional,
          _ref$comments = _ref.comments,
          comments = _ref$comments === void 0 ? generateComment(ofPath, optional) : _ref$comments,
          _ref$keepType = _ref.keepType,
          keepType = _ref$keepType === void 0 ? false : _ref$keepType;

      if (!toPath || !toPath.node) {
        toPath = ofPath.getPrevSibling();
        where = "trailing";
      }

      if (!toPath.node) {
        toPath = ofPath.getNextSibling();
        where = "leading";
      }

      if (!toPath.node) {
        toPath = ofPath.parentPath;
        where = "inner";
      }

      if (!Array.isArray(comments)) {
        comments = [comments];
      }

      comments = comments.map(commentFromString);

      if (!keepType && ofPath && ofPath.node) {
        var node = ofPath.node;
        var parent = ofPath.parentPath;
        var prev = ofPath.getPrevSibling();
        var next = ofPath.getNextSibling();
        var isSingleChild = !(prev.node || next.node);
        var leading = node.leadingComments;
        var trailing = node.trailingComments;

        if (isSingleChild && leading) {
          parent.addComments("inner", leading);
        }

        toPath.addComments(where, comments);
        ofPath.remove();

        if (isSingleChild && trailing) {
          parent.addComments("inner", trailing);
        }
      } else {
        toPath.addComments(where, comments);
      }
    }

    function wrapInFlowComment(path) {
      attachComment({
        ofPath: path,
        comments: generateComment(path, path.parent.optional)
      });
    }

    function generateComment(path, optional) {
      var comment = path.getSource().replace(/\*-\//g, "*-ESCAPED/").replace(/\*\//g, "*-/");
      if (optional) comment = "?" + comment;
      if (comment[0] !== ":") comment = ":: " + comment;
      return comment;
    }

    function isTypeImport(importKind) {
      return importKind === "type" || importKind === "typeof";
    }

    return {
      name: "transform-flow-comments",
      inherits: syntaxFlow,
      visitor: {
        TypeCastExpression: function TypeCastExpression(path) {
          var node = path.node;
          attachComment({
            ofPath: path.get("typeAnnotation"),
            toPath: path.get("expression"),
            keepType: true
          });
          path.replaceWith(ParenthesizedExpression(node.expression));
        },
        Identifier: function Identifier(path) {
          if (path.parentPath.isFlow()) return;
          var node = path.node;

          if (node.typeAnnotation) {
            attachComment({
              ofPath: path.get("typeAnnotation"),
              toPath: path,
              optional: node.optional || node.typeAnnotation.optional
            });

            if (node.optional) {
              node.optional = false;
            }
          } else if (node.optional) {
            attachComment({
              toPath: path,
              comments: ":: ?"
            });
            node.optional = false;
          }
        },
        AssignmentPattern: {
          exit: function exit(_ref2) {
            var node = _ref2.node;
            var left = node.left;

            if (left.optional) {
              left.optional = false;
            }
          }
        },
        Function: function Function(path) {
          if (path.isDeclareFunction()) return;
          var node = path.node;

          if (node.typeParameters) {
            attachComment({
              ofPath: path.get("typeParameters"),
              toPath: path.get("id"),
              optional: node.typeParameters.optional
            });
          }

          if (node.returnType) {
            attachComment({
              ofPath: path.get("returnType"),
              toPath: path.get("body"),
              where: "leading",
              optional: node.returnType.typeAnnotation.optional
            });
          }
        },
        ClassProperty: function ClassProperty(path) {
          var node = path.node;

          if (!node.value) {
            wrapInFlowComment(path);
          } else if (node.typeAnnotation) {
            attachComment({
              ofPath: path.get("typeAnnotation"),
              toPath: path.get("key"),
              optional: node.typeAnnotation.optional
            });
          }
        },
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          var node = path.node;

          if (node.exportKind !== "type" && !isFlow(node.declaration)) {
            return;
          }

          wrapInFlowComment(path);
        },
        ImportDeclaration: function ImportDeclaration(path) {
          var node = path.node;

          if (isTypeImport(node.importKind)) {
            wrapInFlowComment(path);
            return;
          }

          var typeSpecifiers = node.specifiers.filter(function (specifier) {
            return isTypeImport(specifier.importKind);
          });
          var nonTypeSpecifiers = node.specifiers.filter(function (specifier) {
            return !isTypeImport(specifier.importKind);
          });
          node.specifiers = nonTypeSpecifiers;

          if (typeSpecifiers.length > 0) {
            var typeImportNode = cloneNode(node);
            typeImportNode.specifiers = typeSpecifiers;
            var comment = ":: " + generateCode(typeImportNode).code;

            if (nonTypeSpecifiers.length > 0) {
              attachComment({
                toPath: path,
                comments: comment
              });
            } else {
              attachComment({
                ofPath: path,
                comments: comment
              });
            }
          }
        },
        ObjectPattern: function ObjectPattern(path) {
          var node = path.node;

          if (node.typeAnnotation) {
            attachComment({
              ofPath: path.get("typeAnnotation"),
              toPath: path,
              optional: node.optional || node.typeAnnotation.optional
            });
          }
        },
        Flow: function Flow(path) {
          wrapInFlowComment(path);
        },
        Class: function Class(path) {
          var node = path.node;
          var comments = [];

          if (node.typeParameters) {
            var typeParameters = path.get("typeParameters");
            comments.push(generateComment(typeParameters, node.typeParameters.optional));
            var trailingComments = node.typeParameters.trailingComments;

            if (trailingComments) {
              var _comments;

              (_comments = comments).push.apply(_comments, trailingComments);
            }

            typeParameters.remove();
          }

          if (node.superClass) {
            if (comments.length > 0) {
              attachComment({
                toPath: path.get("id"),
                comments: comments
              });
              comments = [];
            }

            if (node.superTypeParameters) {
              var superTypeParameters = path.get("superTypeParameters");
              comments.push(generateComment(superTypeParameters, superTypeParameters.node.optional));
              superTypeParameters.remove();
            }
          }

          if (node["implements"]) {
            var impls = path.get("implements");
            var comment = "implements " + impls.map(function (impl) {
              return generateComment(impl).replace(/^:: /, "");
            }).join(", ");
            delete node["implements"];

            if (comments.length === 1) {
              comments[0] += " " + comment;
            } else {
              comments.push(":: " + comment);
            }
          }

          if (comments.length > 0) {
            attachComment({
              toPath: path.get("body"),
              where: "leading",
              comments: comments
            });
          }
        }
      }
    };
  });

  var transformFlowStripTypes = declare(function (api, opts) {
    api.assertVersion(7);
    var FLOW_DIRECTIVE = /(@flow(\s+(strict(-local)?|weak))?|@noflow)/;
    var skipStrip = false;
    var _opts$requireDirectiv = opts.requireDirective,
        requireDirective = _opts$requireDirectiv === void 0 ? false : _opts$requireDirectiv,
        _opts$allowDeclareFie = opts.allowDeclareFields,
        allowDeclareFields = _opts$allowDeclareFie === void 0 ? false : _opts$allowDeclareFie;
    return {
      name: "transform-flow-strip-types",
      inherits: syntaxFlow,
      visitor: {
        Program: function Program(path, _ref) {
          var comments = _ref.file.ast.comments;
          skipStrip = false;
          var directiveFound = false;

          if (comments) {
            for (var _i = 0, _arr = comments; _i < _arr.length; _i++) {
              var comment = _arr[_i];

              if (FLOW_DIRECTIVE.test(comment.value)) {
                directiveFound = true;
                comment.value = comment.value.replace(FLOW_DIRECTIVE, "");

                if (!comment.value.replace(/\*/g, "").trim()) {
                  comment.ignore = true;
                }
              }
            }
          }

          if (!directiveFound && requireDirective) {
            skipStrip = true;
          }
        },
        ImportDeclaration: function ImportDeclaration(path) {
          if (skipStrip) return;
          if (!path.node.specifiers.length) return;
          var typeCount = 0;
          path.node.specifiers.forEach(function (_ref2) {
            var importKind = _ref2.importKind;

            if (importKind === "type" || importKind === "typeof") {
              typeCount++;
            }
          });

          if (typeCount === path.node.specifiers.length) {
            path.remove();
          }
        },
        Flow: function Flow(path) {
          if (skipStrip) {
            throw path.buildCodeFrameError("A @flow directive is required when using Flow annotations with " + "the `requireDirective` option.");
          }

          path.remove();
        },
        ClassPrivateProperty: function ClassPrivateProperty(path) {
          if (skipStrip) return;
          path.node.typeAnnotation = null;
        },
        Class: function Class(path) {
          if (skipStrip) return;
          path.node["implements"] = null;
          path.get("body.body").forEach(function (child) {
            if (child.isClassProperty()) {
              var node = child.node;

              if (!allowDeclareFields && node.declare) {
                throw child.buildCodeFrameError("The 'declare' modifier is only allowed when the " + "'allowDeclareFields' option of " + "@babel/plugin-transform-flow-strip-types or " + "@babel/preset-flow is enabled.");
              }

              if (node.declare) {
                child.remove();
              } else if (!allowDeclareFields && !node.value && !node.decorators) {
                child.remove();
              } else {
                node.variance = null;
                node.typeAnnotation = null;
              }
            }
          });
        },
        AssignmentPattern: function AssignmentPattern(_ref3) {
          var node = _ref3.node;
          if (skipStrip) return;
          node.left.optional = false;
        },
        Function: function Function(_ref4) {
          var node = _ref4.node;
          if (skipStrip) return;

          for (var i = 0; i < node.params.length; i++) {
            var param = node.params[i];
            param.optional = false;

            if (param.type === "AssignmentPattern") {
              param.left.optional = false;
            }
          }

          node.predicate = null;
        },
        TypeCastExpression: function TypeCastExpression(path) {
          if (skipStrip) return;
          var node = path.node;

          do {
            node = node.expression;
          } while (isTypeCastExpression(node));

          path.replaceWith(node);
        },
        CallExpression: function CallExpression(_ref5) {
          var node = _ref5.node;
          if (skipStrip) return;
          node.typeArguments = null;
        },
        OptionalCallExpression: function OptionalCallExpression(_ref6) {
          var node = _ref6.node;
          if (skipStrip) return;
          node.typeArguments = null;
        },
        NewExpression: function NewExpression(_ref7) {
          var node = _ref7.node;
          if (skipStrip) return;
          node.typeArguments = null;
        }
      }
    };
  });

  function transformWithoutHelper(loose, path, state) {
    var pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
    var node = path.node;
    var build = pushComputedProps(path, state);
    var declar = build.declar;
    var loop = build.loop;
    var block = loop.body;
    path.ensureBlock();

    if (declar) {
      block.body.push(declar);
    }

    block.body = block.body.concat(node.body.body);
    inherits(loop, node);
    inherits(loop.body, node.body);

    if (build.replaceParent) {
      path.parentPath.replaceWithMultiple(build.node);
      path.remove();
    } else {
      path.replaceWithMultiple(build.node);
    }
  }
  var buildForOfLoose = template("\n  for (var LOOP_OBJECT = OBJECT,\n          IS_ARRAY = Array.isArray(LOOP_OBJECT),\n          INDEX = 0,\n          LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n    INTERMEDIATE;\n    if (IS_ARRAY) {\n      if (INDEX >= LOOP_OBJECT.length) break;\n      ID = LOOP_OBJECT[INDEX++];\n    } else {\n      INDEX = LOOP_OBJECT.next();\n      if (INDEX.done) break;\n      ID = INDEX.value;\n    }\n  }\n");
  var buildForOf = template("\n  var ITERATOR_COMPLETION = true;\n  var ITERATOR_HAD_ERROR_KEY = false;\n  var ITERATOR_ERROR_KEY = undefined;\n  try {\n    for (\n      var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;\n      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);\n      ITERATOR_COMPLETION = true\n    ) {}\n  } catch (err) {\n    ITERATOR_HAD_ERROR_KEY = true;\n    ITERATOR_ERROR_KEY = err;\n  } finally {\n    try {\n      if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n        ITERATOR_KEY.return();\n      }\n    } finally {\n      if (ITERATOR_HAD_ERROR_KEY) {\n        throw ITERATOR_ERROR_KEY;\n      }\n    }\n  }\n");

  function pushComputedPropsLoose(path, file) {
    var node = path.node,
        scope = path.scope,
        parent = path.parent;
    var left = node.left;
    var declar, id, intermediate;

    if (isIdentifier(left) || isPattern(left) || isMemberExpression(left)) {
      id = left;
      intermediate = null;
    } else if (isVariableDeclaration(left)) {
      id = scope.generateUidIdentifier("ref");
      declar = VariableDeclaration(left.kind, [VariableDeclarator(left.declarations[0].id, Identifier(id.name))]);
      intermediate = VariableDeclaration("var", [VariableDeclarator(Identifier(id.name))]);
    } else {
      throw file.buildCodeFrameError(left, "Unknown node type " + left.type + " in ForStatement");
    }

    var iteratorKey = scope.generateUidIdentifier("iterator");
    var isArrayKey = scope.generateUidIdentifier("isArray");
    var loop = buildForOfLoose({
      LOOP_OBJECT: iteratorKey,
      IS_ARRAY: isArrayKey,
      OBJECT: node.right,
      INDEX: scope.generateUidIdentifier("i"),
      ID: id,
      INTERMEDIATE: intermediate
    });
    var isLabeledParent = isLabeledStatement(parent);
    var labeled;

    if (isLabeledParent) {
      labeled = LabeledStatement(parent.label, loop);
    }

    return {
      replaceParent: isLabeledParent,
      declar: declar,
      node: labeled || loop,
      loop: loop
    };
  }

  function pushComputedPropsSpec(path, file) {
    var node = path.node,
        scope = path.scope,
        parent = path.parent;
    var left = node.left;
    var declar;
    var stepKey = scope.generateUid("step");
    var stepValue = MemberExpression(Identifier(stepKey), Identifier("value"));

    if (isIdentifier(left) || isPattern(left) || isMemberExpression(left)) {
      declar = ExpressionStatement(AssignmentExpression("=", left, stepValue));
    } else if (isVariableDeclaration(left)) {
      declar = VariableDeclaration(left.kind, [VariableDeclarator(left.declarations[0].id, stepValue)]);
    } else {
      throw file.buildCodeFrameError(left, "Unknown node type " + left.type + " in ForStatement");
    }

    var template = buildForOf({
      ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
      ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
      ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
      ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
      STEP_KEY: Identifier(stepKey),
      OBJECT: node.right
    });
    var isLabeledParent = isLabeledStatement(parent);
    var tryBody = template[3].block.body;
    var loop = tryBody[0];

    if (isLabeledParent) {
      tryBody[0] = LabeledStatement(parent.label, loop);
    }

    return {
      replaceParent: isLabeledParent,
      declar: declar,
      loop: loop,
      node: template
    };
  }

  var transformForOf = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose,
        assumeArray = options.assumeArray;

    if (loose === true && assumeArray === true) {
      throw new Error("The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of");
    }

    if (assumeArray) {
      return {
        name: "transform-for-of",
        visitor: {
          ForOfStatement: function ForOfStatement(path) {
            var scope = path.scope;
            var _path$node = path.node,
                left = _path$node.left,
                right = _path$node.right,
                isAwait = _path$node["await"];

            if (isAwait) {
              return;
            }

            var i = scope.generateUidIdentifier("i");
            var array = scope.maybeGenerateMemoised(right, true);
            var inits = [VariableDeclarator(i, NumericLiteral(0))];

            if (array) {
              inits.push(VariableDeclarator(array, right));
            } else {
              array = right;
            }

            var item = MemberExpression(cloneNode(array), cloneNode(i), true);
            var assignment;

            if (isVariableDeclaration(left)) {
              assignment = left;
              assignment.declarations[0].init = item;
            } else {
              assignment = ExpressionStatement(AssignmentExpression("=", left, item));
            }

            var blockBody;
            var body = path.get("body");

            if (body.isBlockStatement() && Object.keys(path.getBindingIdentifiers()).some(function (id) {
              return body.scope.hasOwnBinding(id);
            })) {
              blockBody = BlockStatement([assignment, body.node]);
            } else {
              blockBody = toBlock(body.node);
              blockBody.body.unshift(assignment);
            }

            path.replaceWith(ForStatement(VariableDeclaration("let", inits), BinaryExpression("<", cloneNode(i), MemberExpression(cloneNode(array), Identifier("length"))), UpdateExpression("++", cloneNode(i)), blockBody));
          }
        }
      };
    }

    var buildForOfArray = template("\n    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;\n  ");
    var buildForOfLoose = template.statements("\n    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT), STEP_KEY;\n        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;\n  ");
    var buildForOf = template.statements("\n    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT), STEP_KEY;\n    try {\n      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;\n    } catch (err) {\n      ITERATOR_HELPER.e(err);\n    } finally {\n      ITERATOR_HELPER.f();\n    }\n  ");
    var builder = loose ? {
      build: buildForOfLoose,
      helper: "createForOfIteratorHelperLoose",
      getContainer: function getContainer(nodes) {
        return nodes;
      }
    } : {
      build: buildForOf,
      helper: "createForOfIteratorHelper",
      getContainer: function getContainer(nodes) {
        return nodes[1].block.body;
      }
    };

    function _ForOfStatementArray(path) {
      var node = path.node,
          scope = path.scope;
      var right = scope.generateUidIdentifierBasedOnNode(node.right, "arr");
      var iterationKey = scope.generateUidIdentifier("i");
      var loop = buildForOfArray({
        BODY: node.body,
        KEY: iterationKey,
        NAME: right,
        ARR: node.right
      });
      inherits(loop, node);
      ensureBlock(loop);
      var iterationValue = MemberExpression(cloneNode(right), cloneNode(iterationKey), true);
      var left = node.left;

      if (isVariableDeclaration(left)) {
        left.declarations[0].init = iterationValue;
        loop.body.body.unshift(left);
      } else {
        loop.body.body.unshift(ExpressionStatement(AssignmentExpression("=", left, iterationValue)));
      }

      return loop;
    }

    return {
      name: "transform-for-of",
      visitor: {
        ForOfStatement: function ForOfStatement(path, state) {
          var right = path.get("right");

          if (right.isArrayExpression() || right.isGenericType("Array") || isArrayTypeAnnotation(right.getTypeAnnotation())) {
            path.replaceWith(_ForOfStatementArray(path));
            return;
          }

          if (!state.availableHelper(builder.helper)) {
            transformWithoutHelper(loose, path, state);
            return;
          }

          var node = path.node,
              parent = path.parent,
              scope = path.scope;
          var left = node.left;
          var declar;
          var stepKey = scope.generateUid("step");
          var stepValue = MemberExpression(Identifier(stepKey), Identifier("value"));

          if (isVariableDeclaration(left)) {
            declar = VariableDeclaration(left.kind, [VariableDeclarator(left.declarations[0].id, stepValue)]);
          } else {
            declar = ExpressionStatement(AssignmentExpression("=", left, stepValue));
          }

          path.ensureBlock();
          node.body.body.unshift(declar);
          var nodes = builder.build({
            CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),
            ITERATOR_HELPER: scope.generateUidIdentifier("iterator"),
            STEP_KEY: Identifier(stepKey),
            OBJECT: node.right,
            BODY: node.body
          });
          var container = builder.getContainer(nodes);
          inherits(container[0], node);
          inherits(container[0].body, node.body);

          if (isLabeledStatement(parent)) {
            container[0] = LabeledStatement(parent.label, container[0]);
            path.parentPath.replaceWithMultiple(nodes);
            path.remove();
          } else {
            path.replaceWithMultiple(nodes);
          }
        }
      }
    };
  });

  var transformFunctionName = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-function-name",
      visitor: {
        FunctionExpression: {
          exit: function exit(path) {
            if (path.key !== "value" && !path.parentPath.isObjectProperty()) {
              var replacement = nameFunction(path);
              if (replacement) path.replaceWith(replacement);
            }
          }
        },
        ObjectProperty: function ObjectProperty(path) {
          var value = path.get("value");

          if (value.isFunction()) {
            var newNode = nameFunction(value);
            if (newNode) value.replaceWith(newNode);
          }
        }
      }
    };
  });

  var transformInstanceof = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-instanceof",
      visitor: {
        BinaryExpression: function BinaryExpression(path) {
          var node = path.node;

          if (node.operator === "instanceof") {
            var helper = this.addHelper("instanceof");
            var isUnderHelper = path.findParent(function (path) {
              return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
            });

            if (isUnderHelper) {
              return;
            } else {
              path.replaceWith(CallExpression(helper, [node.left, node.right]));
            }
          }
        }
      }
    };
  });

  var transformJscript = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-jscript",
      visitor: {
        FunctionExpression: {
          exit: function exit(path) {
            var node = path.node;
            if (!node.id) return;
            path.replaceWith(CallExpression(FunctionExpression(null, [], BlockStatement([toStatement(node), ReturnStatement(cloneNode(node.id))])), []));
          }
        }
      }
    };
  });

  var transformLiterals = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-literals",
      visitor: {
        NumericLiteral: function NumericLiteral(_ref) {
          var node = _ref.node;

          if (node.extra && /^0[ob]/i.test(node.extra.raw)) {
            node.extra = undefined;
          }
        },
        StringLiteral: function StringLiteral(_ref2) {
          var node = _ref2.node;

          if (node.extra && /\\[u]/gi.test(node.extra.raw)) {
            node.extra = undefined;
          }
        }
      }
    };
  });

  var transformMemberExpressionLiterals = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-member-expression-literals",
      visitor: {
        MemberExpression: {
          exit: function exit(_ref) {
            var node = _ref.node;
            var prop = node.property;

            if (!node.computed && isIdentifier(prop) && !isValidES3Identifier(prop.name)) {
              node.property = StringLiteral(prop.name);
              node.computed = true;
            }
          }
        }
      }
    };
  });

  var utils = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImportSource = getImportSource;
  exports.createDynamicImportTransform = createDynamicImportTransform;

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function getImportSource(t, callNode) {
    var importArguments = callNode.arguments;

    var _importArguments = _slicedToArray(importArguments, 1),
        importPath = _importArguments[0];

    var isString = t.isStringLiteral(importPath) || t.isTemplateLiteral(importPath);

    if (isString) {
      t.removeComments(importPath);
      return importPath;
    }

    return t.templateLiteral([t.templateElement({
      raw: '',
      cooked: ''
    }), t.templateElement({
      raw: '',
      cooked: ''
    }, true)], importArguments);
  }

  function createDynamicImportTransform(_ref) {
    var template = _ref.template,
        t = _ref.types;
    var buildImport = template('Promise.resolve().then(() => MODULE)');
    return function (context, path) {
      var requireCall = t.callExpression(t.identifier('require'), [getImportSource(t, path.parent)]);
      var _context$opts$noInter = context.opts.noInterop,
          noInterop = _context$opts$noInter === undefined ? false : _context$opts$noInter;
      var MODULE = noInterop === true ? requireCall : t.callExpression(context.addHelper('interopRequireWildcard'), [requireCall]);
      var newImport = buildImport({
        MODULE: MODULE
      });
      path.parentPath.replaceWith(newImport);
    };
  }
  });

  unwrapExports(utils);
  var utils_1 = utils.getImportSource;
  var utils_2 = utils.createDynamicImportTransform;

  var utils$1 = utils;
  var utils_1$1 = utils$1.createDynamicImportTransform;
  var utils_2$1 = utils$1.getImportSource;

  function _templateObject$a() {
    var data = _taggedTemplateLiteralLoose(["\n            new Promise((", ", ", ") =>\n              ", "(\n                [", "],\n                imported => ", "(", "),\n                ", "\n              )\n            )"]);

    _templateObject$a = function _templateObject() {
      return data;
    };

    return data;
  }
  var buildWrapper = template("\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n");
  var buildAnonymousWrapper = template("\n  define([\"require\"], function(REQUIRE) {\n  })\n");

  function injectWrapper(path, wrapper) {
    var _path$node = path.node,
        body = _path$node.body,
        directives = _path$node.directives;
    path.node.directives = [];
    path.node.body = [];
    var amdWrapper = path.pushContainer("body", wrapper)[0];
    var amdFactory = amdWrapper.get("expression.arguments").filter(function (arg) {
      return arg.isFunctionExpression();
    })[0].get("body");
    amdFactory.pushContainer("directives", directives);
    amdFactory.pushContainer("body", body);
  }

  var transformModulesAmd = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose,
        allowTopLevelThis = options.allowTopLevelThis,
        strict = options.strict,
        strictMode = options.strictMode,
        noInterop = options.noInterop;
    return {
      name: "transform-modules-amd",
      pre: function pre() {
        this.file.set("@babel/plugin-transform-modules-*", "amd");
      },
      visitor: {
        CallExpression: function CallExpression(path, state) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
          if (!path.get("callee").isImport()) return;
          var requireId = state.requireId,
              resolveId = state.resolveId,
              rejectId = state.rejectId;

          if (!requireId) {
            requireId = path.scope.generateUidIdentifier("require");
            state.requireId = requireId;
          }

          if (!resolveId || !rejectId) {
            resolveId = path.scope.generateUidIdentifier("resolve");
            rejectId = path.scope.generateUidIdentifier("reject");
            state.resolveId = resolveId;
            state.rejectId = rejectId;
          }

          var result = Identifier("imported");
          if (!noInterop) result = wrapInterop(path, result, "namespace");
          path.replaceWith(template.expression.ast(_templateObject$a(), resolveId, rejectId, requireId, utils_2$1(t, path.node), resolveId, result, rejectId));
        },
        Program: {
          exit: function exit(path, _ref) {
            var requireId = _ref.requireId;

            if (!isModule(path)) {
              if (requireId) {
                injectWrapper(path, buildAnonymousWrapper({
                  REQUIRE: requireId
                }));
              }

              return;
            }

            var amdArgs = [];
            var importNames = [];

            if (requireId) {
              amdArgs.push(StringLiteral("require"));
              importNames.push(requireId);
            }

            var moduleName = getModuleName(this.file.opts, options);
            if (moduleName) moduleName = StringLiteral(moduleName);

            var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
              loose: loose,
              strict: strict,
              strictMode: strictMode,
              allowTopLevelThis: allowTopLevelThis,
              noInterop: noInterop
            }),
                meta = _rewriteModuleStateme.meta,
                headers = _rewriteModuleStateme.headers;

            if (hasExports(meta)) {
              amdArgs.push(StringLiteral("exports"));
              importNames.push(Identifier(meta.exportName));
            }

            for (var _iterator = meta.source, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
              var _ref2;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref2 = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref2 = _i.value;
              }

              var _ref3 = _ref2,
                  source = _ref3[0],
                  metadata = _ref3[1];
              amdArgs.push(StringLiteral(source));
              importNames.push(Identifier(metadata.name));

              if (!isSideEffectImport(metadata)) {
                var interop = wrapInterop(path, Identifier(metadata.name), metadata.interop);

                if (interop) {
                  var header = ExpressionStatement(AssignmentExpression("=", Identifier(metadata.name), interop));
                  header.loc = metadata.loc;
                  headers.push(header);
                }
              }

              headers.push.apply(headers, buildNamespaceInitStatements(meta, metadata, loose));
            }

            ensureStatementsHoisted(headers);
            path.unshiftContainer("body", headers);
            injectWrapper(path, buildWrapper({
              MODULE_NAME: moduleName,
              AMD_ARGUMENTS: ArrayExpression(amdArgs),
              IMPORT_NAMES: importNames
            }));
          }
        }
      }
    };
  });

  function _templateObject3$4() {
    var data = _taggedTemplateLiteralLoose(["\n                  var ", " = ", ";\n                "]);

    _templateObject3$4 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2$4() {
    var data = _taggedTemplateLiteralLoose(["\n                  function ", "() {\n                    const data = ", ";\n                    ", " = function(){ return data; };\n                    return data;\n                  }\n                "]);

    _templateObject2$4 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$b() {
    var data = _taggedTemplateLiteralLoose(["\n    (function(){\n      throw new Error(\n        \"The CommonJS '\" + \"", "\" + \"' variable is not available in ES6 modules.\" +\n        \"Consider setting setting sourceType:script or sourceType:unambiguous in your \" +\n        \"Babel config for this file.\");\n    })()\n  "]);

    _templateObject$b = function _templateObject() {
      return data;
    };

    return data;
  }
  var transformModulesCommonjs = declare(function (api, options) {
    api.assertVersion(7);
    var transformImportCall = utils_1$1(api);
    var loose = options.loose,
        _options$strictNamesp = options.strictNamespace,
        strictNamespace = _options$strictNamesp === void 0 ? false : _options$strictNamesp,
        _options$mjsStrictNam = options.mjsStrictNamespace,
        mjsStrictNamespace = _options$mjsStrictNam === void 0 ? true : _options$mjsStrictNam,
        allowTopLevelThis = options.allowTopLevelThis,
        strict = options.strict,
        strictMode = options.strictMode,
        noInterop = options.noInterop,
        _options$lazy = options.lazy,
        lazy = _options$lazy === void 0 ? false : _options$lazy,
        _options$allowCommonJ = options.allowCommonJSExports,
        allowCommonJSExports = _options$allowCommonJ === void 0 ? true : _options$allowCommonJ;

    if (typeof lazy !== "boolean" && typeof lazy !== "function" && (!Array.isArray(lazy) || !lazy.every(function (item) {
      return typeof item === "string";
    }))) {
      throw new Error(".lazy must be a boolean, array of strings, or a function");
    }

    if (typeof strictNamespace !== "boolean") {
      throw new Error(".strictNamespace must be a boolean, or undefined");
    }

    if (typeof mjsStrictNamespace !== "boolean") {
      throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
    }

    var getAssertion = function getAssertion(localName) {
      return template.expression.ast(_templateObject$b(), localName);
    };

    var moduleExportsVisitor = {
      ReferencedIdentifier: function ReferencedIdentifier(path) {
        var localName = path.node.name;
        if (localName !== "module" && localName !== "exports") return;
        var localBinding = path.scope.getBinding(localName);
        var rootBinding = this.scope.getBinding(localName);

        if (rootBinding !== localBinding || path.parentPath.isObjectProperty({
          value: path.node
        }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({
          left: path.node
        }) || path.isAssignmentExpression({
          left: path.node
        })) {
          return;
        }

        path.replaceWith(getAssertion(localName));
      },
      AssignmentExpression: function AssignmentExpression(path) {
        var _this = this;

        var left = path.get("left");

        if (left.isIdentifier()) {
          var localName = path.node.name;
          if (localName !== "module" && localName !== "exports") return;
          var localBinding = path.scope.getBinding(localName);
          var rootBinding = this.scope.getBinding(localName);
          if (rootBinding !== localBinding) return;
          var right = path.get("right");
          right.replaceWith(SequenceExpression([right.node, getAssertion(localName)]));
        } else if (left.isPattern()) {
          var ids = left.getOuterBindingIdentifiers();
          var _localName = Object.keys(ids).filter(function (localName) {
            if (localName !== "module" && localName !== "exports") return false;
            return _this.scope.getBinding(localName) === path.scope.getBinding(localName);
          })[0];

          if (_localName) {
            var _right = path.get("right");

            _right.replaceWith(SequenceExpression([_right.node, getAssertion(_localName)]));
          }
        }
      }
    };
    return {
      name: "transform-modules-commonjs",
      pre: function pre() {
        this.file.set("@babel/plugin-transform-modules-*", "commonjs");
      },
      visitor: {
        CallExpression: function CallExpression(path) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
          if (!path.get("callee").isImport()) return;
          var scope = path.scope;

          do {
            scope.rename("require");
          } while (scope = scope.parent);

          transformImportCall(this, path.get("callee"));
        },
        Program: {
          exit: function exit(path, state) {
            if (!isModule(path)) return;
            path.scope.rename("exports");
            path.scope.rename("module");
            path.scope.rename("require");
            path.scope.rename("__filename");
            path.scope.rename("__dirname");

            if (!allowCommonJSExports) {
              simplifyAccess(path, new Set(["module", "exports"]));
              path.traverse(moduleExportsVisitor, {
                scope: path.scope
              });
            }

            var moduleName = getModuleName(this.file.opts, options);
            if (moduleName) moduleName = StringLiteral(moduleName);

            var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
              exportName: "exports",
              loose: loose,
              strict: strict,
              strictMode: strictMode,
              allowTopLevelThis: allowTopLevelThis,
              noInterop: noInterop,
              lazy: lazy,
              esNamespaceOnly: typeof state.filename === "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace
            }),
                meta = _rewriteModuleStateme.meta,
                headers = _rewriteModuleStateme.headers;

            for (var _iterator = meta.source, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var _ref2 = _ref,
                  source = _ref2[0],
                  metadata = _ref2[1];
              var loadExpr = CallExpression(Identifier("require"), [StringLiteral(source)]);
              var header = void 0;

              if (isSideEffectImport(metadata)) {
                if (metadata.lazy) throw new Error("Assertion failure");
                header = ExpressionStatement(loadExpr);
              } else {
                var init = wrapInterop(path, loadExpr, metadata.interop) || loadExpr;

                if (metadata.lazy) {
                  header = template.ast(_templateObject2$4(), metadata.name, init, metadata.name);
                } else {
                  header = template.ast(_templateObject3$4(), metadata.name, init);
                }
              }

              header.loc = metadata.loc;
              headers.push(header);
              headers.push.apply(headers, buildNamespaceInitStatements(meta, metadata, loose));
            }

            ensureStatementsHoisted(headers);
            path.unshiftContainer("body", headers);
          }
        }
      }
    };
  });

  var visitor$3 = {
    Scope: function Scope(path, state) {
      if (state.kind === "let") path.skip();
    },
    Function: function Function(path) {
      path.skip();
    },
    VariableDeclaration: function VariableDeclaration(path, state) {
      if (state.kind && path.node.kind !== state.kind) return;
      var nodes = [];
      var declarations = path.get("declarations");
      var firstId;

      for (var _iterator = declarations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var declar = _ref;
        firstId = declar.node.id;

        if (declar.node.init) {
          nodes.push(ExpressionStatement(AssignmentExpression("=", declar.node.id, declar.node.init)));
        }

        for (var _i2 = 0, _Object$keys = Object.keys(declar.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
          var name = _Object$keys[_i2];
          state.emit(Identifier(name), name, declar.node.init !== null);
        }
      }

      if (path.parentPath.isFor({
        left: path.node
      })) {
        path.replaceWith(firstId);
      } else {
        path.replaceWithMultiple(nodes);
      }
    }
  };
  function hoistVariables (path, emit, kind) {
    if (kind === void 0) {
      kind = "var";
    }

    path.traverse(visitor$3, {
      kind: kind,
      emit: emit
    });
  }

  var buildTemplate = template("\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: function () {\n        BODY;\n      }\n    };\n  });\n");
  var buildExportAll = template("\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n");
  var MISSING_PLUGIN_WARNING = "WARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n";

  function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget) {
    var statements = [];

    if (exportNames.length === 1) {
      statements.push(ExpressionStatement(CallExpression(exportIdent, [StringLiteral(exportNames[0]), exportValues[0]])));
    } else if (!exportStarTarget) {
      var objectProperties = [];

      for (var i = 0; i < exportNames.length; i++) {
        var exportName = exportNames[i];
        var exportValue = exportValues[i];
        objectProperties.push(ObjectProperty(Identifier(exportName), exportValue));
      }

      statements.push(ExpressionStatement(CallExpression(exportIdent, [ObjectExpression(objectProperties)])));
    } else {
      var exportObj = path.scope.generateUid("exportObj");
      statements.push(VariableDeclaration("var", [VariableDeclarator(Identifier(exportObj), ObjectExpression([]))]));
      statements.push(buildExportAll({
        KEY: path.scope.generateUidIdentifier("key"),
        EXPORT_OBJ: Identifier(exportObj),
        TARGET: exportStarTarget
      }));

      for (var _i = 0; _i < exportNames.length; _i++) {
        var _exportName = exportNames[_i];
        var _exportValue = exportValues[_i];
        statements.push(ExpressionStatement(AssignmentExpression("=", MemberExpression(Identifier(exportObj), Identifier(_exportName)), _exportValue)));
      }

      statements.push(ExpressionStatement(CallExpression(exportIdent, [Identifier(exportObj)])));
    }

    return statements;
  }

  var transformModulesSystemjs = declare(function (api, options) {
    api.assertVersion(7);
    var _options$systemGlobal = options.systemGlobal,
        systemGlobal = _options$systemGlobal === void 0 ? "System" : _options$systemGlobal,
        _options$allowTopLeve = options.allowTopLevelThis,
        allowTopLevelThis = _options$allowTopLeve === void 0 ? false : _options$allowTopLeve;
    var IGNORE_REASSIGNMENT_SYMBOL = Symbol();
    var reassignmentVisitor = {
      "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path) {
        if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;
        path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;
        var arg = path.get(path.isAssignmentExpression() ? "left" : "argument");

        if (arg.isObjectPattern() || arg.isArrayPattern()) {
          var exprs = [path.node];

          for (var _i2 = 0, _Object$keys = Object.keys(arg.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
            var _name = _Object$keys[_i2];

            if (this.scope.getBinding(_name) !== path.scope.getBinding(_name)) {
              return;
            }

            var _exportedNames = this.exports[_name];
            if (!_exportedNames) return;

            for (var _iterator = _exportedNames, _isArray = Array.isArray(_iterator), _i3 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
              var _ref;

              if (_isArray) {
                if (_i3 >= _iterator.length) break;
                _ref = _iterator[_i3++];
              } else {
                _i3 = _iterator.next();
                if (_i3.done) break;
                _ref = _i3.value;
              }

              var exportedName = _ref;
              exprs.push(this.buildCall(exportedName, Identifier(_name)).expression);
            }
          }

          path.replaceWith(SequenceExpression(exprs));
          return;
        }

        if (!arg.isIdentifier()) return;
        var name = arg.node.name;
        if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
        var exportedNames = this.exports[name];
        if (!exportedNames) return;
        var node = path.node;
        var isPostUpdateExpression = path.isUpdateExpression({
          prefix: false
        });

        if (isPostUpdateExpression) {
          node = BinaryExpression(node.operator[0], UnaryExpression("+", cloneNode(node.argument)), NumericLiteral(1));
        }

        for (var _iterator2 = exportedNames, _isArray2 = Array.isArray(_iterator2), _i4 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
          var _ref2;

          if (_isArray2) {
            if (_i4 >= _iterator2.length) break;
            _ref2 = _iterator2[_i4++];
          } else {
            _i4 = _iterator2.next();
            if (_i4.done) break;
            _ref2 = _i4.value;
          }

          var _exportedName = _ref2;
          node = this.buildCall(_exportedName, node).expression;
        }

        if (isPostUpdateExpression) {
          node = SequenceExpression([node, path.node]);
        }

        path.replaceWith(node);
      }
    };
    return {
      name: "transform-modules-systemjs",
      pre: function pre() {
        this.file.set("@babel/plugin-transform-modules-*", "systemjs");
      },
      visitor: {
        CallExpression: function CallExpression$1(path, state) {
          if (isImport(path.node.callee)) {
            if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
              console.warn(MISSING_PLUGIN_WARNING);
            }

            path.replaceWith(CallExpression(MemberExpression(Identifier(state.contextIdent), Identifier("import")), [utils_2$1(t, path.node)]));
          }
        },
        MetaProperty: function MetaProperty(path, state) {
          if (path.node.meta.name === "import" && path.node.property.name === "meta") {
            path.replaceWith(MemberExpression(Identifier(state.contextIdent), Identifier("meta")));
          }
        },
        ReferencedIdentifier: function ReferencedIdentifier(path, state) {
          if (path.node.name === "__moduleName" && !path.scope.hasBinding("__moduleName")) {
            path.replaceWith(MemberExpression(Identifier(state.contextIdent), Identifier("id")));
          }
        },
        Program: {
          enter: function enter(path, state) {
            state.contextIdent = path.scope.generateUid("context");

            if (!allowTopLevelThis) {
              rewriteThis(path);
            }
          },
          exit: function exit(path, state) {
            var undefinedIdent = path.scope.buildUndefinedNode();
            var exportIdent = path.scope.generateUid("export");
            var contextIdent = state.contextIdent;
            var exportMap = Object.create(null);
            var modules = [];
            var beforeBody = [];
            var setters = [];
            var sources = [];
            var variableIds = [];
            var removedPaths = [];

            function addExportName(key, val) {
              exportMap[key] = exportMap[key] || [];
              exportMap[key].push(val);
            }

            function pushModule(source, key, specifiers) {
              var module;
              modules.forEach(function (m) {
                if (m.key === source) {
                  module = m;
                }
              });

              if (!module) {
                modules.push(module = {
                  key: source,
                  imports: [],
                  exports: []
                });
              }

              module[key] = module[key].concat(specifiers);
            }

            function buildExportCall(name, val) {
              return ExpressionStatement(CallExpression(Identifier(exportIdent), [StringLiteral(name), val]));
            }

            var exportNames = [];
            var exportValues = [];
            var body = path.get("body");

            for (var _iterator3 = body, _isArray3 = Array.isArray(_iterator3), _i5 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
              var _ref3;

              if (_isArray3) {
                if (_i5 >= _iterator3.length) break;
                _ref3 = _iterator3[_i5++];
              } else {
                _i5 = _iterator3.next();
                if (_i5.done) break;
                _ref3 = _i5.value;
              }

              var _path = _ref3;

              if (_path.isFunctionDeclaration()) {
                beforeBody.push(_path.node);
                removedPaths.push(_path);
              } else if (_path.isClassDeclaration()) {
                variableIds.push(_path.node.id);

                _path.replaceWith(ExpressionStatement(AssignmentExpression("=", cloneNode(_path.node.id), toExpression(_path.node))));
              } else if (_path.isImportDeclaration()) {
                var source = _path.node.source.value;
                pushModule(source, "imports", _path.node.specifiers);

                for (var _i9 = 0, _Object$keys2 = Object.keys(_path.getBindingIdentifiers()); _i9 < _Object$keys2.length; _i9++) {
                  var name = _Object$keys2[_i9];

                  _path.scope.removeBinding(name);

                  variableIds.push(Identifier(name));
                }

                _path.remove();
              } else if (_path.isExportAllDeclaration()) {
                pushModule(_path.node.source.value, "exports", _path.node);

                _path.remove();
              } else if (_path.isExportDefaultDeclaration()) {
                var declar = _path.get("declaration");

                var id = declar.node.id;

                if (declar.isClassDeclaration()) {
                  if (id) {
                    exportNames.push("default");
                    exportValues.push(undefinedIdent);
                    variableIds.push(id);
                    addExportName(id.name, "default");

                    _path.replaceWith(ExpressionStatement(AssignmentExpression("=", cloneNode(id), toExpression(declar.node))));
                  } else {
                    exportNames.push("default");
                    exportValues.push(toExpression(declar.node));
                    removedPaths.push(_path);
                  }
                } else if (declar.isFunctionDeclaration()) {
                  if (id) {
                    beforeBody.push(declar.node);
                    exportNames.push("default");
                    exportValues.push(cloneNode(id));
                    addExportName(id.name, "default");
                  } else {
                    exportNames.push("default");
                    exportValues.push(toExpression(declar.node));
                  }

                  removedPaths.push(_path);
                } else {
                  _path.replaceWith(buildExportCall("default", declar.node));
                }
              } else if (_path.isExportNamedDeclaration()) {
                var _declar = _path.get("declaration");

                if (_declar.node) {
                  _path.replaceWith(_declar);

                  if (_path.isFunction()) {
                    var node = _declar.node;
                    var _name2 = node.id.name;
                    addExportName(_name2, _name2);
                    beforeBody.push(node);
                    exportNames.push(_name2);
                    exportValues.push(cloneNode(node.id));
                    removedPaths.push(_path);
                  } else if (_path.isClass()) {
                    var _name3 = _declar.node.id.name;
                    exportNames.push(_name3);
                    exportValues.push(undefinedIdent);
                    variableIds.push(_declar.node.id);

                    _path.replaceWith(ExpressionStatement(AssignmentExpression("=", cloneNode(_declar.node.id), toExpression(_declar.node))));

                    addExportName(_name3, _name3);
                  } else {
                    for (var _i10 = 0, _Object$keys3 = Object.keys(_declar.getBindingIdentifiers()); _i10 < _Object$keys3.length; _i10++) {
                      var _name4 = _Object$keys3[_i10];
                      addExportName(_name4, _name4);
                    }
                  }
                } else {
                  var specifiers = _path.node.specifiers;

                  if (specifiers && specifiers.length) {
                    if (_path.node.source) {
                      pushModule(_path.node.source.value, "exports", specifiers);

                      _path.remove();
                    } else {
                      var nodes = [];

                      for (var _iterator6 = specifiers, _isArray6 = Array.isArray(_iterator6), _i11 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
                        var _ref6;

                        if (_isArray6) {
                          if (_i11 >= _iterator6.length) break;
                          _ref6 = _iterator6[_i11++];
                        } else {
                          _i11 = _iterator6.next();
                          if (_i11.done) break;
                          _ref6 = _i11.value;
                        }

                        var specifier = _ref6;

                        var binding = _path.scope.getBinding(specifier.local.name);

                        if (binding && isFunctionDeclaration(binding.path.node)) {
                          exportNames.push(specifier.exported.name);
                          exportValues.push(cloneNode(specifier.local));
                        } else if (!binding) {
                            nodes.push(buildExportCall(specifier.exported.name, specifier.local));
                          }

                        addExportName(specifier.local.name, specifier.exported.name);
                      }

                      _path.replaceWithMultiple(nodes);
                    }
                  } else {
                    _path.remove();
                  }
                }
              }
            }

            modules.forEach(function (specifiers) {
              var setterBody = [];
              var target = path.scope.generateUid(specifiers.key);

              for (var _iterator4 = specifiers.imports, _isArray4 = Array.isArray(_iterator4), _i6 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
                var _ref4;

                if (_isArray4) {
                  if (_i6 >= _iterator4.length) break;
                  _ref4 = _iterator4[_i6++];
                } else {
                  _i6 = _iterator4.next();
                  if (_i6.done) break;
                  _ref4 = _i6.value;
                }

                var specifier = _ref4;

                if (isImportNamespaceSpecifier(specifier)) {
                  setterBody.push(ExpressionStatement(AssignmentExpression("=", specifier.local, Identifier(target))));
                } else if (isImportDefaultSpecifier(specifier)) {
                  specifier = ImportSpecifier(specifier.local, Identifier("default"));
                }

                if (isImportSpecifier(specifier)) {
                  setterBody.push(ExpressionStatement(AssignmentExpression("=", specifier.local, MemberExpression(Identifier(target), specifier.imported))));
                }
              }

              if (specifiers.exports.length) {
                var _exportNames = [];
                var _exportValues = [];
                var hasExportStar = false;

                for (var _iterator5 = specifiers.exports, _isArray5 = Array.isArray(_iterator5), _i7 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
                  var _ref5;

                  if (_isArray5) {
                    if (_i7 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i7++];
                  } else {
                    _i7 = _iterator5.next();
                    if (_i7.done) break;
                    _ref5 = _i7.value;
                  }

                  var node = _ref5;

                  if (isExportAllDeclaration(node)) {
                    hasExportStar = true;
                  } else if (isExportSpecifier(node)) {
                    _exportNames.push(node.exported.name);

                    _exportValues.push(MemberExpression(Identifier(target), node.local));
                  }
                }

                setterBody = setterBody.concat(constructExportCall(path, Identifier(exportIdent), _exportNames, _exportValues, hasExportStar ? Identifier(target) : null));
              }

              sources.push(StringLiteral(specifiers.key));
              setters.push(FunctionExpression(null, [Identifier(target)], BlockStatement(setterBody)));
            });
            var moduleName = getModuleName(this.file.opts, options);
            if (moduleName) moduleName = StringLiteral(moduleName);
            hoistVariables(path, function (id, name, hasInit) {
              variableIds.push(id);

              if (!hasInit) {
                exportNames.push(name);
                exportValues.push(undefinedIdent);
              }
            }, null);

            if (variableIds.length) {
              beforeBody.unshift(VariableDeclaration("var", variableIds.map(function (id) {
                return VariableDeclarator(id);
              })));
            }

            if (exportNames.length) {
              beforeBody = beforeBody.concat(constructExportCall(path, Identifier(exportIdent), exportNames, exportValues, null));
            }

            path.traverse(reassignmentVisitor, {
              exports: exportMap,
              buildCall: buildExportCall,
              scope: path.scope
            });

            for (var _i8 = 0, _removedPaths = removedPaths; _i8 < _removedPaths.length; _i8++) {
              var _path2 = _removedPaths[_i8];

              _path2.remove();
            }

            path.node.body = [buildTemplate({
              SYSTEM_REGISTER: MemberExpression(Identifier(systemGlobal), Identifier("register")),
              BEFORE_BODY: beforeBody,
              MODULE_NAME: moduleName,
              SETTERS: ArrayExpression(setters),
              SOURCES: ArrayExpression(sources),
              BODY: path.node.body,
              EXPORT_IDENTIFIER: Identifier(exportIdent),
              CONTEXT_IDENTIFIER: Identifier(contextIdent)
            })];
          }
        }
      }
    };
  });

  var buildPrerequisiteAssignment = template("\n  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}\n");
  var buildWrapper$1 = template("\n  (function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n      define(MODULE_NAME, AMD_ARGUMENTS, factory);\n    } else if (typeof exports !== \"undefined\") {\n      factory(COMMONJS_ARGUMENTS);\n    } else {\n      var mod = { exports: {} };\n      factory(BROWSER_ARGUMENTS);\n\n      GLOBAL_TO_ASSIGN;\n    }\n  })(\n    typeof globalThis !== \"undefined\" ? globalThis\n      : typeof self !== \"undefined\" ? self\n      : this,\n    function(IMPORT_NAMES) {\n  })\n");
  var transformModulesUmd = declare(function (api, options) {
    api.assertVersion(7);
    var globals = options.globals,
        exactGlobals = options.exactGlobals,
        loose = options.loose,
        allowTopLevelThis = options.allowTopLevelThis,
        strict = options.strict,
        strictMode = options.strictMode,
        noInterop = options.noInterop;

    function buildBrowserInit(browserGlobals, exactGlobals, filename, moduleName) {
      var moduleNameOrBasename = moduleName ? moduleName.value : basename(filename, extname(filename));
      var globalToAssign = MemberExpression(Identifier("global"), Identifier(toIdentifier(moduleNameOrBasename)));
      var initAssignments = [];

      if (exactGlobals) {
        var globalName = browserGlobals[moduleNameOrBasename];

        if (globalName) {
          initAssignments = [];
          var members = globalName.split(".");
          globalToAssign = members.slice(1).reduce(function (accum, curr) {
            initAssignments.push(buildPrerequisiteAssignment({
              GLOBAL_REFERENCE: cloneNode(accum)
            }));
            return MemberExpression(accum, Identifier(curr));
          }, MemberExpression(Identifier("global"), Identifier(members[0])));
        }
      }

      initAssignments.push(ExpressionStatement(AssignmentExpression("=", globalToAssign, MemberExpression(Identifier("mod"), Identifier("exports")))));
      return initAssignments;
    }

    function buildBrowserArg(browserGlobals, exactGlobals, source) {
      var memberExpression;

      if (exactGlobals) {
        var globalRef = browserGlobals[source];

        if (globalRef) {
          memberExpression = globalRef.split(".").reduce(function (accum, curr) {
            return MemberExpression(accum, Identifier(curr));
          }, Identifier("global"));
        } else {
          memberExpression = MemberExpression(Identifier("global"), Identifier(toIdentifier(source)));
        }
      } else {
        var requireName = basename(source, extname(source));
        var globalName = browserGlobals[requireName] || requireName;
        memberExpression = MemberExpression(Identifier("global"), Identifier(toIdentifier(globalName)));
      }

      return memberExpression;
    }

    return {
      name: "transform-modules-umd",
      visitor: {
        Program: {
          exit: function exit(path) {
            if (!isModule(path)) return;
            var browserGlobals = globals || {};
            var moduleName = getModuleName(this.file.opts, options);
            if (moduleName) moduleName = StringLiteral(moduleName);

            var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
              loose: loose,
              strict: strict,
              strictMode: strictMode,
              allowTopLevelThis: allowTopLevelThis,
              noInterop: noInterop
            }),
                meta = _rewriteModuleStateme.meta,
                headers = _rewriteModuleStateme.headers;

            var amdArgs = [];
            var commonjsArgs = [];
            var browserArgs = [];
            var importNames = [];

            if (hasExports(meta)) {
              amdArgs.push(StringLiteral("exports"));
              commonjsArgs.push(Identifier("exports"));
              browserArgs.push(MemberExpression(Identifier("mod"), Identifier("exports")));
              importNames.push(Identifier(meta.exportName));
            }

            for (var _iterator = meta.source, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var _ref2 = _ref,
                  source = _ref2[0],
                  metadata = _ref2[1];
              amdArgs.push(StringLiteral(source));
              commonjsArgs.push(CallExpression(Identifier("require"), [StringLiteral(source)]));
              browserArgs.push(buildBrowserArg(browserGlobals, exactGlobals, source));
              importNames.push(Identifier(metadata.name));

              if (!isSideEffectImport(metadata)) {
                var interop = wrapInterop(path, Identifier(metadata.name), metadata.interop);

                if (interop) {
                  var header = ExpressionStatement(AssignmentExpression("=", Identifier(metadata.name), interop));
                  header.loc = meta.loc;
                  headers.push(header);
                }
              }

              headers.push.apply(headers, buildNamespaceInitStatements(meta, metadata, loose));
            }

            ensureStatementsHoisted(headers);
            path.unshiftContainer("body", headers);
            var _path$node = path.node,
                body = _path$node.body,
                directives = _path$node.directives;
            path.node.directives = [];
            path.node.body = [];
            var umdWrapper = path.pushContainer("body", [buildWrapper$1({
              MODULE_NAME: moduleName,
              AMD_ARGUMENTS: ArrayExpression(amdArgs),
              COMMONJS_ARGUMENTS: commonjsArgs,
              BROWSER_ARGUMENTS: browserArgs,
              IMPORT_NAMES: importNames,
              GLOBAL_TO_ASSIGN: buildBrowserInit(browserGlobals, exactGlobals, this.filename || "unknown", moduleName)
            })])[0];
            var umdFactory = umdWrapper.get("expression.arguments")[1].get("body");
            umdFactory.pushContainer("directives", directives);
            umdFactory.pushContainer("body", body);
          }
        }
      }
    };
  });

  function transformNamedCapturingGroupsRegex (core, options) {
    var _options$runtime = options.runtime,
        runtime = _options$runtime === void 0 ? true : _options$runtime;

    if (typeof runtime !== "boolean") {
      throw new Error("The 'runtime' option must be boolean");
    }

    return createRegExpFeaturePlugin({
      name: "transform-named-capturing-groups-regex",
      feature: "namedCaptureGroups",
      options: {
        runtime: runtime
      }
    });
  }

  var transformNewTarget = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-new-target",
      visitor: {
        MetaProperty: function MetaProperty(path) {
          var meta = path.get("meta");
          var property = path.get("property");
          var scope = path.scope;

          if (meta.isIdentifier({
            name: "new"
          }) && property.isIdentifier({
            name: "target"
          })) {
            var func = path.findParent(function (path) {
              if (path.isClass()) return true;

              if (path.isFunction() && !path.isArrowFunctionExpression()) {
                if (path.isClassMethod({
                  kind: "constructor"
                })) {
                  return false;
                }

                return true;
              }

              return false;
            });

            if (!func) {
              throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
            }

            var node = func.node;

            if (!node.id) {
              if (func.isMethod()) {
                path.replaceWith(scope.buildUndefinedNode());
                return;
              }

              node.id = scope.generateUidIdentifier("target");
            }

            var _constructor = MemberExpression(ThisExpression(), Identifier("constructor"));

            if (func.isClass()) {
              path.replaceWith(_constructor);
              return;
            }

            path.replaceWith(ConditionalExpression(BinaryExpression("instanceof", ThisExpression(), cloneNode(node.id)), _constructor, scope.buildUndefinedNode()));
          }
        }
      }
    };
  });

  var transformObjectAssign = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-object-assign",
      visitor: {
        CallExpression: function CallExpression(path, file) {
          if (path.get("callee").matchesPattern("Object.assign")) {
            path.node.callee = file.addHelper("extends");
          }
        }
      }
    };
  });

  function replacePropertySuper(path, getObjectRef, file) {
    var replaceSupers = new ReplaceSupers({
      getObjectRef: getObjectRef,
      methodPath: path,
      file: file
    });
    replaceSupers.replace();
  }

  var transformObjectSuper = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-object-super",
      visitor: {
        ObjectExpression: function ObjectExpression(path, state) {
          var objectRef;

          var getObjectRef = function getObjectRef() {
            return objectRef = objectRef || path.scope.generateUidIdentifier("obj");
          };

          path.get("properties").forEach(function (propPath) {
            if (!propPath.isMethod()) return;
            replacePropertySuper(propPath, getObjectRef, state);
          });

          if (objectRef) {
            path.scope.push({
              id: cloneNode(objectRef)
            });
            path.replaceWith(AssignmentExpression("=", cloneNode(objectRef), path.node));
          }
        }
      }
    };
  });

  var transformObjectSetPrototypeOfToAssign = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-object-set-prototype-of-to-assign",
      visitor: {
        CallExpression: function CallExpression(path, file) {
          if (path.get("callee").matchesPattern("Object.setPrototypeOf")) {
            path.node.callee = file.addHelper("defaults");
          }
        }
      }
    };
  });

  var buildDefaultParam = template("\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n");
  var buildLooseDefaultParam = template("\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n");
  var buildLooseDestructuredDefaultParam = template("\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n");
  var buildSafeArgumentsAccess = template("\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n");
  var iifeVisitor = {
    "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
      var scope = path.scope,
          node = path.node;
      var name = node.name;

      if (name === "eval" || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) {
        state.needsOuterBinding = true;
        path.stop();
      }
    }
  };
  function convertFunctionParams(path, loose) {
    var params = path.get("params");
    var isSimpleParameterList = params.every(function (param) {
      return param.isIdentifier();
    });
    if (isSimpleParameterList) return false;
    var node = path.node,
        scope = path.scope;
    var state = {
      stop: false,
      needsOuterBinding: false,
      scope: scope
    };
    var body = [];
    var shadowedParams = new Set();

    for (var _iterator = params, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var _param2 = _ref;

      for (var _i3 = 0, _Object$keys = Object.keys(_param2.getBindingIdentifiers()); _i3 < _Object$keys.length; _i3++) {
        var _scope$bindings$name;

        var name = _Object$keys[_i3];
        var constantViolations = (_scope$bindings$name = scope.bindings[name]) == null ? void 0 : _scope$bindings$name.constantViolations;

        if (constantViolations) {
          for (var _iterator3 = constantViolations, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
            var _ref3;

            if (_isArray3) {
              if (_i4 >= _iterator3.length) break;
              _ref3 = _iterator3[_i4++];
            } else {
              _i4 = _iterator3.next();
              if (_i4.done) break;
              _ref3 = _i4.value;
            }

            var redeclarator = _ref3;
            var _node = redeclarator.node;

            switch (_node.type) {
              case "VariableDeclarator":
                {
                  if (_node.init === null) {
                    var declaration = redeclarator.parentPath;

                    if (!declaration.parentPath.isFor() || declaration.parentPath.get("body") === declaration) {
                      redeclarator.remove();
                      break;
                    }
                  }

                  shadowedParams.add(name);
                  break;
                }

              case "FunctionDeclaration":
                shadowedParams.add(name);
                break;
            }
          }
        }
      }
    }

    if (shadowedParams.size === 0) {
      for (var _iterator2 = params, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var param = _ref2;
        if (!param.isIdentifier()) param.traverse(iifeVisitor, state);
        if (state.needsOuterBinding) break;
      }
    }

    var firstOptionalIndex = null;

    for (var i = 0; i < params.length; i++) {
      var _param = params[i];

      var paramIsAssignmentPattern = _param.isAssignmentPattern();

      if (paramIsAssignmentPattern && (loose || node.kind === "set")) {
        var left = _param.get("left");

        var right = _param.get("right");

        var undefinedNode = scope.buildUndefinedNode();

        if (left.isIdentifier()) {
          body.push(buildLooseDefaultParam({
            ASSIGNMENT_IDENTIFIER: cloneNode(left.node),
            DEFAULT_VALUE: right.node,
            UNDEFINED: undefinedNode
          }));

          _param.replaceWith(left.node);
        } else if (left.isObjectPattern() || left.isArrayPattern()) {
          var paramName = scope.generateUidIdentifier();
          body.push(buildLooseDestructuredDefaultParam({
            ASSIGNMENT_IDENTIFIER: left.node,
            DEFAULT_VALUE: right.node,
            PARAMETER_NAME: cloneNode(paramName),
            UNDEFINED: undefinedNode
          }));

          _param.replaceWith(paramName);
        }
      } else if (paramIsAssignmentPattern) {
        if (firstOptionalIndex === null) firstOptionalIndex = i;

        var _left = _param.get("left");

        var _right = _param.get("right");

        var defNode = buildDefaultParam({
          VARIABLE_NAME: _left.node,
          DEFAULT_VALUE: _right.node,
          ARGUMENT_KEY: NumericLiteral(i)
        });
        body.push(defNode);
      } else if (firstOptionalIndex !== null) {
        var _defNode = buildSafeArgumentsAccess([_param.node, NumericLiteral(i)]);

        body.push(_defNode);
      } else if (_param.isObjectPattern() || _param.isArrayPattern()) {
        var uid = path.scope.generateUidIdentifier("ref");

        var _defNode2 = VariableDeclaration("let", [VariableDeclarator(_param.node, uid)]);

        body.push(_defNode2);

        _param.replaceWith(cloneNode(uid));
      }
    }

    if (firstOptionalIndex !== null) {
      node.params = node.params.slice(0, firstOptionalIndex);
    }

    path.ensureBlock();

    if (state.needsOuterBinding || shadowedParams.size > 0) {
      body.push(buildScopeIIFE(shadowedParams, path.get("body").node));
      path.set("body", BlockStatement(body));
      var bodyPath = path.get("body.body");
      var arrowPath = bodyPath[bodyPath.length - 1].get("argument.callee");
      arrowPath.arrowFunctionToExpression();
    } else {
      path.get("body").unshiftContainer("body", body);
    }

    return true;
  }

  function buildScopeIIFE(shadowedParams, body) {
    var args = [];
    var params = [];

    for (var _iterator4 = shadowedParams, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
      var _ref4;

      if (_isArray4) {
        if (_i5 >= _iterator4.length) break;
        _ref4 = _iterator4[_i5++];
      } else {
        _i5 = _iterator4.next();
        if (_i5.done) break;
        _ref4 = _i5.value;
      }

      var name = _ref4;
      args.push(Identifier(name));
      params.push(Identifier(name));
    }

    return ReturnStatement(CallExpression(ArrowFunctionExpression(params, body), params));
  }

  var buildRest = template("\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n");
  var restIndex = template("\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n");
  var restIndexImpure = template("\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n");
  var restLength = template("\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n");

  function referencesRest(path, state) {
    if (path.node.name === state.name) {
      return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
    }

    return false;
  }

  var memberExpressionOptimisationVisitor = {
    Scope: function Scope(path, state) {
      if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {
        path.skip();
      }
    },
    Flow: function Flow(path) {
      if (path.isTypeCastExpression()) return;
      path.skip();
    },
    Function: function Function(path, state) {
      var oldNoOptimise = state.noOptimise;
      state.noOptimise = true;
      path.traverse(memberExpressionOptimisationVisitor, state);
      state.noOptimise = oldNoOptimise;
      path.skip();
    },
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      var node = path.node;

      if (node.name === "arguments") {
        state.deopted = true;
      }

      if (!referencesRest(path, state)) return;

      if (state.noOptimise) {
        state.deopted = true;
      } else {
        var parentPath = path.parentPath;

        if (parentPath.listKey === "params" && parentPath.key < state.offset) {
          return;
        }

        if (parentPath.isMemberExpression({
          object: node
        })) {
          var grandparentPath = parentPath.parentPath;
          var argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({
            operator: "delete"
          }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);

          if (argsOptEligible) {
            if (parentPath.node.computed) {
              if (parentPath.get("property").isBaseType("number")) {
                state.candidates.push({
                  cause: "indexGetter",
                  path: path
                });
                return;
              }
            } else if (parentPath.node.property.name === "length") {
              state.candidates.push({
                cause: "lengthGetter",
                path: path
              });
              return;
            }
          }
        }

        if (state.offset === 0 && parentPath.isSpreadElement()) {
          var call = parentPath.parentPath;

          if (call.isCallExpression() && call.node.arguments.length === 1) {
            state.candidates.push({
              cause: "argSpread",
              path: path
            });
            return;
          }
        }

        state.references.push(path);
      }
    },
    BindingIdentifier: function BindingIdentifier(path, state) {
      if (referencesRest(path, state)) {
        state.deopted = true;
      }
    }
  };

  function getParamsCount(node) {
    var count = node.params.length;

    if (count > 0 && isIdentifier(node.params[0], {
      name: "this"
    })) {
      count -= 1;
    }

    return count;
  }

  function hasRest(node) {
    var length = node.params.length;
    return length > 0 && isRestElement(node.params[length - 1]);
  }

  function optimiseIndexGetter(path, argsId, offset) {
    var offsetLiteral = NumericLiteral(offset);
    var index;

    if (isNumericLiteral(path.parent.property)) {
      index = NumericLiteral(path.parent.property.value + offset);
    } else if (offset === 0) {
      index = path.parent.property;
    } else {
      index = BinaryExpression("+", path.parent.property, cloneNode(offsetLiteral));
    }

    var scope = path.scope;

    if (!scope.isPure(index)) {
      var temp = scope.generateUidIdentifierBasedOnNode(index);
      scope.push({
        id: temp,
        kind: "var"
      });
      path.parentPath.replaceWith(restIndexImpure({
        ARGUMENTS: argsId,
        OFFSET: offsetLiteral,
        INDEX: index,
        REF: cloneNode(temp)
      }));
    } else {
      var parentPath = path.parentPath;
      parentPath.replaceWith(restIndex({
        ARGUMENTS: argsId,
        OFFSET: offsetLiteral,
        INDEX: index
      }));
      var offsetTestPath = parentPath.get("test").get("left");
      var valRes = offsetTestPath.evaluate();

      if (valRes.confident) {
        if (valRes.value === true) {
          parentPath.replaceWith(parentPath.scope.buildUndefinedNode());
        } else {
          parentPath.get("test").replaceWith(parentPath.get("test").get("right"));
        }
      }
    }
  }

  function optimiseLengthGetter(path, argsId, offset) {
    if (offset) {
      path.parentPath.replaceWith(restLength({
        ARGUMENTS: argsId,
        OFFSET: NumericLiteral(offset)
      }));
    } else {
      path.replaceWith(argsId);
    }
  }

  function convertFunctionRest(path) {
    var node = path.node,
        scope = path.scope;
    if (!hasRest(node)) return false;
    var rest = node.params.pop().argument;
    var argsId = Identifier("arguments");

    if (isPattern(rest)) {
      var pattern = rest;
      rest = scope.generateUidIdentifier("ref");
      var declar = VariableDeclaration("let", [VariableDeclarator(pattern, rest)]);
      node.body.body.unshift(declar);
    }

    var paramsCount = getParamsCount(node);
    var state = {
      references: [],
      offset: paramsCount,
      argumentsNode: argsId,
      outerBinding: scope.getBindingIdentifier(rest.name),
      candidates: [],
      name: rest.name,
      deopted: false
    };
    path.traverse(memberExpressionOptimisationVisitor, state);

    if (!state.deopted && !state.references.length) {
      for (var _i = 0, _arr = state.candidates; _i < _arr.length; _i++) {
        var _arr$_i = _arr[_i],
            _path = _arr$_i.path,
            cause = _arr$_i.cause;
        var clonedArgsId = cloneNode(argsId);

        switch (cause) {
          case "indexGetter":
            optimiseIndexGetter(_path, clonedArgsId, state.offset);
            break;

          case "lengthGetter":
            optimiseLengthGetter(_path, clonedArgsId, state.offset);
            break;

          default:
            _path.replaceWith(clonedArgsId);

        }
      }

      return true;
    }

    state.references = state.references.concat(state.candidates.map(function (_ref) {
      var path = _ref.path;
      return path;
    }));
    var start = NumericLiteral(paramsCount);
    var key = scope.generateUidIdentifier("key");
    var len = scope.generateUidIdentifier("len");
    var arrKey, arrLen;

    if (paramsCount) {
      arrKey = BinaryExpression("-", cloneNode(key), cloneNode(start));
      arrLen = ConditionalExpression(BinaryExpression(">", cloneNode(len), cloneNode(start)), BinaryExpression("-", cloneNode(len), cloneNode(start)), NumericLiteral(0));
    } else {
      arrKey = Identifier(key.name);
      arrLen = Identifier(len.name);
    }

    var loop = buildRest({
      ARGUMENTS: argsId,
      ARRAY_KEY: arrKey,
      ARRAY_LEN: arrLen,
      START: start,
      ARRAY: rest,
      KEY: key,
      LEN: len
    });

    if (state.deopted) {
      node.body.body.unshift(loop);
    } else {
      var target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();
      target.findParent(function (path) {
        if (path.isLoop()) {
          target = path;
        } else {
          return path.isFunction();
        }
      });
      target.insertBefore(loop);
    }

    return true;
  }

  var transformParameters = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose;
    return {
      name: "transform-parameters",
      visitor: {
        Function: function Function(path) {
          if (path.isArrowFunctionExpression() && path.get("params").some(function (param) {
            return param.isRestElement() || param.isAssignmentPattern();
          })) {
            path.arrowFunctionToExpression();
          }

          var convertedRest = convertFunctionRest(path);
          var convertedParams = convertFunctionParams(path, loose);

          if (convertedRest || convertedParams) {
            path.scope.crawl();
          }
        }
      }
    };
  });

  var transformPropertyLiterals = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-property-literals",
      visitor: {
        ObjectProperty: {
          exit: function exit(_ref) {
            var node = _ref.node;
            var key = node.key;

            if (!node.computed && isIdentifier(key) && !isValidES3Identifier(key.name)) {
              node.key = StringLiteral(key.name);
            }
          }
        }
      }
    };
  });

  var transformPropertyMutators = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-property-mutators",
      visitor: {
        ObjectExpression: function ObjectExpression(path, file) {
          var node = path.node;
          var hasAny = false;

          for (var _i = 0, _arr = node.properties; _i < _arr.length; _i++) {
            var prop = _arr[_i];

            if (prop.kind === "get" || prop.kind === "set") {
              hasAny = true;
              break;
            }
          }

          if (!hasAny) return;
          var mutatorMap = {};
          node.properties = node.properties.filter(function (prop) {
            if (!prop.computed && (prop.kind === "get" || prop.kind === "set")) {
              push(mutatorMap, prop, null, file);
              return false;
            } else {
              return true;
            }
          });
          path.replaceWith(CallExpression(MemberExpression(Identifier("Object"), Identifier("defineProperties")), [node, toDefineObject(mutatorMap)]));
        }
      }
    };
  });

  var transformProtoToAssign = declare(function (api) {
    api.assertVersion(7);

    function isProtoKey(node) {
      return isLiteral(toComputedKey(node, node.key), {
        value: "__proto__"
      });
    }

    function isProtoAssignmentExpression(node) {
      var left = node.left;
      return isMemberExpression(left) && isLiteral(toComputedKey(left, left.property), {
        value: "__proto__"
      });
    }

    function buildDefaultsCallExpression(expr, ref, file) {
      return ExpressionStatement(CallExpression(file.addHelper("defaults"), [ref, expr.right]));
    }

    return {
      name: "transform-proto-to-assign",
      visitor: {
        AssignmentExpression: function AssignmentExpression$1(path, file) {
          if (!isProtoAssignmentExpression(path.node)) return;
          var nodes = [];
          var left = path.node.left.object;
          var temp = path.scope.maybeGenerateMemoised(left);

          if (temp) {
            nodes.push(ExpressionStatement(AssignmentExpression("=", temp, left)));
          }

          nodes.push(buildDefaultsCallExpression(path.node, cloneNode(temp || left), file));
          if (temp) nodes.push(cloneNode(temp));
          path.replaceWithMultiple(nodes);
        },
        ExpressionStatement: function ExpressionStatement(path, file) {
          var expr = path.node.expression;
          if (!isAssignmentExpression(expr, {
            operator: "="
          })) return;

          if (isProtoAssignmentExpression(expr)) {
            path.replaceWith(buildDefaultsCallExpression(expr, expr.left.object, file));
          }
        },
        ObjectExpression: function ObjectExpression$1(path, file) {
          var proto;
          var node = path.node;

          for (var _i = 0, _arr = node.properties; _i < _arr.length; _i++) {
            var prop = _arr[_i];

            if (isProtoKey(prop)) {
              proto = prop.value;
              pull_1(node.properties, prop);
            }
          }

          if (proto) {
            var args = [ObjectExpression([]), proto];
            if (node.properties.length) args.push(node);
            path.replaceWith(CallExpression(file.addHelper("extends"), args));
          }
        }
      }
    };
  });

  var transformReactConstantElements = declare(function (api, options) {
    api.assertVersion(7);
    var allowMutablePropsOnTags = options.allowMutablePropsOnTags;

    if (allowMutablePropsOnTags != null && !Array.isArray(allowMutablePropsOnTags)) {
      throw new Error(".allowMutablePropsOnTags must be an array, null, or undefined.");
    }

    var HOISTED = new WeakSet();
    var immutabilityVisitor = {
      enter: function enter(path, state) {
        var stop = function stop() {
          state.isImmutable = false;
          path.stop();
        };

        if (path.isJSXClosingElement()) {
          path.skip();
          return;
        }

        if (path.isJSXIdentifier({
          name: "ref"
        }) && path.parentPath.isJSXAttribute({
          name: path.node
        })) {
          return stop();
        }

        if (path.isJSXIdentifier() || path.isIdentifier() || path.isJSXMemberExpression()) {
          return;
        }

        if (!path.isImmutable()) {
          if (path.isPure()) {
            var expressionResult = path.evaluate();

            if (expressionResult.confident) {
              var value = expressionResult.value;
              var isMutable = !state.mutablePropsAllowed && value && typeof value === "object" || typeof value === "function";

              if (!isMutable) {
                path.skip();
                return;
              }
            } else if (isIdentifier(expressionResult.deopt)) {
              return;
            }
          }

          stop();
        }
      }
    };
    return {
      name: "transform-react-constant-elements",
      visitor: {
        JSXElement: function JSXElement(path) {
          if (HOISTED.has(path.node)) return;
          HOISTED.add(path.node);
          var state = {
            isImmutable: true
          };

          if (allowMutablePropsOnTags != null) {
            var namePath = path.get("openingElement.name");

            while (namePath.isJSXMemberExpression()) {
              namePath = namePath.get("property");
            }

            var elementName = namePath.node.name;
            state.mutablePropsAllowed = allowMutablePropsOnTags.indexOf(elementName) > -1;
          }

          path.traverse(immutabilityVisitor, state);
          if (state.isImmutable) path.hoist();
        }
      }
    };
  });

  var transformReactDisplayName = declare(function (api) {
    api.assertVersion(7);

    function addDisplayName(id, call) {
      var props = call.arguments[0].properties;
      var safe = true;

      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        var key = toComputedKey(prop);

        if (isLiteral(key, {
          value: "displayName"
        })) {
          safe = false;
          break;
        }
      }

      if (safe) {
        props.unshift(ObjectProperty(Identifier("displayName"), StringLiteral(id)));
      }
    }

    var isCreateClassCallExpression = buildMatchMemberExpression("React.createClass");

    var isCreateClassAddon = function isCreateClassAddon(callee) {
      return callee.name === "createReactClass";
    };

    function isCreateClass(node) {
      if (!node || !isCallExpression(node)) return false;

      if (!isCreateClassCallExpression(node.callee) && !isCreateClassAddon(node.callee)) {
        return false;
      }

      var args = node.arguments;
      if (args.length !== 1) return false;
      var first = args[0];
      if (!isObjectExpression(first)) return false;
      return true;
    }

    return {
      name: "transform-react-display-name",
      visitor: {
        ExportDefaultDeclaration: function ExportDefaultDeclaration(_ref, state) {
          var node = _ref.node;

          if (isCreateClass(node.declaration)) {
            var filename = state.filename || "unknown";
            var displayName = path$1.basename(filename, path$1.extname(filename));

            if (displayName === "index") {
              displayName = path$1.basename(path$1.dirname(filename));
            }

            addDisplayName(displayName, node.declaration);
          }
        },
        CallExpression: function CallExpression(path) {
          var node = path.node;
          if (!isCreateClass(node)) return;
          var id;
          path.find(function (path) {
            if (path.isAssignmentExpression()) {
              id = path.node.left;
            } else if (path.isObjectProperty()) {
              id = path.node.key;
            } else if (path.isVariableDeclarator()) {
              id = path.node.id;
            } else if (path.isStatement()) {
              return true;
            }

            if (id) return true;
          });
          if (!id) return;

          if (isMemberExpression(id)) {
            id = id.property;
          }

          if (isIdentifier(id)) {
            addDisplayName(id.name, node);
          }
        }
      }
    };
  });

  function helper$2 (opts) {
    var visitor = {};

    visitor.JSXNamespacedName = function (path) {
      if (opts.throwIfNamespace) {
        throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
      }
    };

    visitor.JSXSpreadChild = function (path) {
      throw path.buildCodeFrameError("Spread children are not supported in React.");
    };

    visitor.JSXElement = {
      exit: function exit(path, file) {
        var callExpr = buildElementCall(path, file);

        if (callExpr) {
          path.replaceWith(inherits(callExpr, path.node));
        }
      }
    };
    visitor.JSXFragment = {
      exit: function exit(path, file) {
        if (opts.compat) {
          throw path.buildCodeFrameError("Fragment tags are only supported in React 16 and up.");
        }

        var callExpr = buildFragmentCall(path, file);

        if (callExpr) {
          path.replaceWith(inherits(callExpr, path.node));
        }
      }
    };
    return visitor;

    function convertJSXIdentifier(node, parent) {
      if (isJSXIdentifier(node)) {
        if (node.name === "this" && isReferenced(node, parent)) {
          return ThisExpression();
        } else if (isValidIdentifier(node.name, false)) {
          node.type = "Identifier";
        } else {
          return StringLiteral(node.name);
        }
      } else if (isJSXMemberExpression(node)) {
        return MemberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
      } else if (isJSXNamespacedName(node)) {
        return StringLiteral(node.namespace.name + ":" + node.name.name);
      }

      return node;
    }

    function convertAttributeValue(node) {
      if (isJSXExpressionContainer(node)) {
        return node.expression;
      } else {
        return node;
      }
    }

    function convertAttribute(node) {
      var value = convertAttributeValue(node.value || BooleanLiteral(true));

      if (isJSXSpreadAttribute(node)) {
        return SpreadElement(node.argument);
      }

      if (isStringLiteral(value) && !isJSXExpressionContainer(node.value)) {
        var _value$extra;

        value.value = value.value.replace(/\n\s+/g, " ");
        (_value$extra = value.extra) == null ? true : delete _value$extra.raw;
      }

      if (isJSXNamespacedName(node.name)) {
        node.name = StringLiteral(node.name.namespace.name + ":" + node.name.name.name);
      } else if (isValidIdentifier(node.name.name, false)) {
        node.name.type = "Identifier";
      } else {
        node.name = StringLiteral(node.name.name);
      }

      return inherits(ObjectProperty(node.name, value), node);
    }

    function buildElementCall(path, file) {
      if (opts.filter && !opts.filter(path.node, file)) return;
      var openingPath = path.get("openingElement");
      openingPath.parent.children = react.buildChildren(openingPath.parent);
      var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
      var args = [];
      var tagName;

      if (isIdentifier(tagExpr)) {
        tagName = tagExpr.name;
      } else if (isLiteral(tagExpr)) {
        tagName = tagExpr.value;
      }

      var state = {
        tagExpr: tagExpr,
        tagName: tagName,
        args: args,
        pure: false
      };

      if (opts.pre) {
        opts.pre(state, file);
      }

      var attribs = openingPath.node.attributes;

      if (attribs.length) {
        attribs = buildOpeningElementAttributes(attribs, file);
      } else {
        attribs = NullLiteral();
      }

      args.push.apply(args, [attribs].concat(path.node.children));

      if (opts.post) {
        opts.post(state, file);
      }

      var call = state.call || CallExpression(state.callee, args);
      if (state.pure) annotateAsPure(call);
      return call;
    }

    function pushProps(_props, objs) {
      if (!_props.length) return _props;
      objs.push(ObjectExpression(_props));
      return [];
    }

    function buildOpeningElementAttributes(attribs, file) {
      var _props = [];
      var objs = [];
      var _file$opts$useSpread = file.opts.useSpread,
          useSpread = _file$opts$useSpread === void 0 ? false : _file$opts$useSpread;

      if (typeof useSpread !== "boolean") {
        throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useSpread (defaults to false)");
      }

      var useBuiltIns = file.opts.useBuiltIns || false;

      if (typeof useBuiltIns !== "boolean") {
        throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useBuiltIns (defaults to false)");
      }

      if (useSpread && useBuiltIns) {
        throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread " + "but not both");
      }

      if (useSpread) {
        var props = attribs.map(convertAttribute);
        return ObjectExpression(props);
      }

      while (attribs.length) {
        var prop = attribs.shift();

        if (isJSXSpreadAttribute(prop)) {
          _props = pushProps(_props, objs);
          objs.push(prop.argument);
        } else {
          _props.push(convertAttribute(prop));
        }
      }

      pushProps(_props, objs);

      if (objs.length === 1) {
        attribs = objs[0];
      } else {
        if (!isObjectExpression(objs[0])) {
          objs.unshift(ObjectExpression([]));
        }

        var helper = useBuiltIns ? MemberExpression(Identifier("Object"), Identifier("assign")) : file.addHelper("extends");
        attribs = CallExpression(helper, objs);
      }

      return attribs;
    }

    function buildFragmentCall(path, file) {
      if (opts.filter && !opts.filter(path.node, file)) return;
      var openingPath = path.get("openingElement");
      openingPath.parent.children = react.buildChildren(openingPath.parent);
      var args = [];
      var tagName = null;
      var tagExpr = file.get("jsxFragIdentifier")();
      var state = {
        tagExpr: tagExpr,
        tagName: tagName,
        args: args,
        pure: false
      };

      if (opts.pre) {
        opts.pre(state, file);
      }

      args.push.apply(args, [NullLiteral()].concat(path.node.children));

      if (opts.post) {
        opts.post(state, file);
      }

      file.set("usedFragment", true);
      var call = state.call || CallExpression(state.callee, args);
      if (state.pure) annotateAsPure(call);
      return call;
    }
  }

  var transformReactInlineElements = declare(function (api) {
    api.assertVersion(7);

    function hasRefOrSpread(attrs) {
      for (var i = 0; i < attrs.length; i++) {
        var attr = attrs[i];
        if (isJSXSpreadAttribute(attr)) return true;
        if (isJSXAttributeOfName(attr, "ref")) return true;
      }

      return false;
    }

    function isJSXAttributeOfName(attr, name) {
      return isJSXAttribute(attr) && isJSXIdentifier(attr.name, {
        name: name
      });
    }

    var visitor = helper$2({
      filter: function filter(node) {
        return node.openingElement && !hasRefOrSpread(node.openingElement.attributes);
      },
      pre: function pre(state) {
        var tagName = state.tagName;
        var args = state.args;

        if (react.isCompatTag(tagName)) {
          args.push(StringLiteral(tagName));
        } else {
          args.push(state.tagExpr);
        }
      },
      post: function post(state, pass) {
        state.callee = pass.addHelper("jsx");
        var props = state.args[1];
        var hasKey = false;

        if (isObjectExpression(props)) {
          var keyIndex = props.properties.findIndex(function (prop) {
            return isIdentifier(prop.key, {
              name: "key"
            });
          });

          if (keyIndex > -1) {
            state.args.splice(2, 0, props.properties[keyIndex].value);
            props.properties.splice(keyIndex, 1);
            hasKey = true;
          }
        } else if (isNullLiteral(props)) {
          state.args.splice(1, 1, ObjectExpression([]));
        }

        if (!hasKey && state.args.length > 2) {
          state.args.splice(2, 0, UnaryExpression("void", NumericLiteral(0)));
        }

        state.pure = true;
      }
    });
    return {
      name: "transform-react-inline-elements",
      visitor: visitor
    };
  });

  var DEFAULT = {
    pragma: "React.createElement",
    pragmaFrag: "React.Fragment"
  };
  var transformClassic = declare(function (api, options) {
    var THROW_IF_NAMESPACE = options.throwIfNamespace === undefined ? true : !!options.throwIfNamespace;
    var PRAGMA_DEFAULT = options.pragma || DEFAULT.pragma;
    var PRAGMA_FRAG_DEFAULT = options.pragmaFrag || DEFAULT.pragmaFrag;
    var PURE_ANNOTATION = options.pure;
    var JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
    var JSX_FRAG_ANNOTATION_REGEX = /\*?\s*@jsxFrag\s+([^\s]+)/;

    var createIdentifierParser = function createIdentifierParser(id) {
      return function () {
        return id.split(".").map(function (name) {
          return Identifier(name);
        }).reduce(function (object, property) {
          return MemberExpression(object, property);
        });
      };
    };

    var visitor = helper$2({
      pre: function pre(state) {
        var tagName = state.tagName;
        var args = state.args;

        if (react.isCompatTag(tagName)) {
          args.push(StringLiteral(tagName));
        } else {
          args.push(state.tagExpr);
        }
      },
      post: function post(state, pass) {
        state.callee = pass.get("jsxIdentifier")();
        state.pure = PURE_ANNOTATION != null ? PURE_ANNOTATION : pass.get("pragma") === DEFAULT.pragma;
      },
      throwIfNamespace: THROW_IF_NAMESPACE
    });
    visitor.Program = {
      enter: function enter(path, state) {
        var file = state.file;
        var pragma = PRAGMA_DEFAULT;
        var pragmaFrag = PRAGMA_FRAG_DEFAULT;
        var pragmaSet = !!options.pragma;
        var pragmaFragSet = !!options.pragma;

        if (file.ast.comments) {
          for (var _i = 0, _arr = file.ast.comments; _i < _arr.length; _i++) {
            var comment = _arr[_i];
            var jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);

            if (jsxMatches) {
              pragma = jsxMatches[1];
              pragmaSet = true;
            }

            var jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);

            if (jsxFragMatches) {
              pragmaFrag = jsxFragMatches[1];
              pragmaFragSet = true;
            }
          }
        }

        state.set("jsxIdentifier", createIdentifierParser(pragma));
        state.set("jsxFragIdentifier", createIdentifierParser(pragmaFrag));
        state.set("usedFragment", false);
        state.set("pragma", pragma);
        state.set("pragmaSet", pragmaSet);
        state.set("pragmaFragSet", pragmaFragSet);
      },
      exit: function exit(path, state) {
        if (state.get("pragmaSet") && state.get("usedFragment") && !state.get("pragmaFragSet")) {
          throw new Error("transform-react-jsx: pragma has been set but " + "pragmaFrag has not been set");
        }
      }
    };

    visitor.JSXAttribute = function (path) {
      if (isJSXElement(path.node.value)) {
        path.node.value = JSXExpressionContainer(path.node.value);
      }
    };

    return {
      name: "transform-react-jsx",
      inherits: syntaxJsx,
      visitor: visitor
    };
  });

  var DEFAULT$1 = {
    importSource: "react",
    runtime: "automatic",
    pragma: "React.createElement",
    pragmaFrag: "React.Fragment"
  };
  function helper$3(babel, options) {
    var FILE_NAME_VAR = "_jsxFileName";
    var JSX_SOURCE_ANNOTATION_REGEX = /\*?\s*@jsxImportSource\s+([^\s]+)/;
    var JSX_RUNTIME_ANNOTATION_REGEX = /\*?\s*@jsxRuntime\s+([^\s]+)/;
    var JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
    var JSX_FRAG_ANNOTATION_REGEX = /\*?\s*@jsxFrag\s+([^\s]+)/;
    var IMPORT_NAME_SIZE = options.development ? 3 : 4;
    var _options$importSource = options.importSource,
        IMPORT_SOURCE_DEFAULT = _options$importSource === void 0 ? DEFAULT$1.importSource : _options$importSource,
        _options$runtime = options.runtime,
        RUNTIME_DEFAULT = _options$runtime === void 0 ? DEFAULT$1.runtime : _options$runtime,
        _options$pragma = options.pragma,
        PRAGMA_DEFAULT = _options$pragma === void 0 ? DEFAULT$1.pragma : _options$pragma,
        _options$pragmaFrag = options.pragmaFrag,
        PRAGMA_FRAG_DEFAULT = _options$pragmaFrag === void 0 ? DEFAULT$1.pragmaFrag : _options$pragmaFrag;
    var injectMetaPropertiesVisitor = {
      JSXOpeningElement: function JSXOpeningElement(path, state) {
        for (var _iterator = path.get("attributes"), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var attr = _ref;
          if (!attr.isJSXElement()) continue;
          var name = attr.node.name.name;

          if (name === "__source" || name === "__self") {
            throw path.buildCodeFrameError("__source and __self should not be defined in props and are reserved for internal usage.");
          }
        }

        var source = JSXAttribute(JSXIdentifier("__source"), JSXExpressionContainer(makeSource(path, state)));
        var self = JSXAttribute(JSXIdentifier("__self"), JSXExpressionContainer(ThisExpression()));
        path.pushContainer("attributes", [source, self]);
      }
    };
    return {
      JSXNamespacedName: function JSXNamespacedName(path, state) {
        var throwIfNamespace = state.opts.throwIfNamespace === undefined ? true : !!state.opts.throwIfNamespace;

        if (throwIfNamespace) {
          throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
        }
      },
      JSXSpreadChild: function JSXSpreadChild(path) {
        throw path.buildCodeFrameError("Spread children are not supported in React.");
      },
      JSXElement: {
        exit: function exit(path, file) {
          var callExpr;

          if (file.get("@babel/plugin-react-jsx/runtime") === "classic" || shouldUseCreateElement(path)) {
            callExpr = buildCreateElementCall(path, file);
          } else {
            callExpr = buildJSXElementCall(path, file);
          }

          path.replaceWith(inherits(callExpr, path.node));
        }
      },
      JSXFragment: {
        exit: function exit(path, file) {
          var callExpr;

          if (file.get("@babel/plugin-react-jsx/runtime") === "classic") {
            callExpr = buildCreateElementFragmentCall(path, file);
          } else {
            callExpr = buildJSXFragmentCall(path, file);
          }

          path.replaceWith(inherits(callExpr, path.node));
        }
      },
      JSXAttribute: function JSXAttribute(path) {
        if (isJSXElement(path.node.value)) {
          path.node.value = JSXExpressionContainer(path.node.value);
        }
      },
      Program: {
        enter: function enter(path, state) {
          if (hasJSX(path)) {
            var file = state.file;
            var runtime = RUNTIME_DEFAULT;
            var source = IMPORT_SOURCE_DEFAULT;
            var sourceSet = !!options.importSource;
            var pragma = PRAGMA_DEFAULT;
            var pragmaFrag = PRAGMA_FRAG_DEFAULT;
            var pragmaSet = !!options.pragma;
            var pragmaFragSet = !!options.pragmaFrag;

            if (file.ast.comments) {
              for (var _i2 = 0, _arr = file.ast.comments; _i2 < _arr.length; _i2++) {
                var comment = _arr[_i2];
                var sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);

                if (sourceMatches) {
                  source = sourceMatches[1];
                  sourceSet = true;
                }

                var runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);

                if (runtimeMatches) {
                  runtime = runtimeMatches[1];
                }

                var jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);

                if (jsxMatches) {
                  pragma = jsxMatches[1];
                  pragmaSet = true;
                }

                var jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);

                if (jsxFragMatches) {
                  pragmaFrag = jsxFragMatches[1];
                  pragmaFragSet = true;
                }
              }
            }

            state.set("@babel/plugin-react-jsx/runtime", runtime);

            if (runtime === "classic") {
              if (sourceSet) {
                throw path.buildCodeFrameError("importSource cannot be set when runtime is classic.");
              }

              state.set("@babel/plugin-react-jsx/createElementIdentifier", createIdentifierParser(pragma));
              state.set("@babel/plugin-react-jsx/jsxFragIdentifier", createIdentifierParser(pragmaFrag));
              state.set("@babel/plugin-react-jsx/usedFragment", false);
              state.set("@babel/plugin-react-jsx/pragmaSet", pragma !== DEFAULT$1.pragma);
              state.set("@babel/plugin-react-jsx/pragmaFragSet", pragmaFrag !== DEFAULT$1.pragmaFrag);
            } else if (runtime === "automatic") {
              if (pragmaSet || pragmaFragSet) {
                throw path.buildCodeFrameError("pragma and pragmaFrag cannot be set when runtime is automatic.");
              }

              var importName = addAutoImports(path, Object.assign({}, state.opts, {
                source: source
              }));
              state.set("@babel/plugin-react-jsx/jsxIdentifier", createIdentifierParser(createIdentifierName(path, options.development ? "jsxDEV" : "jsx", importName)));
              state.set("@babel/plugin-react-jsx/jsxStaticIdentifier", createIdentifierParser(createIdentifierName(path, options.development ? "jsxDEV" : "jsxs", importName)));
              state.set("@babel/plugin-react-jsx/createElementIdentifier", createIdentifierParser(createIdentifierName(path, "createElement", importName)));
              state.set("@babel/plugin-react-jsx/jsxFragIdentifier", createIdentifierParser(createIdentifierName(path, "Fragment", importName)));
              state.set("@babel/plugin-react-jsx/importSourceSet", source !== DEFAULT$1.importSource);
            } else {
              throw path.buildCodeFrameError("Runtime must be either \"classic\" or \"automatic\".");
            }

            if (options.development) {
              path.traverse(injectMetaPropertiesVisitor, state);
            }
          }
        },
        exit: function exit(path, state) {
          if (state.get("@babel/plugin-react-jsx/runtime") === "classic" && state.get("@babel/plugin-react-jsx/pragmaSet") && state.get("@babel/plugin-react-jsx/usedFragment") && !state.get("@babel/plugin-react-jsx/pragmaFragSet")) {
            throw new Error("transform-react-jsx: pragma has been set but " + "pragmaFrag has not been set");
          }
        }
      }
    };

    function shouldUseCreateElement(path) {
      var openingPath = path.get("openingElement");
      var attributes = openingPath.node.attributes;
      var seenPropsSpread = false;

      for (var i = 0; i < attributes.length; i++) {
        var attr = attributes[i];

        if (seenPropsSpread && isJSXAttribute(attr) && attr.name.name === "key") {
          return true;
        } else if (isJSXSpreadAttribute(attr)) {
          seenPropsSpread = true;
        }
      }

      return false;
    }

    function createIdentifierName(path, name, importName) {
      if (isModule(path)) {
        var identifierName = "" + importName[name];
        return identifierName;
      } else {
        return importName[name] + "." + name;
      }
    }

    function getImportNames(parentPath) {
      var imports = new Set();
      parentPath.traverse({
        "JSXElement|JSXFragment": function JSXElementJSXFragment(path) {
          if (path.type === "JSXFragment") imports.add("Fragment");
          var openingPath = path.get("openingElement");
          var validChildren = openingPath.parent.children.filter(function (child) {
            return !isJSXEmptyExpression(child) && !(isJSXText(child) && child.value.trim() === "");
          });
          var importName;

          if (path.type === "JSXElement" && shouldUseCreateElement(path)) {
            importName = "createElement";
          } else if (options.development) {
            importName = "jsxDEV";
          } else if (validChildren.length > 1) {
            importName = "jsxs";
          } else {
            importName = "jsx";
          }

          imports.add(importName);

          if (imports.size === IMPORT_NAME_SIZE) {
            path.stop();
          }
        }
      });
      return imports;
    }

    function hasJSX(parentPath) {
      var fileHasJSX = false;
      parentPath.traverse({
        "JSXElement|JSXFragment": function JSXElementJSXFragment(path) {
          fileHasJSX = true;
          path.stop();
        }
      });
      return fileHasJSX;
    }

    function getSource(source, importName) {
      switch (importName) {
        case "Fragment":
          return source + "/" + (options.development ? "jsx-dev-runtime" : "jsx-runtime");

        case "jsxDEV":
          return source + "/jsx-dev-runtime";

        case "jsx":
        case "jsxs":
          return source + "/jsx-runtime";

        case "createElement":
          return source;
      }
    }

    function addAutoImports(path, state) {
      var imports = getImportNames(path);

      if (isModule(path)) {
        var importMap = {};
        imports.forEach(function (importName) {
          if (!importMap[importName]) {
            importMap[importName] = addNamed(path, importName, getSource(state.source, importName), {
              importedInterop: "uncompiled",
              ensureLiveReference: true
            }).name;
          }
        });
        return importMap;
      } else {
        var _importMap = {};
        var sourceMap = {};
        imports.forEach(function (importName) {
          var source = getSource(state.source, importName);

          if (!_importMap[importName]) {
            if (!sourceMap[source]) {
              sourceMap[source] = addNamespace(path, source, {
                importedInterop: "uncompiled",
                ensureLiveReference: true
              }).name;
            }

            _importMap[importName] = sourceMap[source];
          }
        });
        return _importMap;
      }
    }

    function createIdentifierParser(id) {
      return function () {
        return id.split(".").map(function (name) {
          return Identifier(name);
        }).reduce(function (object, property) {
          return MemberExpression(object, property);
        });
      };
    }

    function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
      var fileLineLiteral = lineNumber != null ? NumericLiteral(lineNumber) : NullLiteral();
      var fileColumnLiteral = column0Based != null ? NumericLiteral(column0Based + 1) : NullLiteral();
      var fileNameProperty = ObjectProperty(Identifier("fileName"), fileNameIdentifier);
      var lineNumberProperty = ObjectProperty(Identifier("lineNumber"), fileLineLiteral);
      var columnNumberProperty = ObjectProperty(Identifier("columnNumber"), fileColumnLiteral);
      return ObjectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);
    }

    function makeSource(path, state) {
      var location = path.node.loc;

      if (!location) {
        return;
      }

      if (!state.fileNameIdentifier) {
        var _state$filename = state.filename,
            filename = _state$filename === void 0 ? "" : _state$filename;
        var fileNameIdentifier = path.scope.generateUidIdentifier(FILE_NAME_VAR);
        var scope = path.hub.getScope();

        if (scope) {
          scope.push({
            id: fileNameIdentifier,
            init: StringLiteral(filename)
          });
        }

        state.fileNameIdentifier = fileNameIdentifier;
      }

      return makeTrace(state.fileNameIdentifier, location.start.line, location.start.column);
    }

    function convertJSXIdentifier(node, parent) {
      if (isJSXIdentifier(node)) {
        if (node.name === "this" && isReferenced(node, parent)) {
          return ThisExpression();
        } else if (isValidIdentifier(node.name, false)) {
          node.type = "Identifier";
        } else {
          return StringLiteral(node.name);
        }
      } else if (isJSXMemberExpression(node)) {
        return MemberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
      } else if (isJSXNamespacedName(node)) {
        return StringLiteral(node.namespace.name + ":" + node.name.name);
      }

      return node;
    }

    function convertAttributeValue(node) {
      if (isJSXExpressionContainer(node)) {
        return node.expression;
      } else {
        return node;
      }
    }

    function convertAttribute(node) {
      var value = convertAttributeValue(node.value || BooleanLiteral(true));

      if (isJSXSpreadAttribute(node)) {
        return SpreadElement(node.argument);
      }

      if (isStringLiteral(value) && !isJSXExpressionContainer(node.value)) {
        value.value = value.value.replace(/\n\s+/g, " ");

        if (value.extra && value.extra.raw) {
          delete value.extra.raw;
        }
      }

      if (isJSXNamespacedName(node.name)) {
        node.name = StringLiteral(node.name.namespace.name + ":" + node.name.name.name);
      } else if (isValidIdentifier(node.name.name, false)) {
        node.name.type = "Identifier";
      } else {
        node.name = StringLiteral(node.name.name);
      }

      return inherits(ObjectProperty(node.name, value), node);
    }

    function buildJSXElementCall(path, file) {
      var openingPath = path.get("openingElement");
      openingPath.parent.children = react.buildChildren(openingPath.parent);
      var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
      var args = [];
      var tagName;

      if (isIdentifier(tagExpr)) {
        tagName = tagExpr.name;
      } else if (isLiteral(tagExpr)) {
        tagName = tagExpr.value;
      }

      var state = {
        tagExpr: tagExpr,
        tagName: tagName,
        args: args,
        pure: false
      };

      if (options.pre) {
        options.pre(state, file);
      }

      var attribs = [];
      var extracted = Object.create(null);

      for (var _iterator2 = openingPath.get("attributes"), _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i3 >= _iterator2.length) break;
          _ref2 = _iterator2[_i3++];
        } else {
          _i3 = _iterator2.next();
          if (_i3.done) break;
          _ref2 = _i3.value;
        }

        var attr = _ref2;

        if (attr.isJSXAttribute() && isJSXIdentifier(attr.node.name)) {
          var name = attr.node.name.name;

          switch (name) {
            case "__source":
            case "__self":
              if (extracted[name]) throw sourceSelfError(path, name);

            case "key":
              extracted[name] = convertAttributeValue(attr.node.value);
              break;

            default:
              attribs.push(attr.node);
          }
        } else {
          attribs.push(attr.node);
        }
      }

      if (attribs.length || path.node.children.length) {
        attribs = buildJSXOpeningElementAttributes(attribs, file, path.node.children);
      } else {
        attribs = ObjectExpression([]);
      }

      args.push(attribs);

      if (!options.development) {
        if (extracted.key !== undefined) {
          args.push(extracted.key);
        }
      } else {
        var _extracted$key, _extracted$__source, _extracted$__self;

        args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), BooleanLiteral(path.node.children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : ThisExpression());
      }

      if (options.post) {
        options.post(state, file);
      }

      var call = state.call || CallExpression(path.node.children.length > 1 ? state.jsxStaticCallee : state.jsxCallee, args);
      if (state.pure) annotateAsPure(call);
      return call;
    }

    function buildJSXOpeningElementAttributes(attribs, file, children) {
      var props = attribs.map(convertAttribute);

      if (children && children.length > 0) {
        if (children.length === 1) {
          props.push(ObjectProperty(Identifier("children"), children[0]));
        } else {
          props.push(ObjectProperty(Identifier("children"), ArrayExpression(children)));
        }
      }

      return ObjectExpression(props);
    }

    function buildJSXFragmentCall(path, file) {
      var openingPath = path.get("openingElement");
      openingPath.parent.children = react.buildChildren(openingPath.parent);
      var args = [];
      var tagName = null;
      var tagExpr = file.get("@babel/plugin-react-jsx/jsxFragIdentifier")();
      var state = {
        tagExpr: tagExpr,
        tagName: tagName,
        args: args,
        pure: false
      };

      if (options.pre) {
        options.pre(state, file);
      }

      var childrenNode;

      if (path.node.children.length > 0) {
        if (path.node.children.length === 1) {
          childrenNode = path.node.children[0];
        } else {
          childrenNode = ArrayExpression(path.node.children);
        }
      }

      args.push(ObjectExpression(childrenNode !== undefined ? [ObjectProperty(Identifier("children"), childrenNode)] : []));

      if (options.development) {
        args.push(path.scope.buildUndefinedNode(), BooleanLiteral(path.node.children.length > 1));
      }

      if (options.post) {
        options.post(state, file);
      }

      var call = state.call || CallExpression(path.node.children.length > 1 ? state.jsxStaticCallee : state.jsxCallee, args);
      if (state.pure) annotateAsPure(call);
      return call;
    }

    function buildCreateElementFragmentCall(path, file) {
      if (options.filter && !options.filter(path.node, file)) {
        return;
      }

      var openingPath = path.get("openingElement");
      openingPath.parent.children = react.buildChildren(openingPath.parent);
      var args = [];
      var tagName = null;
      var tagExpr = file.get("@babel/plugin-react-jsx/jsxFragIdentifier")();
      var state = {
        tagExpr: tagExpr,
        tagName: tagName,
        args: args,
        pure: false
      };

      if (options.pre) {
        options.pre(state, file);
      }

      args.push.apply(args, [NullLiteral()].concat(path.node.children));

      if (options.post) {
        options.post(state, file);
      }

      file.set("@babel/plugin-react-jsx/usedFragment", true);
      var call = state.call || CallExpression(state.createElementCallee, args);
      if (state.pure) annotateAsPure(call);
      return call;
    }

    function buildCreateElementCall(path, file) {
      var openingPath = path.get("openingElement");
      openingPath.parent.children = react.buildChildren(openingPath.parent);
      var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
      var args = [];
      var tagName;

      if (isIdentifier(tagExpr)) {
        tagName = tagExpr.name;
      } else if (isLiteral(tagExpr)) {
        tagName = tagExpr.value;
      }

      var state = {
        tagExpr: tagExpr,
        tagName: tagName,
        args: args,
        pure: false
      };

      if (options.pre) {
        options.pre(state, file);
      }

      var attribs = buildCreateElementOpeningElementAttributes(path, openingPath.node.attributes);
      args.push.apply(args, [attribs].concat(path.node.children));

      if (options.post) {
        options.post(state, file);
      }

      var call = state.call || CallExpression(state.createElementCallee, args);
      if (state.pure) annotateAsPure(call);
      return call;
    }

    function buildCreateElementOpeningElementAttributes(path, attribs) {
      var props = [];
      var found = Object.create(null);

      for (var _iterator3 = attribs, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i4 >= _iterator3.length) break;
          _ref3 = _iterator3[_i4++];
        } else {
          _i4 = _iterator3.next();
          if (_i4.done) break;
          _ref3 = _i4.value;
        }

        var attr = _ref3;
        var name = isJSXAttribute(attr) && isJSXIdentifier(attr.name) && attr.name.name;

        if (name === "__source" || name === "__self") {
          if (found[name]) throw sourceSelfError(path, name);
          found[name] = true;
          if (!options.development) continue;
        }

        props.push(convertAttribute(attr));
      }

      return props.length > 0 ? ObjectExpression(props) : NullLiteral();
    }

    function sourceSelfError(path, name) {
      var pluginName = "transform-react-jsx-" + name.slice(2);
      return path.buildCodeFrameError("Duplicate " + name + " prop found. You are most likely using the deprecated " + pluginName + " Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.");
    }
  }

  var transformAutomatic = declare(function (api, options) {
    var PURE_ANNOTATION = options.pure;
    var visitor = helper$3(api, Object.assign({
      pre: function pre(state) {
        var tagName = state.tagName;
        var args = state.args;

        if (react.isCompatTag(tagName)) {
          args.push(StringLiteral(tagName));
        } else {
          args.push(state.tagExpr);
        }
      },
      post: function post(state, pass) {
        if (pass.get("@babel/plugin-react-jsx/runtime") === "classic") {
          state.createElementCallee = pass.get("@babel/plugin-react-jsx/createElementIdentifier")();
          state.pure = PURE_ANNOTATION != null ? PURE_ANNOTATION : !pass.get("@babel/plugin-react-jsx/pragmaSet");
        } else {
          state.jsxCallee = pass.get("@babel/plugin-react-jsx/jsxIdentifier")();
          state.jsxStaticCallee = pass.get("@babel/plugin-react-jsx/jsxStaticIdentifier")();
          state.createElementCallee = pass.get("@babel/plugin-react-jsx/createElementIdentifier")();
          state.pure = PURE_ANNOTATION != null ? PURE_ANNOTATION : !pass.get("@babel/plugin-react-jsx/importSourceSet");
        }
      }
    }, options, {
      development: false
    }));
    return {
      name: "transform-react-jsx",
      inherits: syntaxJsx,
      visitor: visitor
    };
  });

  var transformReactJSX = declare(function (api, options) {
    var _options$runtime = options.runtime,
        runtime = _options$runtime === void 0 ? "classic" : _options$runtime;

    if (runtime === "classic") {
      return transformClassic(api, options);
    } else {
      return transformAutomatic(api, options);
    }
  });

  var transformReactJsxCompat = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-react-jsx-compat",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("jsx");
      },
      visitor: helper$2({
        pre: function pre(state) {
          state.callee = state.tagExpr;
        },
        post: function post(state) {
          if (react.isCompatTag(state.tagName)) {
            state.call = CallExpression(MemberExpression(MemberExpression(Identifier("React"), Identifier("DOM")), state.tagExpr, isLiteral(state.tagExpr)), state.args);
          }
        },
        compat: true
      })
    };
  });

  var transformReactJSXDevelopment = declare(function (api, options) {
    var PURE_ANNOTATION = options.pure;
    var visitor = helper$3(api, Object.assign({
      pre: function pre(state) {
        var tagName = state.tagName;
        var args = state.args;

        if (react.isCompatTag(tagName)) {
          args.push(StringLiteral(tagName));
        } else {
          args.push(state.tagExpr);
        }
      },
      post: function post(state, pass) {
        if (pass.get("@babel/plugin-react-jsx/runtime") === "classic") {
          state.createElementCallee = pass.get("@babel/plugin-react-jsx/createElementIdentifier")();
          state.pure = PURE_ANNOTATION != null ? PURE_ANNOTATION : !pass.get("@babel/plugin-react-jsx/pragmaSet");
        } else {
          state.jsxCallee = pass.get("@babel/plugin-react-jsx/jsxIdentifier")();
          state.jsxStaticCallee = pass.get("@babel/plugin-react-jsx/jsxStaticIdentifier")();
          state.createElementCallee = pass.get("@babel/plugin-react-jsx/createElementIdentifier")();
          state.pure = PURE_ANNOTATION != null ? PURE_ANNOTATION : !pass.get("@babel/plugin-react-jsx/importSourceSet");
        }
      }
    }, options, {
      development: true
    }));
    return {
      name: "transform-react-jsx",
      inherits: syntaxJsx,
      visitor: visitor
    };
  });

  var TRACE_ID = "__self";
  var transformReactJSXSelf = declare(function (api) {
    api.assertVersion(7);
    var visitor = {
      JSXOpeningElement: function JSXOpeningElement(_ref) {
        var node = _ref.node;
        var id = JSXIdentifier(TRACE_ID);
        var trace = ThisExpression();
        node.attributes.push(JSXAttribute(id, JSXExpressionContainer(trace)));
      }
    };
    return {
      name: "transform-react-jsx-self",
      visitor: {
        Program: function Program(path) {
          path.traverse(visitor);
        }
      }
    };
  });

  var TRACE_ID$1 = "__source";
  var FILE_NAME_VAR = "_jsxFileName";
  var transformReactJSXSource = declare(function (api) {
    api.assertVersion(7);

    function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
      var fileLineLiteral = lineNumber != null ? NumericLiteral(lineNumber) : NullLiteral();
      var fileColumnLiteral = column0Based != null ? NumericLiteral(column0Based + 1) : NullLiteral();
      var fileNameProperty = ObjectProperty(Identifier("fileName"), fileNameIdentifier);
      var lineNumberProperty = ObjectProperty(Identifier("lineNumber"), fileLineLiteral);
      var columnNumberProperty = ObjectProperty(Identifier("columnNumber"), fileColumnLiteral);
      return ObjectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);
    }

    var visitor = {
      JSXOpeningElement: function JSXOpeningElement(path, state) {
        var id = JSXIdentifier(TRACE_ID$1);
        var location = path.container.openingElement.loc;

        if (!location) {
          return;
        }

        var attributes = path.container.openingElement.attributes;

        for (var i = 0; i < attributes.length; i++) {
          var name = attributes[i].name;

          if (name && name.name === TRACE_ID$1) {
            return;
          }
        }

        if (!state.fileNameIdentifier) {
          var fileName = state.filename || "";
          var fileNameIdentifier = path.scope.generateUidIdentifier(FILE_NAME_VAR);
          var scope = path.hub.getScope();

          if (scope) {
            scope.push({
              id: fileNameIdentifier,
              init: StringLiteral(fileName)
            });
          }

          state.fileNameIdentifier = fileNameIdentifier;
        }

        var trace = makeTrace(state.fileNameIdentifier, location.start.line, location.start.column);
        attributes.push(JSXAttribute(id, JSXExpressionContainer(trace)));
      }
    };
    return {
      name: "transform-react-jsx-source",
      visitor: visitor
    };
  });

  var _typeof_1 = createCommonjsModule(function (module) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  module.exports = _typeof;
  });

  var interopRequireWildcard = createCommonjsModule(function (module) {
  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();

    _getRequireWildcardCache = function _getRequireWildcardCache() {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || _typeof_1(obj) !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }

    var cache = _getRequireWildcardCache();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj["default"] = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  module.exports = _interopRequireWildcard;
  });

  unwrapExports(interopRequireWildcard);

  var interopRequireDefault = createCommonjsModule(function (module) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  module.exports = _interopRequireDefault;
  });

  unwrapExports(interopRequireDefault);

  var util$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.wrapWithTypes = wrapWithTypes;
  exports.getTypes = getTypes;
  exports.runtimeProperty = runtimeProperty;
  exports.isReference = isReference;
  exports.replaceWithOrRemove = replaceWithOrRemove;
  var currentTypes = null;

  function wrapWithTypes(types, fn) {
    return function () {
      var oldTypes = currentTypes;
      currentTypes = types;

      try {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return fn.apply(this, args);
      } finally {
        currentTypes = oldTypes;
      }
    };
  }

  function getTypes() {
    return currentTypes;
  }

  function runtimeProperty(name) {
    var t = getTypes();
    return t.memberExpression(t.identifier("regeneratorRuntime"), t.identifier(name), false);
  }

  function isReference(path) {
    return path.isReferenced() || path.parentPath.isAssignmentExpression({
      left: path.node
    });
  }

  function replaceWithOrRemove(path, replacement) {
    if (replacement) {
      path.replaceWith(replacement);
    } else {
      path.remove();
    }
  }
  });

  unwrapExports(util$1);
  var util_1$1 = util$1.wrapWithTypes;
  var util_2$1 = util$1.getTypes;
  var util_3$1 = util$1.runtimeProperty;
  var util_4$1 = util$1.isReference;
  var util_5$1 = util$1.replaceWithOrRemove;

  var util$2 = interopRequireWildcard(util$1);

  var hasOwn$1 = Object.prototype.hasOwnProperty;

  var hoist_1 = function (funPath) {
    var t = util$2.getTypes();
    t.assertFunction(funPath.node);
    var vars = {};

    function varDeclToExpr(_ref, includeIdentifiers) {
      var vdec = _ref.node,
          scope = _ref.scope;
      t.assertVariableDeclaration(vdec);
      var exprs = [];
      vdec.declarations.forEach(function (dec) {
        vars[dec.id.name] = t.identifier(dec.id.name);
        scope.removeBinding(dec.id.name);

        if (dec.init) {
          exprs.push(t.assignmentExpression("=", dec.id, dec.init));
        } else if (includeIdentifiers) {
          exprs.push(dec.id);
        }
      });
      if (exprs.length === 0) return null;
      if (exprs.length === 1) return exprs[0];
      return t.sequenceExpression(exprs);
    }

    funPath.get("body").traverse({
      VariableDeclaration: {
        exit: function exit(path) {
          var expr = varDeclToExpr(path, false);

          if (expr === null) {
            path.remove();
          } else {
            util$2.replaceWithOrRemove(path, t.expressionStatement(expr));
          }

          path.skip();
        }
      },
      ForStatement: function ForStatement(path) {
        var init = path.get("init");

        if (init.isVariableDeclaration()) {
          util$2.replaceWithOrRemove(init, varDeclToExpr(init, false));
        }
      },
      ForXStatement: function ForXStatement(path) {
        var left = path.get("left");

        if (left.isVariableDeclaration()) {
          util$2.replaceWithOrRemove(left, varDeclToExpr(left, true));
        }
      },
      FunctionDeclaration: function FunctionDeclaration(path) {
        var node = path.node;
        vars[node.id.name] = node.id;
        var assignment = t.expressionStatement(t.assignmentExpression("=", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));

        if (path.parentPath.isBlockStatement()) {
          path.parentPath.unshiftContainer("body", assignment);
          path.remove();
        } else {
          util$2.replaceWithOrRemove(path, assignment);
        }

        path.scope.removeBinding(node.id.name);
        path.skip();
      },
      FunctionExpression: function FunctionExpression(path) {
        path.skip();
      },
      ArrowFunctionExpression: function ArrowFunctionExpression(path) {
        path.skip();
      }
    });
    var paramNames = {};
    funPath.get("params").forEach(function (paramPath) {
      var param = paramPath.node;

      if (t.isIdentifier(param)) {
        paramNames[param.name] = param;
      }
    });
    var declarations = [];
    Object.keys(vars).forEach(function (name) {
      if (!hasOwn$1.call(paramNames, name)) {
        declarations.push(t.variableDeclarator(vars[name], null));
      }
    });

    if (declarations.length === 0) {
      return null;
    }

    return t.variableDeclaration("var", declarations);
  };

  var hoist$1 = {
    hoist: hoist_1
  };

  var _assert = interopRequireDefault(assert$2);







  function Entry() {
    _assert["default"].ok(this instanceof Entry);
  }

  function FunctionEntry(returnLoc) {
    Entry.call(this);
    (0, util$1.getTypes)().assertLiteral(returnLoc);
    this.returnLoc = returnLoc;
  }

  (0, _util.inherits)(FunctionEntry, Entry);
  var FunctionEntry_1 = FunctionEntry;

  function LoopEntry(breakLoc, continueLoc, label) {
    Entry.call(this);
    var t = (0, util$1.getTypes)();
    t.assertLiteral(breakLoc);
    t.assertLiteral(continueLoc);

    if (label) {
      t.assertIdentifier(label);
    } else {
      label = null;
    }

    this.breakLoc = breakLoc;
    this.continueLoc = continueLoc;
    this.label = label;
  }

  (0, _util.inherits)(LoopEntry, Entry);
  var LoopEntry_1 = LoopEntry;

  function SwitchEntry(breakLoc) {
    Entry.call(this);
    (0, util$1.getTypes)().assertLiteral(breakLoc);
    this.breakLoc = breakLoc;
  }

  (0, _util.inherits)(SwitchEntry, Entry);
  var SwitchEntry_1 = SwitchEntry;

  function TryEntry(firstLoc, catchEntry, finallyEntry) {
    Entry.call(this);
    var t = (0, util$1.getTypes)();
    t.assertLiteral(firstLoc);

    if (catchEntry) {
      _assert["default"].ok(catchEntry instanceof CatchEntry);
    } else {
      catchEntry = null;
    }

    if (finallyEntry) {
      _assert["default"].ok(finallyEntry instanceof FinallyEntry);
    } else {
      finallyEntry = null;
    }

    _assert["default"].ok(catchEntry || finallyEntry);

    this.firstLoc = firstLoc;
    this.catchEntry = catchEntry;
    this.finallyEntry = finallyEntry;
  }

  (0, _util.inherits)(TryEntry, Entry);
  var TryEntry_1 = TryEntry;

  function CatchEntry(firstLoc, paramId) {
    Entry.call(this);
    var t = (0, util$1.getTypes)();
    t.assertLiteral(firstLoc);
    t.assertIdentifier(paramId);
    this.firstLoc = firstLoc;
    this.paramId = paramId;
  }

  (0, _util.inherits)(CatchEntry, Entry);
  var CatchEntry_1 = CatchEntry;

  function FinallyEntry(firstLoc, afterLoc) {
    Entry.call(this);
    var t = (0, util$1.getTypes)();
    t.assertLiteral(firstLoc);
    t.assertLiteral(afterLoc);
    this.firstLoc = firstLoc;
    this.afterLoc = afterLoc;
  }

  (0, _util.inherits)(FinallyEntry, Entry);
  var FinallyEntry_1 = FinallyEntry;

  function LabeledEntry(breakLoc, label) {
    Entry.call(this);
    var t = (0, util$1.getTypes)();
    t.assertLiteral(breakLoc);
    t.assertIdentifier(label);
    this.breakLoc = breakLoc;
    this.label = label;
  }

  (0, _util.inherits)(LabeledEntry, Entry);
  var LabeledEntry_1 = LabeledEntry;

  function LeapManager(emitter) {
    _assert["default"].ok(this instanceof LeapManager);

    _assert["default"].ok(emitter instanceof emit$1.Emitter);

    this.emitter = emitter;
    this.entryStack = [new FunctionEntry(emitter.finalLoc)];
  }

  var LMp = LeapManager.prototype;
  var LeapManager_1 = LeapManager;

  LMp.withEntry = function (entry, callback) {
    _assert["default"].ok(entry instanceof Entry);

    this.entryStack.push(entry);

    try {
      callback.call(this.emitter);
    } finally {
      var popped = this.entryStack.pop();

      _assert["default"].strictEqual(popped, entry);
    }
  };

  LMp._findLeapLocation = function (property, label) {
    for (var i = this.entryStack.length - 1; i >= 0; --i) {
      var entry = this.entryStack[i];
      var loc = entry[property];

      if (loc) {
        if (label) {
          if (entry.label && entry.label.name === label.name) {
            return loc;
          }
        } else if (entry instanceof LabeledEntry) ; else {
          return loc;
        }
      }
    }

    return null;
  };

  LMp.getBreakLoc = function (label) {
    return this._findLeapLocation("breakLoc", label);
  };

  LMp.getContinueLoc = function (label) {
    return this._findLeapLocation("continueLoc", label);
  };

  var leap = {
    FunctionEntry: FunctionEntry_1,
    LoopEntry: LoopEntry_1,
    SwitchEntry: SwitchEntry_1,
    TryEntry: TryEntry_1,
    CatchEntry: CatchEntry_1,
    FinallyEntry: FinallyEntry_1,
    LabeledEntry: LabeledEntry_1,
    LeapManager: LeapManager_1
  };

  var originalObject = Object;
  var originalDefProp = Object.defineProperty;
  var originalCreate = Object.create;

  function defProp(obj, name, value) {
    if (originalDefProp) try {
      originalDefProp.call(originalObject, obj, name, {
        value: value
      });
    } catch (definePropertyIsBrokenInIE8) {
      obj[name] = value;
    } else {
      obj[name] = value;
    }
  }

  function makeSafeToCall(fun) {
    if (fun) {
      defProp(fun, "call", fun.call);
      defProp(fun, "apply", fun.apply);
    }

    return fun;
  }

  makeSafeToCall(originalDefProp);
  makeSafeToCall(originalCreate);
  var hasOwn$2 = makeSafeToCall(Object.prototype.hasOwnProperty);
  var numToStr = makeSafeToCall(Number.prototype.toString);
  var strSlice = makeSafeToCall(String.prototype.slice);

  var cloner = function cloner() {};

  function create(prototype) {
    if (originalCreate) {
      return originalCreate.call(originalObject, prototype);
    }

    cloner.prototype = prototype || null;
    return new cloner();
  }

  var rand = Math.random;
  var uniqueKeys = create(null);

  function makeUniqueKey() {
    do {
      var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2));
    } while (hasOwn$2.call(uniqueKeys, uniqueKey));

    return uniqueKeys[uniqueKey] = uniqueKey;
  }

  function internString(str) {
    var obj = {};
    obj[str] = true;
    return Object.keys(obj)[0];
  }

  var makeUniqueKey_1 = makeUniqueKey;
  var originalGetOPNs = Object.getOwnPropertyNames;

  Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
    for (var names = originalGetOPNs(object), src = 0, dst = 0, len = names.length; src < len; ++src) {
      if (!hasOwn$2.call(uniqueKeys, names[src])) {
        if (src > dst) {
          names[dst] = names[src];
        }

        ++dst;
      }
    }

    names.length = dst;
    return names;
  };

  function defaultCreatorFn(object) {
    return create(null);
  }

  function makeAccessor(secretCreatorFn) {
    var brand = makeUniqueKey();
    var passkey = create(null);
    secretCreatorFn = secretCreatorFn || defaultCreatorFn;

    function register(object) {
      var secret;

      function vault(key, forget) {
        if (key === passkey) {
          return forget ? secret = null : secret || (secret = secretCreatorFn(object));
        }
      }

      defProp(object, brand, vault);
    }

    function accessor(object) {
      if (!hasOwn$2.call(object, brand)) register(object);
      return object[brand](passkey);
    }

    accessor.forget = function (object) {
      if (hasOwn$2.call(object, brand)) object[brand](passkey, true);
    };

    return accessor;
  }

  var makeAccessor_1 = makeAccessor;

  var _private = {
    makeUniqueKey: makeUniqueKey_1,
    makeAccessor: makeAccessor_1
  };

  var _assert$1 = interopRequireDefault(assert$2);





  var m$2 = (0, _private.makeAccessor)();
  var hasOwn$3 = Object.prototype.hasOwnProperty;

  function makePredicate(propertyName, knownTypes) {
    function onlyChildren(node) {
      var t = (0, util$1.getTypes)();
      t.assertNode(node);
      var result = false;

      function check(child) {
        if (result) ; else if (Array.isArray(child)) {
          child.some(check);
        } else if (t.isNode(child)) {
          _assert$1["default"].strictEqual(result, false);

          result = predicate(child);
        }

        return result;
      }

      var keys = t.VISITOR_KEYS[node.type];

      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var child = node[key];
          check(child);
        }
      }

      return result;
    }

    function predicate(node) {
      (0, util$1.getTypes)().assertNode(node);
      var meta = m$2(node);
      if (hasOwn$3.call(meta, propertyName)) return meta[propertyName];
      if (hasOwn$3.call(opaqueTypes, node.type)) return meta[propertyName] = false;
      if (hasOwn$3.call(knownTypes, node.type)) return meta[propertyName] = true;
      return meta[propertyName] = onlyChildren(node);
    }

    predicate.onlyChildren = onlyChildren;
    return predicate;
  }

  var opaqueTypes = {
    FunctionExpression: true,
    ArrowFunctionExpression: true
  };
  var sideEffectTypes = {
    CallExpression: true,
    ForInStatement: true,
    UnaryExpression: true,
    BinaryExpression: true,
    AssignmentExpression: true,
    UpdateExpression: true,
    NewExpression: true
  };
  var leapTypes = {
    YieldExpression: true,
    BreakStatement: true,
    ContinueStatement: true,
    ReturnStatement: true,
    ThrowStatement: true
  };

  for (var type$2 in leapTypes) {
    if (hasOwn$3.call(leapTypes, type$2)) {
      sideEffectTypes[type$2] = leapTypes[type$2];
    }
  }

  var hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes);
  var containsLeap = makePredicate("containsLeap", leapTypes);

  var meta = {
    hasSideEffects: hasSideEffects,
    containsLeap: containsLeap
  };

  var _assert$2 = interopRequireDefault(assert$2);

  var leap$1 = interopRequireWildcard(leap);

  var meta$1 = interopRequireWildcard(meta);

  var util$3 = interopRequireWildcard(util$1);

  var hasOwn$4 = Object.prototype.hasOwnProperty;

  function Emitter(contextId) {
    _assert$2["default"].ok(this instanceof Emitter);

    util$3.getTypes().assertIdentifier(contextId);
    this.nextTempId = 0;
    this.contextId = contextId;
    this.listing = [];
    this.marked = [true];
    this.insertedLocs = new Set();
    this.finalLoc = this.loc();
    this.tryEntries = [];
    this.leapManager = new leap$1.LeapManager(this);
  }

  var Ep = Emitter.prototype;
  var Emitter_1 = Emitter;

  Ep.loc = function () {
    var l = util$3.getTypes().numericLiteral(-1);
    this.insertedLocs.add(l);
    return l;
  };

  Ep.getInsertedLocs = function () {
    return this.insertedLocs;
  };

  Ep.getContextId = function () {
    return util$3.getTypes().clone(this.contextId);
  };

  Ep.mark = function (loc) {
    util$3.getTypes().assertLiteral(loc);
    var index = this.listing.length;

    if (loc.value === -1) {
      loc.value = index;
    } else {
      _assert$2["default"].strictEqual(loc.value, index);
    }

    this.marked[index] = true;
    return loc;
  };

  Ep.emit = function (node) {
    var t = util$3.getTypes();

    if (t.isExpression(node)) {
      node = t.expressionStatement(node);
    }

    t.assertStatement(node);
    this.listing.push(node);
  };

  Ep.emitAssign = function (lhs, rhs) {
    this.emit(this.assign(lhs, rhs));
    return lhs;
  };

  Ep.assign = function (lhs, rhs) {
    var t = util$3.getTypes();
    return t.expressionStatement(t.assignmentExpression("=", t.cloneDeep(lhs), rhs));
  };

  Ep.contextProperty = function (name, computed) {
    var t = util$3.getTypes();
    return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);
  };

  Ep.stop = function (rval) {
    if (rval) {
      this.setReturnValue(rval);
    }

    this.jump(this.finalLoc);
  };

  Ep.setReturnValue = function (valuePath) {
    util$3.getTypes().assertExpression(valuePath.value);
    this.emitAssign(this.contextProperty("rval"), this.explodeExpression(valuePath));
  };

  Ep.clearPendingException = function (tryLoc, assignee) {
    var t = util$3.getTypes();
    t.assertLiteral(tryLoc);
    var catchCall = t.callExpression(this.contextProperty("catch", true), [t.clone(tryLoc)]);

    if (assignee) {
      this.emitAssign(assignee, catchCall);
    } else {
      this.emit(catchCall);
    }
  };

  Ep.jump = function (toLoc) {
    this.emitAssign(this.contextProperty("next"), toLoc);
    this.emit(util$3.getTypes().breakStatement());
  };

  Ep.jumpIf = function (test, toLoc) {
    var t = util$3.getTypes();
    t.assertExpression(test);
    t.assertLiteral(toLoc);
    this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()])));
  };

  Ep.jumpIfNot = function (test, toLoc) {
    var t = util$3.getTypes();
    t.assertExpression(test);
    t.assertLiteral(toLoc);
    var negatedTest;

    if (t.isUnaryExpression(test) && test.operator === "!") {
      negatedTest = test.argument;
    } else {
      negatedTest = t.unaryExpression("!", test);
    }

    this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()])));
  };

  Ep.makeTempVar = function () {
    return this.contextProperty("t" + this.nextTempId++);
  };

  Ep.getContextFunction = function (id) {
    var t = util$3.getTypes();
    return t.functionExpression(id || null, [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false, false);
  };

  Ep.getDispatchLoop = function () {
    var self = this;
    var t = util$3.getTypes();
    var cases = [];
    var current;
    var alreadyEnded = false;
    self.listing.forEach(function (stmt, i) {
      if (self.marked.hasOwnProperty(i)) {
        cases.push(t.switchCase(t.numericLiteral(i), current = []));
        alreadyEnded = false;
      }

      if (!alreadyEnded) {
        current.push(stmt);
        if (t.isCompletionStatement(stmt)) alreadyEnded = true;
      }
    });
    this.finalLoc.value = this.listing.length;
    cases.push(t.switchCase(this.finalLoc, []), t.switchCase(t.stringLiteral("end"), [t.returnStatement(t.callExpression(this.contextProperty("stop"), []))]));
    return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases));
  };

  Ep.getTryLocsList = function () {
    if (this.tryEntries.length === 0) {
      return null;
    }

    var t = util$3.getTypes();
    var lastLocValue = 0;
    return t.arrayExpression(this.tryEntries.map(function (tryEntry) {
      var thisLocValue = tryEntry.firstLoc.value;

      _assert$2["default"].ok(thisLocValue >= lastLocValue, "try entries out of order");

      lastLocValue = thisLocValue;
      var ce = tryEntry.catchEntry;
      var fe = tryEntry.finallyEntry;
      var locs = [tryEntry.firstLoc, ce ? ce.firstLoc : null];

      if (fe) {
        locs[2] = fe.firstLoc;
        locs[3] = fe.afterLoc;
      }

      return t.arrayExpression(locs.map(function (loc) {
        return loc && t.clone(loc);
      }));
    }));
  };

  Ep.explode = function (path, ignoreResult) {
    var t = util$3.getTypes();
    var node = path.node;
    var self = this;
    t.assertNode(node);
    if (t.isDeclaration(node)) throw getDeclError(node);
    if (t.isStatement(node)) return self.explodeStatement(path);
    if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);

    switch (node.type) {
      case "Program":
        return path.get("body").map(self.explodeStatement, self);

      case "VariableDeclarator":
        throw getDeclError(node);

      case "Property":
      case "SwitchCase":
      case "CatchClause":
        throw new Error(node.type + " nodes should be handled by their parents");

      default:
        throw new Error("unknown Node of type " + JSON.stringify(node.type));
    }
  };

  function getDeclError(node) {
    return new Error("all declarations should have been transformed into " + "assignments before the Exploder began its work: " + JSON.stringify(node));
  }

  Ep.explodeStatement = function (path, labelId) {
    var t = util$3.getTypes();
    var stmt = path.node;
    var self = this;
    var before, after, head;
    t.assertStatement(stmt);

    if (labelId) {
      t.assertIdentifier(labelId);
    } else {
      labelId = null;
    }

    if (t.isBlockStatement(stmt)) {
      path.get("body").forEach(function (path) {
        self.explodeStatement(path);
      });
      return;
    }

    if (!meta$1.containsLeap(stmt)) {
      self.emit(stmt);
      return;
    }

    switch (stmt.type) {
      case "ExpressionStatement":
        self.explodeExpression(path.get("expression"), true);
        break;

      case "LabeledStatement":
        after = this.loc();
        self.leapManager.withEntry(new leap$1.LabeledEntry(after, stmt.label), function () {
          self.explodeStatement(path.get("body"), stmt.label);
        });
        self.mark(after);
        break;

      case "WhileStatement":
        before = this.loc();
        after = this.loc();
        self.mark(before);
        self.jumpIfNot(self.explodeExpression(path.get("test")), after);
        self.leapManager.withEntry(new leap$1.LoopEntry(after, before, labelId), function () {
          self.explodeStatement(path.get("body"));
        });
        self.jump(before);
        self.mark(after);
        break;

      case "DoWhileStatement":
        var first = this.loc();
        var test = this.loc();
        after = this.loc();
        self.mark(first);
        self.leapManager.withEntry(new leap$1.LoopEntry(after, test, labelId), function () {
          self.explode(path.get("body"));
        });
        self.mark(test);
        self.jumpIf(self.explodeExpression(path.get("test")), first);
        self.mark(after);
        break;

      case "ForStatement":
        head = this.loc();
        var update = this.loc();
        after = this.loc();

        if (stmt.init) {
          self.explode(path.get("init"), true);
        }

        self.mark(head);

        if (stmt.test) {
          self.jumpIfNot(self.explodeExpression(path.get("test")), after);
        }

        self.leapManager.withEntry(new leap$1.LoopEntry(after, update, labelId), function () {
          self.explodeStatement(path.get("body"));
        });
        self.mark(update);

        if (stmt.update) {
          self.explode(path.get("update"), true);
        }

        self.jump(head);
        self.mark(after);
        break;

      case "TypeCastExpression":
        return self.explodeExpression(path.get("expression"));

      case "ForInStatement":
        head = this.loc();
        after = this.loc();
        var keyIterNextFn = self.makeTempVar();
        self.emitAssign(keyIterNextFn, t.callExpression(util$3.runtimeProperty("keys"), [self.explodeExpression(path.get("right"))]));
        self.mark(head);
        var keyInfoTmpVar = self.makeTempVar();
        self.jumpIf(t.memberExpression(t.assignmentExpression("=", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier("done"), false), after);
        self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier("value"), false));
        self.leapManager.withEntry(new leap$1.LoopEntry(after, head, labelId), function () {
          self.explodeStatement(path.get("body"));
        });
        self.jump(head);
        self.mark(after);
        break;

      case "BreakStatement":
        self.emitAbruptCompletion({
          type: "break",
          target: self.leapManager.getBreakLoc(stmt.label)
        });
        break;

      case "ContinueStatement":
        self.emitAbruptCompletion({
          type: "continue",
          target: self.leapManager.getContinueLoc(stmt.label)
        });
        break;

      case "SwitchStatement":
        var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")));
        after = this.loc();
        var defaultLoc = this.loc();
        var condition = defaultLoc;
        var caseLocs = [];
        var cases = stmt.cases || [];

        for (var i = cases.length - 1; i >= 0; --i) {
          var c = cases[i];
          t.assertSwitchCase(c);

          if (c.test) {
            condition = t.conditionalExpression(t.binaryExpression("===", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition);
          } else {
            caseLocs[i] = defaultLoc;
          }
        }

        var discriminant = path.get("discriminant");
        util$3.replaceWithOrRemove(discriminant, condition);
        self.jump(self.explodeExpression(discriminant));
        self.leapManager.withEntry(new leap$1.SwitchEntry(after), function () {
          path.get("cases").forEach(function (casePath) {
            var i = casePath.key;
            self.mark(caseLocs[i]);
            casePath.get("consequent").forEach(function (path) {
              self.explodeStatement(path);
            });
          });
        });
        self.mark(after);

        if (defaultLoc.value === -1) {
          self.mark(defaultLoc);

          _assert$2["default"].strictEqual(after.value, defaultLoc.value);
        }

        break;

      case "IfStatement":
        var elseLoc = stmt.alternate && this.loc();
        after = this.loc();
        self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after);
        self.explodeStatement(path.get("consequent"));

        if (elseLoc) {
          self.jump(after);
          self.mark(elseLoc);
          self.explodeStatement(path.get("alternate"));
        }

        self.mark(after);
        break;

      case "ReturnStatement":
        self.emitAbruptCompletion({
          type: "return",
          value: self.explodeExpression(path.get("argument"))
        });
        break;

      case "WithStatement":
        throw new Error("WithStatement not supported in generator functions.");

      case "TryStatement":
        after = this.loc();
        var handler = stmt.handler;
        var catchLoc = handler && this.loc();
        var catchEntry = catchLoc && new leap$1.CatchEntry(catchLoc, handler.param);
        var finallyLoc = stmt.finalizer && this.loc();
        var finallyEntry = finallyLoc && new leap$1.FinallyEntry(finallyLoc, after);
        var tryEntry = new leap$1.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
        self.tryEntries.push(tryEntry);
        self.updateContextPrevLoc(tryEntry.firstLoc);
        self.leapManager.withEntry(tryEntry, function () {
          self.explodeStatement(path.get("block"));

          if (catchLoc) {
            if (finallyLoc) {
              self.jump(finallyLoc);
            } else {
              self.jump(after);
            }

            self.updateContextPrevLoc(self.mark(catchLoc));
            var bodyPath = path.get("handler.body");
            var safeParam = self.makeTempVar();
            self.clearPendingException(tryEntry.firstLoc, safeParam);
            bodyPath.traverse(catchParamVisitor, {
              getSafeParam: function getSafeParam() {
                return t.cloneDeep(safeParam);
              },
              catchParamName: handler.param.name
            });
            self.leapManager.withEntry(catchEntry, function () {
              self.explodeStatement(bodyPath);
            });
          }

          if (finallyLoc) {
            self.updateContextPrevLoc(self.mark(finallyLoc));
            self.leapManager.withEntry(finallyEntry, function () {
              self.explodeStatement(path.get("finalizer"));
            });
            self.emit(t.returnStatement(t.callExpression(self.contextProperty("finish"), [finallyEntry.firstLoc])));
          }
        });
        self.mark(after);
        break;

      case "ThrowStatement":
        self.emit(t.throwStatement(self.explodeExpression(path.get("argument"))));
        break;

      default:
        throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
    }
  };

  var catchParamVisitor = {
    Identifier: function Identifier(path, state) {
      if (path.node.name === state.catchParamName && util$3.isReference(path)) {
        util$3.replaceWithOrRemove(path, state.getSafeParam());
      }
    },
    Scope: function Scope(path, state) {
      if (path.scope.hasOwnBinding(state.catchParamName)) {
        path.skip();
      }
    }
  };

  Ep.emitAbruptCompletion = function (record) {
    if (!isValidCompletion(record)) {
      _assert$2["default"].ok(false, "invalid completion record: " + JSON.stringify(record));
    }

    _assert$2["default"].notStrictEqual(record.type, "normal", "normal completions are not abrupt");

    var t = util$3.getTypes();
    var abruptArgs = [t.stringLiteral(record.type)];

    if (record.type === "break" || record.type === "continue") {
      t.assertLiteral(record.target);
      abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);
    } else if (record.type === "return" || record.type === "throw") {
      if (record.value) {
        t.assertExpression(record.value);
        abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);
      }
    }

    this.emit(t.returnStatement(t.callExpression(this.contextProperty("abrupt"), abruptArgs)));
  };

  function isValidCompletion(record) {
    var type = record.type;

    if (type === "normal") {
      return !hasOwn$4.call(record, "target");
    }

    if (type === "break" || type === "continue") {
      return !hasOwn$4.call(record, "value") && util$3.getTypes().isLiteral(record.target);
    }

    if (type === "return" || type === "throw") {
      return hasOwn$4.call(record, "value") && !hasOwn$4.call(record, "target");
    }

    return false;
  }

  Ep.getUnmarkedCurrentLoc = function () {
    return util$3.getTypes().numericLiteral(this.listing.length);
  };

  Ep.updateContextPrevLoc = function (loc) {
    var t = util$3.getTypes();

    if (loc) {
      t.assertLiteral(loc);

      if (loc.value === -1) {
        loc.value = this.listing.length;
      } else {
        _assert$2["default"].strictEqual(loc.value, this.listing.length);
      }
    } else {
      loc = this.getUnmarkedCurrentLoc();
    }

    this.emitAssign(this.contextProperty("prev"), loc);
  };

  Ep.explodeExpression = function (path, ignoreResult) {
    var t = util$3.getTypes();
    var expr = path.node;

    if (expr) {
      t.assertExpression(expr);
    } else {
      return expr;
    }

    var self = this;
    var result;
    var after;

    function finish(expr) {
      t.assertExpression(expr);

      if (ignoreResult) {
        self.emit(expr);
      } else {
        return expr;
      }
    }

    if (!meta$1.containsLeap(expr)) {
      return finish(expr);
    }

    var hasLeapingChildren = meta$1.containsLeap.onlyChildren(expr);

    function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {
      _assert$2["default"].ok(!ignoreChildResult || !tempVar, "Ignoring the result of a child expression but forcing it to " + "be assigned to a temporary variable?");

      var result = self.explodeExpression(childPath, ignoreChildResult);

      if (ignoreChildResult) ; else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {
        result = self.emitAssign(tempVar || self.makeTempVar(), result);
      }

      return result;
    }

    switch (expr.type) {
      case "MemberExpression":
        return finish(t.memberExpression(self.explodeExpression(path.get("object")), expr.computed ? explodeViaTempVar(null, path.get("property")) : expr.property, expr.computed));

      case "CallExpression":
        var calleePath = path.get("callee");
        var argsPath = path.get("arguments");
        var newCallee;
        var newArgs;
        var hasLeapingArgs = argsPath.some(function (argPath) {
          return meta$1.containsLeap(argPath.node);
        });
        var injectFirstArg = null;

        if (t.isMemberExpression(calleePath.node)) {
          if (hasLeapingArgs) {
            var newObject = explodeViaTempVar(self.makeTempVar(), calleePath.get("object"));
            var newProperty = calleePath.node.computed ? explodeViaTempVar(null, calleePath.get("property")) : calleePath.node.property;
            injectFirstArg = newObject;
            newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier("call"), false);
          } else {
            newCallee = self.explodeExpression(calleePath);
          }
        } else {
          newCallee = explodeViaTempVar(null, calleePath);

          if (t.isMemberExpression(newCallee)) {
            newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);
          }
        }

        if (hasLeapingArgs) {
          newArgs = argsPath.map(function (argPath) {
            return explodeViaTempVar(null, argPath);
          });
          if (injectFirstArg) newArgs.unshift(injectFirstArg);
          newArgs = newArgs.map(function (arg) {
            return t.cloneDeep(arg);
          });
        } else {
          newArgs = path.node.arguments;
        }

        return finish(t.callExpression(newCallee, newArgs));

      case "NewExpression":
        return finish(t.newExpression(explodeViaTempVar(null, path.get("callee")), path.get("arguments").map(function (argPath) {
          return explodeViaTempVar(null, argPath);
        })));

      case "ObjectExpression":
        return finish(t.objectExpression(path.get("properties").map(function (propPath) {
          if (propPath.isObjectProperty()) {
            return t.objectProperty(propPath.node.key, explodeViaTempVar(null, propPath.get("value")), propPath.node.computed);
          } else {
            return propPath.node;
          }
        })));

      case "ArrayExpression":
        return finish(t.arrayExpression(path.get("elements").map(function (elemPath) {
          if (elemPath.isSpreadElement()) {
            return t.spreadElement(explodeViaTempVar(null, elemPath.get("argument")));
          } else {
            return explodeViaTempVar(null, elemPath);
          }
        })));

      case "SequenceExpression":
        var lastIndex = expr.expressions.length - 1;
        path.get("expressions").forEach(function (exprPath) {
          if (exprPath.key === lastIndex) {
            result = self.explodeExpression(exprPath, ignoreResult);
          } else {
            self.explodeExpression(exprPath, true);
          }
        });
        return result;

      case "LogicalExpression":
        after = this.loc();

        if (!ignoreResult) {
          result = self.makeTempVar();
        }

        var left = explodeViaTempVar(result, path.get("left"));

        if (expr.operator === "&&") {
          self.jumpIfNot(left, after);
        } else {
          _assert$2["default"].strictEqual(expr.operator, "||");

          self.jumpIf(left, after);
        }

        explodeViaTempVar(result, path.get("right"), ignoreResult);
        self.mark(after);
        return result;

      case "ConditionalExpression":
        var elseLoc = this.loc();
        after = this.loc();
        var test = self.explodeExpression(path.get("test"));
        self.jumpIfNot(test, elseLoc);

        if (!ignoreResult) {
          result = self.makeTempVar();
        }

        explodeViaTempVar(result, path.get("consequent"), ignoreResult);
        self.jump(after);
        self.mark(elseLoc);
        explodeViaTempVar(result, path.get("alternate"), ignoreResult);
        self.mark(after);
        return result;

      case "UnaryExpression":
        return finish(t.unaryExpression(expr.operator, self.explodeExpression(path.get("argument")), !!expr.prefix));

      case "BinaryExpression":
        return finish(t.binaryExpression(expr.operator, explodeViaTempVar(null, path.get("left")), explodeViaTempVar(null, path.get("right"))));

      case "AssignmentExpression":
        if (expr.operator === "=") {
          return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get("left")), self.explodeExpression(path.get("right"))));
        }

        var lhs = self.explodeExpression(path.get("left"));
        var temp = self.emitAssign(self.makeTempVar(), lhs);
        return finish(t.assignmentExpression("=", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get("right")))));

      case "UpdateExpression":
        return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get("argument")), expr.prefix));

      case "YieldExpression":
        after = this.loc();
        var arg = expr.argument && self.explodeExpression(path.get("argument"));

        if (arg && expr.delegate) {
          var _result = self.makeTempVar();

          var _ret = t.returnStatement(t.callExpression(self.contextProperty("delegateYield"), [arg, t.stringLiteral(_result.property.name), after]));

          _ret.loc = expr.loc;
          self.emit(_ret);
          self.mark(after);
          return _result;
        }

        self.emitAssign(self.contextProperty("next"), after);
        var ret = t.returnStatement(t.cloneDeep(arg) || null);
        ret.loc = expr.loc;
        self.emit(ret);
        self.mark(after);
        return self.contextProperty("sent");

      default:
        throw new Error("unknown Expression of type " + JSON.stringify(expr.type));
    }
  };

  var emit$1 = {
    Emitter: Emitter_1
  };

  var replaceShorthandObjectMethod_1 = createCommonjsModule(function (module, exports) {



  exports.__esModule = true;
  exports["default"] = replaceShorthandObjectMethod;

  var util = interopRequireWildcard(util$1);

  function replaceShorthandObjectMethod(path) {
    var t = util.getTypes();

    if (!path.node || !t.isFunction(path.node)) {
      throw new Error("replaceShorthandObjectMethod can only be called on Function AST node paths.");
    }

    if (!t.isObjectMethod(path.node)) {
      return path;
    }

    if (!path.node.generator) {
      return path;
    }

    var parameters = path.node.params.map(function (param) {
      return t.cloneDeep(param);
    });
    var functionExpression = t.functionExpression(null, parameters, t.cloneDeep(path.node.body), path.node.generator, path.node.async);
    util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), functionExpression, path.node.computed, false));
    return path.get("value");
  }
  });

  unwrapExports(replaceShorthandObjectMethod_1);

  var _assert$3 = interopRequireDefault(assert$2);





  var _replaceShorthandObjectMethod = interopRequireDefault(replaceShorthandObjectMethod_1);

  var util$4 = interopRequireWildcard(util$1);



  var getVisitor = function (_ref) {
    var t = _ref.types;
    return {
      Method: function Method(path, state) {
        var node = path.node;
        if (!shouldRegenerate(node, state)) return;
        var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);
        path.get("body").set("body", [t.returnStatement(t.callExpression(container, []))]);
        node.async = false;
        node.generator = false;
        path.get("body.body.0.argument.callee").unwrapFunctionEnvironment();
      },
      Function: {
        exit: util$4.wrapWithTypes(t, function (path, state) {
          var node = path.node;
          if (!shouldRegenerate(node, state)) return;
          path = (0, _replaceShorthandObjectMethod["default"])(path);
          node = path.node;
          var contextId = path.scope.generateUidIdentifier("context");
          var argsId = path.scope.generateUidIdentifier("args");
          path.ensureBlock();
          var bodyBlockPath = path.get("body");

          if (node.async) {
            bodyBlockPath.traverse(awaitVisitor$1);
          }

          bodyBlockPath.traverse(functionSentVisitor, {
            context: contextId
          });
          var outerBody = [];
          var innerBody = [];
          bodyBlockPath.get("body").forEach(function (childPath) {
            var node = childPath.node;

            if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {
              outerBody.push(node);
            } else if (node && node._blockHoist != null) {
              outerBody.push(node);
            } else {
              innerBody.push(node);
            }
          });

          if (outerBody.length > 0) {
            bodyBlockPath.node.body = innerBody;
          }

          var outerFnExpr = getOuterFnExpr(path);
          t.assertIdentifier(node.id);
          var innerFnId = t.identifier(node.id.name + "$");
          var vars = (0, hoist$1.hoist)(path);
          var context = {
            usesThis: false,
            usesArguments: false,
            getArgsId: function getArgsId() {
              return t.clone(argsId);
            }
          };
          path.traverse(argumentsThisVisitor, context);

          if (context.usesArguments) {
            vars = vars || t.variableDeclaration("var", []);
            vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier("arguments")));
          }

          var emitter = new emit$1.Emitter(contextId);
          emitter.explode(path.get("body"));

          if (vars && vars.declarations.length > 0) {
            outerBody.push(vars);
          }

          var wrapArgs = [emitter.getContextFunction(innerFnId)];
          var tryLocsList = emitter.getTryLocsList();

          if (node.generator) {
            wrapArgs.push(outerFnExpr);
          } else if (context.usesThis || tryLocsList || node.async) {
            wrapArgs.push(t.nullLiteral());
          }

          if (context.usesThis) {
            wrapArgs.push(t.thisExpression());
          } else if (tryLocsList || node.async) {
            wrapArgs.push(t.nullLiteral());
          }

          if (tryLocsList) {
            wrapArgs.push(tryLocsList);
          } else if (node.async) {
            wrapArgs.push(t.nullLiteral());
          }

          if (node.async) {
            var currentScope = path.scope;

            do {
              if (currentScope.hasOwnBinding("Promise")) currentScope.rename("Promise");
            } while (currentScope = currentScope.parent);

            wrapArgs.push(t.identifier("Promise"));
          }

          var wrapCall = t.callExpression(util$4.runtimeProperty(node.async ? "async" : "wrap"), wrapArgs);
          outerBody.push(t.returnStatement(wrapCall));
          node.body = t.blockStatement(outerBody);
          path.get("body.body").forEach(function (p) {
            return p.scope.registerDeclaration(p);
          });
          var oldDirectives = bodyBlockPath.node.directives;

          if (oldDirectives) {
            node.body.directives = oldDirectives;
          }

          var wasGeneratorFunction = node.generator;

          if (wasGeneratorFunction) {
            node.generator = false;
          }

          if (node.async) {
            node.async = false;
          }

          if (wasGeneratorFunction && t.isExpression(node)) {
            util$4.replaceWithOrRemove(path, t.callExpression(util$4.runtimeProperty("mark"), [node]));
            path.addComment("leading", "#__PURE__");
          }

          var insertedLocs = emitter.getInsertedLocs();
          path.traverse({
            NumericLiteral: function NumericLiteral(path) {
              if (!insertedLocs.has(path.node)) {
                return;
              }

              path.replaceWith(t.numericLiteral(path.node.value));
            }
          });
          path.requeue();
        })
      }
    };
  };

  function shouldRegenerate(node, state) {
    if (node.generator) {
      if (node.async) {
        return state.opts.asyncGenerators !== false;
      } else {
        return state.opts.generators !== false;
      }
    } else if (node.async) {
      return state.opts.async !== false;
    } else {
      return false;
    }
  }

  function getOuterFnExpr(funPath) {
    var t = util$4.getTypes();
    var node = funPath.node;
    t.assertFunction(node);

    if (!node.id) {
      node.id = funPath.scope.parent.generateUidIdentifier("callee");
    }

    if (node.generator && t.isFunctionDeclaration(node)) {
      return getMarkedFunctionId(funPath);
    }

    return t.clone(node.id);
  }

  var getMarkInfo = (0, _private.makeAccessor)();

  function getMarkedFunctionId(funPath) {
    var t = util$4.getTypes();
    var node = funPath.node;
    t.assertIdentifier(node.id);
    var blockPath = funPath.findParent(function (path) {
      return path.isProgram() || path.isBlockStatement();
    });

    if (!blockPath) {
      return node.id;
    }

    var block = blockPath.node;

    _assert$3["default"].ok(Array.isArray(block.body));

    var info = getMarkInfo(block);

    if (!info.decl) {
      info.decl = t.variableDeclaration("var", []);
      blockPath.unshiftContainer("body", info.decl);
      info.declPath = blockPath.get("body.0");
    }

    _assert$3["default"].strictEqual(info.declPath.node, info.decl);

    var markedId = blockPath.scope.generateUidIdentifier("marked");
    var markCallExp = t.callExpression(util$4.runtimeProperty("mark"), [t.clone(node.id)]);
    var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;
    var markCallExpPath = info.declPath.get("declarations." + index + ".init");

    _assert$3["default"].strictEqual(markCallExpPath.node, markCallExp);

    markCallExpPath.addComment("leading", "#__PURE__");
    return t.clone(markedId);
  }

  var argumentsThisVisitor = {
    "FunctionExpression|FunctionDeclaration|Method": function FunctionExpressionFunctionDeclarationMethod(path) {
      path.skip();
    },
    Identifier: function Identifier(path, state) {
      if (path.node.name === "arguments" && util$4.isReference(path)) {
        util$4.replaceWithOrRemove(path, state.getArgsId());
        state.usesArguments = true;
      }
    },
    ThisExpression: function ThisExpression(path, state) {
      state.usesThis = true;
    }
  };
  var functionSentVisitor = {
    MetaProperty: function MetaProperty(path) {
      var node = path.node;

      if (node.meta.name === "function" && node.property.name === "sent") {
        var t = util$4.getTypes();
        util$4.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier("_sent")));
      }
    }
  };
  var awaitVisitor$1 = {
    Function: function Function(path) {
      path.skip();
    },
    AwaitExpression: function AwaitExpression(path) {
      var t = util$4.getTypes();
      var argument = path.node.argument;
      util$4.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util$4.runtimeProperty("awrap"), [argument]), false));
    }
  };

  var visit$2 = {
    getVisitor: getVisitor
  };

  var lib$d = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = _default;



  function _default(context) {
    var plugin = {
      visitor: (0, visit$2.getVisitor)(context)
    };
    var version = context && context.version;

    if (version && parseInt(version, 10) >= 7) {
      plugin.name = "regenerator-transform";
    }

    return plugin;
  }
  });

  var transformRegenerator = unwrapExports(lib$d);

  var transformReservedWords = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-reserved-words",
      visitor: {
        "BindingIdentifier|ReferencedIdentifier": function BindingIdentifierReferencedIdentifier(path) {
          if (!isValidES3Identifier(path.node.name)) {
            path.scope.rename(path.node.name);
          }
        }
      }
    };
  });

  var caller = function () {
    var origPrepareStackTrace = Error.prepareStackTrace;

    Error.prepareStackTrace = function (_, stack) {
      return stack;
    };

    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
  };

  var pathParse = createCommonjsModule(function (module) {

  var isWindows = process.platform === 'win32';
  var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
  var splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
  var win32 = {};

  function win32SplitPath(filename) {
    var result = splitDeviceRe.exec(filename),
        device = (result[1] || '') + (result[2] || ''),
        tail = result[3] || '';
    var result2 = splitTailRe.exec(tail),
        dir = result2[1],
        basename = result2[2],
        ext = result2[3];
    return [device, dir, basename, ext];
  }

  win32.parse = function (pathString) {
    if (typeof pathString !== 'string') {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }

    var allParts = win32SplitPath(pathString);

    if (!allParts || allParts.length !== 4) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }

    return {
      root: allParts[0],
      dir: allParts[0] + allParts[1].slice(0, -1),
      base: allParts[2],
      ext: allParts[3],
      name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
    };
  };

  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var posix = {};

  function posixSplitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
  }

  posix.parse = function (pathString) {
    if (typeof pathString !== 'string') {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }

    var allParts = posixSplitPath(pathString);

    if (!allParts || allParts.length !== 4) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }

    allParts[1] = allParts[1] || '';
    allParts[2] = allParts[2] || '';
    allParts[3] = allParts[3] || '';
    return {
      root: allParts[0],
      dir: allParts[0] + allParts[1].slice(0, -1),
      base: allParts[2],
      ext: allParts[3],
      name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
    };
  };

  if (isWindows) module.exports = win32.parse;else module.exports = posix.parse;
  module.exports.posix = posix.parse;
  module.exports.win32 = win32.parse;
  });
  var pathParse_1 = pathParse.posix;
  var pathParse_2 = pathParse.win32;

  var parse$5 = path$1.parse || pathParse;

  var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = '/';

    if (/^([A-Za-z]:)/.test(absoluteStart)) {
      prefix = '';
    } else if (/^\\\\/.test(absoluteStart)) {
      prefix = '\\\\';
    }

    var paths = [absoluteStart];
    var parsed = parse$5(absoluteStart);

    while (parsed.dir !== paths[paths.length - 1]) {
      paths.push(parsed.dir);
      parsed = parse$5(parsed.dir);
    }

    return paths.reduce(function (dirs, aPath) {
      return dirs.concat(modules.map(function (moduleDir) {
        return path$1.resolve(prefix, aPath, moduleDir);
      }));
    }, []);
  };

  var nodeModulesPaths = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ['node_modules'];

    if (opts && typeof opts.paths === 'function') {
      return opts.paths(request, start, function () {
        return getNodeModulesDirs(start, modules);
      }, opts);
    }

    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
  };

  var normalizeOptions$3 = function (x, opts) {
    return opts || {};
  };

  var assert$3 = true;
  var async_hooks = ">= 8";
  var buffer_ieee754 = "< 0.9.7";
  var buffer = true;
  var child_process = true;
  var cluster = true;
  var console$1 = true;
  var constants = true;
  var crypto = true;
  var _debug_agent = ">= 1 && < 8";
  var _debugger = "< 8";
  var dgram = true;
  var dns = true;
  var domain = true;
  var events = true;
  var freelist = "< 6";
  var fs$1 = true;
  var _http_agent = ">= 0.11.1";
  var _http_client = ">= 0.11.1";
  var _http_common = ">= 0.11.1";
  var _http_incoming = ">= 0.11.1";
  var _http_outgoing = ">= 0.11.1";
  var _http_server = ">= 0.11.1";
  var http = true;
  var http2 = ">= 8.8";
  var https = true;
  var inspector = ">= 8.0.0";
  var _linklist = "< 8";
  var module = true;
  var net = true;
  var os = true;
  var path$3 = true;
  var perf_hooks = ">= 8.5";
  var process$1 = ">= 1";
  var punycode = true;
  var querystring = true;
  var readline = true;
  var repl = true;
  var smalloc = ">= 0.11.5 && < 3";
  var _stream_duplex = ">= 0.9.4";
  var _stream_transform = ">= 0.9.4";
  var _stream_wrap = ">= 1.4.1";
  var _stream_passthrough = ">= 0.9.4";
  var _stream_readable = ">= 0.9.4";
  var _stream_writable = ">= 0.9.4";
  var stream = true;
  var string_decoder = true;
  var sys = true;
  var timers = true;
  var _tls_common = ">= 0.11.13";
  var _tls_legacy = ">= 0.11.3 && < 10";
  var _tls_wrap = ">= 0.11.3";
  var tls = true;
  var trace_events = ">= 10";
  var tty = true;
  var url = true;
  var util$5 = true;
  var v8 = ">= 1";
  var vm = true;
  var wasi = ">= 13.4 && < 13.5";
  var worker_threads = ">= 11.7";
  var zlib = true;
  var core = {
    assert: assert$3,
    async_hooks: async_hooks,
    buffer_ieee754: buffer_ieee754,
    buffer: buffer,
    child_process: child_process,
    cluster: cluster,
    console: console$1,
    constants: constants,
    crypto: crypto,
    _debug_agent: _debug_agent,
    _debugger: _debugger,
    dgram: dgram,
    dns: dns,
    domain: domain,
    events: events,
    freelist: freelist,
    fs: fs$1,
    "fs/promises": ">= 10 && < 10.1",
    _http_agent: _http_agent,
    _http_client: _http_client,
    _http_common: _http_common,
    _http_incoming: _http_incoming,
    _http_outgoing: _http_outgoing,
    _http_server: _http_server,
    http: http,
    http2: http2,
    https: https,
    inspector: inspector,
    _linklist: _linklist,
    module: module,
    net: net,
    "node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
    os: os,
    path: path$3,
    perf_hooks: perf_hooks,
    process: process$1,
    punycode: punycode,
    querystring: querystring,
    readline: readline,
    repl: repl,
    smalloc: smalloc,
    _stream_duplex: _stream_duplex,
    _stream_transform: _stream_transform,
    _stream_wrap: _stream_wrap,
    _stream_passthrough: _stream_passthrough,
    _stream_readable: _stream_readable,
    _stream_writable: _stream_writable,
    stream: stream,
    string_decoder: string_decoder,
    sys: sys,
    timers: timers,
    _tls_common: _tls_common,
    _tls_legacy: _tls_legacy,
    _tls_wrap: _tls_wrap,
    tls: tls,
    trace_events: trace_events,
    tty: tty,
    url: url,
    util: util$5,
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [
    ">= 4.4.0 && < 5",
    ">= 5.2.0 && < 12"
  ],
    "v8/tools/consarray": [
    ">= 4.4.0 && < 5",
    ">= 5.2.0 && < 12"
  ],
    "v8/tools/csvparser": [
    ">= 4.4.0 && < 5",
    ">= 5.2.0 && < 12"
  ],
    "v8/tools/logreader": [
    ">= 4.4.0 && < 5",
    ">= 5.2.0 && < 12"
  ],
    "v8/tools/profile_view": [
    ">= 4.4.0 && < 5",
    ">= 5.2.0 && < 12"
  ],
    "v8/tools/splaytree": [
    ">= 4.4.0 && < 5",
    ">= 5.2.0 && < 12"
  ],
    v8: v8,
    vm: vm,
    wasi: wasi,
    worker_threads: worker_threads,
    zlib: zlib
  };

  var core$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    assert: assert$3,
    async_hooks: async_hooks,
    buffer_ieee754: buffer_ieee754,
    buffer: buffer,
    child_process: child_process,
    cluster: cluster,
    console: console$1,
    constants: constants,
    crypto: crypto,
    _debug_agent: _debug_agent,
    _debugger: _debugger,
    dgram: dgram,
    dns: dns,
    domain: domain,
    events: events,
    freelist: freelist,
    fs: fs$1,
    _http_agent: _http_agent,
    _http_client: _http_client,
    _http_common: _http_common,
    _http_incoming: _http_incoming,
    _http_outgoing: _http_outgoing,
    _http_server: _http_server,
    http: http,
    http2: http2,
    https: https,
    inspector: inspector,
    _linklist: _linklist,
    module: module,
    net: net,
    os: os,
    path: path$3,
    perf_hooks: perf_hooks,
    process: process$1,
    punycode: punycode,
    querystring: querystring,
    readline: readline,
    repl: repl,
    smalloc: smalloc,
    _stream_duplex: _stream_duplex,
    _stream_transform: _stream_transform,
    _stream_wrap: _stream_wrap,
    _stream_passthrough: _stream_passthrough,
    _stream_readable: _stream_readable,
    _stream_writable: _stream_writable,
    stream: stream,
    string_decoder: string_decoder,
    sys: sys,
    timers: timers,
    _tls_common: _tls_common,
    _tls_legacy: _tls_legacy,
    _tls_wrap: _tls_wrap,
    tls: tls,
    trace_events: trace_events,
    tty: tty,
    url: url,
    util: util$5,
    v8: v8,
    vm: vm,
    wasi: wasi,
    worker_threads: worker_threads,
    zlib: zlib,
    'default': core
  });

  var data = getCjsExportFromNamespace(core$1);

  var current = process.versions && process.versions.node && process.versions.node.split('.') || [];

  function specifierIncluded(specifier) {
    var parts = specifier.split(' ');
    var op = parts.length > 1 ? parts[0] : '=';
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

    for (var i = 0; i < 3; ++i) {
      var cur = Number(current[i] || 0);
      var ver = Number(versionParts[i] || 0);

      if (cur === ver) {
        continue;
      }

      if (op === '<') {
        return cur < ver;
      } else if (op === '>=') {
        return cur >= ver;
      } else {
        return false;
      }
    }

    return op === '>=';
  }

  function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);

    if (specifiers.length === 0) {
      return false;
    }

    for (var i = 0; i < specifiers.length; ++i) {
      if (!specifierIncluded(specifiers[i])) {
        return false;
      }
    }

    return true;
  }

  function versionIncluded(specifierValue) {
    if (typeof specifierValue === 'boolean') {
      return specifierValue;
    }

    if (specifierValue && typeof specifierValue === 'object') {
      for (var i = 0; i < specifierValue.length; ++i) {
        if (matchesRange(specifierValue[i])) {
          return true;
        }
      }

      return false;
    }

    return matchesRange(specifierValue);
  }



  var core$2 = {};

  for (var mod in data) {
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
      core$2[mod] = versionIncluded(data[mod]);
    }
  }

  var core_1 = core$2;

  var isCore = function isCore(x) {
    return Object.prototype.hasOwnProperty.call(core_1, x);
  };

  var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function (err, stat) {
      if (!err) {
        return cb(null, stat.isFile() || stat.isFIFO());
      }

      if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
      return cb(err);
    });
  };

  var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function (err, stat) {
      if (!err) {
        return cb(null, stat.isDirectory());
      }

      if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
      return cb(err);
    });
  };

  var maybeUnwrapSymlink = function maybeUnwrapSymlink(x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
      fs.realpath(x, function (realPathErr, realPath) {
        if (realPathErr && realPathErr.code !== 'ENOENT') cb(realPathErr);else cb(null, realPathErr ? x : realPath);
      });
    } else {
      cb(null, x);
    }
  };

  var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);

    for (var i = 0; i < dirs.length; i++) {
      dirs[i] = path$1.join(dirs[i], x);
    }

    return dirs;
  };

  var async = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;

    if (typeof options === 'function') {
      cb = opts;
      opts = {};
    }

    if (typeof x !== 'string') {
      var err = new TypeError('Path must be a string.');
      return nextTick(function () {
        cb(err);
      });
    }

    opts = normalizeOptions$3(x, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path$1.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || [];
    var absoluteStart = path$1.resolve(basedir);
    maybeUnwrapSymlink(absoluteStart, opts, function (err, realStart) {
      if (err) cb(err);else init(realStart);
    });
    var res;

    function init(basedir) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        res = path$1.resolve(basedir, x);
        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';

        if (/\/$/.test(x) && res === basedir) {
          loadAsDirectory(res, opts["package"], onfile);
        } else loadAsFile(res, opts["package"], onfile);
      } else if (isCore(x)) {
        return cb(null, x);
      } else loadNodeModules(x, basedir, function (err, n, pkg) {
        if (err) cb(err);else if (n) {
          return maybeUnwrapSymlink(n, opts, function (err, realN) {
            if (err) {
              cb(err);
            } else {
              cb(null, realN, pkg);
            }
          });
        } else {
          var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
          moduleError.code = 'MODULE_NOT_FOUND';
          cb(moduleError);
        }
      });
    }

    function onfile(err, m, pkg) {
      if (err) cb(err);else if (m) cb(null, m, pkg);else loadAsDirectory(res, function (err, d, pkg) {
        if (err) cb(err);else if (d) {
          maybeUnwrapSymlink(d, opts, function (err, realD) {
            if (err) {
              cb(err);
            } else {
              cb(null, realD, pkg);
            }
          });
        } else {
          var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
          moduleError.code = 'MODULE_NOT_FOUND';
          cb(moduleError);
        }
      });
    }

    function loadAsFile(x, thePackage, callback) {
      var loadAsFilePackage = thePackage;
      var cb = callback;

      if (typeof loadAsFilePackage === 'function') {
        cb = loadAsFilePackage;
        loadAsFilePackage = undefined;
      }

      var exts = [''].concat(extensions);
      load(exts, x, loadAsFilePackage);

      function load(exts, x, loadPackage) {
        if (exts.length === 0) return cb(null, undefined, loadPackage);
        var file = x + exts[0];
        var pkg = loadPackage;
        if (pkg) onpkg(null, pkg);else loadpkg(path$1.dirname(file), onpkg);

        function onpkg(err, pkg_, dir) {
          pkg = pkg_;
          if (err) return cb(err);

          if (dir && pkg && opts.pathFilter) {
            var rfile = path$1.relative(dir, file);
            var rel = rfile.slice(0, rfile.length - exts[0].length);
            var r = opts.pathFilter(pkg, x, rel);
            if (r) return load([''].concat(extensions.slice()), path$1.resolve(dir, r), pkg);
          }

          isFile(file, onex);
        }

        function onex(err, ex) {
          if (err) return cb(err);
          if (ex) return cb(null, file, pkg);
          load(exts.slice(1), x, pkg);
        }
      }
    }

    function loadpkg(dir, cb) {
      if (dir === '' || dir === '/') return cb(null);

      if (process.platform === 'win32' && /^\w:[/\\]*$/.test(dir)) {
        return cb(null);
      }

      if (/[/\\]node_modules[/\\]*$/.test(dir)) return cb(null);
      maybeUnwrapSymlink(dir, opts, function (unwrapErr, pkgdir) {
        if (unwrapErr) return loadpkg(path$1.dirname(dir), cb);
        var pkgfile = path$1.join(pkgdir, 'package.json');
        isFile(pkgfile, function (err, ex) {
          if (!ex) return loadpkg(path$1.dirname(dir), cb);
          readFile(pkgfile, function (err, body) {
            if (err) cb(err);

            try {
              var pkg = JSON.parse(body);
            } catch (jsonErr) {}

            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }

            cb(null, pkg, dir);
          });
        });
      });
    }

    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
      var cb = callback;
      var fpkg = loadAsDirectoryPackage;

      if (typeof fpkg === 'function') {
        cb = fpkg;
        fpkg = opts["package"];
      }

      maybeUnwrapSymlink(x, opts, function (unwrapErr, pkgdir) {
        if (unwrapErr) return cb(unwrapErr);
        var pkgfile = path$1.join(pkgdir, 'package.json');
        isFile(pkgfile, function (err, ex) {
          if (err) return cb(err);
          if (!ex) return loadAsFile(path$1.join(x, 'index'), fpkg, cb);
          readFile(pkgfile, function (err, body) {
            if (err) return cb(err);

            try {
              var pkg = JSON.parse(body);
            } catch (jsonErr) {}

            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }

            if (pkg && pkg.main) {
              if (typeof pkg.main !== 'string') {
                var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
                mainError.code = 'INVALID_PACKAGE_MAIN';
                return cb(mainError);
              }

              if (pkg.main === '.' || pkg.main === './') {
                pkg.main = 'index';
              }

              loadAsFile(path$1.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                if (err) return cb(err);
                if (m) return cb(null, m, pkg);
                if (!pkg) return loadAsFile(path$1.join(x, 'index'), pkg, cb);
                var dir = path$1.resolve(x, pkg.main);
                loadAsDirectory(dir, pkg, function (err, n, pkg) {
                  if (err) return cb(err);
                  if (n) return cb(null, n, pkg);
                  loadAsFile(path$1.join(x, 'index'), pkg, cb);
                });
              });
              return;
            }

            loadAsFile(path$1.join(x, '/index'), pkg, cb);
          });
        });
      });
    }

    function processDirs(cb, dirs) {
      if (dirs.length === 0) return cb(null, undefined);
      var dir = dirs[0];
      isDirectory(path$1.dirname(dir), isdir);

      function isdir(err, isdir) {
        if (err) return cb(err);
        if (!isdir) return processDirs(cb, dirs.slice(1));
        loadAsFile(dir, opts["package"], onfile);
      }

      function onfile(err, m, pkg) {
        if (err) return cb(err);
        if (m) return cb(null, m, pkg);
        loadAsDirectory(dir, opts["package"], ondir);
      }

      function ondir(err, n, pkg) {
        if (err) return cb(err);
        if (n) return cb(null, n, pkg);
        processDirs(cb, dirs.slice(1));
      }
    }

    function loadNodeModules(x, start, cb) {
      var thunk = function thunk() {
        return getPackageCandidates(x, start, opts);
      };

      processDirs(cb, packageIterator ? packageIterator(x, start, thunk, opts) : thunk());
    }
  };

  var defaultIsFile$1 = function isFile(file) {
    try {
      var stat = fs.statSync(file);
    } catch (e) {
      if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
      throw e;
    }

    return stat.isFile() || stat.isFIFO();
  };

  var defaultIsDir$1 = function isDirectory(dir) {
    try {
      var stat = fs.statSync(dir);
    } catch (e) {
      if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
      throw e;
    }

    return stat.isDirectory();
  };

  var maybeUnwrapSymlink$1 = function maybeUnwrapSymlink(x, opts) {
    if (opts && opts.preserveSymlinks === false) {
      try {
        return fs.realpathSync(x);
      } catch (realPathErr) {
        if (realPathErr.code !== 'ENOENT') {
          throw realPathErr;
        }
      }
    }

    return x;
  };

  var getPackageCandidates$1 = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);

    for (var i = 0; i < dirs.length; i++) {
      dirs[i] = path$1.join(dirs[i], x);
    }

    return dirs;
  };

  var sync = function resolveSync(x, options) {
    if (typeof x !== 'string') {
      throw new TypeError('Path must be a string.');
    }

    var opts = normalizeOptions$3(x, options);
    var isFile = opts.isFile || defaultIsFile$1;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir$1;
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path$1.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || [];
    var absoluteStart = maybeUnwrapSymlink$1(path$1.resolve(basedir), opts);

    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
      var res = path$1.resolve(absoluteStart, x);
      if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
      var m = loadAsFileSync(res) || loadAsDirectorySync(res);
      if (m) return maybeUnwrapSymlink$1(m, opts);
    } else if (isCore(x)) {
      return x;
    } else {
      var n = loadNodeModulesSync(x, absoluteStart);
      if (n) return maybeUnwrapSymlink$1(n, opts);
    }

    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(x) {
      var pkg = loadpkg(path$1.dirname(x));

      if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
        var rfile = path$1.relative(pkg.dir, x);
        var r = opts.pathFilter(pkg.pkg, x, rfile);

        if (r) {
          x = path$1.resolve(pkg.dir, r);
        }
      }

      if (isFile(x)) {
        return x;
      }

      for (var i = 0; i < extensions.length; i++) {
        var file = x + extensions[i];

        if (isFile(file)) {
          return file;
        }
      }
    }

    function loadpkg(dir) {
      if (dir === '' || dir === '/') return;

      if (process.platform === 'win32' && /^\w:[/\\]*$/.test(dir)) {
        return;
      }

      if (/[/\\]node_modules[/\\]*$/.test(dir)) return;
      var pkgfile = path$1.join(maybeUnwrapSymlink$1(dir, opts), 'package.json');

      if (!isFile(pkgfile)) {
        return loadpkg(path$1.dirname(dir));
      }

      var body = readFileSync(pkgfile);

      try {
        var pkg = JSON.parse(body);
      } catch (jsonErr) {}

      if (pkg && opts.packageFilter) {
        pkg = opts.packageFilter(pkg, dir);
      }

      return {
        pkg: pkg,
        dir: dir
      };
    }

    function loadAsDirectorySync(x) {
      var pkgfile = path$1.join(maybeUnwrapSymlink$1(x, opts), '/package.json');

      if (isFile(pkgfile)) {
        try {
          var body = readFileSync(pkgfile, 'UTF8');
          var pkg = JSON.parse(body);
        } catch (e) {}

        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, x);
        }

        if (pkg && pkg.main) {
          if (typeof pkg.main !== 'string') {
            var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
            mainError.code = 'INVALID_PACKAGE_MAIN';
            throw mainError;
          }

          if (pkg.main === '.' || pkg.main === './') {
            pkg.main = 'index';
          }

          try {
            var m = loadAsFileSync(path$1.resolve(x, pkg.main));
            if (m) return m;
            var n = loadAsDirectorySync(path$1.resolve(x, pkg.main));
            if (n) return n;
          } catch (e) {}
        }
      }

      return loadAsFileSync(path$1.join(x, '/index'));
    }

    function loadNodeModulesSync(x, start) {
      var thunk = function thunk() {
        return getPackageCandidates$1(x, start, opts);
      };

      var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();

      for (var i = 0; i < dirs.length; i++) {
        var dir = dirs[i];

        if (isDirectory(path$1.dirname(dir))) {
          var m = loadAsFileSync(dir);
          if (m) return m;
          var n = loadAsDirectorySync(dir);
          if (n) return n;
        }
      }
    }
  };

  async.core = core_1;
  async.isCore = isCore;
  async.sync = sync;
  var resolve$2 = async;

  function hasMinVersion(minVersion, runtimeVersion) {
    if (!runtimeVersion) return true;
    if (semver.valid(runtimeVersion)) runtimeVersion = "^" + runtimeVersion;
    return !semver.intersects("<" + minVersion, runtimeVersion) && !semver.intersects(">=8.0.0", runtimeVersion);
  }
  function typeAnnotationToString(node) {
    switch (node.type) {
      case "GenericTypeAnnotation":
        if (isIdentifier(node.id, {
          name: "Array"
        })) return "array";
        break;

      case "StringTypeAnnotation":
        return "string";
    }
  }

  var getCoreJS2Definitions = (function (runtimeVersion) {
    var includeMathModule = hasMinVersion("7.0.1", runtimeVersion);
    return {
      BuiltIns: {
        Symbol: {
          stable: true,
          path: "symbol"
        },
        Promise: {
          stable: true,
          path: "promise"
        },
        Map: {
          stable: true,
          path: "map"
        },
        WeakMap: {
          stable: true,
          path: "weak-map"
        },
        Set: {
          stable: true,
          path: "set"
        },
        WeakSet: {
          stable: true,
          path: "weak-set"
        },
        setImmediate: {
          stable: true,
          path: "set-immediate"
        },
        clearImmediate: {
          stable: true,
          path: "clear-immediate"
        },
        parseFloat: {
          stable: true,
          path: "parse-float"
        },
        parseInt: {
          stable: true,
          path: "parse-int"
        }
      },
      StaticProperties: Object.assign({
        Array: {
          from: {
            stable: true,
            path: "array/from"
          },
          isArray: {
            stable: true,
            path: "array/is-array"
          },
          of: {
            stable: true,
            path: "array/of"
          }
        },
        JSON: {
          stringify: {
            stable: true,
            path: "json/stringify"
          }
        },
        Object: {
          assign: {
            stable: true,
            path: "object/assign"
          },
          create: {
            stable: true,
            path: "object/create"
          },
          defineProperties: {
            stable: true,
            path: "object/define-properties"
          },
          defineProperty: {
            stable: true,
            path: "object/define-property"
          },
          entries: {
            stable: true,
            path: "object/entries"
          },
          freeze: {
            stable: true,
            path: "object/freeze"
          },
          getOwnPropertyDescriptor: {
            stable: true,
            path: "object/get-own-property-descriptor"
          },
          getOwnPropertyDescriptors: {
            stable: true,
            path: "object/get-own-property-descriptors"
          },
          getOwnPropertyNames: {
            stable: true,
            path: "object/get-own-property-names"
          },
          getOwnPropertySymbols: {
            stable: true,
            path: "object/get-own-property-symbols"
          },
          getPrototypeOf: {
            stable: true,
            path: "object/get-prototype-of"
          },
          isExtensible: {
            stable: true,
            path: "object/is-extensible"
          },
          isFrozen: {
            stable: true,
            path: "object/is-frozen"
          },
          isSealed: {
            stable: true,
            path: "object/is-sealed"
          },
          is: {
            stable: true,
            path: "object/is"
          },
          keys: {
            stable: true,
            path: "object/keys"
          },
          preventExtensions: {
            stable: true,
            path: "object/prevent-extensions"
          },
          seal: {
            stable: true,
            path: "object/seal"
          },
          setPrototypeOf: {
            stable: true,
            path: "object/set-prototype-of"
          },
          values: {
            stable: true,
            path: "object/values"
          }
        }
      }, includeMathModule ? {
        Math: {
          acosh: {
            stable: true,
            path: "math/acosh"
          },
          asinh: {
            stable: true,
            path: "math/asinh"
          },
          atanh: {
            stable: true,
            path: "math/atanh"
          },
          cbrt: {
            stable: true,
            path: "math/cbrt"
          },
          clz32: {
            stable: true,
            path: "math/clz32"
          },
          cosh: {
            stable: true,
            path: "math/cosh"
          },
          expm1: {
            stable: true,
            path: "math/expm1"
          },
          fround: {
            stable: true,
            path: "math/fround"
          },
          hypot: {
            stable: true,
            path: "math/hypot"
          },
          imul: {
            stable: true,
            path: "math/imul"
          },
          log10: {
            stable: true,
            path: "math/log10"
          },
          log1p: {
            stable: true,
            path: "math/log1p"
          },
          log2: {
            stable: true,
            path: "math/log2"
          },
          sign: {
            stable: true,
            path: "math/sign"
          },
          sinh: {
            stable: true,
            path: "math/sinh"
          },
          tanh: {
            stable: true,
            path: "math/tanh"
          },
          trunc: {
            stable: true,
            path: "math/trunc"
          }
        }
      } : {}, {
        Symbol: {
          "for": {
            stable: true,
            path: "symbol/for"
          },
          hasInstance: {
            stable: true,
            path: "symbol/has-instance"
          },
          isConcatSpreadable: {
            stable: true,
            path: "symbol/is-concat-spreadable"
          },
          iterator: {
            stable: true,
            path: "symbol/iterator"
          },
          keyFor: {
            stable: true,
            path: "symbol/key-for"
          },
          match: {
            stable: true,
            path: "symbol/match"
          },
          replace: {
            stable: true,
            path: "symbol/replace"
          },
          search: {
            stable: true,
            path: "symbol/search"
          },
          species: {
            stable: true,
            path: "symbol/species"
          },
          split: {
            stable: true,
            path: "symbol/split"
          },
          toPrimitive: {
            stable: true,
            path: "symbol/to-primitive"
          },
          toStringTag: {
            stable: true,
            path: "symbol/to-string-tag"
          },
          unscopables: {
            stable: true,
            path: "symbol/unscopables"
          }
        },
        String: {
          at: {
            stable: true,
            path: "string/at"
          },
          fromCodePoint: {
            stable: true,
            path: "string/from-code-point"
          },
          raw: {
            stable: true,
            path: "string/raw"
          }
        },
        Number: {
          EPSILON: {
            stable: true,
            path: "number/epsilon"
          },
          isFinite: {
            stable: true,
            path: "number/is-finite"
          },
          isInteger: {
            stable: true,
            path: "number/is-integer"
          },
          isNaN: {
            stable: true,
            path: "number/is-nan"
          },
          isSafeInteger: {
            stable: true,
            path: "number/is-safe-integer"
          },
          MAX_SAFE_INTEGER: {
            stable: true,
            path: "number/max-safe-integer"
          },
          MIN_SAFE_INTEGER: {
            stable: true,
            path: "number/min-safe-integer"
          },
          parseFloat: {
            stable: true,
            path: "number/parse-float"
          },
          parseInt: {
            stable: true,
            path: "number/parse-int"
          }
        },
        Reflect: {
          apply: {
            stable: true,
            path: "reflect/apply"
          },
          construct: {
            stable: true,
            path: "reflect/construct"
          },
          defineProperty: {
            stable: true,
            path: "reflect/define-property"
          },
          deleteProperty: {
            stable: true,
            path: "reflect/delete-property"
          },
          getOwnPropertyDescriptor: {
            stable: true,
            path: "reflect/get-own-property-descriptor"
          },
          getPrototypeOf: {
            stable: true,
            path: "reflect/get-prototype-of"
          },
          get: {
            stable: true,
            path: "reflect/get"
          },
          has: {
            stable: true,
            path: "reflect/has"
          },
          isExtensible: {
            stable: true,
            path: "reflect/is-extensible"
          },
          ownKeys: {
            stable: true,
            path: "reflect/own-keys"
          },
          preventExtensions: {
            stable: true,
            path: "reflect/prevent-extensions"
          },
          setPrototypeOf: {
            stable: true,
            path: "reflect/set-prototype-of"
          },
          set: {
            stable: true,
            path: "reflect/set"
          }
        },
        Date: {
          now: {
            stable: true,
            path: "date/now"
          }
        }
      })
    };
  });

  var getCoreJS3Definitions = (function () {
    return {
      BuiltIns: {
        AggregateError: {
          stable: false,
          path: "aggregate-error"
        },
        Map: {
          stable: true,
          path: "map"
        },
        Observable: {
          stable: false,
          path: "observable"
        },
        Promise: {
          stable: true,
          path: "promise"
        },
        Set: {
          stable: true,
          path: "set"
        },
        Symbol: {
          stable: true,
          path: "symbol"
        },
        URL: {
          stable: true,
          path: "url"
        },
        URLSearchParams: {
          stable: true,
          path: "url-search-params"
        },
        WeakMap: {
          stable: true,
          path: "weak-map"
        },
        WeakSet: {
          stable: true,
          path: "weak-set"
        },
        clearImmediate: {
          stable: true,
          path: "clear-immediate"
        },
        compositeKey: {
          stable: false,
          path: "composite-key"
        },
        compositeSymbol: {
          stable: false,
          path: "composite-symbol"
        },
        globalThis: {
          stable: false,
          path: "global-this"
        },
        parseFloat: {
          stable: true,
          path: "parse-float"
        },
        parseInt: {
          stable: true,
          path: "parse-int"
        },
        queueMicrotask: {
          stable: true,
          path: "queue-microtask"
        },
        setImmediate: {
          stable: true,
          path: "set-immediate"
        },
        setInterval: {
          stable: true,
          path: "set-interval"
        },
        setTimeout: {
          stable: true,
          path: "set-timeout"
        }
      },
      StaticProperties: {
        Array: {
          from: {
            stable: true,
            path: "array/from"
          },
          isArray: {
            stable: true,
            path: "array/is-array"
          },
          of: {
            stable: true,
            path: "array/of"
          }
        },
        Date: {
          now: {
            stable: true,
            path: "date/now"
          }
        },
        JSON: {
          stringify: {
            stable: true,
            path: "json/stringify"
          }
        },
        Math: {
          DEG_PER_RAD: {
            stable: false,
            path: "math/deg-per-rad"
          },
          RAD_PER_DEG: {
            stable: false,
            path: "math/rad-per-deg"
          },
          acosh: {
            stable: true,
            path: "math/acosh"
          },
          asinh: {
            stable: true,
            path: "math/asinh"
          },
          atanh: {
            stable: true,
            path: "math/atanh"
          },
          cbrt: {
            stable: true,
            path: "math/cbrt"
          },
          clamp: {
            stable: false,
            path: "math/clamp"
          },
          clz32: {
            stable: true,
            path: "math/clz32"
          },
          cosh: {
            stable: true,
            path: "math/cosh"
          },
          degrees: {
            stable: false,
            path: "math/degrees"
          },
          expm1: {
            stable: true,
            path: "math/expm1"
          },
          fround: {
            stable: true,
            path: "math/fround"
          },
          fscale: {
            stable: false,
            path: "math/fscale"
          },
          hypot: {
            stable: true,
            path: "math/hypot"
          },
          iaddh: {
            stable: false,
            path: "math/iaddh"
          },
          imul: {
            stable: true,
            path: "math/imul"
          },
          imulh: {
            stable: false,
            path: "math/imulh"
          },
          isubh: {
            stable: false,
            path: "math/isubh"
          },
          log10: {
            stable: true,
            path: "math/log10"
          },
          log1p: {
            stable: true,
            path: "math/log1p"
          },
          log2: {
            stable: true,
            path: "math/log2"
          },
          radians: {
            stable: false,
            path: "math/radians"
          },
          scale: {
            stable: false,
            path: "math/scale"
          },
          seededPRNG: {
            stable: false,
            path: "math/seeded-prng"
          },
          sign: {
            stable: true,
            path: "math/sign"
          },
          signbit: {
            stable: false,
            path: "math/signbit"
          },
          sinh: {
            stable: true,
            path: "math/sinh"
          },
          tanh: {
            stable: true,
            path: "math/tanh"
          },
          trunc: {
            stable: true,
            path: "math/trunc"
          },
          umulh: {
            stable: false,
            path: "math/umulh"
          }
        },
        Number: {
          EPSILON: {
            stable: true,
            path: "number/epsilon"
          },
          MAX_SAFE_INTEGER: {
            stable: true,
            path: "number/max-safe-integer"
          },
          MIN_SAFE_INTEGER: {
            stable: true,
            path: "number/min-safe-integer"
          },
          fromString: {
            stable: false,
            path: "number/from-string"
          },
          isFinite: {
            stable: true,
            path: "number/is-finite"
          },
          isInteger: {
            stable: true,
            path: "number/is-integer"
          },
          isNaN: {
            stable: true,
            path: "number/is-nan"
          },
          isSafeInteger: {
            stable: true,
            path: "number/is-safe-integer"
          },
          parseFloat: {
            stable: true,
            path: "number/parse-float"
          },
          parseInt: {
            stable: true,
            path: "number/parse-int"
          }
        },
        Object: {
          assign: {
            stable: true,
            path: "object/assign"
          },
          create: {
            stable: true,
            path: "object/create"
          },
          defineProperties: {
            stable: true,
            path: "object/define-properties"
          },
          defineProperty: {
            stable: true,
            path: "object/define-property"
          },
          entries: {
            stable: true,
            path: "object/entries"
          },
          freeze: {
            stable: true,
            path: "object/freeze"
          },
          fromEntries: {
            stable: true,
            path: "object/from-entries"
          },
          getOwnPropertyDescriptor: {
            stable: true,
            path: "object/get-own-property-descriptor"
          },
          getOwnPropertyDescriptors: {
            stable: true,
            path: "object/get-own-property-descriptors"
          },
          getOwnPropertyNames: {
            stable: true,
            path: "object/get-own-property-names"
          },
          getOwnPropertySymbols: {
            stable: true,
            path: "object/get-own-property-symbols"
          },
          getPrototypeOf: {
            stable: true,
            path: "object/get-prototype-of"
          },
          isExtensible: {
            stable: true,
            path: "object/is-extensible"
          },
          isFrozen: {
            stable: true,
            path: "object/is-frozen"
          },
          isSealed: {
            stable: true,
            path: "object/is-sealed"
          },
          is: {
            stable: true,
            path: "object/is"
          },
          keys: {
            stable: true,
            path: "object/keys"
          },
          preventExtensions: {
            stable: true,
            path: "object/prevent-extensions"
          },
          seal: {
            stable: true,
            path: "object/seal"
          },
          setPrototypeOf: {
            stable: true,
            path: "object/set-prototype-of"
          },
          values: {
            stable: true,
            path: "object/values"
          }
        },
        Reflect: {
          apply: {
            stable: true,
            path: "reflect/apply"
          },
          construct: {
            stable: true,
            path: "reflect/construct"
          },
          defineMetadata: {
            stable: false,
            path: "reflect/define-metadata"
          },
          defineProperty: {
            stable: true,
            path: "reflect/define-property"
          },
          deleteMetadata: {
            stable: false,
            path: "reflect/delete-metadata"
          },
          deleteProperty: {
            stable: true,
            path: "reflect/delete-property"
          },
          getMetadata: {
            stable: false,
            path: "reflect/get-metadata"
          },
          getMetadataKeys: {
            stable: false,
            path: "reflect/get-metadata-keys"
          },
          getOwnMetadata: {
            stable: false,
            path: "reflect/get-own-metadata"
          },
          getOwnMetadataKeys: {
            stable: false,
            path: "reflect/get-own-metadata-keys"
          },
          getOwnPropertyDescriptor: {
            stable: true,
            path: "reflect/get-own-property-descriptor"
          },
          getPrototypeOf: {
            stable: true,
            path: "reflect/get-prototype-of"
          },
          get: {
            stable: true,
            path: "reflect/get"
          },
          has: {
            stable: true,
            path: "reflect/has"
          },
          hasMetadata: {
            stable: false,
            path: "reflect/has-metadata"
          },
          hasOwnMetadata: {
            stable: false,
            path: "reflect/has-own-metadata"
          },
          isExtensible: {
            stable: true,
            path: "reflect/is-extensible"
          },
          metadata: {
            stable: false,
            path: "reflect/metadata"
          },
          ownKeys: {
            stable: true,
            path: "reflect/own-keys"
          },
          preventExtensions: {
            stable: true,
            path: "reflect/prevent-extensions"
          },
          set: {
            stable: true,
            path: "reflect/set"
          },
          setPrototypeOf: {
            stable: true,
            path: "reflect/set-prototype-of"
          }
        },
        String: {
          fromCodePoint: {
            stable: true,
            path: "string/from-code-point"
          },
          raw: {
            stable: true,
            path: "string/raw"
          }
        },
        Symbol: {
          asyncIterator: {
            stable: true,
            path: "symbol/async-iterator"
          },
          dispose: {
            stable: false,
            path: "symbol/dispose"
          },
          "for": {
            stable: true,
            path: "symbol/for"
          },
          hasInstance: {
            stable: true,
            path: "symbol/has-instance"
          },
          isConcatSpreadable: {
            stable: true,
            path: "symbol/is-concat-spreadable"
          },
          iterator: {
            stable: true,
            path: "symbol/iterator"
          },
          keyFor: {
            stable: true,
            path: "symbol/key-for"
          },
          match: {
            stable: true,
            path: "symbol/match"
          },
          observable: {
            stable: false,
            path: "symbol/observable"
          },
          patternMatch: {
            stable: false,
            path: "symbol/pattern-match"
          },
          replace: {
            stable: true,
            path: "symbol/replace"
          },
          search: {
            stable: true,
            path: "symbol/search"
          },
          species: {
            stable: true,
            path: "symbol/species"
          },
          split: {
            stable: true,
            path: "symbol/split"
          },
          toPrimitive: {
            stable: true,
            path: "symbol/to-primitive"
          },
          toStringTag: {
            stable: true,
            path: "symbol/to-string-tag"
          },
          unscopables: {
            stable: true,
            path: "symbol/unscopables"
          }
        }
      },
      InstanceProperties: {
        at: {
          stable: false,
          path: "at"
        },
        bind: {
          stable: true,
          path: "bind"
        },
        codePointAt: {
          stable: true,
          path: "code-point-at"
        },
        codePoints: {
          stable: false,
          path: "code-points"
        },
        concat: {
          stable: true,
          path: "concat",
          types: ["array"]
        },
        copyWithin: {
          stable: true,
          path: "copy-within"
        },
        endsWith: {
          stable: true,
          path: "ends-with"
        },
        entries: {
          stable: true,
          path: "entries"
        },
        every: {
          stable: true,
          path: "every"
        },
        fill: {
          stable: true,
          path: "fill"
        },
        filter: {
          stable: true,
          path: "filter"
        },
        find: {
          stable: true,
          path: "find"
        },
        findIndex: {
          stable: true,
          path: "find-index"
        },
        flags: {
          stable: true,
          path: "flags"
        },
        flatMap: {
          stable: true,
          path: "flat-map"
        },
        flat: {
          stable: true,
          path: "flat"
        },
        forEach: {
          stable: true,
          path: "for-each"
        },
        includes: {
          stable: true,
          path: "includes"
        },
        indexOf: {
          stable: true,
          path: "index-of"
        },
        keys: {
          stable: true,
          path: "keys"
        },
        lastIndexOf: {
          stable: true,
          path: "last-index-of"
        },
        map: {
          stable: true,
          path: "map"
        },
        matchAll: {
          stable: false,
          path: "match-all"
        },
        padEnd: {
          stable: true,
          path: "pad-end"
        },
        padStart: {
          stable: true,
          path: "pad-start"
        },
        reduce: {
          stable: true,
          path: "reduce"
        },
        reduceRight: {
          stable: true,
          path: "reduce-right"
        },
        repeat: {
          stable: true,
          path: "repeat"
        },
        replaceAll: {
          stable: false,
          path: "replace-all"
        },
        reverse: {
          stable: true,
          path: "reverse"
        },
        slice: {
          stable: true,
          path: "slice"
        },
        some: {
          stable: true,
          path: "some"
        },
        sort: {
          stable: true,
          path: "sort"
        },
        splice: {
          stable: true,
          path: "splice"
        },
        startsWith: {
          stable: true,
          path: "starts-with"
        },
        trim: {
          stable: true,
          path: "trim"
        },
        trimEnd: {
          stable: true,
          path: "trim-end"
        },
        trimLeft: {
          stable: true,
          path: "trim-left"
        },
        trimRight: {
          stable: true,
          path: "trim-right"
        },
        trimStart: {
          stable: true,
          path: "trim-start"
        },
        values: {
          stable: true,
          path: "values"
        }
      }
    };
  });

  function resolveAbsoluteRuntime(moduleName, dirname) {
    try {
      return path$1.dirname(resolve$2.sync(moduleName + "/package.json", {
        basedir: dirname
      }));
    } catch (err) {
      if (err.code !== "MODULE_NOT_FOUND") throw err;
      throw Object.assign(new Error("Failed to resolve \"" + moduleName + "\" relative to \"" + dirname + "\""), {
        code: "BABEL_RUNTIME_NOT_FOUND",
        runtime: moduleName,
        dirname: dirname
      });
    }
  }

  function supportsStaticESM(caller) {
    return !!(caller && caller.supportsStaticESM);
  }

  var transformRuntime = declare(function (api, options, dirname) {
    api.assertVersion(7);
    var corejs = options.corejs,
        _options$helpers = options.helpers,
        useRuntimeHelpers = _options$helpers === void 0 ? true : _options$helpers,
        _options$regenerator = options.regenerator,
        useRuntimeRegenerator = _options$regenerator === void 0 ? true : _options$regenerator,
        _options$useESModules = options.useESModules,
        useESModules = _options$useESModules === void 0 ? false : _options$useESModules,
        _options$version = options.version,
        runtimeVersion = _options$version === void 0 ? "7.0.0-beta.0" : _options$version,
        _options$absoluteRunt = options.absoluteRuntime,
        absoluteRuntime = _options$absoluteRunt === void 0 ? false : _options$absoluteRunt;
    var proposals = false;
    var rawVersion;

    if (typeof corejs === "object" && corejs !== null) {
      rawVersion = corejs.version;
      proposals = Boolean(corejs.proposals);
    } else {
      rawVersion = corejs;
    }

    var corejsVersion = rawVersion ? Number(rawVersion) : false;

    if (![false, 2, 3].includes(corejsVersion)) {
      throw new Error("The `core-js` version must be false, 2 or 3, but got " + JSON.stringify(rawVersion) + ".");
    }

    if (proposals && (!corejsVersion || corejsVersion < 3)) {
      throw new Error("The 'proposals' option is only supported when using 'corejs: 3'");
    }

    if (typeof useRuntimeRegenerator !== "boolean") {
      throw new Error("The 'regenerator' option must be undefined, or a boolean.");
    }

    if (typeof useRuntimeHelpers !== "boolean") {
      throw new Error("The 'helpers' option must be undefined, or a boolean.");
    }

    if (typeof useESModules !== "boolean" && useESModules !== "auto") {
      throw new Error("The 'useESModules' option must be undefined, or a boolean, or 'auto'.");
    }

    if (typeof absoluteRuntime !== "boolean" && typeof absoluteRuntime !== "string") {
      throw new Error("The 'absoluteRuntime' option must be undefined, a boolean, or a string.");
    }

    if (typeof runtimeVersion !== "string") {
      throw new Error("The 'version' option must be a version string.");
    }

    function has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }

    function hasMapping(methods, name) {
      return has(methods, name) && (proposals || methods[name].stable);
    }

    function hasStaticMapping(object, method) {
      return has(StaticProperties, object) && hasMapping(StaticProperties[object], method);
    }

    function isNamespaced(path) {
      var binding = path.scope.getBinding(path.node.name);
      if (!binding) return false;
      return binding.path.isImportNamespaceSpecifier();
    }

    function maybeNeedsPolyfill(path, methods, name) {
      if (isNamespaced(path.get("object"))) return false;
      if (!methods[name].types) return true;
      var typeAnnotation = path.get("object").getTypeAnnotation();
      var type = typeAnnotationToString(typeAnnotation);
      if (!type) return true;
      return methods[name].types.some(function (name) {
        return name === type;
      });
    }

    function resolvePropertyName(path, computed) {
      var node = path.node;
      if (!computed) return node.name;
      if (path.isStringLiteral()) return node.value;
      var result = path.evaluate();
      return result.value;
    }

    if (has(options, "useBuiltIns")) {
      if (options.useBuiltIns) {
        throw new Error("The 'useBuiltIns' option has been removed. The @babel/runtime " + "module now uses builtins by default.");
      } else {
        throw new Error("The 'useBuiltIns' option has been removed. Use the 'corejs'" + "option to polyfill with `core-js` via @babel/runtime.");
      }
    }

    if (has(options, "polyfill")) {
      if (options.polyfill === false) {
        throw new Error("The 'polyfill' option has been removed. The @babel/runtime " + "module now skips polyfilling by default.");
      } else {
        throw new Error("The 'polyfill' option has been removed. Use the 'corejs'" + "option to polyfill with `core-js` via @babel/runtime.");
      }
    }

    if (has(options, "moduleName")) {
      throw new Error("The 'moduleName' option has been removed. @babel/transform-runtime " + "no longer supports arbitrary runtimes. If you were using this to " + "set an absolute path for Babel's standard runtimes, please use the " + "'absoluteRuntime' option.");
    }

    var esModules = useESModules === "auto" ? api.caller(supportsStaticESM) : useESModules;
    var injectCoreJS2 = corejsVersion === 2;
    var injectCoreJS3 = corejsVersion === 3;
    var injectCoreJS = corejsVersion !== false;
    var moduleName = injectCoreJS3 ? "@babel/runtime-corejs3" : injectCoreJS2 ? "@babel/runtime-corejs2" : "@babel/runtime";
    var corejsRoot = injectCoreJS3 && !proposals ? "core-js-stable" : "core-js";

    var _ref = (injectCoreJS2 ? getCoreJS2Definitions : getCoreJS3Definitions)(runtimeVersion),
        BuiltIns = _ref.BuiltIns,
        StaticProperties = _ref.StaticProperties,
        InstanceProperties = _ref.InstanceProperties;

    var HEADER_HELPERS = ["interopRequireWildcard", "interopRequireDefault"];
    var modulePath = moduleName;

    if (absoluteRuntime !== false) {
      modulePath = resolveAbsoluteRuntime(moduleName, path$1.resolve(dirname, absoluteRuntime === true ? "." : absoluteRuntime));
    }

    return {
      name: "transform-runtime",
      pre: function pre(file) {
        var _this = this;

        if (useRuntimeHelpers) {
          file.set("helperGenerator", function (name) {
            if (file.availableHelper && !file.availableHelper(name, runtimeVersion)) {
              return;
            }

            var isInteropHelper = HEADER_HELPERS.indexOf(name) !== -1;
            var blockHoist = isInteropHelper && !isModule(file.path) ? 4 : undefined;
            var helpersDir = esModules && file.path.node.sourceType === "module" ? "helpers/esm" : "helpers";
            return _this.addDefaultImport(modulePath + "/" + helpersDir + "/" + name, name, blockHoist);
          });
        }

        var cache = new Map();

        this.addDefaultImport = function (source, nameHint, blockHoist) {
          var cacheKey = isModule(file.path);
          var key = source + ":" + nameHint + ":" + (cacheKey || "");
          var cached = cache.get(key);

          if (cached) {
            cached = cloneNode(cached);
          } else {
            cached = addDefault(file.path, source, {
              importedInterop: "uncompiled",
              nameHint: nameHint,
              blockHoist: blockHoist
            });
            cache.set(key, cached);
          }

          return cached;
        };
      },
      visitor: {
        ReferencedIdentifier: function ReferencedIdentifier(path) {
          var node = path.node,
              parent = path.parent,
              scope = path.scope;
          var name = node.name;

          if (name === "regeneratorRuntime" && useRuntimeRegenerator) {
            path.replaceWith(this.addDefaultImport(modulePath + "/regenerator", "regeneratorRuntime"));
            return;
          }

          if (!injectCoreJS) return;
          if (isMemberExpression(parent)) return;
          if (!hasMapping(BuiltIns, name)) return;
          if (scope.getBindingIdentifier(name)) return;
          path.replaceWith(this.addDefaultImport(modulePath + "/" + corejsRoot + "/" + BuiltIns[name].path, name));
        },
        CallExpression: function CallExpression$1(path) {
          if (!injectCoreJS) return;
          var node = path.node;
          var callee = node.callee;
          if (!isMemberExpression(callee)) return;
          var object = callee.object;
          var propertyName = resolvePropertyName(path.get("callee.property"), callee.computed);

          if (injectCoreJS3 && !hasStaticMapping(object.name, propertyName)) {
            if (hasMapping(InstanceProperties, propertyName) && maybeNeedsPolyfill(path.get("callee"), InstanceProperties, propertyName)) {
              var context1, context2;

              if (isIdentifier(object)) {
                context1 = object;
                context2 = cloneNode(object);
              } else {
                context1 = path.scope.generateDeclaredUidIdentifier("context");
                context2 = AssignmentExpression("=", context1, object);
              }

              node.callee = MemberExpression(CallExpression(this.addDefaultImport(moduleName + "/" + corejsRoot + "/instance/" + InstanceProperties[propertyName].path, propertyName + "InstanceProperty"), [context2]), Identifier("call"));
              node.arguments.unshift(context1);
              return;
            }
          }

          if (node.arguments.length) return;
          if (!callee.computed) return;

          if (!path.get("callee.property").matchesPattern("Symbol.iterator")) {
            return;
          }

          path.replaceWith(CallExpression(this.addDefaultImport(modulePath + "/core-js/get-iterator", "getIterator"), [object]));
        },
        BinaryExpression: function BinaryExpression(path) {
          if (!injectCoreJS) return;
          if (path.node.operator !== "in") return;
          if (!path.get("left").matchesPattern("Symbol.iterator")) return;
          path.replaceWith(CallExpression(this.addDefaultImport(modulePath + "/core-js/is-iterable", "isIterable"), [path.node.right]));
        },
        MemberExpression: {
          enter: function enter(path) {
            if (!injectCoreJS) return;
            if (!path.isReferenced()) return;
            var node = path.node;
            var object = node.object;
            if (!isReferenced(object, node)) return;

            if (!injectCoreJS2 && node.computed && path.get("property").matchesPattern("Symbol.iterator")) {
              path.replaceWith(CallExpression(this.addDefaultImport(moduleName + "/core-js/get-iterator-method", "getIteratorMethod"), [object]));
              return;
            }

            var objectName = object.name;
            var propertyName = resolvePropertyName(path.get("property"), node.computed);

            if (path.scope.getBindingIdentifier(objectName) || !hasStaticMapping(objectName, propertyName)) {
              if (injectCoreJS3 && hasMapping(InstanceProperties, propertyName) && maybeNeedsPolyfill(path, InstanceProperties, propertyName)) {
                path.replaceWith(CallExpression(this.addDefaultImport(moduleName + "/" + corejsRoot + "/instance/" + InstanceProperties[propertyName].path, propertyName + "InstanceProperty"), [object]));
              }

              return;
            }

            path.replaceWith(this.addDefaultImport(modulePath + "/" + corejsRoot + "/" + StaticProperties[objectName][propertyName].path, objectName + "$" + propertyName));
          },
          exit: function exit(path) {
            if (!injectCoreJS) return;
            if (!path.isReferenced()) return;
            if (path.node.computed) return;
            var node = path.node;
            var object = node.object;
            var name = object.name;
            if (!hasMapping(BuiltIns, name)) return;
            if (path.scope.getBindingIdentifier(name)) return;
            path.replaceWith(MemberExpression(this.addDefaultImport(modulePath + "/" + corejsRoot + "/" + BuiltIns[name].path, name), node.property));
          }
        }
      }
    };
  });

  var transformShorthandProperties = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-shorthand-properties",
      visitor: {
        ObjectMethod: function ObjectMethod(path) {
          var node = path.node;

          if (node.kind === "method") {
            var func = FunctionExpression(null, node.params, node.body, node.generator, node.async);
            func.returnType = node.returnType;
            path.replaceWith(ObjectProperty(node.key, func, node.computed));
          }
        },
        ObjectProperty: function ObjectProperty(_ref) {
          var node = _ref.node;

          if (node.shorthand) {
            node.shorthand = false;
          }
        }
      }
    };
  });

  var transformSpread = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose;

    function getSpreadLiteral(spread, scope) {
      if (loose && !isIdentifier(spread.argument, {
        name: "arguments"
      })) {
        return spread.argument;
      } else {
        return scope.toArray(spread.argument, true);
      }
    }

    function hasSpread(nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (isSpreadElement(nodes[i])) {
          return true;
        }
      }

      return false;
    }

    function push(_props, nodes) {
      if (!_props.length) return _props;
      nodes.push(ArrayExpression(_props));
      return [];
    }

    function build(props, scope) {
      var nodes = [];
      var _props = [];

      for (var _iterator = props, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var prop = _ref;

        if (isSpreadElement(prop)) {
          _props = push(_props, nodes);
          nodes.push(getSpreadLiteral(prop, scope));
        } else {
          _props.push(prop);
        }
      }

      push(_props, nodes);
      return nodes;
    }

    return {
      name: "transform-spread",
      visitor: {
        ArrayExpression: function ArrayExpression$1(path) {
          var node = path.node,
              scope = path.scope;
          var elements = node.elements;
          if (!hasSpread(elements)) return;
          var nodes = build(elements, scope);
          var first = nodes[0];

          if (nodes.length === 1 && first !== elements[0].argument) {
            path.replaceWith(first);
            return;
          }

          if (!isArrayExpression(first)) {
            first = ArrayExpression([]);
          } else {
            nodes.shift();
          }

          path.replaceWith(CallExpression(MemberExpression(first, Identifier("concat")), nodes));
        },
        CallExpression: function CallExpression$1(path) {
          var node = path.node,
              scope = path.scope;
          var args = node.arguments;
          if (!hasSpread(args)) return;
          var calleePath = path.get("callee");
          if (calleePath.isSuper()) return;
          var contextLiteral = scope.buildUndefinedNode();
          node.arguments = [];
          var nodes;

          if (args.length === 1 && args[0].argument.name === "arguments") {
            nodes = [args[0].argument];
          } else {
            nodes = build(args, scope);
          }

          var first = nodes.shift();

          if (nodes.length) {
            node.arguments.push(CallExpression(MemberExpression(first, Identifier("concat")), nodes));
          } else {
            node.arguments.push(first);
          }

          var callee = node.callee;

          if (calleePath.isMemberExpression()) {
            var temp = scope.maybeGenerateMemoised(callee.object);

            if (temp) {
              callee.object = AssignmentExpression("=", temp, callee.object);
              contextLiteral = temp;
            } else {
              contextLiteral = cloneNode(callee.object);
            }

            appendToMemberExpression(callee, Identifier("apply"));
          } else {
            node.callee = MemberExpression(node.callee, Identifier("apply"));
          }

          if (isSuper(contextLiteral)) {
            contextLiteral = ThisExpression();
          }

          node.arguments.unshift(cloneNode(contextLiteral));
        },
        NewExpression: function NewExpression(path) {
          var node = path.node,
              scope = path.scope;
          var args = node.arguments;
          if (!hasSpread(args)) return;
          var nodes = build(args, scope);
          var first = nodes.shift();

          if (nodes.length) {
            args = CallExpression(MemberExpression(first, Identifier("concat")), nodes);
          } else {
            args = first;
          }

          path.replaceWith(CallExpression(path.hub.addHelper("construct"), [node.callee, args]));
        }
      }
    };
  });

  var transformStickyRegex = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-sticky-regex",
      visitor: {
        RegExpLiteral: function RegExpLiteral(path) {
          var node = path.node;
          if (!is$2(node, "y")) return;
          path.replaceWith(NewExpression(Identifier("RegExp"), [StringLiteral(node.pattern), StringLiteral(node.flags)]));
        }
      }
    };
  });

  var transformStrictMode = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-strict-mode",
      visitor: {
        Program: function Program(path) {
          var node = path.node;

          for (var _i = 0, _arr = node.directives; _i < _arr.length; _i++) {
            var directive = _arr[_i];
            if (directive.value.value === "use strict") return;
          }

          path.unshiftContainer("directives", Directive(DirectiveLiteral("use strict")));
        }
      }
    };
  });

  function _templateObject$c() {
    var data = _taggedTemplateLiteralLoose(["\n          function ", "() {\n            const data = ", ";\n            ", " = function() { return data };\n            return data;\n          } \n        "]);

    _templateObject$c = function _templateObject() {
      return data;
    };

    return data;
  }
  var transformTemplateLiterals = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose;
    var helperName = "taggedTemplateLiteral";
    if (loose) helperName += "Loose";

    function buildConcatCallExpressions(items) {
      var avail = true;
      return items.reduce(function (left, right) {
        var canBeInserted = isLiteral(right);

        if (!canBeInserted && avail) {
          canBeInserted = true;
          avail = false;
        }

        if (canBeInserted && isCallExpression(left)) {
          left.arguments.push(right);
          return left;
        }

        return CallExpression(MemberExpression(left, Identifier("concat")), [right]);
      });
    }

    return {
      name: "transform-template-literals",
      visitor: {
        TaggedTemplateExpression: function TaggedTemplateExpression(path) {
          var node = path.node;
          var quasi = node.quasi;
          var strings = [];
          var raws = [];
          var isStringsRawEqual = true;

          for (var _i = 0, _arr = quasi.quasis; _i < _arr.length; _i++) {
            var elem = _arr[_i];
            var _elem$value = elem.value,
                raw = _elem$value.raw,
                cooked = _elem$value.cooked;
            var value = cooked == null ? path.scope.buildUndefinedNode() : StringLiteral(cooked);
            strings.push(value);
            raws.push(StringLiteral(raw));

            if (raw !== cooked) {
              isStringsRawEqual = false;
            }
          }

          var scope = path.scope.getProgramParent();
          var templateObject = scope.generateUidIdentifier("templateObject");
          var helperId = this.addHelper(helperName);
          var callExpressionInput = [ArrayExpression(strings)];

          if (!isStringsRawEqual) {
            callExpressionInput.push(ArrayExpression(raws));
          }

          var lazyLoad = template.ast(_templateObject$c(), templateObject, CallExpression(helperId, callExpressionInput), templateObject);
          scope.path.unshiftContainer("body", lazyLoad);
          path.replaceWith(CallExpression(node.tag, [CallExpression(cloneNode(templateObject), [])].concat(quasi.expressions)));
        },
        TemplateLiteral: function TemplateLiteral(path) {
          var nodes = [];
          var expressions = path.get("expressions");
          var index = 0;

          for (var _i2 = 0, _arr2 = path.node.quasis; _i2 < _arr2.length; _i2++) {
            var elem = _arr2[_i2];

            if (elem.value.cooked) {
              nodes.push(StringLiteral(elem.value.cooked));
            }

            if (index < expressions.length) {
              var expr = expressions[index++];
              var node = expr.node;

              if (!isStringLiteral(node, {
                value: ""
              })) {
                nodes.push(node);
              }
            }
          }

          var considerSecondNode = !loose || !isStringLiteral(nodes[1]);

          if (!isStringLiteral(nodes[0]) && considerSecondNode) {
            nodes.unshift(StringLiteral(""));
          }

          var root = nodes[0];

          if (loose) {
            for (var i = 1; i < nodes.length; i++) {
              root = BinaryExpression("+", root, nodes[i]);
            }
          } else if (nodes.length > 1) {
            root = buildConcatCallExpressions(nodes);
          }

          path.replaceWith(root);
        }
      }
    };
  });

  var transformTypeofSymbol = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-typeof-symbol",
      visitor: {
        Scope: function Scope(_ref) {
          var scope = _ref.scope;

          if (!scope.getBinding("Symbol")) {
            return;
          }

          scope.rename("Symbol");
        },
        UnaryExpression: function UnaryExpression$1(path) {
          var node = path.node,
              parent = path.parent;
          if (node.operator !== "typeof") return;

          if (path.parentPath.isBinaryExpression() && EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {
            var opposite = path.getOpposite();

            if (opposite.isLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object") {
              return;
            }
          }

          var isUnderHelper = path.findParent(function (path) {
            if (path.isFunction()) {
              var _path$get;

              return ((_path$get = path.get("body.directives.0")) == null ? void 0 : _path$get.node.value.value) === "@babel/helpers - typeof";
            }
          });
          if (isUnderHelper) return;
          var helper = this.addHelper("typeof");
          isUnderHelper = path.findParent(function (path) {
            return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
          });

          if (isUnderHelper) {
            return;
          }

          var call = CallExpression(helper, [node.argument]);
          var arg = path.get("argument");

          if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {
            var unary = UnaryExpression("typeof", cloneNode(node.argument));
            path.replaceWith(ConditionalExpression(BinaryExpression("===", unary, StringLiteral("undefined")), StringLiteral("undefined"), call));
          } else {
            path.replaceWith(call);
          }
        }
      }
    };
  });

  function transpileEnum(path, t) {
    var node = path.node;

    if (node.declare) {
      path.remove();
      return;
    }

    if (node["const"]) {
      throw path.buildCodeFrameError("'const' enums are not supported.");
    }

    var name = node.id.name;
    var fill = enumFill(path, t, node.id);

    switch (path.parent.type) {
      case "BlockStatement":
      case "ExportNamedDeclaration":
      case "Program":
        {
          path.insertAfter(fill);

          if (seen(path.parentPath)) {
            path.remove();
          } else {
            var isGlobal = t.isProgram(path.parent);
            path.scope.registerDeclaration(path.replaceWith(makeVar(node.id, t, isGlobal ? "var" : "let"))[0]);
          }

          break;
        }

      default:
        throw new Error("Unexpected enum parent '" + path.parent.type);
    }

    function seen(parentPath) {
      if (parentPath.isExportDeclaration()) {
        return seen(parentPath.parentPath);
      }

      if (parentPath.getData(name)) {
        return true;
      } else {
        parentPath.setData(name, true);
        return false;
      }
    }
  }

  function makeVar(id, t, kind) {
    return t.variableDeclaration(kind, [t.variableDeclarator(id)]);
  }

  var buildEnumWrapper = template("\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n");
  var buildStringAssignment = template("\n  ENUM[\"NAME\"] = VALUE;\n");
  var buildNumericAssignment = template("\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n");

  var buildEnumMember = function buildEnumMember(isString, options) {
    return (isString ? buildStringAssignment : buildNumericAssignment)(options);
  };

  function enumFill(path, t, id) {
    var x = translateEnumValues(path, t);
    var assignments = x.map(function (_ref) {
      var memberName = _ref[0],
          memberValue = _ref[1];
      return buildEnumMember(t.isStringLiteral(memberValue), {
        ENUM: t.cloneNode(id),
        NAME: memberName,
        VALUE: memberValue
      });
    });
    return buildEnumWrapper({
      ID: t.cloneNode(id),
      ASSIGNMENTS: assignments
    });
  }

  function translateEnumValues(path, t) {
    var seen = Object.create(null);
    var prev = -1;
    return path.node.members.map(function (member) {
      var name = t.isIdentifier(member.id) ? member.id.name : member.id.value;
      var initializer = member.initializer;
      var value;

      if (initializer) {
        var constValue = evaluate$1(initializer, seen);

        if (constValue !== undefined) {
          seen[name] = constValue;

          if (typeof constValue === "number") {
            value = t.numericLiteral(constValue);
            prev = constValue;
          } else {
            assert$2(typeof constValue === "string");
            value = t.stringLiteral(constValue);
            prev = undefined;
          }
        } else {
          value = initializer;
          prev = undefined;
        }
      } else {
        if (prev !== undefined) {
          prev++;
          value = t.numericLiteral(prev);
          seen[name] = prev;
        } else {
          throw path.buildCodeFrameError("Enum member must have initializer.");
        }
      }

      return [name, value];
    });
  }

  function evaluate$1(expr, seen) {
    return evalConstant(expr);

    function evalConstant(expr) {
      switch (expr.type) {
        case "StringLiteral":
          return expr.value;

        case "UnaryExpression":
          return evalUnaryExpression(expr);

        case "BinaryExpression":
          return evalBinaryExpression(expr);

        case "NumericLiteral":
          return expr.value;

        case "ParenthesizedExpression":
          return evalConstant(expr.expression);

        case "Identifier":
          return seen[expr.name];

        case "TemplateLiteral":
          if (expr.quasis.length === 1) {
            return expr.quasis[0].value.cooked;
          }

        default:
          return undefined;
      }
    }

    function evalUnaryExpression(_ref2) {
      var argument = _ref2.argument,
          operator = _ref2.operator;
      var value = evalConstant(argument);

      if (value === undefined) {
        return undefined;
      }

      switch (operator) {
        case "+":
          return value;

        case "-":
          return -value;

        case "~":
          return ~value;

        default:
          return undefined;
      }
    }

    function evalBinaryExpression(expr) {
      var left = evalConstant(expr.left);

      if (left === undefined) {
        return undefined;
      }

      var right = evalConstant(expr.right);

      if (right === undefined) {
        return undefined;
      }

      switch (expr.operator) {
        case "|":
          return left | right;

        case "&":
          return left & right;

        case ">>":
          return left >> right;

        case ">>>":
          return left >>> right;

        case "<<":
          return left << right;

        case "^":
          return left ^ right;

        case "*":
          return left * right;

        case "/":
          return left / right;

        case "+":
          return left + right;

        case "-":
          return left - right;

        case "%":
          return left % right;

        default:
          return undefined;
      }
    }
  }

  function _templateObject2$5() {
    var data = _taggedTemplateLiteralLoose(["\n    (function (", ") {\n      ", "\n    })(", " || (", " = ", "));\n  "]);

    _templateObject2$5 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$d() {
    var data = _taggedTemplateLiteralLoose(["\n      ", ".", " || (\n        ", ".", " = ", "\n      )\n    "]);

    _templateObject$d = function _templateObject() {
      return data;
    };

    return data;
  }
  function transpileNamespace(path, t, allowNamespaces) {
    if (path.node.declare || path.node.id.type === "StringLiteral") {
      path.remove();
      return;
    }

    if (!allowNamespaces) {
      throw path.hub.file.buildCodeFrameError(path.node.id, "Namespace not marked type-only declare." + " Non-declarative namespaces are only supported experimentally in Babel." + " To enable and review caveats see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    }

    var name = path.node.id.name;
    var value = handleNested(path, t, t.cloneDeep(path.node));
    var bound = path.scope.hasOwnBinding(name);

    if (path.parent.type === "ExportNamedDeclaration") {
      if (!bound) {
        path.parentPath.insertAfter(value);
        path.replaceWith(getDeclaration(t, name));
        path.scope.registerDeclaration(path.parentPath);
      } else {
        path.parentPath.replaceWith(value);
      }
    } else if (bound) {
      path.replaceWith(value);
    } else {
      path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(t, name), value])[0]);
    }
  }

  function getDeclaration(t, name) {
    return t.variableDeclaration("let", [t.variableDeclarator(t.identifier(name))]);
  }

  function getMemberExpression(t, name, itemName) {
    return t.memberExpression(t.identifier(name), t.identifier(itemName));
  }

  function handleNested(path, t, node, parentExport) {
    var names = new Set();
    var realName = node.id;
    var name = path.scope.generateUid(realName.name);
    var namespaceTopLevel = node.body.body;

    for (var i = 0; i < namespaceTopLevel.length; i++) {
      var subNode = namespaceTopLevel[i];

      switch (subNode.type) {
        case "TSModuleDeclaration":
          {
            var transformed = handleNested(path, t, subNode);
            var moduleName = subNode.id.name;

            if (names.has(moduleName)) {
              namespaceTopLevel[i] = transformed;
            } else {
              names.add(moduleName);
              namespaceTopLevel.splice(i++, 1, getDeclaration(t, moduleName), transformed);
            }

            continue;
          }

        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          names.add(subNode.id.name);
          continue;

        case "VariableDeclaration":
          for (var _iterator = subNode.declarations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var variable = _ref;
            names.add(variable.id.name);
          }

          continue;

        default:
          continue;

        case "ExportNamedDeclaration":
      }

      switch (subNode.declaration.type) {
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          {
            var itemName = subNode.declaration.id.name;
            names.add(itemName);
            namespaceTopLevel.splice(i++, 1, subNode.declaration, t.expressionStatement(t.assignmentExpression("=", getMemberExpression(t, name, itemName), t.identifier(itemName))));
            break;
          }

        case "VariableDeclaration":
          if (subNode.declaration.kind !== "const") {
            throw path.hub.file.buildCodeFrameError(subNode.declaration, "Namespaces exporting non-const are not supported by Babel." + " Change to const or see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          }

          for (var _iterator2 = subNode.declaration.declarations, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray2) {
              if (_i2 >= _iterator2.length) break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done) break;
              _ref2 = _i2.value;
            }

            var _variable = _ref2;
            _variable.init = t.assignmentExpression("=", getMemberExpression(t, name, _variable.id.name), _variable.init);
          }

          namespaceTopLevel[i] = subNode.declaration;
          break;

        case "TSModuleDeclaration":
          {
            var _transformed = handleNested(path, t, subNode.declaration, t.identifier(name));

            var _moduleName = subNode.declaration.id.name;

            if (names.has(_moduleName)) {
              namespaceTopLevel[i] = _transformed;
            } else {
              names.add(_moduleName);
              namespaceTopLevel.splice(i++, 1, getDeclaration(t, _moduleName), _transformed);
            }
          }
      }
    }

    var fallthroughValue = t.objectExpression([]);

    if (parentExport) {
      fallthroughValue = template.expression.ast(_templateObject$d(), parentExport, realName, parentExport, realName, fallthroughValue);
    }

    return template.statement.ast(_templateObject2$5(), t.identifier(name), namespaceTopLevel, realName, realName, fallthroughValue);
  }

  function _templateObject$e() {
    var data = _taggedTemplateLiteralLoose(["this.", " = ", ""]);

    _templateObject$e = function _templateObject() {
      return data;
    };

    return data;
  }

  function isInType(path) {
    switch (path.parent.type) {
      case "TSTypeReference":
      case "TSQualifiedName":
      case "TSExpressionWithTypeArguments":
      case "TSTypeQuery":
        return true;

      default:
        return false;
    }
  }

  var PARSED_PARAMS = new WeakSet();
  var GLOBAL_TYPES = new WeakMap();

  function isGlobalType(path, name) {
    var program = path.find(function (path) {
      return path.isProgram();
    }).node;
    if (path.scope.hasOwnBinding(name)) return false;
    if (GLOBAL_TYPES.get(program).has(name)) return true;
    console.warn("The exported identifier \"" + name + "\" is not declared in Babel's scope tracker\n" + "as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\n" + "never encountered it as a TypeScript type declaration.\n" + "It will be treated as a JavaScript value.\n\n" + "This problem is likely caused by another plugin injecting\n" + ("\"" + name + "\" without registering it in the scope tracker. If you are the author\n") + " of that plugin, please use \"scope.registerDeclaration(declarationPath)\".");
    return false;
  }

  function registerGlobalType(programScope, name) {
    GLOBAL_TYPES.get(programScope.path.node).add(name);
  }

  var transformTypeScript = declare(function (api, _ref) {
    var _ref$jsxPragma = _ref.jsxPragma,
        jsxPragma = _ref$jsxPragma === void 0 ? "React" : _ref$jsxPragma,
        _ref$allowNamespaces = _ref.allowNamespaces,
        allowNamespaces = _ref$allowNamespaces === void 0 ? false : _ref$allowNamespaces,
        _ref$allowDeclareFiel = _ref.allowDeclareFields,
        allowDeclareFields = _ref$allowDeclareFiel === void 0 ? false : _ref$allowDeclareFiel,
        _ref$onlyRemoveTypeIm = _ref.onlyRemoveTypeImports,
        onlyRemoveTypeImports = _ref$onlyRemoveTypeIm === void 0 ? false : _ref$onlyRemoveTypeIm;
    api.assertVersion(7);
    var JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
    var classMemberVisitors = {
      field: function field(path) {
        var node = path.node;

        if (!allowDeclareFields && node.declare) {
          throw path.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of " + "@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
        }

        if (node.definite || node.declare) {
          if (node.value) {
            throw path.buildCodeFrameError("Definietly assigned fields and fields with the 'declare' modifier cannot" + " be initialized here, but only in the constructor");
          }

          if (!node.decorators) {
            path.remove();
          }
        } else if (!allowDeclareFields && !node.value && !node.decorators && !isClassPrivateProperty(node)) {
          path.remove();
        }

        if (node.accessibility) node.accessibility = null;
        if (node["abstract"]) node["abstract"] = null;
        if (node.readonly) node.readonly = null;
        if (node.optional) node.optional = null;
        if (node.typeAnnotation) node.typeAnnotation = null;
        if (node.definite) node.definite = null;
      },
      method: function method(_ref2) {
        var node = _ref2.node;
        if (node.accessibility) node.accessibility = null;
        if (node["abstract"]) node["abstract"] = null;
        if (node.optional) node.optional = null;
      },
      constructor: function constructor(path, classPath) {
        if (path.node.accessibility) path.node.accessibility = null;
        var parameterProperties = [];

        for (var _iterator = path.node.params, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref3;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref3 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref3 = _i.value;
          }

          var param = _ref3;

          if (param.type === "TSParameterProperty" && !PARSED_PARAMS.has(param.parameter)) {
            PARSED_PARAMS.add(param.parameter);
            parameterProperties.push(param.parameter);
          }
        }

        if (parameterProperties.length) {
          var assigns = parameterProperties.map(function (p) {
            var id;

            if (isIdentifier(p)) {
              id = p;
            } else if (isAssignmentPattern(p) && isIdentifier(p.left)) {
              id = p.left;
            } else {
              throw path.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
            }

            return template.statement.ast(_templateObject$e(), id, id);
          });
          injectInitialization(classPath, path, assigns);
        }
      }
    };
    return {
      name: "transform-typescript",
      inherits: syntaxTypescript,
      visitor: {
        Pattern: visitPattern,
        Identifier: visitPattern,
        RestElement: visitPattern,
        Program: function Program(path, state) {
          var file = state.file;
          var fileJsxPragma = null;

          if (!GLOBAL_TYPES.has(path.node)) {
            GLOBAL_TYPES.set(path.node, new Set());
          }

          if (file.ast.comments) {
            for (var _i2 = 0, _arr = file.ast.comments; _i2 < _arr.length; _i2++) {
              var comment = _arr[_i2];
              var jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);

              if (jsxMatches) {
                fileJsxPragma = jsxMatches[1];
              }
            }
          }

          for (var _iterator2 = path.get("body"), _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref4;

            if (_isArray2) {
              if (_i3 >= _iterator2.length) break;
              _ref4 = _iterator2[_i3++];
            } else {
              _i3 = _iterator2.next();
              if (_i3.done) break;
              _ref4 = _i3.value;
            }

            var stmt = _ref4;

            if (isImportDeclaration(stmt)) {
              if (stmt.node.importKind === "type") {
                stmt.remove();
                continue;
              }

              if (!onlyRemoveTypeImports) {
                if (stmt.node.specifiers.length === 0) {
                  continue;
                }

                var allElided = true;
                var importsToRemove = [];

                for (var _iterator3 = stmt.node.specifiers, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
                  var _ref5;

                  if (_isArray3) {
                    if (_i4 >= _iterator3.length) break;
                    _ref5 = _iterator3[_i4++];
                  } else {
                    _i4 = _iterator3.next();
                    if (_i4.done) break;
                    _ref5 = _i4.value;
                  }

                  var specifier = _ref5;
                  var binding = stmt.scope.getBinding(specifier.local.name);

                  if (binding && isImportTypeOnly({
                    binding: binding,
                    programPath: path,
                    jsxPragma: fileJsxPragma || jsxPragma
                  })) {
                    importsToRemove.push(binding.path);
                  } else {
                    allElided = false;
                  }
                }

                if (allElided) {
                  stmt.remove();
                } else {
                  for (var _iterator4 = importsToRemove, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
                    var _ref6;

                    if (_isArray4) {
                      if (_i5 >= _iterator4.length) break;
                      _ref6 = _iterator4[_i5++];
                    } else {
                      _i5 = _iterator4.next();
                      if (_i5.done) break;
                      _ref6 = _i5.value;
                    }

                    var importPath = _ref6;
                    importPath.remove();
                  }
                }
              }

              continue;
            }

            if (stmt.isExportDeclaration()) {
              stmt = stmt.get("declaration");
            }

            if (stmt.isVariableDeclaration({
              declare: true
            })) {
              for (var _i6 = 0, _Object$keys = Object.keys(stmt.getBindingIdentifiers()); _i6 < _Object$keys.length; _i6++) {
                var name = _Object$keys[_i6];
                registerGlobalType(path.scope, name);
              }
            } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({
              declare: true
            }) || stmt.isTSEnumDeclaration({
              declare: true
            }) || stmt.isTSModuleDeclaration({
              declare: true
            }) && stmt.get("id").isIdentifier()) {
              registerGlobalType(path.scope, stmt.node.id.name);
            }
          }
        },
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          if (path.node.exportKind === "type") {
            path.remove();
            return;
          }

          if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(function (_ref7) {
            var local = _ref7.local;
            return isGlobalType(path, local.name);
          })) {
            path.remove();
          }
        },
        ExportSpecifier: function ExportSpecifier(path) {
          if (!path.parent.source && isGlobalType(path, path.node.local.name)) {
            path.remove();
          }
        },
        ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
          if (isIdentifier(path.node.declaration) && isGlobalType(path, path.node.declaration.name)) {
            path.remove();
          }
        },
        TSDeclareFunction: function TSDeclareFunction(path) {
          path.remove();
        },
        TSDeclareMethod: function TSDeclareMethod(path) {
          path.remove();
        },
        VariableDeclaration: function VariableDeclaration(path) {
          if (path.node.declare) {
            path.remove();
          }
        },
        VariableDeclarator: function VariableDeclarator(_ref8) {
          var node = _ref8.node;
          if (node.definite) node.definite = null;
        },
        TSIndexSignature: function TSIndexSignature(path) {
          path.remove();
        },
        ClassDeclaration: function ClassDeclaration(path) {
          var node = path.node;

          if (node.declare) {
            path.remove();
            return;
          }
        },
        Class: function Class(path) {
          var node = path.node;
          if (node.typeParameters) node.typeParameters = null;
          if (node.superTypeParameters) node.superTypeParameters = null;
          if (node["implements"]) node["implements"] = null;
          if (node["abstract"]) node["abstract"] = null;
          path.get("body.body").forEach(function (child) {
            if (child.isClassMethod() || child.isClassPrivateMethod()) {
              if (child.node.kind === "constructor") {
                classMemberVisitors.constructor(child, path);
              } else {
                classMemberVisitors.method(child, path);
              }
            } else if (child.isClassProperty() || child.isClassPrivateProperty()) {
              classMemberVisitors.field(child, path);
            }
          });
        },
        Function: function Function(_ref9) {
          var node = _ref9.node;
          if (node.typeParameters) node.typeParameters = null;
          if (node.returnType) node.returnType = null;
          var p0 = node.params[0];

          if (p0 && isIdentifier(p0) && p0.name === "this") {
            node.params.shift();
          }

          node.params = node.params.map(function (p) {
            return p.type === "TSParameterProperty" ? p.parameter : p;
          });
        },
        TSModuleDeclaration: function TSModuleDeclaration(path) {
          transpileNamespace(path, t, allowNamespaces);
        },
        TSInterfaceDeclaration: function TSInterfaceDeclaration(path) {
          path.remove();
        },
        TSTypeAliasDeclaration: function TSTypeAliasDeclaration(path) {
          path.remove();
        },
        TSEnumDeclaration: function TSEnumDeclaration(path) {
          transpileEnum(path, t);
        },
        TSImportEqualsDeclaration: function TSImportEqualsDeclaration(path) {
          throw path.buildCodeFrameError("`import =` is not supported by @babel/plugin-transform-typescript\n" + "Please consider using " + "`import <moduleName> from '<moduleName>';` alongside " + "Typescript's --allowSyntheticDefaultImports option.");
        },
        TSExportAssignment: function TSExportAssignment(path) {
          throw path.buildCodeFrameError("`export =` is not supported by @babel/plugin-transform-typescript\n" + "Please consider using `export <value>;`.");
        },
        TSTypeAssertion: function TSTypeAssertion(path) {
          path.replaceWith(path.node.expression);
        },
        TSAsExpression: function TSAsExpression(path) {
          var node = path.node;

          do {
            node = node.expression;
          } while (isTSAsExpression(node));

          path.replaceWith(node);
        },
        TSNonNullExpression: function TSNonNullExpression(path) {
          path.replaceWith(path.node.expression);
        },
        CallExpression: function CallExpression(path) {
          path.node.typeParameters = null;
        },
        NewExpression: function NewExpression(path) {
          path.node.typeParameters = null;
        },
        JSXOpeningElement: function JSXOpeningElement(path) {
          path.node.typeParameters = null;
        },
        TaggedTemplateExpression: function TaggedTemplateExpression(path) {
          path.node.typeParameters = null;
        }
      }
    };

    function visitPattern(_ref10) {
      var node = _ref10.node;
      if (node.typeAnnotation) node.typeAnnotation = null;
      if (isIdentifier(node) && node.optional) node.optional = null;
    }

    function isImportTypeOnly(_ref11) {
      var binding = _ref11.binding,
          programPath = _ref11.programPath,
          jsxPragma = _ref11.jsxPragma;

      for (var _iterator5 = binding.referencePaths, _isArray5 = Array.isArray(_iterator5), _i7 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
        var _ref12;

        if (_isArray5) {
          if (_i7 >= _iterator5.length) break;
          _ref12 = _iterator5[_i7++];
        } else {
          _i7 = _iterator5.next();
          if (_i7.done) break;
          _ref12 = _i7.value;
        }

        var path = _ref12;

        if (!isInType(path)) {
          return false;
        }
      }

      if (binding.identifier.name !== jsxPragma) {
        return true;
      }

      var sourceFileHasJsx = false;
      programPath.traverse({
        JSXElement: function JSXElement() {
          sourceFileHasJsx = true;
        },
        JSXFragment: function JSXFragment() {
          sourceFileHasJsx = true;
        }
      });
      return !sourceFileHasJsx;
    }
  });

  var transformUnicodeRegex = declare(function (api) {
    api.assertVersion(7);
    return createRegExpFeaturePlugin({
      name: "transform-unicode-regex",
      feature: "unicodeFlag"
    });
  });

  var all = {
    "external-helpers": externalHelpers,
    "syntax-async-generators": syntaxAsyncGenerators,
    "syntax-class-properties": syntaxClassProperties,
    "syntax-decorators": syntaxDecorators,
    "syntax-do-expressions": syntaxDoExpressions,
    "syntax-dynamic-import": syntaxDynamicImport,
    "syntax-export-default-from": syntaxExportDefaultFrom,
    "syntax-export-namespace-from": syntaxExportNamespaceFrom,
    "syntax-flow": syntaxFlow,
    "syntax-function-bind": syntaxFunctionBind,
    "syntax-function-sent": syntaxFunctionSent,
    "syntax-import-meta": syntaxImportMeta,
    "syntax-jsx": syntaxJsx,
    "syntax-object-rest-spread": syntaxObjectRestSpread,
    "syntax-optional-catch-binding": syntaxOptionalCatchBinding,
    "syntax-pipeline-operator": syntaxPipelineOperator,
    "syntax-top-level-await": syntaxTopLevelAwait,
    "syntax-typescript": syntaxTypescript,
    "proposal-async-generator-functions": proposalAsyncGeneratorFunctions,
    "proposal-class-properties": proposalClassProperties,
    "proposal-decorators": proposalDecorators,
    "proposal-do-expressions": proposalDoExpressions,
    "proposal-dynamic-import": proposalDynamicImport,
    "proposal-export-default-from": proposalExportDefaultFrom,
    "proposal-export-namespace-from": proposalExportNamespaceFrom,
    "proposal-function-bind": proposalFunctionBind,
    "proposal-function-sent": proposalFunctionSent,
    "proposal-json-strings": proposalJsonStrings,
    "proposal-logical-assignment-operators": proposalLogicalAssignmentOperators,
    "proposal-nullish-coalescing-operator": proposalNullishCoalescingOperator,
    "proposal-numeric-separator": proposalNumericSeparator,
    "proposal-object-rest-spread": proposalObjectRestSpread,
    "proposal-optional-catch-binding": proposalOptionalCatchBinding,
    "proposal-optional-chaining": proposalOptionalChaining,
    "proposal-pipeline-operator": proposalPipelineOperator,
    "proposal-private-methods": proposalPrivateMethods,
    "proposal-throw-expressions": proposalThrowExpressions,
    "proposal-unicode-property-regex": proposalUnicodePropertyRegex,
    "transform-async-to-generator": transformAsyncToGenerator,
    "transform-arrow-functions": transformArrowFunctions,
    "transform-block-scoped-functions": transformBlockScopedFunctions,
    "transform-block-scoping": transformBlockScoping,
    "transform-classes": transformClasses,
    "transform-computed-properties": transformComputedProperties,
    "transform-destructuring": transformDestructuring,
    "transform-dotall-regex": transformDotallRegex,
    "transform-duplicate-keys": transformDuplicateKeys,
    "transform-exponentiation-operator": transformExponentialOperator,
    "transform-flow-comments": transformFlowComments,
    "transform-flow-strip-types": transformFlowStripTypes,
    "transform-for-of": transformForOf,
    "transform-function-name": transformFunctionName,
    "transform-instanceof": transformInstanceof,
    "transform-jscript": transformJscript,
    "transform-literals": transformLiterals,
    "transform-member-expression-literals": transformMemberExpressionLiterals,
    "transform-modules-amd": transformModulesAmd,
    "transform-modules-commonjs": transformModulesCommonjs,
    "transform-modules-systemjs": transformModulesSystemjs,
    "transform-modules-umd": transformModulesUmd,
    "transform-named-capturing-groups-regex": transformNamedCapturingGroupsRegex,
    "transform-new-target": transformNewTarget,
    "transform-object-assign": transformObjectAssign,
    "transform-object-super": transformObjectSuper,
    "transform-object-set-prototype-of-to-assign": transformObjectSetPrototypeOfToAssign,
    "transform-parameters": transformParameters,
    "transform-property-literals": transformPropertyLiterals,
    "transform-property-mutators": transformPropertyMutators,
    "transform-proto-to-assign": transformProtoToAssign,
    "transform-react-constant-elements": transformReactConstantElements,
    "transform-react-display-name": transformReactDisplayName,
    "transform-react-inline-elements": transformReactInlineElements,
    "transform-react-jsx": transformReactJSX,
    "transform-react-jsx-compat": transformReactJsxCompat,
    "transform-react-jsx-development": transformReactJSXDevelopment,
    "transform-react-jsx-self": transformReactJSXSelf,
    "transform-react-jsx-source": transformReactJSXSource,
    "transform-regenerator": transformRegenerator,
    "transform-reserved-words": transformReservedWords,
    "transform-runtime": transformRuntime,
    "transform-shorthand-properties": transformShorthandProperties,
    "transform-spread": transformSpread,
    "transform-sticky-regex": transformStickyRegex,
    "transform-strict-mode": transformStrictMode,
    "transform-template-literals": transformTemplateLiterals,
    "transform-typeof-symbol": transformTypeofSymbol,
    "transform-typescript": transformTypeScript,
    "transform-unicode-regex": transformUnicodeRegex
  };

  var preset2015 = (function (_, opts) {
    var loose = false;
    var modules = "commonjs";
    var spec = false;

    if (opts !== undefined) {
      if (opts.loose !== undefined) loose = opts.loose;
      if (opts.modules !== undefined) modules = opts.modules;
      if (opts.spec !== undefined) spec = opts.spec;
    }

    var optsLoose = {
      loose: loose
    };
    return {
      plugins: [[transformTemplateLiterals, {
        loose: loose,
        spec: spec
      }], transformLiterals, transformFunctionName, [transformArrowFunctions, {
        spec: spec
      }], transformBlockScopedFunctions, [transformClasses, optsLoose], transformObjectSuper, transformShorthandProperties, transformDuplicateKeys, [transformComputedProperties, optsLoose], [transformForOf, optsLoose], transformStickyRegex, transformUnicodeRegex, [transformSpread, optsLoose], [transformParameters, optsLoose], [transformDestructuring, optsLoose], transformBlockScoping, transformTypeofSymbol, transformInstanceof, (modules === "commonjs" || modules === "cjs") && [transformModulesCommonjs, optsLoose], modules === "systemjs" && [transformModulesSystemjs, optsLoose], modules === "amd" && [transformModulesAmd, optsLoose], modules === "umd" && [transformModulesUmd, optsLoose], [transformRegenerator, {
        async: false,
        asyncGenerators: false
      }]].filter(Boolean)
    };
  });

  var presetStage3 = (function (_, opts) {
    var loose = false;

    if (opts !== undefined) {
      if (opts.loose !== undefined) loose = opts.loose;
    }

    return {
      plugins: [syntaxDynamicImport, syntaxImportMeta, [proposalOptionalChaining, {
        loose: loose
      }], [proposalNullishCoalescingOperator, {
        loose: loose
      }], [proposalClassProperties, {
        loose: loose
      }], proposalJsonStrings, [proposalPrivateMethods, {
        loose: loose
      }]]
    };
  });

  var presetStage2 = (function (_, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _opts = opts,
        _opts$loose = _opts.loose,
        loose = _opts$loose === void 0 ? false : _opts$loose,
        _opts$useBuiltIns = _opts.useBuiltIns,
        useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
        _opts$decoratorsLegac = _opts.decoratorsLegacy,
        decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
        decoratorsBeforeExport = _opts.decoratorsBeforeExport;
    return {
      presets: [[presetStage3, {
        loose: loose,
        useBuiltIns: useBuiltIns
      }]],
      plugins: [[proposalDecorators, {
        legacy: decoratorsLegacy,
        decoratorsBeforeExport: decoratorsBeforeExport
      }], proposalFunctionSent, proposalExportNamespaceFrom, proposalNumericSeparator, proposalThrowExpressions]
    };
  });

  var presetStage1 = (function (_, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _opts = opts,
        _opts$loose = _opts.loose,
        loose = _opts$loose === void 0 ? false : _opts$loose,
        _opts$useBuiltIns = _opts.useBuiltIns,
        useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
        _opts$decoratorsLegac = _opts.decoratorsLegacy,
        decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
        decoratorsBeforeExport = _opts.decoratorsBeforeExport,
        _opts$pipelineProposa = _opts.pipelineProposal,
        pipelineProposal = _opts$pipelineProposa === void 0 ? "minimal" : _opts$pipelineProposa;
    return {
      presets: [[presetStage2, {
        loose: loose,
        useBuiltIns: useBuiltIns,
        decoratorsLegacy: decoratorsLegacy,
        decoratorsBeforeExport: decoratorsBeforeExport
      }]],
      plugins: [proposalExportDefaultFrom, proposalLogicalAssignmentOperators, [proposalPipelineOperator, {
        proposal: pipelineProposal
      }], proposalDoExpressions]
    };
  });

  var presetStage0 = (function (_, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _opts = opts,
        _opts$loose = _opts.loose,
        loose = _opts$loose === void 0 ? false : _opts$loose,
        _opts$useBuiltIns = _opts.useBuiltIns,
        useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
        _opts$decoratorsLegac = _opts.decoratorsLegacy,
        decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
        decoratorsBeforeExport = _opts.decoratorsBeforeExport,
        _opts$pipelineProposa = _opts.pipelineProposal,
        pipelineProposal = _opts$pipelineProposa === void 0 ? "minimal" : _opts$pipelineProposa;
    return {
      presets: [[presetStage1, {
        loose: loose,
        useBuiltIns: useBuiltIns,
        decoratorsLegacy: decoratorsLegacy,
        decoratorsBeforeExport: decoratorsBeforeExport,
        pipelineProposal: pipelineProposal
      }]],
      plugins: [proposalFunctionBind]
    };
  });

  var envs = [
    {
      name: "nodejs",
      version: "0.2.0",
      date: "2011-08-26",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "0.3.0",
      date: "2011-08-26",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "0.4.0",
      date: "2011-08-26",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "0.5.0",
      date: "2011-08-26",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "0.6.0",
      date: "2011-11-04",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "0.7.0",
      date: "2012-01-17",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "0.8.0",
      date: "2012-06-22",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "0.9.0",
      date: "2012-07-20",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "0.10.0",
      date: "2013-03-11",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "0.11.0",
      date: "2013-03-28",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "0.12.0",
      date: "2015-02-06",
      lts: false,
      security: false
    },
    {
      name: "iojs",
      version: "1.0.0",
      date: "2015-01-14"
    },
    {
      name: "iojs",
      version: "1.1.0",
      date: "2015-02-03"
    },
    {
      name: "iojs",
      version: "1.2.0",
      date: "2015-02-11"
    },
    {
      name: "iojs",
      version: "1.3.0",
      date: "2015-02-20"
    },
    {
      name: "iojs",
      version: "1.5.0",
      date: "2015-03-06"
    },
    {
      name: "iojs",
      version: "1.6.0",
      date: "2015-03-20"
    },
    {
      name: "iojs",
      version: "2.0.0",
      date: "2015-05-04"
    },
    {
      name: "iojs",
      version: "2.1.0",
      date: "2015-05-24"
    },
    {
      name: "iojs",
      version: "2.2.0",
      date: "2015-06-01"
    },
    {
      name: "iojs",
      version: "2.3.0",
      date: "2015-06-13"
    },
    {
      name: "iojs",
      version: "2.4.0",
      date: "2015-07-17"
    },
    {
      name: "iojs",
      version: "2.5.0",
      date: "2015-07-28"
    },
    {
      name: "iojs",
      version: "3.0.0",
      date: "2015-08-04"
    },
    {
      name: "iojs",
      version: "3.1.0",
      date: "2015-08-19"
    },
    {
      name: "iojs",
      version: "3.2.0",
      date: "2015-08-25"
    },
    {
      name: "iojs",
      version: "3.3.0",
      date: "2015-09-02"
    },
    {
      name: "nodejs",
      version: "4.0.0",
      date: "2015-09-08",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "4.1.0",
      date: "2015-09-17",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "4.2.0",
      date: "2015-10-12",
      lts: "Argon",
      security: false
    },
    {
      name: "nodejs",
      version: "4.3.0",
      date: "2016-02-09",
      lts: "Argon",
      security: false
    },
    {
      name: "nodejs",
      version: "4.4.0",
      date: "2016-03-08",
      lts: "Argon",
      security: false
    },
    {
      name: "nodejs",
      version: "4.5.0",
      date: "2016-08-16",
      lts: "Argon",
      security: false
    },
    {
      name: "nodejs",
      version: "4.6.0",
      date: "2016-09-27",
      lts: "Argon",
      security: true
    },
    {
      name: "nodejs",
      version: "4.7.0",
      date: "2016-12-06",
      lts: "Argon",
      security: false
    },
    {
      name: "nodejs",
      version: "4.8.0",
      date: "2017-02-21",
      lts: "Argon",
      security: false
    },
    {
      name: "nodejs",
      version: "4.9.0",
      date: "2018-03-28",
      lts: "Argon",
      security: true
    },
    {
      name: "nodejs",
      version: "5.0.0",
      date: "2015-10-29",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "5.1.0",
      date: "2015-11-17",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "5.2.0",
      date: "2015-12-09",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "5.3.0",
      date: "2015-12-15",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "5.4.0",
      date: "2016-01-06",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "5.5.0",
      date: "2016-01-21",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "5.6.0",
      date: "2016-02-09",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "5.7.0",
      date: "2016-02-23",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "5.8.0",
      date: "2016-03-09",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "5.9.0",
      date: "2016-03-16",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "5.10.0",
      date: "2016-04-01",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "5.11.0",
      date: "2016-04-21",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "5.12.0",
      date: "2016-06-23",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "6.0.0",
      date: "2016-04-26",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "6.1.0",
      date: "2016-05-05",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "6.2.0",
      date: "2016-05-17",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "6.3.0",
      date: "2016-07-06",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "6.4.0",
      date: "2016-08-12",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "6.5.0",
      date: "2016-08-26",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "6.6.0",
      date: "2016-09-14",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "6.7.0",
      date: "2016-09-27",
      lts: false,
      security: true
    },
    {
      name: "nodejs",
      version: "6.8.0",
      date: "2016-10-12",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "6.9.0",
      date: "2016-10-18",
      lts: "Boron",
      security: false
    },
    {
      name: "nodejs",
      version: "6.10.0",
      date: "2017-02-21",
      lts: "Boron",
      security: false
    },
    {
      name: "nodejs",
      version: "6.11.0",
      date: "2017-06-06",
      lts: "Boron",
      security: false
    },
    {
      name: "nodejs",
      version: "6.12.0",
      date: "2017-11-06",
      lts: "Boron",
      security: false
    },
    {
      name: "nodejs",
      version: "6.13.0",
      date: "2018-02-10",
      lts: "Boron",
      security: false
    },
    {
      name: "nodejs",
      version: "6.14.0",
      date: "2018-03-28",
      lts: "Boron",
      security: true
    },
    {
      name: "nodejs",
      version: "6.15.0",
      date: "2018-11-27",
      lts: "Boron",
      security: true
    },
    {
      name: "nodejs",
      version: "6.16.0",
      date: "2018-12-26",
      lts: "Boron",
      security: false
    },
    {
      name: "nodejs",
      version: "6.17.0",
      date: "2019-02-28",
      lts: "Boron",
      security: true
    },
    {
      name: "nodejs",
      version: "7.0.0",
      date: "2016-10-25",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "7.1.0",
      date: "2016-11-08",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "7.2.0",
      date: "2016-11-22",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "7.3.0",
      date: "2016-12-20",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "7.4.0",
      date: "2017-01-04",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "7.5.0",
      date: "2017-01-31",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "7.6.0",
      date: "2017-02-21",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "7.7.0",
      date: "2017-02-28",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "7.8.0",
      date: "2017-03-29",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "7.9.0",
      date: "2017-04-11",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "7.10.0",
      date: "2017-05-02",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "8.0.0",
      date: "2017-05-30",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "8.1.0",
      date: "2017-06-08",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "8.2.0",
      date: "2017-07-19",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "8.3.0",
      date: "2017-08-08",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "8.4.0",
      date: "2017-08-15",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "8.5.0",
      date: "2017-09-12",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "8.6.0",
      date: "2017-09-26",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "8.7.0",
      date: "2017-10-11",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "8.8.0",
      date: "2017-10-24",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "8.9.0",
      date: "2017-10-31",
      lts: "Carbon",
      security: false
    },
    {
      name: "nodejs",
      version: "8.10.0",
      date: "2018-03-06",
      lts: "Carbon",
      security: false
    },
    {
      name: "nodejs",
      version: "8.11.0",
      date: "2018-03-28",
      lts: "Carbon",
      security: true
    },
    {
      name: "nodejs",
      version: "8.12.0",
      date: "2018-09-10",
      lts: "Carbon",
      security: false
    },
    {
      name: "nodejs",
      version: "8.13.0",
      date: "2018-11-20",
      lts: "Carbon",
      security: false
    },
    {
      name: "nodejs",
      version: "8.14.0",
      date: "2018-11-27",
      lts: "Carbon",
      security: true
    },
    {
      name: "nodejs",
      version: "8.15.0",
      date: "2018-12-26",
      lts: "Carbon",
      security: false
    },
    {
      name: "nodejs",
      version: "8.16.0",
      date: "2019-04-16",
      lts: "Carbon",
      security: false
    },
    {
      name: "nodejs",
      version: "8.17.0",
      date: "2019-12-17",
      lts: "Carbon",
      security: true
    },
    {
      name: "nodejs",
      version: "9.0.0",
      date: "2017-10-31",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "9.1.0",
      date: "2017-11-07",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "9.2.0",
      date: "2017-11-14",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "9.3.0",
      date: "2017-12-12",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "9.4.0",
      date: "2018-01-10",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "9.5.0",
      date: "2018-01-31",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "9.6.0",
      date: "2018-02-21",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "9.7.0",
      date: "2018-03-01",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "9.8.0",
      date: "2018-03-07",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "9.9.0",
      date: "2018-03-21",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "9.10.0",
      date: "2018-03-28",
      lts: false,
      security: true
    },
    {
      name: "nodejs",
      version: "9.11.0",
      date: "2018-04-04",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.0.0",
      date: "2018-04-24",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.1.0",
      date: "2018-05-08",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.2.0",
      date: "2018-05-23",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.3.0",
      date: "2018-05-29",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.4.0",
      date: "2018-06-06",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.5.0",
      date: "2018-06-20",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.6.0",
      date: "2018-07-04",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.7.0",
      date: "2018-07-18",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.8.0",
      date: "2018-08-01",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.9.0",
      date: "2018-08-15",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.10.0",
      date: "2018-09-06",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.11.0",
      date: "2018-09-19",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.12.0",
      date: "2018-10-10",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "10.13.0",
      date: "2018-10-30",
      lts: "Dubnium",
      security: false
    },
    {
      name: "nodejs",
      version: "10.14.0",
      date: "2018-11-27",
      lts: "Dubnium",
      security: true
    },
    {
      name: "nodejs",
      version: "10.15.0",
      date: "2018-12-26",
      lts: "Dubnium",
      security: false
    },
    {
      name: "nodejs",
      version: "10.16.0",
      date: "2019-05-28",
      lts: "Dubnium",
      security: false
    },
    {
      name: "nodejs",
      version: "10.17.0",
      date: "2019-10-21",
      lts: "Dubnium",
      security: false
    },
    {
      name: "nodejs",
      version: "10.18.0",
      date: "2019-12-16",
      lts: "Dubnium",
      security: true
    },
    {
      name: "nodejs",
      version: "10.19.0",
      date: "2020-02-05",
      lts: "Dubnium",
      security: true
    },
    {
      name: "nodejs",
      version: "11.0.0",
      date: "2018-10-23",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.1.0",
      date: "2018-10-30",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.2.0",
      date: "2018-11-15",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.3.0",
      date: "2018-11-27",
      lts: false,
      security: true
    },
    {
      name: "nodejs",
      version: "11.4.0",
      date: "2018-12-07",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.5.0",
      date: "2018-12-18",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.6.0",
      date: "2018-12-26",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.7.0",
      date: "2019-01-17",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.8.0",
      date: "2019-01-24",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.9.0",
      date: "2019-01-30",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.10.0",
      date: "2019-02-14",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.11.0",
      date: "2019-03-05",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.12.0",
      date: "2019-03-14",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.13.0",
      date: "2019-03-28",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.14.0",
      date: "2019-04-10",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "11.15.0",
      date: "2019-04-30",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.0.0",
      date: "2019-04-23",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.1.0",
      date: "2019-04-29",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.2.0",
      date: "2019-05-07",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.3.0",
      date: "2019-05-21",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.4.0",
      date: "2019-06-04",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.5.0",
      date: "2019-06-26",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.6.0",
      date: "2019-07-03",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.7.0",
      date: "2019-07-23",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.8.0",
      date: "2019-08-06",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.9.0",
      date: "2019-08-20",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.10.0",
      date: "2019-09-04",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.11.0",
      date: "2019-09-25",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.12.0",
      date: "2019-10-11",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "12.13.0",
      date: "2019-10-21",
      lts: "Erbium",
      security: false
    },
    {
      name: "nodejs",
      version: "12.14.0",
      date: "2019-12-16",
      lts: "Erbium",
      security: true
    },
    {
      name: "nodejs",
      version: "12.15.0",
      date: "2020-02-05",
      lts: "Erbium",
      security: true
    },
    {
      name: "nodejs",
      version: "12.16.0",
      date: "2020-02-11",
      lts: "Erbium",
      security: false
    },
    {
      name: "nodejs",
      version: "13.0.0",
      date: "2019-10-10",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "13.1.0",
      date: "2019-11-05",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "13.2.0",
      date: "2019-11-21",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "13.3.0",
      date: "2019-12-03",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "13.4.0",
      date: "2019-12-17",
      lts: false,
      security: true
    },
    {
      name: "nodejs",
      version: "13.5.0",
      date: "2019-12-18",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "13.6.0",
      date: "2020-01-07",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "13.7.0",
      date: "2020-01-21",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "13.8.0",
      date: "2020-02-05",
      lts: false,
      security: true
    },
    {
      name: "nodejs",
      version: "13.9.0",
      date: "2020-02-18",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "13.10.0",
      date: "2020-03-03",
      lts: false,
      security: false
    },
    {
      name: "nodejs",
      version: "13.11.0",
      date: "2020-03-12",
      lts: false,
      security: false
    }
  ];

  var envs$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': envs
  });

  var browsers = {
    A: "ie",
    B: "edge",
    C: "firefox",
    D: "chrome",
    E: "safari",
    F: "opera",
    G: "ios_saf",
    H: "op_mini",
    I: "android",
    J: "bb",
    K: "op_mob",
    L: "and_chr",
    M: "and_ff",
    N: "ie_mob",
    O: "and_uc",
    P: "samsung",
    Q: "and_qq",
    R: "baidu",
    S: "kaios"
  };

  var browsers_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var browsers$1 = exports.browsers = browsers;
  });

  unwrapExports(browsers_1);
  var browsers_2 = browsers_1.browsers;

  var browserVersions = {
    "0": "56",
    "1": "57",
    "2": "58",
    "3": "60",
    "4": "62",
    "5": "63",
    "6": "64",
    "7": "65",
    "8": "66",
    "9": "14",
    A: "10",
    B: "11",
    C: "12",
    D: "9",
    E: "7",
    F: "4",
    G: "8",
    H: "6",
    I: "15",
    J: "16",
    K: "17",
    L: "18",
    M: "80",
    N: "13",
    O: "46",
    P: "11.1",
    Q: "44",
    R: "20",
    S: "22",
    T: "23",
    U: "24",
    V: "25",
    W: "26",
    X: "27",
    Y: "28",
    Z: "29",
    a: "30",
    b: "31",
    c: "32",
    d: "33",
    e: "34",
    f: "35",
    g: "19",
    h: "37",
    i: "38",
    j: "39",
    k: "40",
    l: "41",
    m: "42",
    n: "43",
    o: "21",
    p: "45",
    q: "5",
    r: "47",
    s: "48",
    t: "49",
    u: "50",
    v: "51",
    w: "52",
    x: "53",
    y: "54",
    z: "55",
    AB: "68",
    BB: "12.1",
    CB: "36",
    DB: "67",
    EB: "79",
    FB: "59",
    GB: "4.2-4.3",
    HB: "61",
    IB: "69",
    JB: "70",
    KB: "71",
    LB: "72",
    MB: "73",
    NB: "74",
    OB: "75",
    PB: "76",
    QB: "11.5",
    RB: "3",
    SB: "10.1",
    TB: "3.2",
    UB: "9.3",
    VB: "81",
    WB: "83",
    XB: "3.1",
    YB: "78",
    ZB: "5.1",
    aB: "6.1",
    bB: "7.1",
    cB: "9.1",
    dB: "77",
    eB: "3.6",
    fB: "3.5",
    gB: "13.1",
    hB: "TP",
    iB: "9.5-9.6",
    jB: "10.0-10.1",
    kB: "10.5",
    lB: "10.6",
    mB: "2",
    nB: "11.6",
    oB: "4.0-4.1",
    pB: "5.5",
    qB: "5.0-5.1",
    rB: "6.0-6.1",
    sB: "7.0-7.1",
    tB: "8.1-8.4",
    uB: "9.0-9.2",
    vB: "82",
    wB: "10.0-10.2",
    xB: "10.3",
    yB: "11.0-11.2",
    zB: "11.3-11.4",
    "0B": "12.0-12.1",
    "1B": "12.2-12.4",
    "2B": "13.0-13.1",
    "3B": "13.2",
    "4B": "13.3",
    "5B": "13.4",
    "6B": "all",
    "7B": "2.1",
    "8B": "2.2",
    "9B": "2.3",
    AC: "4.1",
    BC: "4.4",
    CC: "4.4.3-4.4.4",
    DC: "12.12",
    EC: "5.0-5.4",
    FC: "6.2-6.4",
    GC: "7.2-7.4",
    HC: "8.2",
    IC: "9.2",
    JC: "1.2",
    KC: "7.12",
    LC: "2.5"
  };

  var browserVersions_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var browserVersions$1 = exports.browserVersions = browserVersions;
  });

  unwrapExports(browserVersions_1);
  var browserVersions_2 = browserVersions_1.browserVersions;

  var agents = {
    A: {
      A: {
        H: 0.00478465,
        E: 0.00478465,
        G: 0.100478,
        D: 0.157894,
        A: 0.0382772,
        B: 1.39233,
        pB: 0.009298
      },
      B: "ms",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "pB", "H", "E", "G", "D", "A", "B", "", "", ""],
      E: "IE",
      F: {
        pB: 962323200,
        H: 998870400,
        E: 1161129600,
        G: 1237420800,
        D: 1300060800,
        A: 1346716800,
        B: 1381968000
      }
    },
    B: {
      A: {
        "9": 0.013698,
        C: 0.009132,
        N: 0.009132,
        I: 0.013698,
        J: 0.036528,
        K: 0.123282,
        L: 1.93142,
        EB: 0,
        M: 0
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "N", "9", "I", "J", "K", "L", "EB", "M", "", "", ""],
      E: "Edge",
      F: {
        "9": 1470096000,
        C: 1438128000,
        N: 1447286400,
        I: 1491868800,
        J: 1508198400,
        K: 1525046400,
        L: 1542067200,
        EB: 1579046400,
        M: 1581033600
      },
      D: {
        "9": "ms",
        C: "ms",
        N: "ms",
        I: "ms",
        J: "ms",
        K: "ms",
        L: "ms"
      }
    },
    C: {
      A: {
        "0": 0.027396,
        "1": 0.009132,
        "2": 0.009132,
        "3": 0.031962,
        "4": 0.009132,
        "5": 0.018264,
        "6": 0.018264,
        "7": 0.050226,
        "8": 0.04566,
        "9": 0.00453,
        mB: 0.004827,
        RB: 0.00487,
        F: 0.00974,
        q: 0.004879,
        H: 0.020136,
        E: 0.005725,
        G: 0.004525,
        D: 0.00533,
        A: 0.004283,
        B: 0.009042,
        C: 0.004471,
        N: 0.004486,
        I: 0.004465,
        J: 0.004417,
        K: 0.008922,
        L: 0.004393,
        g: 0.004443,
        R: 0.004283,
        o: 0.013596,
        S: 0.013698,
        T: 0.004525,
        U: 0.008786,
        V: 0.004403,
        W: 0.004317,
        X: 0.004393,
        Y: 0.004418,
        Z: 0.008834,
        a: 0.004403,
        b: 0.008928,
        c: 0.004471,
        d: 0.013698,
        e: 0.004707,
        f: 0.009132,
        CB: 0.004465,
        h: 0.004783,
        i: 0.02283,
        j: 0.004783,
        k: 0.00487,
        l: 0.005029,
        m: 0.0047,
        n: 0.009132,
        Q: 0.009132,
        p: 0.009132,
        O: 0.004525,
        r: 0.018264,
        s: 0.031962,
        t: 0.009132,
        u: 0.009132,
        v: 0.009132,
        w: 0.13698,
        x: 0.02283,
        y: 0.013698,
        z: 0.009132,
        FB: 0.009132,
        HB: 0.009132,
        DB: 0.018264,
        AB: 0.150678,
        IB: 0.027396,
        JB: 0.036528,
        KB: 0.054792,
        LB: 2.05013,
        MB: 1.29218,
        NB: 0.041094,
        OB: 0,
        PB: 0,
        fB: 0.008786,
        eB: 0.00487
      },
      B: "moz",
      C: ["", "", "mB", "RB", "fB", "eB", "F", "q", "H", "E", "G", "D", "A", "B", "C", "N", "9", "I", "J", "K", "L", "g", "R", "o", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "CB", "h", "i", "j", "k", "l", "m", "n", "Q", "p", "O", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "FB", "3", "HB", "4", "5", "6", "7", "8", "DB", "AB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", ""],
      E: "Firefox",
      F: {
        "0": 1506556800,
        "1": 1510617600,
        "2": 1516665600,
        "3": 1525824000,
        "4": 1536105600,
        "5": 1540252800,
        "6": 1544486400,
        "7": 1548720000,
        "8": 1552953600,
        "9": 1338854400,
        mB: 1161648000,
        RB: 1213660800,
        fB: 1246320000,
        eB: 1264032000,
        F: 1300752000,
        q: 1308614400,
        H: 1313452800,
        E: 1317081600,
        G: 1317081600,
        D: 1320710400,
        A: 1324339200,
        B: 1327968000,
        C: 1331596800,
        N: 1335225600,
        I: 1342483200,
        J: 1346112000,
        K: 1349740800,
        L: 1353628800,
        g: 1357603200,
        R: 1361232000,
        o: 1364860800,
        S: 1368489600,
        T: 1372118400,
        U: 1375747200,
        V: 1379376000,
        W: 1386633600,
        X: 1391472000,
        Y: 1395100800,
        Z: 1398729600,
        a: 1402358400,
        b: 1405987200,
        c: 1409616000,
        d: 1413244800,
        e: 1417392000,
        f: 1421107200,
        CB: 1424736000,
        h: 1428278400,
        i: 1431475200,
        j: 1435881600,
        k: 1439251200,
        l: 1442880000,
        m: 1446508800,
        n: 1450137600,
        Q: 1453852800,
        p: 1457395200,
        O: 1461628800,
        r: 1465257600,
        s: 1470096000,
        t: 1474329600,
        u: 1479168000,
        v: 1485216000,
        w: 1488844800,
        x: 1492560000,
        y: 1497312000,
        z: 1502150400,
        FB: 1520985600,
        HB: 1529971200,
        DB: 1558396800,
        AB: 1562630400,
        IB: 1567468800,
        JB: 1571788800,
        KB: 1575331200,
        LB: 1578355200,
        MB: 1581379200,
        NB: 1583798400,
        OB: null,
        PB: null
      }
    },
    D: {
      A: {
        "0": 0.031962,
        "1": 0.054792,
        "2": 0.027396,
        "3": 0.027396,
        "4": 0.02283,
        "5": 0.27396,
        "6": 0.018264,
        "7": 0.050226,
        "8": 0.031962,
        "9": 0.004706,
        F: 0.004706,
        q: 0.004879,
        H: 0.004879,
        E: 0.005591,
        G: 0.005591,
        D: 0.005591,
        A: 0.004534,
        B: 0.004464,
        C: 0.010424,
        N: 0.004566,
        I: 0.015087,
        J: 0.004393,
        K: 0.004393,
        L: 0.008652,
        g: 0.004418,
        R: 0.004393,
        o: 0.004317,
        S: 0.004566,
        T: 0.008786,
        U: 0.004566,
        V: 0.004461,
        W: 0.004566,
        X: 0.004326,
        Y: 0.0047,
        Z: 0.004461,
        a: 0.004403,
        b: 0.013698,
        c: 0.004566,
        d: 0.013698,
        e: 0.009132,
        f: 0.004566,
        CB: 0.004566,
        h: 0.004464,
        i: 0.02283,
        j: 0.004464,
        k: 0.013698,
        l: 0.004566,
        m: 0.004403,
        n: 0.018264,
        Q: 0.004465,
        p: 0.009132,
        O: 0.004566,
        r: 0.009132,
        s: 0.036528,
        t: 0.474864,
        u: 0.009132,
        v: 0.013698,
        w: 0.004403,
        x: 0.027396,
        y: 0.013698,
        z: 0.031962,
        FB: 0.018264,
        HB: 0.031962,
        DB: 0.059358,
        AB: 0.031962,
        IB: 0.15981,
        JB: 0.095886,
        KB: 0.123282,
        LB: 0.150678,
        MB: 0.13698,
        NB: 0.18264,
        OB: 0.200904,
        PB: 0.196338,
        dB: 0.219168,
        YB: 0.429204,
        EB: 16.8622,
        M: 10.657,
        VB: 0.036528,
        vB: 0.018264,
        WB: 0
      },
      B: "webkit",
      C: ["F", "q", "H", "E", "G", "D", "A", "B", "C", "N", "9", "I", "J", "K", "L", "g", "R", "o", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "CB", "h", "i", "j", "k", "l", "m", "n", "Q", "p", "O", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "FB", "3", "HB", "4", "5", "6", "7", "8", "DB", "AB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "dB", "YB", "EB", "M", "VB", "vB", "WB"],
      E: "Chrome",
      F: {
        "0": 1485302400,
        "1": 1489017600,
        "2": 1492560000,
        "3": 1500940800,
        "4": 1508198400,
        "5": 1512518400,
        "6": 1516752000,
        "7": 1520294400,
        "8": 1523923200,
        "9": 1316131200,
        F: 1264377600,
        q: 1274745600,
        H: 1283385600,
        E: 1287619200,
        G: 1291248000,
        D: 1296777600,
        A: 1299542400,
        B: 1303862400,
        C: 1307404800,
        N: 1312243200,
        I: 1316131200,
        J: 1319500800,
        K: 1323734400,
        L: 1328659200,
        g: 1332892800,
        R: 1337040000,
        o: 1340668800,
        S: 1343692800,
        T: 1348531200,
        U: 1352246400,
        V: 1357862400,
        W: 1361404800,
        X: 1364428800,
        Y: 1369094400,
        Z: 1374105600,
        a: 1376956800,
        b: 1384214400,
        c: 1389657600,
        d: 1392940800,
        e: 1397001600,
        f: 1400544000,
        CB: 1405468800,
        h: 1409011200,
        i: 1412640000,
        j: 1416268800,
        k: 1421798400,
        l: 1425513600,
        m: 1429401600,
        n: 1432080000,
        Q: 1437523200,
        p: 1441152000,
        O: 1444780800,
        r: 1449014400,
        s: 1453248000,
        t: 1456963200,
        u: 1460592000,
        v: 1464134400,
        w: 1469059200,
        x: 1472601600,
        y: 1476230400,
        z: 1480550400,
        FB: 1496707200,
        HB: 1504569600,
        DB: 1527552000,
        AB: 1532390400,
        IB: 1536019200,
        JB: 1539648000,
        KB: 1543968000,
        LB: 1548720000,
        MB: 1552348800,
        NB: 1555977600,
        OB: 1559606400,
        PB: 1564444800,
        dB: 1568073600,
        YB: 1571702400,
        EB: 1575936000,
        M: 1580860800,
        VB: null,
        vB: null,
        WB: null
      }
    },
    E: {
      A: {
        F: 0,
        q: 0.004566,
        H: 0.009132,
        E: 0.004465,
        G: 0.02283,
        D: 0.013698,
        A: 0.013698,
        B: 0.031962,
        C: 0.11415,
        N: 2.84918,
        XB: 0,
        TB: 0.008692,
        ZB: 0.09132,
        aB: 0.00456,
        bB: 0.004283,
        cB: 0.04566,
        SB: 0.09132,
        P: 0.18264,
        BB: 0.38811,
        gB: 0,
        hB: 0
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "XB", "TB", "F", "q", "ZB", "H", "aB", "E", "bB", "G", "D", "cB", "A", "SB", "B", "P", "C", "BB", "N", "gB", "hB", ""],
      E: "Safari",
      F: {
        XB: 1205798400,
        TB: 1226534400,
        F: 1244419200,
        q: 1275868800,
        ZB: 1311120000,
        H: 1343174400,
        aB: 1382400000,
        E: 1382400000,
        bB: 1410998400,
        G: 1413417600,
        D: 1443657600,
        cB: 1458518400,
        A: 1474329600,
        SB: 1490572800,
        B: 1505779200,
        P: 1522281600,
        C: 1537142400,
        BB: 1553472000,
        N: 1568851200,
        gB: null,
        hB: null
      }
    },
    F: {
      A: {
        "0": 0.004566,
        "1": 0.004532,
        "2": 0.004566,
        "3": 0.004403,
        "4": 0.004532,
        "5": 0.004566,
        "6": 0.02283,
        "7": 0.02283,
        "8": 0.894936,
        D: 0.0082,
        B: 0.016581,
        C: 0.004317,
        I: 0.00685,
        J: 0.00685,
        K: 0.00685,
        L: 0.005014,
        g: 0.006015,
        R: 0.004879,
        o: 0.006597,
        S: 0.006597,
        T: 0.013434,
        U: 0.006702,
        V: 0.006015,
        W: 0.005595,
        X: 0.004393,
        Y: 0.008652,
        Z: 0.004879,
        a: 0.004879,
        b: 0.009132,
        c: 0.005152,
        d: 0.005014,
        e: 0.009758,
        f: 0.004879,
        CB: 0.009132,
        h: 0.004283,
        i: 0.004367,
        j: 0.004534,
        k: 0.004367,
        l: 0.004227,
        m: 0.004418,
        n: 0.009042,
        Q: 0.004227,
        p: 0.004725,
        O: 0.004417,
        r: 0.008942,
        s: 0.004707,
        t: 0.004827,
        u: 0.004707,
        v: 0.004707,
        w: 0.004326,
        x: 0.008922,
        y: 0.014349,
        z: 0.004725,
        iB: 0.00685,
        jB: 0,
        kB: 0.008392,
        lB: 0.004706,
        P: 0.006229,
        QB: 0.004879,
        nB: 0.008786,
        BB: 0.009132
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "iB", "jB", "kB", "lB", "B", "P", "QB", "nB", "C", "BB", "I", "J", "K", "L", "g", "R", "o", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "CB", "h", "i", "j", "k", "l", "m", "n", "Q", "p", "O", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "", "", ""],
      E: "Opera",
      F: {
        "0": 1537833600,
        "1": 1543363200,
        "2": 1548201600,
        "3": 1554768000,
        "4": 1561593600,
        "5": 1566259200,
        "6": 1570406400,
        "7": 1573689600,
        "8": 1578441600,
        D: 1150761600,
        iB: 1223424000,
        jB: 1251763200,
        kB: 1267488000,
        lB: 1277942400,
        B: 1292457600,
        P: 1302566400,
        QB: 1309219200,
        nB: 1323129600,
        C: 1323129600,
        BB: 1352073600,
        I: 1372723200,
        J: 1377561600,
        K: 1381104000,
        L: 1386288000,
        g: 1390867200,
        R: 1393891200,
        o: 1399334400,
        S: 1401753600,
        T: 1405987200,
        U: 1409616000,
        V: 1413331200,
        W: 1417132800,
        X: 1422316800,
        Y: 1425945600,
        Z: 1430179200,
        a: 1433808000,
        b: 1438646400,
        c: 1442448000,
        d: 1445904000,
        e: 1449100800,
        f: 1454371200,
        CB: 1457308800,
        h: 1462320000,
        i: 1465344000,
        j: 1470096000,
        k: 1474329600,
        l: 1477267200,
        m: 1481587200,
        n: 1486425600,
        Q: 1490054400,
        p: 1494374400,
        O: 1498003200,
        r: 1502236800,
        s: 1506470400,
        t: 1510099200,
        u: 1515024000,
        v: 1517961600,
        w: 1521676800,
        x: 1525910400,
        y: 1530144000,
        z: 1534982400
      },
      D: {
        D: "o",
        B: "o",
        C: "o",
        iB: "o",
        jB: "o",
        kB: "o",
        lB: "o",
        P: "o",
        QB: "o",
        nB: "o",
        BB: "o"
      }
    },
    G: {
      A: {
        G: 0,
        TB: 0.0012907,
        oB: 0.0012907,
        GB: 0.0012907,
        qB: 0.00903488,
        rB: 0.00645349,
        sB: 0.0141977,
        tB: 0.0245233,
        uB: 0.0154884,
        UB: 0.165209,
        wB: 0.0503372,
        xB: 0.170372,
        yB: 0.13036,
        zB: 0.219419,
        "0B": 0.317512,
        "1B": 1.65596,
        "2B": 0.555,
        "3B": 0.247814,
        "4B": 9.29302,
        "5B": 0
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "TB", "oB", "GB", "qB", "rB", "sB", "G", "tB", "uB", "UB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "", ""],
      E: "iOS Safari",
      F: {
        TB: 1270252800,
        oB: 1283904000,
        GB: 1299628800,
        qB: 1331078400,
        rB: 1359331200,
        sB: 1394409600,
        G: 1410912000,
        tB: 1413763200,
        uB: 1442361600,
        UB: 1458518400,
        wB: 1473724800,
        xB: 1490572800,
        yB: 1505779200,
        zB: 1522281600,
        "0B": 1537142400,
        "1B": 1553472000,
        "2B": 1568851200,
        "3B": 1572220800,
        "4B": 1580169600,
        "5B": null
      }
    },
    H: {
      A: {
        "6B": 0.895153
      },
      B: "o",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "6B", "", "", ""],
      E: "Opera Mini",
      F: {
        "6B": 1426464000
      }
    },
    I: {
      A: {
        RB: 0.00039504,
        F: 0.0039504,
        M: 0,
        "7B": 0,
        "8B": 0.000790081,
        "9B": 0.00039504,
        AC: 0.00592561,
        GB: 0.129968,
        BC: 0,
        CC: 0.103106
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "7B", "8B", "9B", "RB", "F", "AC", "GB", "BC", "CC", "M", "", "", ""],
      E: "Android Browser",
      F: {
        "7B": 1256515200,
        "8B": 1274313600,
        "9B": 1291593600,
        RB: 1298332800,
        F: 1318896000,
        AC: 1341792000,
        GB: 1374624000,
        BC: 1386547200,
        CC: 1401667200,
        M: 1581984000
      }
    },
    J: {
      A: {
        E: 0,
        A: 0.010868
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "E", "A", "", "", ""],
      E: "Blackberry Browser",
      F: {
        E: 1325376000,
        A: 1359504000
      }
    },
    K: {
      A: {
        A: 0,
        B: 0,
        C: 0,
        O: 0.0111391,
        P: 0,
        QB: 0,
        BB: 0
      },
      B: "o",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "P", "QB", "C", "BB", "O", "", "", ""],
      E: "Opera Mobile",
      F: {
        A: 1287100800,
        B: 1300752000,
        P: 1314835200,
        QB: 1318291200,
        C: 1330300800,
        BB: 1349740800,
        O: 1474588800
      },
      D: {
        O: "webkit"
      }
    },
    L: {
      A: {
        M: 34.2581
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "M", "", "", ""],
      E: "Chrome for Android",
      F: {
        M: null
      }
    },
    M: {
      A: {
        AB: 0.222794
      },
      B: "moz",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AB", "", "", ""],
      E: "Firefox for Android",
      F: {
        AB: 1567468800
      }
    },
    N: {
      A: {
        A: 0.0115934,
        B: 0.043472
      },
      B: "ms",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""],
      E: "IE Mobile",
      F: {
        A: 1340150400,
        B: 1353456000
      }
    },
    O: {
      A: {
        DC: 2.20077
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "DC", "", "", ""],
      E: "UC Browser for Android",
      F: {
        DC: 1471392000
      },
      D: {
        DC: "webkit"
      }
    },
    P: {
      A: {
        F: 0.287499,
        EC: 0.0205357,
        FC: 0.0205357,
        GC: 0.112946,
        HC: 0.0308035,
        IC: 0.23616,
        SB: 2.42321,
        P: 0.308035
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "EC", "FC", "GC", "HC", "IC", "SB", "P", "", "", ""],
      E: "Samsung Internet",
      F: {
        F: 1461024000,
        EC: 1481846400,
        FC: 1509408000,
        GC: 1528329600,
        HC: 1546128000,
        IC: 1554163200,
        SB: 1567900800,
        P: 1582588800
      }
    },
    Q: {
      A: {
        JC: 0.24453
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "JC", "", "", ""],
      E: "QQ Browser",
      F: {
        JC: 1483228800
      }
    },
    R: {
      A: {
        KC: 0
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "KC", "", "", ""],
      E: "Baidu Browser",
      F: {
        KC: 1491004800
      }
    },
    S: {
      A: {
        LC: 0.10868
      },
      B: "moz",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "LC", "", "", ""],
      E: "KaiOS Browser",
      F: {
        LC: 1527811200
      }
    }
  };

  var agents_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.agents = undefined;







  function unpackBrowserVersions(versionsData) {
    return Object.keys(versionsData).reduce(function (usage, version) {
      usage[browserVersions_1.browserVersions[version]] = versionsData[version];
      return usage;
    }, {});
  }

  var agents$1 = exports.agents = Object.keys(agents).reduce(function (map, key) {
    var versionsData = agents[key];
    map[browsers_1.browsers[key]] = Object.keys(versionsData).reduce(function (data, entry) {
      if (entry === 'A') {
        data.usage_global = unpackBrowserVersions(versionsData[entry]);
      } else if (entry === 'C') {
        data.versions = versionsData[entry].reduce(function (list, version) {
          if (version === '') {
            list.push(null);
          } else {
            list.push(browserVersions_1.browserVersions[version]);
          }

          return list;
        }, []);
      } else if (entry === 'D') {
        data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]);
      } else if (entry === 'E') {
        data.browser = versionsData[entry];
      } else if (entry === 'F') {
        data.release_date = Object.keys(versionsData[entry]).reduce(function (map, key) {
          map[browserVersions_1.browserVersions[key]] = versionsData[entry][key];
          return map;
        }, {});
      } else {
        data.prefix = versionsData[entry];
      }

      return data;
    }, {});
    return map;
  }, {});
  });

  unwrapExports(agents_1);
  var agents_2 = agents_1.agents;

  var v4 = {
    start: "2015-09-08",
    lts: "2015-10-12",
    maintenance: "2017-04-01",
    end: "2018-04-30",
    codename: "Argon"
  };
  var v5 = {
    start: "2015-10-29",
    maintenance: "2016-04-30",
    end: "2016-06-30"
  };
  var v6 = {
    start: "2016-04-26",
    lts: "2016-10-18",
    maintenance: "2018-04-30",
    end: "2019-04-30",
    codename: "Boron"
  };
  var v7 = {
    start: "2016-10-25",
    maintenance: "2017-04-30",
    end: "2017-06-30"
  };
  var v8$1 = {
    start: "2017-05-30",
    lts: "2017-10-31",
    maintenance: "2019-01-01",
    end: "2019-12-31",
    codename: "Carbon"
  };
  var v9 = {
    start: "2017-10-01",
    maintenance: "2018-04-01",
    end: "2018-06-30"
  };
  var v10 = {
    start: "2018-04-24",
    lts: "2018-10-30",
    maintenance: "2020-04-30",
    end: "2021-04-30",
    codename: "Dubnium"
  };
  var v11 = {
    start: "2018-10-23",
    maintenance: "2019-04-22",
    end: "2019-06-01"
  };
  var v12 = {
    start: "2019-04-23",
    lts: "2019-10-21",
    maintenance: "2020-10-20",
    end: "2022-04-30",
    codename: "Erbium"
  };
  var v13 = {
    start: "2019-10-22",
    maintenance: "2020-04-01",
    end: "2020-06-01"
  };
  var v14 = {
    start: "2020-04-21",
    lts: "2020-10-20",
    maintenance: "2021-10-19",
    end: "2023-04-30",
    codename: ""
  };
  var releaseSchedule = {
    "v0.10": {
    start: "2013-03-11",
    end: "2016-10-31"
  },
    "v0.12": {
    start: "2015-02-06",
    end: "2016-12-31"
  },
    v4: v4,
    v5: v5,
    v6: v6,
    v7: v7,
    v8: v8$1,
    v9: v9,
    v10: v10,
    v11: v11,
    v12: v12,
    v13: v13,
    v14: v14
  };

  var releaseSchedule$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    v4: v4,
    v5: v5,
    v6: v6,
    v7: v7,
    v8: v8$1,
    v9: v9,
    v10: v10,
    v11: v11,
    v12: v12,
    v13: v13,
    v14: v14,
    'default': releaseSchedule
  });

  var versions$1 = {
    "9.0": "82",
    "8.1": "80",
    "8.0": "79",
    "7.2": "78",
    "7.1": "78",
    "7.0": "78",
    "6.1": "76",
    "6.0": "76",
    "5.0": "72",
    "4.2": "69",
    "4.1": "69",
    "4.0": "69",
    "3.1": "66",
    "3.0": "66",
    "2.1": "61",
    "2.0": "61",
    "1.8": "59",
    "1.7": "58",
    "1.6": "56",
    "1.5": "54",
    "1.4": "53",
    "1.3": "52",
    "1.2": "51",
    "1.1": "50",
    "1.0": "49",
    "0.37": "49",
    "0.36": "47",
    "0.35": "45",
    "0.34": "45",
    "0.33": "45",
    "0.32": "45",
    "0.31": "44",
    "0.30": "44",
    "0.29": "43",
    "0.28": "43",
    "0.27": "42",
    "0.26": "42",
    "0.25": "42",
    "0.24": "41",
    "0.23": "41",
    "0.22": "41",
    "0.21": "40",
    "0.20": "39"
  };

  function BrowserslistError(message) {
    this.name = 'BrowserslistError';
    this.message = message;
    this.browserslist = true;

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, BrowserslistError);
    }
  }

  BrowserslistError.prototype = Error.prototype;
  var error = BrowserslistError;

  function noop$2() {}

  var browser$6 = {
    loadQueries: function loadQueries() {
      throw new error('Sharable configs are not supported in client-side build of Browserslist');
    },
    getStat: function getStat(opts) {
      return opts.stats;
    },
    loadConfig: function loadConfig(opts) {
      if (opts.config) {
        throw new error('Browserslist config are not supported in client-side build');
      }
    },
    loadCountry: function loadCountry() {
      throw new error('Country statistics is not supported ' + 'in client-side build of Browserslist');
    },
    currentNode: function currentNode(resolve, context) {
      return resolve(['maintained node versions'], context)[0];
    },
    parseConfig: noop$2,
    readConfig: noop$2,
    findConfig: noop$2,
    clearCaches: noop$2,
    oldDataWarning: noop$2
  };

  var jsReleases = getCjsExportFromNamespace(envs$1);

  var jsEOL = getCjsExportFromNamespace(releaseSchedule$1);

  var agents$1 = agents_1.agents;











  var YEAR = 365.259641 * 24 * 60 * 60 * 1000;
  var ANDROID_EVERGREEN_FIRST = 37;
  var QUERY_OR = 1;
  var QUERY_AND = 2;

  function isVersionsMatch(versionA, versionB) {
    return (versionA + '.').indexOf(versionB + '.') === 0;
  }

  function isEolReleased(name) {
    var version = name.slice(1);
    return jsReleases.some(function (i) {
      return isVersionsMatch(i.version, version);
    });
  }

  function normalize$1(versions) {
    return versions.filter(function (version) {
      return typeof version === 'string';
    });
  }

  function normalizeElectron(version) {
    var versionToUse = version;

    if (version.split('.').length === 3) {
      versionToUse = version.split('.').slice(0, -1).join('.');
    }

    return versionToUse;
  }

  function nameMapper(name) {
    return function mapName(version) {
      return name + ' ' + version;
    };
  }

  function getMajor(version) {
    return parseInt(version.split('.')[0]);
  }

  function getMajorVersions(released, number) {
    if (released.length === 0) return [];
    var majorVersions = uniq$1(released.map(getMajor));
    var minimum = majorVersions[majorVersions.length - number];

    if (!minimum) {
      return released;
    }

    var selected = [];

    for (var i = released.length - 1; i >= 0; i--) {
      if (minimum > getMajor(released[i])) break;
      selected.unshift(released[i]);
    }

    return selected;
  }

  function uniq$1(array) {
    var filtered = [];

    for (var i = 0; i < array.length; i++) {
      if (filtered.indexOf(array[i]) === -1) filtered.push(array[i]);
    }

    return filtered;
  }

  function fillUsage(result, name, data) {
    for (var i in data) {
      result[name + ' ' + i] = data[i];
    }
  }

  function generateFilter(sign, version) {
    version = parseFloat(version);

    if (sign === '>') {
      return function (v) {
        return parseFloat(v) > version;
      };
    } else if (sign === '>=') {
      return function (v) {
        return parseFloat(v) >= version;
      };
    } else if (sign === '<') {
      return function (v) {
        return parseFloat(v) < version;
      };
    } else {
      return function (v) {
        return parseFloat(v) <= version;
      };
    }
  }

  function generateSemverFilter(sign, version) {
    version = version.split('.').map(parseSimpleInt);
    version[1] = version[1] || 0;
    version[2] = version[2] || 0;

    if (sign === '>') {
      return function (v) {
        v = v.split('.').map(parseSimpleInt);
        return compareSemver(v, version) > 0;
      };
    } else if (sign === '>=') {
      return function (v) {
        v = v.split('.').map(parseSimpleInt);
        return compareSemver(v, version) >= 0;
      };
    } else if (sign === '<') {
      return function (v) {
        v = v.split('.').map(parseSimpleInt);
        return compareSemver(version, v) > 0;
      };
    } else {
      return function (v) {
        v = v.split('.').map(parseSimpleInt);
        return compareSemver(version, v) >= 0;
      };
    }
  }

  function parseSimpleInt(x) {
    return parseInt(x);
  }

  function compare$1(a, b) {
    if (a < b) return -1;
    if (a > b) return +1;
    return 0;
  }

  function compareSemver(a, b) {
    return compare$1(parseInt(a[0]), parseInt(b[0])) || compare$1(parseInt(a[1] || '0'), parseInt(b[1] || '0')) || compare$1(parseInt(a[2] || '0'), parseInt(b[2] || '0'));
  }

  function semverFilterLoose(operator, range) {
    range = range.split('.').map(parseSimpleInt);

    if (typeof range[1] === 'undefined') {
      range[1] = 'x';
    }

    switch (operator) {
      case '<=':
        return function (version) {
          version = version.split('.').map(parseSimpleInt);
          return compareSemverLoose(version, range) <= 0;
        };

      default:
      case '>=':
        return function (version) {
          version = version.split('.').map(parseSimpleInt);
          return compareSemverLoose(version, range) >= 0;
        };
    }
  }

  function compareSemverLoose(version, range) {
    if (version[0] !== range[0]) {
      return version[0] < range[0] ? -1 : +1;
    }

    if (range[1] === 'x') {
      return 0;
    }

    if (version[1] !== range[1]) {
      return version[1] < range[1] ? -1 : +1;
    }

    return 0;
  }

  function resolveVersion(data, version) {
    if (data.versions.indexOf(version) !== -1) {
      return version;
    } else if (browserslist.versionAliases[data.name][version]) {
      return browserslist.versionAliases[data.name][version];
    } else {
      return false;
    }
  }

  function normalizeVersion(data, version) {
    var resolved = resolveVersion(data, version);

    if (resolved) {
      return resolved;
    } else if (data.versions.length === 1) {
      return data.versions[0];
    } else {
      return false;
    }
  }

  function filterByYear(since, context) {
    since = since / 1000;
    return Object.keys(agents$1).reduce(function (selected, name) {
      var data = byName(name, context);
      if (!data) return selected;
      var versions = Object.keys(data.releaseDate).filter(function (v) {
        return data.releaseDate[v] >= since;
      });
      return selected.concat(versions.map(nameMapper(data.name)));
    }, []);
  }

  function cloneData(data) {
    return {
      name: data.name,
      versions: data.versions,
      released: data.released,
      releaseDate: data.releaseDate
    };
  }

  function mapVersions(data, map) {
    data.versions = data.versions.map(function (i) {
      return map[i] || i;
    });
    data.released = data.versions.map(function (i) {
      return map[i] || i;
    });
    var fixedDate = {};

    for (var i in data.releaseDate) {
      fixedDate[map[i] || i] = data.releaseDate[i];
    }

    data.releaseDate = fixedDate;
    return data;
  }

  function byName(name, context) {
    name = name.toLowerCase();
    name = browserslist.aliases[name] || name;

    if (context.mobileToDesktop && browserslist.desktopNames[name]) {
      var desktop = browserslist.data[browserslist.desktopNames[name]];

      if (name === 'android') {
        return normalizeAndroidData(cloneData(browserslist.data[name]), desktop);
      } else {
        var cloned = cloneData(desktop);
        cloned.name = name;

        if (name === 'op_mob') {
          cloned = mapVersions(cloned, {
            '10.0-10.1': '10'
          });
        }

        return cloned;
      }
    }

    return browserslist.data[name];
  }

  function normalizeAndroidVersions(androidVersions, chromeVersions) {
    var firstEvergreen = ANDROID_EVERGREEN_FIRST;
    var last = chromeVersions[chromeVersions.length - 1];
    return androidVersions.filter(function (version) {
      return /^(?:[2-4]\.|[34]$)/.test(version);
    }).concat(chromeVersions.slice(firstEvergreen - last - 1));
  }

  function normalizeAndroidData(android, chrome) {
    android.released = normalizeAndroidVersions(android.released, chrome.released);
    android.versions = normalizeAndroidVersions(android.versions, chrome.versions);
    return android;
  }

  function checkName(name, context) {
    var data = byName(name, context);
    if (!data) throw new error('Unknown browser ' + name);
    return data;
  }

  function unknownQuery(query) {
    return new error('Unknown browser query `' + query + '`. ' + 'Maybe you are using old Browserslist or made typo in query.');
  }

  function filterAndroid(list, versions, context) {
    if (context.mobileToDesktop) return list;
    var released = browserslist.data.android.released;
    var last = released[released.length - 1];
    var diff = last - ANDROID_EVERGREEN_FIRST - versions;

    if (diff > 0) {
      return list.slice(-1);
    } else {
      return list.slice(diff - 1);
    }
  }

  function resolve$3(queries, context) {
    if (Array.isArray(queries)) {
      queries = flatten(queries.map(parse$6));
    } else {
      queries = parse$6(queries);
    }

    return queries.reduce(function (result, query, index) {
      var selection = query.queryString;
      var isExclude = selection.indexOf('not ') === 0;

      if (isExclude) {
        if (index === 0) {
          throw new error('Write any browsers query (for instance, `defaults`) ' + 'before `' + selection + '`');
        }

        selection = selection.slice(4);
      }

      for (var i = 0; i < QUERIES.length; i++) {
        var type = QUERIES[i];
        var match = selection.match(type.regexp);

        if (match) {
          var args = [context].concat(match.slice(1));
          var array = type.select.apply(browserslist, args).map(function (j) {
            var parts = j.split(' ');

            if (parts[1] === '0') {
              return parts[0] + ' ' + byName(parts[0], context).versions[0];
            } else {
              return j;
            }
          });

          switch (query.type) {
            case QUERY_AND:
              if (isExclude) {
                return result.filter(function (j) {
                  return array.indexOf(j) === -1;
                });
              } else {
                return result.filter(function (j) {
                  return array.indexOf(j) !== -1;
                });
              }

            case QUERY_OR:
            default:
              if (isExclude) {
                var filter = {};
                array.forEach(function (j) {
                  filter[j] = true;
                });
                return result.filter(function (j) {
                  return !filter[j];
                });
              }

              return result.concat(array);
          }
        }
      }

      throw unknownQuery(selection);
    }, []);
  }

  var cache$1 = {};

  function browserslist(queries, opts) {
    if (typeof opts === 'undefined') opts = {};

    if (typeof opts.path === 'undefined') {
      opts.path = path$2.resolve ? path$2.resolve('.') : '.';
    }

    if (typeof queries === 'undefined' || queries === null) {
      var config = browserslist.loadConfig(opts);

      if (config) {
        queries = config;
      } else {
        queries = browserslist.defaults;
      }
    }

    if (!(typeof queries === 'string' || Array.isArray(queries))) {
      throw new error('Browser queries must be an array or string. Got ' + typeof queries + '.');
    }

    var context = {
      ignoreUnknownVersions: opts.ignoreUnknownVersions,
      dangerousExtend: opts.dangerousExtend,
      mobileToDesktop: opts.mobileToDesktop
    };
    browser$6.oldDataWarning(browserslist.data);
    var stats = browser$6.getStat(opts, browserslist.data);

    if (stats) {
      context.customUsage = {};

      for (var browser in stats) {
        fillUsage(context.customUsage, browser, stats[browser]);
      }
    }

    var cacheKey = JSON.stringify([queries, context]);
    if (cache$1[cacheKey]) return cache$1[cacheKey];
    var result = uniq$1(resolve$3(queries, context)).sort(function (name1, name2) {
      name1 = name1.split(' ');
      name2 = name2.split(' ');

      if (name1[0] === name2[0]) {
        var version1 = name1[1].split('-')[0];
        var version2 = name2[1].split('-')[0];
        return compareSemver(version2.split('.'), version1.split('.'));
      } else {
        return compare$1(name1[0], name2[0]);
      }
    });

    if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
      cache$1[cacheKey] = result;
    }

    return result;
  }

  function parse$6(queries) {
    var qs = [];

    do {
      queries = doMatch(queries, qs);
    } while (queries);

    return qs;
  }

  function doMatch(string, qs) {
    var or = /^(?:,\s*|\s+or\s+)(.*)/i;
    var and = /^\s+and\s+(.*)/i;
    return find$2(string, function (parsed, n, max) {
      if (and.test(parsed)) {
        qs.unshift({
          type: QUERY_AND,
          queryString: parsed.match(and)[1]
        });
        return true;
      } else if (or.test(parsed)) {
        qs.unshift({
          type: QUERY_OR,
          queryString: parsed.match(or)[1]
        });
        return true;
      } else if (n === max) {
        qs.unshift({
          type: QUERY_OR,
          queryString: parsed.trim()
        });
        return true;
      }

      return false;
    });
  }

  function find$2(string, predicate) {
    for (var n = 1, max = string.length; n <= max; n++) {
      var parsed = string.substr(-n, n);

      if (predicate(parsed, n, max)) {
        return string.slice(0, -n);
      }
    }

    return '';
  }

  function flatten(array) {
    if (!Array.isArray(array)) return [array];
    return array.reduce(function (a, b) {
      return a.concat(flatten(b));
    }, []);
  }

  browserslist.data = {};
  browserslist.usage = {
    global: {},
    custom: null
  };
  browserslist.defaults = ['> 0.5%', 'last 2 versions', 'Firefox ESR', 'not dead'];
  browserslist.aliases = {
    fx: 'firefox',
    ff: 'firefox',
    ios: 'ios_saf',
    explorer: 'ie',
    blackberry: 'bb',
    explorermobile: 'ie_mob',
    operamini: 'op_mini',
    operamobile: 'op_mob',
    chromeandroid: 'and_chr',
    firefoxandroid: 'and_ff',
    ucandroid: 'and_uc',
    qqandroid: 'and_qq'
  };
  browserslist.desktopNames = {
    and_chr: 'chrome',
    and_ff: 'firefox',
    ie_mob: 'ie',
    op_mob: 'opera',
    android: 'chrome'
  };
  browserslist.versionAliases = {};
  browserslist.clearCaches = browser$6.clearCaches;
  browserslist.parseConfig = browser$6.parseConfig;
  browserslist.readConfig = browser$6.readConfig;
  browserslist.findConfig = browser$6.findConfig;
  browserslist.loadConfig = browser$6.loadConfig;

  browserslist.coverage = function (browsers, stats) {
    var data;

    if (typeof stats === 'undefined') {
      data = browserslist.usage.global;
    } else if (stats === 'my stats') {
      var opts = {};
      opts.path = path$2.resolve ? path$2.resolve('.') : '.';
      var customStats = browser$6.getStat(opts);

      if (!customStats) {
        throw new error('Custom usage statistics was not provided');
      }

      data = {};

      for (var browser in customStats) {
        fillUsage(data, browser, customStats[browser]);
      }
    } else if (typeof stats === 'string') {
      if (stats.length > 2) {
        stats = stats.toLowerCase();
      } else {
        stats = stats.toUpperCase();
      }

      browser$6.loadCountry(browserslist.usage, stats, browserslist.data);
      data = browserslist.usage[stats];
    } else {
      if ('dataByBrowser' in stats) {
        stats = stats.dataByBrowser;
      }

      data = {};

      for (var name in stats) {
        for (var version in stats[name]) {
          data[name + ' ' + version] = stats[name][version];
        }
      }
    }

    return browsers.reduce(function (all, i) {
      var usage = data[i];

      if (usage === undefined) {
        usage = data[i.replace(/ \S+$/, ' 0')];
      }

      return all + (usage || 0);
    }, 0);
  };

  var QUERIES = [{
    regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
    select: function select(context, versions) {
      return Object.keys(agents$1).reduce(function (selected, name) {
        var data = byName(name, context);
        if (!data) return selected;
        var list = getMajorVersions(data.released, versions);
        list = list.map(nameMapper(data.name));

        if (data.name === 'android') {
          list = filterAndroid(list, versions, context);
        }

        return selected.concat(list);
      }, []);
    }
  }, {
    regexp: /^last\s+(\d+)\s+versions?$/i,
    select: function select(context, versions) {
      return Object.keys(agents$1).reduce(function (selected, name) {
        var data = byName(name, context);
        if (!data) return selected;
        var list = data.released.slice(-versions);
        list = list.map(nameMapper(data.name));

        if (data.name === 'android') {
          list = filterAndroid(list, versions, context);
        }

        return selected.concat(list);
      }, []);
    }
  }, {
    regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
    select: function select(context, versions) {
      var validVersions = getMajorVersions(Object.keys(versions$1).reverse(), versions);
      return validVersions.map(function (i) {
        return 'chrome ' + versions$1[i];
      });
    }
  }, {
    regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
    select: function select(context, versions, name) {
      var data = checkName(name, context);
      var validVersions = getMajorVersions(data.released, versions);
      var list = validVersions.map(nameMapper(data.name));

      if (data.name === 'android') {
        list = filterAndroid(list, versions, context);
      }

      return list;
    }
  }, {
    regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
    select: function select(context, versions) {
      return Object.keys(versions$1).reverse().slice(-versions).map(function (i) {
        return 'chrome ' + versions$1[i];
      });
    }
  }, {
    regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
    select: function select(context, versions, name) {
      var data = checkName(name, context);
      var list = data.released.slice(-versions).map(nameMapper(data.name));

      if (data.name === 'android') {
        list = filterAndroid(list, versions, context);
      }

      return list;
    }
  }, {
    regexp: /^unreleased\s+versions$/i,
    select: function select(context) {
      return Object.keys(agents$1).reduce(function (selected, name) {
        var data = byName(name, context);
        if (!data) return selected;
        var list = data.versions.filter(function (v) {
          return data.released.indexOf(v) === -1;
        });
        list = list.map(nameMapper(data.name));
        return selected.concat(list);
      }, []);
    }
  }, {
    regexp: /^unreleased\s+electron\s+versions?$/i,
    select: function select() {
      return [];
    }
  }, {
    regexp: /^unreleased\s+(\w+)\s+versions?$/i,
    select: function select(context, name) {
      var data = checkName(name, context);
      return data.versions.filter(function (v) {
        return data.released.indexOf(v) === -1;
      }).map(nameMapper(data.name));
    }
  }, {
    regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
    select: function select(context, years) {
      return filterByYear(Date.now() - YEAR * years, context);
    }
  }, {
    regexp: /^since (\d+)(?:-(\d+))?(?:-(\d+))?$/i,
    select: function select(context, year, month, date) {
      year = parseInt(year);
      month = parseInt(month || '01') - 1;
      date = parseInt(date || '01');
      return filterByYear(Date.UTC(year, month, date, 0, 0, 0), context);
    }
  }, {
    regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%$/,
    select: function select(context, sign, popularity) {
      popularity = parseFloat(popularity);
      var usage = browserslist.usage.global;
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version);
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version);
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version);
          }
        } else if (usage[version] >= popularity) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+my\s+stats$/,
    select: function select(context, sign, popularity) {
      popularity = parseFloat(popularity);

      if (!context.customUsage) {
        throw new error('Custom usage statistics was not provided');
      }

      var usage = context.customUsage;
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version);
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version);
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version);
          }
        } else if (usage[version] >= popularity) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+(\S+)\s+stats$/,
    select: function select(context, sign, popularity, name) {
      popularity = parseFloat(popularity);
      var stats = browser$6.loadStat(context, name, browserslist.data);

      if (stats) {
        context.customUsage = {};

        for (var browser in stats) {
          fillUsage(context.customUsage, browser, stats[browser]);
        }
      }

      if (!context.customUsage) {
        throw new error('Custom usage statistics was not provided');
      }

      var usage = context.customUsage;
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version);
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version);
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version);
          }
        } else if (usage[version] >= popularity) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+((alt-)?\w\w)$/,
    select: function select(context, sign, popularity, place) {
      popularity = parseFloat(popularity);

      if (place.length === 2) {
        place = place.toUpperCase();
      } else {
        place = place.toLowerCase();
      }

      browser$6.loadCountry(browserslist.usage, place, browserslist.data);
      var usage = browserslist.usage[place];
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version);
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version);
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version);
          }
        } else if (usage[version] >= popularity) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^cover\s+(\d*\.?\d+)%(\s+in\s+(my\s+stats|(alt-)?\w\w))?$/,
    select: function select(context, coverage, statMode) {
      coverage = parseFloat(coverage);
      var usage = browserslist.usage.global;

      if (statMode) {
        if (statMode.match(/^\s+in\s+my\s+stats$/)) {
          if (!context.customUsage) {
            throw new error('Custom usage statistics was not provided');
          }

          usage = context.customUsage;
        } else {
          var match = statMode.match(/\s+in\s+((alt-)?\w\w)/);
          var place = match[1];

          if (place.length === 2) {
            place = place.toUpperCase();
          } else {
            place = place.toLowerCase();
          }

          browser$6.loadCountry(browserslist.usage, place, browserslist.data);
          usage = browserslist.usage[place];
        }
      }

      var versions = Object.keys(usage).sort(function (a, b) {
        return usage[b] - usage[a];
      });
      var coveraged = 0;
      var result = [];
      var version;

      for (var i = 0; i <= versions.length; i++) {
        version = versions[i];
        if (usage[version] === 0) break;
        coveraged += usage[version];
        result.push(version);
        if (coveraged >= coverage) break;
      }

      return result;
    }
  }, {
    regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function select(context, from, to) {
      var fromToUse = normalizeElectron(from);
      var toToUse = normalizeElectron(to);

      if (!versions$1[fromToUse]) {
        throw new error('Unknown version ' + from + ' of electron');
      }

      if (!versions$1[toToUse]) {
        throw new error('Unknown version ' + to + ' of electron');
      }

      from = parseFloat(from);
      to = parseFloat(to);
      return Object.keys(versions$1).filter(function (i) {
        var parsed = parseFloat(i);
        return parsed >= from && parsed <= to;
      }).map(function (i) {
        return 'chrome ' + versions$1[i];
      });
    }
  }, {
    regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function select(context, from, to) {
      var nodeVersions = jsReleases.filter(function (i) {
        return i.name === 'nodejs';
      }).map(function (i) {
        return i.version;
      });
      var semverRegExp = /^(0|[1-9]\d*)(\.(0|[1-9]\d*)){0,2}$/;

      if (!semverRegExp.test(from)) {
        throw new error('Unknown version ' + from + ' of Node.js');
      }

      if (!semverRegExp.test(to)) {
        throw new error('Unknown version ' + to + ' of Node.js');
      }

      return nodeVersions.filter(semverFilterLoose('>=', from)).filter(semverFilterLoose('<=', to)).map(function (v) {
        return 'node ' + v;
      });
    }
  }, {
    regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function select(context, name, from, to) {
      var data = checkName(name, context);
      from = parseFloat(normalizeVersion(data, from) || from);
      to = parseFloat(normalizeVersion(data, to) || to);

      function filter(v) {
        var parsed = parseFloat(v);
        return parsed >= from && parsed <= to;
      }

      return data.released.filter(filter).map(nameMapper(data.name));
    }
  }, {
    regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
    select: function select(context, sign, version) {
      var versionToUse = normalizeElectron(version);
      return Object.keys(versions$1).filter(generateFilter(sign, versionToUse)).map(function (i) {
        return 'chrome ' + versions$1[i];
      });
    }
  }, {
    regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
    select: function select(context, sign, version) {
      var nodeVersions = jsReleases.filter(function (i) {
        return i.name === 'nodejs';
      }).map(function (i) {
        return i.version;
      });
      return nodeVersions.filter(generateSemverFilter(sign, version)).map(function (v) {
        return 'node ' + v;
      });
    }
  }, {
    regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
    select: function select(context, name, sign, version) {
      var data = checkName(name, context);
      var alias = browserslist.versionAliases[data.name][version];

      if (alias) {
        version = alias;
      }

      return data.released.filter(generateFilter(sign, version)).map(function (v) {
        return data.name + ' ' + v;
      });
    }
  }, {
    regexp: /^(firefox|ff|fx)\s+esr$/i,
    select: function select() {
      return ['firefox 68'];
    }
  }, {
    regexp: /(operamini|op_mini)\s+all/i,
    select: function select() {
      return ['op_mini all'];
    }
  }, {
    regexp: /^electron\s+([\d.]+)$/i,
    select: function select(context, version) {
      var versionToUse = normalizeElectron(version);
      var chrome = versions$1[versionToUse];

      if (!chrome) {
        throw new error('Unknown version ' + version + ' of electron');
      }

      return ['chrome ' + chrome];
    }
  }, {
    regexp: /^node\s+(\d+(\.\d+)?(\.\d+)?)$/i,
    select: function select(context, version) {
      var nodeReleases = jsReleases.filter(function (i) {
        return i.name === 'nodejs';
      });
      var matched = nodeReleases.filter(function (i) {
        return isVersionsMatch(i.version, version);
      });

      if (matched.length === 0) {
        if (context.ignoreUnknownVersions) {
          return [];
        } else {
          throw new error('Unknown version ' + version + ' of Node.js');
        }
      }

      return ['node ' + matched[matched.length - 1].version];
    }
  }, {
    regexp: /^current\s+node$/i,
    select: function select(context) {
      return [browser$6.currentNode(resolve$3, context)];
    }
  }, {
    regexp: /^maintained\s+node\s+versions$/i,
    select: function select(context) {
      var now = Date.now();
      var queries = Object.keys(jsEOL).filter(function (key) {
        return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
      }).map(function (key) {
        return 'node ' + key.slice(1);
      });
      return resolve$3(queries, context);
    }
  }, {
    regexp: /^phantomjs\s+1.9$/i,
    select: function select() {
      return ['safari 5'];
    }
  }, {
    regexp: /^phantomjs\s+2.1$/i,
    select: function select() {
      return ['safari 6'];
    }
  }, {
    regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
    select: function select(context, name, version) {
      if (/^tp$/i.test(version)) version = 'TP';
      var data = checkName(name, context);
      var alias = normalizeVersion(data, version);

      if (alias) {
        version = alias;
      } else {
        if (version.indexOf('.') === -1) {
          alias = version + '.0';
        } else {
          alias = version.replace(/\.0$/, '');
        }

        alias = normalizeVersion(data, alias);

        if (alias) {
          version = alias;
        } else if (context.ignoreUnknownVersions) {
          return [];
        } else {
          throw new error('Unknown version ' + version + ' of ' + name);
        }
      }

      return [data.name + ' ' + version];
    }
  }, {
    regexp: /^extends (.+)$/i,
    select: function select(context, name) {
      return resolve$3(browser$6.loadQueries(context, name), context);
    }
  }, {
    regexp: /^defaults$/i,
    select: function select(context) {
      return resolve$3(browserslist.defaults, context);
    }
  }, {
    regexp: /^dead$/i,
    select: function select(context) {
      var dead = ['ie <= 10', 'ie_mob <= 11', 'bb <= 10', 'op_mob <= 12.1', 'samsung 4'];
      return resolve$3(dead, context);
    }
  }, {
    regexp: /^(\w+)$/i,
    select: function select(context, name) {
      if (byName(name, context)) {
        throw new error('Specify versions in Browserslist query for browser ' + name);
      } else {
        throw unknownQuery(name);
      }
    }
  }];

  (function () {
    for (var name in agents$1) {
      var browser = agents$1[name];
      browserslist.data[name] = {
        name: name,
        versions: normalize$1(agents$1[name].versions),
        released: normalize$1(agents$1[name].versions.slice(0, -3)),
        releaseDate: agents$1[name].release_date
      };
      fillUsage(browserslist.usage.global, name, browser.usage_global);
      browserslist.versionAliases[name] = {};

      for (var i = 0; i < browser.versions.length; i++) {
        var full = browser.versions[i];
        if (!full) continue;

        if (full.indexOf('-') !== -1) {
          var interval = full.split('-');

          for (var j = 0; j < interval.length; j++) {
            browserslist.versionAliases[name][interval[j]] = full;
          }
        }
      }
    }
  })();

  var browserslist_1 = browserslist;

  var leven_1 = createCommonjsModule(function (module) {

  var array = [];
  var charCodeCache = [];

  var leven = function leven(left, right) {
    if (left === right) {
      return 0;
    }

    var swap = left;

    if (left.length > right.length) {
      left = right;
      right = swap;
    }

    var leftLength = left.length;
    var rightLength = right.length;

    while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
      leftLength--;
      rightLength--;
    }

    var start = 0;

    while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
      start++;
    }

    leftLength -= start;
    rightLength -= start;

    if (leftLength === 0) {
      return rightLength;
    }

    var bCharCode;
    var result;
    var temp;
    var temp2;
    var i = 0;
    var j = 0;

    while (i < leftLength) {
      charCodeCache[i] = left.charCodeAt(start + i);
      array[i] = ++i;
    }

    while (j < rightLength) {
      bCharCode = right.charCodeAt(start + j);
      temp = j++;
      result = j;

      for (i = 0; i < leftLength; i++) {
        temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;
        temp = array[i];
        result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
      }
    }

    return result;
  };

  module.exports = leven;
  module.exports["default"] = leven;
  });

  function levenArray(str, array) {
    var minLeven = Number.POSITIVE_INFINITY;
    var result = undefined;

    for (var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var item = _ref;
      var distance = leven_1(str, item);

      if (distance < minLeven) {
        minLeven = distance;
        result = item;
      }
    }

    return result;
  }

  var invariant = function invariant(condition, format, a, b, c, d, e, f) {
    {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }

    if (!condition) {
      var error;

      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1;
      throw error;
    }
  };

  var browser$7 = invariant;

  var nativeModules = {
    "es6.module": {
    edge: "16",
    firefox: "60",
    chrome: "61",
    safari: "10.1",
    opera: "48",
    ios_saf: "10.3",
    android: "61",
    op_mob: "48",
    and_chr: "61",
    and_ff: "60",
    samsung: "8.2"
  }
  };

  var nativeModules$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': nativeModules
  });

  var require$$0$2 = getCjsExportFromNamespace(nativeModules$1);

  var nativeModules$2 = require$$0$2;

  var unreleasedLabels = {
    safari: "tp"
  };
  var browserNameMap = {
    and_chr: "chrome",
    and_ff: "firefox",
    android: "android",
    chrome: "chrome",
    edge: "edge",
    firefox: "firefox",
    ie: "ie",
    ie_mob: "ie",
    ios_saf: "ios",
    node: "node",
    op_mob: "opera",
    opera: "opera",
    safari: "safari",
    samsung: "samsung"
  };

  var versionRegExp = /^(\d+|\d+.\d+)$/;
  function semverMin(first, second) {
    return first && semver.lt(first, second) ? first : second;
  }
  function semverify(version) {
    if (typeof version === "string" && semver.valid(version)) {
      return version;
    }

    browser$7(typeof version === "number" || typeof version === "string" && versionRegExp.test(version), "'" + version + "' is not a valid version");
    var split = version.toString().split(".");

    while (split.length < 3) {
      split.push("0");
    }

    return split.join(".");
  }
  function isUnreleasedVersion(version, env) {
    var unreleasedLabel = unreleasedLabels[env];
    return !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase();
  }
  function getLowestUnreleased(a, b, env) {
    var unreleasedLabel = unreleasedLabels[env];
    var hasUnreleased = [a, b].some(function (item) {
      return item === unreleasedLabel;
    });

    if (hasUnreleased) {
      return a === hasUnreleased ? b : a || b;
    }

    return semverMin(a, b);
  }
  function getLowestImplementedVersion(plugin, environment) {
    var result = plugin[environment];

    if (!result && environment === "android") {
      return plugin.chrome;
    }

    return result;
  }

  var TargetNames = {
    esmodules: "esmodules",
    node: "node",
    browsers: "browsers",
    chrome: "chrome",
    opera: "opera",
    edge: "edge",
    firefox: "firefox",
    safari: "safari",
    ie: "ie",
    ios: "ios",
    android: "android",
    electron: "electron",
    samsung: "samsung",
    uglify: "uglify"
  };

  function prettifyVersion(version) {
    if (typeof version !== "string") {
      return version;
    }

    var parts = [semver.major(version)];
    var minor = semver.minor(version);
    var patch = semver.patch(version);

    if (minor || patch) {
      parts.push(minor);
    }

    if (patch) {
      parts.push(patch);
    }

    return parts.join(".");
  }
  function prettifyTargets(targets) {
    return Object.keys(targets).reduce(function (results, target) {
      var value = targets[target];
      var unreleasedLabel = unreleasedLabels[target];

      if (typeof value === "string" && unreleasedLabel !== value) {
        value = prettifyVersion(value);
      }

      results[target] = value;
      return results;
    }, {});
  }

  function getInclusionReasons(item, targetVersions, list) {
    var minVersions = list[item] || {};
    return Object.keys(targetVersions).reduce(function (result, env) {
      var minVersion = getLowestImplementedVersion(minVersions, env);
      var targetVersion = targetVersions[env];

      if (!minVersion) {
        result[env] = prettifyVersion(targetVersion);
      } else {
        var minIsUnreleased = isUnreleasedVersion(minVersion, env);
        var targetIsUnreleased = isUnreleasedVersion(targetVersion, env);

        if (!targetIsUnreleased && (minIsUnreleased || semver.lt(targetVersion.toString(), semverify(minVersion)))) {
          result[env] = prettifyVersion(targetVersion);
        }
      }

      return result;
    }, {});
  }

  var plugins = {
    "proposal-numeric-separator": {
    chrome: "75",
    edge: "79",
    firefox: "70",
    safari: "13",
    node: "12.5",
    ios: "13",
    opera: "62",
    electron: "6.1"
  },
    "proposal-nullish-coalescing-operator": {
    chrome: "80",
    edge: "80",
    firefox: "72",
    safari: "13.1",
    opera: "67",
    electron: "8.1"
  },
    "proposal-optional-chaining": {
    chrome: "80",
    edge: "80",
    firefox: "74",
    safari: "13.1",
    opera: "67",
    electron: "8.1"
  },
    "proposal-json-strings": {
    chrome: "66",
    edge: "79",
    firefox: "62",
    safari: "12",
    node: "10",
    ios: "12",
    samsung: "9",
    opera: "53",
    electron: "3.1"
  },
    "proposal-optional-catch-binding": {
    chrome: "66",
    edge: "79",
    firefox: "58",
    safari: "11.1",
    node: "10",
    ios: "11.3",
    samsung: "9",
    opera: "53",
    electron: "3.1"
  },
    "transform-parameters": {
    chrome: "49",
    edge: "18",
    firefox: "53",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "proposal-async-generator-functions": {
    chrome: "63",
    edge: "79",
    firefox: "57",
    safari: "12",
    node: "10",
    ios: "12",
    samsung: "8",
    opera: "50",
    electron: "3.1"
  },
    "proposal-object-rest-spread": {
    chrome: "60",
    edge: "79",
    firefox: "55",
    safari: "11.1",
    node: "8.3",
    ios: "11.3",
    samsung: "8",
    opera: "47",
    electron: "2.1"
  },
    "transform-dotall-regex": {
    chrome: "62",
    edge: "79",
    safari: "11.1",
    node: "8.10",
    ios: "11.3",
    samsung: "8",
    opera: "49",
    electron: "3.1"
  },
    "proposal-unicode-property-regex": {
    chrome: "64",
    edge: "79",
    safari: "11.1",
    node: "10",
    ios: "11.3",
    samsung: "9",
    opera: "51",
    electron: "3.1"
  },
    "transform-named-capturing-groups-regex": {
    chrome: "64",
    edge: "79",
    safari: "11.1",
    node: "10",
    ios: "11.3",
    samsung: "9",
    opera: "51",
    electron: "3.1"
  },
    "transform-async-to-generator": {
    chrome: "55",
    edge: "15",
    firefox: "52",
    safari: "11",
    node: "7.6",
    ios: "11",
    samsung: "6",
    opera: "42",
    electron: "1.6"
  },
    "transform-exponentiation-operator": {
    chrome: "52",
    edge: "14",
    firefox: "52",
    safari: "10.1",
    node: "7",
    ios: "10.3",
    samsung: "6",
    opera: "39",
    electron: "1.3"
  },
    "transform-template-literals": {
    chrome: "41",
    edge: "13",
    firefox: "34",
    safari: "13",
    node: "4",
    ios: "13",
    samsung: "3.4",
    opera: "28",
    electron: "0.24"
  },
    "transform-literals": {
    chrome: "44",
    edge: "12",
    firefox: "53",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    opera: "31",
    electron: "0.31"
  },
    "transform-function-name": {
    chrome: "51",
    edge: "79",
    firefox: "53",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "transform-arrow-functions": {
    chrome: "47",
    edge: "13",
    firefox: "45",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "34",
    electron: "0.36"
  },
    "transform-block-scoped-functions": {
    chrome: "41",
    edge: "12",
    firefox: "46",
    safari: "10",
    node: "4",
    ie: "11",
    ios: "10",
    samsung: "3.4",
    opera: "28",
    electron: "0.24"
  },
    "transform-classes": {
    chrome: "46",
    edge: "13",
    firefox: "45",
    safari: "10",
    node: "5",
    ios: "10",
    samsung: "5",
    opera: "33",
    electron: "0.36"
  },
    "transform-object-super": {
    chrome: "46",
    edge: "13",
    firefox: "45",
    safari: "10",
    node: "5",
    ios: "10",
    samsung: "5",
    opera: "33",
    electron: "0.36"
  },
    "transform-shorthand-properties": {
    chrome: "43",
    edge: "12",
    firefox: "33",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    opera: "30",
    electron: "0.29"
  },
    "transform-duplicate-keys": {
    chrome: "42",
    edge: "12",
    firefox: "34",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    opera: "29",
    electron: "0.27"
  },
    "transform-computed-properties": {
    chrome: "44",
    edge: "12",
    firefox: "34",
    safari: "7.1",
    node: "4",
    ios: "8",
    samsung: "4",
    opera: "31",
    electron: "0.31"
  },
    "transform-for-of": {
    chrome: "51",
    edge: "15",
    firefox: "53",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "transform-sticky-regex": {
    chrome: "49",
    edge: "13",
    firefox: "3",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "transform-unicode-regex": {
    chrome: "50",
    edge: "13",
    firefox: "46",
    safari: "12",
    node: "6",
    ios: "12",
    samsung: "5",
    opera: "37",
    electron: "1.1"
  },
    "transform-spread": {
    chrome: "46",
    edge: "13",
    firefox: "36",
    safari: "10",
    node: "5",
    ios: "10",
    samsung: "5",
    opera: "33",
    electron: "0.36"
  },
    "transform-destructuring": {
    chrome: "51",
    edge: "15",
    firefox: "53",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "transform-block-scoping": {
    chrome: "49",
    edge: "14",
    firefox: "51",
    safari: "11",
    node: "6",
    ios: "11",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "transform-typeof-symbol": {
    chrome: "38",
    edge: "12",
    firefox: "36",
    safari: "9",
    node: "0.12",
    ios: "9",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "transform-new-target": {
    chrome: "46",
    edge: "14",
    firefox: "41",
    safari: "10",
    node: "5",
    ios: "10",
    samsung: "5",
    opera: "33",
    electron: "0.36"
  },
    "transform-regenerator": {
    chrome: "50",
    edge: "13",
    firefox: "53",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "37",
    electron: "1.1"
  },
    "transform-member-expression-literals": {
    chrome: "7",
    opera: "12",
    edge: "12",
    firefox: "2",
    safari: "5.1",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "5"
  },
    "transform-property-literals": {
    chrome: "7",
    opera: "12",
    edge: "12",
    firefox: "2",
    safari: "5.1",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "5"
  },
    "transform-reserved-words": {
    chrome: "13",
    opera: "10.50",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.10",
    ie: "9",
    android: "4.4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "0.2"
  }
  };

  var plugins$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugins
  });

  var require$$0$3 = getCjsExportFromNamespace(plugins$1);

  var plugins$2 = require$$0$3;

  function targetsSupported(target, support) {
    var targetEnvironments = Object.keys(target);

    if (targetEnvironments.length === 0) {
      return false;
    }

    var unsupportedEnvironments = targetEnvironments.filter(function (environment) {
      var lowestImplementedVersion = getLowestImplementedVersion(support, environment);

      if (!lowestImplementedVersion) {
        return true;
      }

      var lowestTargetedVersion = target[environment];

      if (isUnreleasedVersion(lowestTargetedVersion, environment)) {
        return false;
      }

      if (isUnreleasedVersion(lowestImplementedVersion, environment)) {
        return true;
      }

      if (!semver.valid(lowestTargetedVersion.toString())) {
        throw new Error("Invalid version passed for target \"" + environment + "\": \"" + lowestTargetedVersion + "\". " + "Versions must be in semver format (major.minor.patch)");
      }

      return semver.gt(semverify(lowestImplementedVersion), lowestTargetedVersion.toString());
    });
    return unsupportedEnvironments.length === 0;
  }
  function isRequired(name, targets, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$compatData = _ref.compatData,
        compatData = _ref$compatData === void 0 ? plugins$2 : _ref$compatData,
        includes = _ref.includes,
        excludes = _ref.excludes;

    if (excludes && excludes.has(name)) return false;
    if (includes && includes.has(name)) return true;
    return !targetsSupported(targets, compatData[name]);
  }
  function filterItems(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
    var result = new Set();
    var options = {
      compatData: list,
      includes: includes,
      excludes: excludes
    };

    for (var item in list) {
      if (isRequired(item, targets, options)) {
        result.add(item);
      } else if (pluginSyntaxMap) {
        var shippedProposalsSyntax = pluginSyntaxMap.get(item);

        if (shippedProposalsSyntax) {
          result.add(shippedProposalsSyntax);
        }
      }
    }

    if (defaultIncludes) {
      defaultIncludes.forEach(function (item) {
        return !excludes.has(item) && result.add(item);
      });
    }

    if (defaultExcludes) {
      defaultExcludes.forEach(function (item) {
        return !includes.has(item) && result["delete"](item);
      });
    }

    return result;
  }

  var browserslistDefaults = browserslist_1.defaults;
  var validBrowserslistTargets = [].concat(Object.keys(browserslist_1.data), Object.keys(browserslist_1.aliases));

  function objectToBrowserslist(object) {
    return Object.keys(object).reduce(function (list, targetName) {
      if (validBrowserslistTargets.indexOf(targetName) >= 0) {
        var targetVersion = object[targetName];
        return list.concat(targetName + " " + targetVersion);
      }

      return list;
    }, []);
  }

  function validateTargetNames(targets) {
    var validTargets = Object.keys(TargetNames);

    for (var target in targets) {
      if (!TargetNames[target]) {
        throw new Error("Invalid Option: '" + target + "' is not a valid target\n        Maybe you meant to use '" + levenArray(target, validTargets) + "'?");
      }
    }
  }

  function isBrowsersQueryValid(browsers) {
    return typeof browsers === "string" || Array.isArray(browsers);
  }

  function validateBrowsers(browsers) {
    browser$7(typeof browsers === "undefined" || isBrowsersQueryValid(browsers), "Invalid Option: '" + browsers + "' is not a valid browserslist query");
    return browsers;
  }

  function mergeBrowsers(fromQuery, fromTarget) {
    return Object.keys(fromTarget).reduce(function (queryObj, targKey) {
      if (targKey !== TargetNames.browsers) {
        queryObj[targKey] = fromTarget[targKey];
      }

      return queryObj;
    }, fromQuery);
  }

  function getLowestVersions(browsers) {
    return browsers.reduce(function (all, browser) {
      var _browser$split = browser.split(" "),
          browserName = _browser$split[0],
          browserVersion = _browser$split[1];

      var normalizedBrowserName = browserNameMap[browserName];

      if (!normalizedBrowserName) {
        return all;
      }

      try {
        var splitVersion = browserVersion.split("-")[0].toLowerCase();
        var isSplitUnreleased = isUnreleasedVersion(splitVersion, browserName);

        if (!all[normalizedBrowserName]) {
          all[normalizedBrowserName] = isSplitUnreleased ? splitVersion : semverify(splitVersion);
          return all;
        }

        var version = all[normalizedBrowserName];
        var isUnreleased = isUnreleasedVersion(version, browserName);

        if (isUnreleased && isSplitUnreleased) {
          all[normalizedBrowserName] = getLowestUnreleased(version, splitVersion, browserName);
        } else if (isUnreleased) {
          all[normalizedBrowserName] = semverify(splitVersion);
        } else if (!isUnreleased && !isSplitUnreleased) {
          var parsedBrowserVersion = semverify(splitVersion);
          all[normalizedBrowserName] = semverMin(version, parsedBrowserVersion);
        }
      } catch (e) {}

      return all;
    }, {});
  }

  function outputDecimalWarning(decimalTargets) {
    if (!decimalTargets || !decimalTargets.length) {
      return;
    }

    console.log("Warning, the following targets are using a decimal version:");
    console.log("");
    decimalTargets.forEach(function (_ref) {
      var target = _ref.target,
          value = _ref.value;
      return console.log("  " + target + ": " + value);
    });
    console.log("");
    console.log("We recommend using a string for minor/patch versions to avoid numbers like 6.10");
    console.log("getting parsed as 6.1, which can lead to unexpected behavior.");
    console.log("");
  }

  function semverifyTarget(target, value) {
    try {
      return semverify(value);
    } catch (error) {
      throw new Error("Invalid Option: '" + value + "' is not a valid value for 'targets." + target + "'.");
    }
  }

  var targetParserMap = {
    __default: function __default(target, value) {
      var version = isUnreleasedVersion(value, target) ? value.toLowerCase() : semverifyTarget(target, value);
      return [target, version];
    },
    node: function node(target, value) {
      var parsed = value === true || value === "current" ? process.versions.node : semverifyTarget(target, value);
      return [target, parsed];
    }
  };
  function getTargets(targets, options) {
    if (targets === void 0) {
      targets = {};
    }

    if (options === void 0) {
      options = {};
    }

    var targetOpts = {};
    validateTargetNames(targets);

    if (targets.esmodules) {
      var supportsESModules = nativeModules$2["es6.module"];
      targets.browsers = Object.keys(supportsESModules).map(function (browser) {
        return browser + " " + supportsESModules[browser];
      }).join(", ");
    }

    delete targets.esmodules;
    var browsersquery = validateBrowsers(targets.browsers);
    var hasTargets = Object.keys(targets).length > 0;
    var shouldParseBrowsers = !!targets.browsers;
    var shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;

    if (shouldParseBrowsers || shouldSearchForConfig) {
      if (!hasTargets) {
        browserslist_1.defaults = objectToBrowserslist(targets);
      }

      var browsers = browserslist_1(browsersquery, {
        path: options.configPath,
        mobileToDesktop: true
      });
      var queryBrowsers = getLowestVersions(browsers);
      targets = mergeBrowsers(queryBrowsers, targets);
      browserslist_1.defaults = browserslistDefaults;
    }

    var parsed = Object.keys(targets).filter(function (value) {
      return value !== TargetNames.esmodules;
    }).sort().reduce(function (results, target) {
      if (target !== TargetNames.browsers) {
        var value = targets[target];

        if (typeof value === "number" && value % 1 !== 0) {
          results.decimalWarnings.push({
            target: target,
            value: value
          });
        }

        var parser = targetParserMap[target] || targetParserMap.__default;

        var _parser = parser(target, value),
            parsedTarget = _parser[0],
            parsedValue = _parser[1];

        if (parsedValue) {
          results.targets[parsedTarget] = parsedValue;
        }
      }

      return results;
    }, {
      targets: targetOpts,
      decimalWarnings: []
    });
    outputDecimalWarning(parsed.decimalWarnings);
    return parsed.targets;
  }

  var wordEnds = function wordEnds(size) {
    return size > 1 ? "s" : "";
  };

  var logPluginOrPolyfill = function logPluginOrPolyfill(item, targetVersions, list) {
    var filteredList = getInclusionReasons(item, targetVersions, list);
    var formattedTargets = JSON.stringify(filteredList).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
    console.log("  " + item + " " + formattedTargets);
  };
  var logEntryPolyfills = function logEntryPolyfills(polyfillName, importPolyfillIncluded, polyfills, filename, polyfillTargets, allBuiltInsList) {
    if (process.env.BABEL_ENV === "test") {
      filename = filename.replace(/\\/g, "/");
    }

    if (!importPolyfillIncluded) {
      console.log("\n[" + filename + "] Import of " + polyfillName + " was not found.");
      return;
    }

    if (!polyfills.size) {
      console.log("\n[" + filename + "] Based on your targets, polyfills were not added.");
      return;
    }

    console.log("\n[" + filename + "] Replaced " + polyfillName + " entries with the following polyfill" + wordEnds(polyfills.size) + ":");

    for (var _iterator = polyfills, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var polyfill = _ref;
      logPluginOrPolyfill(polyfill, polyfillTargets, allBuiltInsList);
    }
  };
  var logUsagePolyfills = function logUsagePolyfills(polyfills, filename, polyfillTargets, allBuiltInsList) {
    if (process.env.BABEL_ENV === "test") {
      filename = filename.replace(/\\/g, "/");
    }

    if (!polyfills.size) {
      console.log("\n[" + filename + "] Based on your code and targets, core-js polyfills were not added.");
      return;
    }

    console.log("\n[" + filename + "] Added following core-js polyfill" + wordEnds(polyfills.size) + ":");

    for (var _iterator2 = polyfills, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var polyfill = _ref2;
      logPluginOrPolyfill(polyfill, polyfillTargets, allBuiltInsList);
    }
  };

  var defaultExcludesForLooseMode = ["transform-typeof-symbol"];
  function getOptionSpecificExcludesFor (_ref) {
    var loose = _ref.loose;
    return loose ? defaultExcludesForLooseMode : null;
  }

  function removeUnnecessaryItems(items, overlapping) {
    items.forEach(function (item) {
      var _overlapping$item;

      (_overlapping$item = overlapping[item]) == null ? void 0 : _overlapping$item.forEach(function (name) {
        return items["delete"](name);
      });
    });
  }

  var moduleTransformations = {
    auto: "transform-modules-commonjs",
    amd: "transform-modules-amd",
    commonjs: "transform-modules-commonjs",
    cjs: "transform-modules-commonjs",
    systemjs: "transform-modules-systemjs",
    umd: "transform-modules-umd"
  };

  var corejs3Polyfills = {
    "es.symbol": {
    chrome: "49",
    edge: "15",
    electron: "0.37",
    firefox: "51",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.symbol.description": {
    chrome: "70",
    edge: "74",
    electron: "5.0",
    firefox: "63",
    ios: "12.2",
    node: "11.0",
    opera: "57",
    opera_mobile: "49",
    safari: "12.1",
    samsung: "10.0"
  },
    "es.symbol.async-iterator": {
    chrome: "63",
    edge: "74",
    electron: "3.0",
    firefox: "55",
    ios: "12.0",
    node: "10.0",
    opera: "50",
    opera_mobile: "46",
    safari: "12.0",
    samsung: "8.0"
  },
    "es.symbol.has-instance": {
    chrome: "50",
    edge: "15",
    electron: "1.1",
    firefox: "49",
    ios: "10.0",
    node: "6.0",
    opera: "37",
    opera_mobile: "37",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.symbol.is-concat-spreadable": {
    chrome: "48",
    edge: "15",
    electron: "0.37",
    firefox: "48",
    ios: "10.0",
    node: "6.0",
    opera: "35",
    opera_mobile: "35",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.symbol.iterator": {
    chrome: "39",
    edge: "13",
    electron: "0.20",
    firefox: "36",
    ios: "9.0",
    node: "1.0",
    opera: "26",
    opera_mobile: "26",
    safari: "9.0",
    samsung: "3.4"
  },
    "es.symbol.match": {
    chrome: "50",
    edge: "74",
    electron: "1.1",
    firefox: "40",
    ios: "10.0",
    node: "6.0",
    opera: "37",
    opera_mobile: "37",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.symbol.match-all": {
    chrome: "73",
    edge: "74",
    electron: "5.0",
    firefox: "67",
    ios: "13.0",
    node: "12.0",
    opera: "60",
    opera_mobile: "52",
    safari: "13",
    samsung: "11.0"
  },
    "es.symbol.replace": {
    chrome: "50",
    edge: "74",
    electron: "1.1",
    firefox: "49",
    ios: "10.0",
    node: "6.0",
    opera: "37",
    opera_mobile: "37",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.symbol.search": {
    chrome: "50",
    edge: "74",
    electron: "1.1",
    firefox: "49",
    ios: "10.0",
    node: "6.0",
    opera: "37",
    opera_mobile: "37",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.symbol.species": {
    chrome: "51",
    edge: "13",
    electron: "1.2",
    firefox: "41",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.symbol.split": {
    chrome: "50",
    edge: "74",
    electron: "1.1",
    firefox: "49",
    ios: "10.0",
    node: "6.0",
    opera: "37",
    opera_mobile: "37",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.symbol.to-primitive": {
    chrome: "47",
    edge: "15",
    electron: "0.36",
    firefox: "44",
    ios: "10.0",
    node: "6.0",
    opera: "34",
    opera_mobile: "34",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.symbol.to-string-tag": {
    chrome: "49",
    edge: "15",
    electron: "0.37",
    firefox: "51",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.symbol.unscopables": {
    chrome: "39",
    edge: "13",
    electron: "0.20",
    firefox: "48",
    ios: "9.0",
    node: "1.0",
    opera: "26",
    opera_mobile: "26",
    safari: "9.0",
    samsung: "3.4"
  },
    "es.array.concat": {
    chrome: "51",
    edge: "15",
    electron: "1.2",
    firefox: "48",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.array.copy-within": {
    chrome: "45",
    edge: "12",
    electron: "0.31",
    firefox: "48",
    ios: "9.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.array.every": {
    chrome: "48",
    edge: "15",
    electron: "0.37",
    firefox: "50",
    ios: "9.0",
    node: "6.0",
    opera: "35",
    opera_mobile: "35",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.array.fill": {
    chrome: "45",
    edge: "12",
    electron: "0.31",
    firefox: "48",
    ios: "9.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.array.filter": {
    chrome: "51",
    edge: "15",
    electron: "1.2",
    firefox: "48",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.array.find": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "48",
    ios: "9.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.array.find-index": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "48",
    ios: "9.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.array.flat": {
    chrome: "69",
    edge: "74",
    electron: "4.0",
    firefox: "62",
    ios: "12.0",
    node: "11.0",
    opera: "56",
    opera_mobile: "48",
    safari: "12.0",
    samsung: "10.0"
  },
    "es.array.flat-map": {
    chrome: "69",
    edge: "74",
    electron: "4.0",
    firefox: "62",
    ios: "12.0",
    node: "11.0",
    opera: "56",
    opera_mobile: "48",
    safari: "12.0",
    samsung: "10.0"
  },
    "es.array.for-each": {
    chrome: "48",
    edge: "15",
    electron: "0.37",
    firefox: "50",
    ios: "9.0",
    node: "6.0",
    opera: "35",
    opera_mobile: "35",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.array.from": {
    chrome: "51",
    edge: "15",
    electron: "1.2",
    firefox: "53",
    ios: "9.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.array.includes": {
    chrome: "53",
    edge: "15",
    electron: "1.4",
    firefox: "48",
    ios: "10.0",
    node: "7.0",
    opera: "40",
    opera_mobile: "40",
    safari: "10.0",
    samsung: "6.0"
  },
    "es.array.index-of": {
    chrome: "51",
    edge: "15",
    electron: "1.2",
    firefox: "50",
    ios: "11.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "11.0",
    samsung: "5.0"
  },
    "es.array.is-array": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    ie: "9",
    ios: "3.2",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "4.0",
    samsung: "1.0"
  },
    "es.array.iterator": {
    chrome: "66",
    edge: "15",
    electron: "3.0",
    firefox: "60",
    ios: "10.0",
    node: "10.0",
    opera: "53",
    opera_mobile: "47",
    safari: "10.0",
    samsung: "9.0"
  },
    "es.array.join": {
    android: "4.4",
    chrome: "26",
    edge: "13",
    electron: "0.20",
    firefox: "4",
    ios: "8.0",
    node: "0.11.0",
    opera: "16",
    opera_mobile: "16",
    safari: "7.1",
    samsung: "1.5"
  },
    "es.array.last-index-of": {
    chrome: "51",
    edge: "13",
    electron: "1.2",
    firefox: "50",
    ios: "11.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "11.0",
    samsung: "5.0"
  },
    "es.array.map": {
    chrome: "51",
    edge: "13",
    electron: "1.2",
    firefox: "50",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.array.of": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "25",
    ios: "9.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.array.reduce": {
    chrome: "48",
    edge: "15",
    electron: "0.37",
    firefox: "50",
    ios: "9.0",
    node: "6.0",
    opera: "35",
    opera_mobile: "35",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.array.reduce-right": {
    chrome: "48",
    edge: "15",
    electron: "0.37",
    firefox: "50",
    ios: "9.0",
    node: "6.0",
    opera: "35",
    opera_mobile: "35",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.array.reverse": {
    android: "3.0",
    chrome: "1",
    edge: "12",
    electron: "0.20",
    firefox: "1",
    ie: "5.5",
    ios: "12.2",
    node: "0.0.3",
    opera: "10.50",
    opera_mobile: "10.50",
    safari: "12.0.2",
    samsung: "1.0"
  },
    "es.array.slice": {
    chrome: "51",
    edge: "15",
    electron: "1.2",
    firefox: "48",
    ios: "11.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "11.0",
    samsung: "5.0"
  },
    "es.array.some": {
    chrome: "48",
    edge: "15",
    electron: "0.37",
    firefox: "50",
    ios: "9.0",
    node: "6.0",
    opera: "35",
    opera_mobile: "35",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.array.sort": {
    chrome: "63",
    edge: "12",
    electron: "3.0",
    firefox: "4",
    ie: "9",
    ios: "12.0",
    node: "10.0",
    opera: "50",
    opera_mobile: "46",
    safari: "12.0",
    samsung: "8.0"
  },
    "es.array.species": {
    chrome: "51",
    edge: "13",
    electron: "1.2",
    firefox: "48",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.array.splice": {
    chrome: "51",
    edge: "15",
    electron: "1.2",
    firefox: "49",
    ios: "11.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "11.0",
    samsung: "5.0"
  },
    "es.array.unscopables.flat": {
    chrome: "73",
    edge: "74",
    electron: "5.0",
    firefox: "67",
    ios: "13.0",
    node: "12.0",
    opera: "60",
    opera_mobile: "52",
    safari: "13",
    samsung: "11.0"
  },
    "es.array.unscopables.flat-map": {
    chrome: "73",
    edge: "74",
    electron: "5.0",
    firefox: "67",
    ios: "13.0",
    node: "12.0",
    opera: "60",
    opera_mobile: "52",
    safari: "13",
    samsung: "11.0"
  },
    "es.array-buffer.constructor": {
    android: "4.4",
    chrome: "26",
    edge: "14",
    electron: "0.20",
    firefox: "44",
    ios: "12.0",
    node: "0.11.0",
    opera: "16",
    opera_mobile: "16",
    safari: "12.0",
    samsung: "1.5"
  },
    "es.array-buffer.is-view": {
    android: "4.4.3",
    chrome: "32",
    edge: "12",
    electron: "0.20",
    firefox: "29",
    ie: "11",
    ios: "8.0",
    node: "0.11.9",
    opera: "19",
    opera_mobile: "19",
    safari: "7.1",
    samsung: "2.0"
  },
    "es.array-buffer.slice": {
    android: "4.4.3",
    chrome: "31",
    edge: "12",
    electron: "0.20",
    firefox: "46",
    ie: "11",
    ios: "12.2",
    node: "0.11.8",
    opera: "18",
    opera_mobile: "18",
    safari: "12.1",
    samsung: "2.0"
  },
    "es.data-view": {
    android: "4.4",
    chrome: "26",
    edge: "12",
    electron: "0.20",
    firefox: "15",
    ie: "10",
    ios: "8.0",
    node: "0.11.0",
    opera: "16",
    opera_mobile: "16",
    safari: "7.1",
    samsung: "1.5"
  },
    "es.date.now": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    ie: "9",
    ios: "3.2",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "4.0",
    samsung: "1.0"
  },
    "es.date.to-iso-string": {
    android: "4.4",
    chrome: "26",
    edge: "12",
    electron: "0.20",
    firefox: "7",
    ie: "9",
    ios: "8.0",
    node: "0.11.0",
    opera: "16",
    opera_mobile: "16",
    safari: "7.1",
    samsung: "1.5"
  },
    "es.date.to-json": {
    android: "4.4",
    chrome: "26",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    ie: "9",
    ios: "10.0",
    node: "0.11.0",
    opera: "16",
    opera_mobile: "16",
    safari: "10.0",
    samsung: "1.5"
  },
    "es.date.to-primitive": {
    chrome: "47",
    edge: "15",
    electron: "0.36",
    firefox: "44",
    ios: "10.0",
    node: "6.0",
    opera: "34",
    opera_mobile: "34",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.date.to-string": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    ie: "9",
    ios: "2.0",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "3.1",
    samsung: "1.0"
  },
    "es.function.bind": {
    android: "3.0",
    chrome: "7",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    ie: "9",
    ios: "5.1",
    node: "0.1.101",
    opera: "12",
    opera_mobile: "12",
    phantom: "2.0",
    safari: "5.1",
    samsung: "1.0"
  },
    "es.function.has-instance": {
    chrome: "51",
    edge: "15",
    electron: "1.2",
    firefox: "50",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.function.name": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    ios: "3.2",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "4.0",
    samsung: "1.0"
  },
    "es.global-this": {
    chrome: "71",
    edge: "74",
    electron: "5.0",
    firefox: "65",
    ios: "12.2",
    node: "12.0",
    opera: "58",
    opera_mobile: "50",
    safari: "12.1",
    samsung: "10.0"
  },
    "es.json.stringify": {
    chrome: "72",
    edge: "74",
    electron: "5.0",
    firefox: "64",
    ios: "12.2",
    node: "12.0",
    opera: "59",
    opera_mobile: "51",
    safari: "12.1",
    samsung: "11.0"
  },
    "es.json.to-string-tag": {
    chrome: "50",
    edge: "15",
    electron: "1.1",
    firefox: "51",
    ios: "10.0",
    node: "6.0",
    opera: "37",
    opera_mobile: "37",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.map": {
    chrome: "51",
    edge: "15",
    electron: "1.2",
    firefox: "53",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.math.acosh": {
    chrome: "54",
    edge: "13",
    electron: "1.4",
    firefox: "25",
    ios: "8.0",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    safari: "7.1",
    samsung: "6.0"
  },
    "es.math.asinh": {
    chrome: "38",
    edge: "13",
    electron: "0.20",
    firefox: "25",
    ios: "8.0",
    node: "0.11.15",
    opera: "25",
    opera_mobile: "25",
    safari: "7.1",
    samsung: "3.0"
  },
    "es.math.atanh": {
    chrome: "38",
    edge: "13",
    electron: "0.20",
    firefox: "25",
    ios: "8.0",
    node: "0.11.15",
    opera: "25",
    opera_mobile: "25",
    safari: "7.1",
    samsung: "3.0"
  },
    "es.math.cbrt": {
    chrome: "38",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    ios: "8.0",
    node: "0.11.15",
    opera: "25",
    opera_mobile: "25",
    safari: "7.1",
    samsung: "3.0"
  },
    "es.math.clz32": {
    chrome: "38",
    edge: "12",
    electron: "0.20",
    firefox: "31",
    ios: "9.0",
    node: "0.11.15",
    opera: "25",
    opera_mobile: "25",
    safari: "9.0",
    samsung: "3.0"
  },
    "es.math.cosh": {
    chrome: "39",
    edge: "13",
    electron: "0.20",
    firefox: "25",
    ios: "8.0",
    node: "1.0",
    opera: "26",
    opera_mobile: "26",
    safari: "7.1",
    samsung: "3.4"
  },
    "es.math.expm1": {
    chrome: "39",
    edge: "13",
    electron: "0.20",
    firefox: "46",
    ios: "8.0",
    node: "1.0",
    opera: "26",
    opera_mobile: "26",
    safari: "7.1",
    samsung: "3.4"
  },
    "es.math.fround": {
    chrome: "38",
    edge: "12",
    electron: "0.20",
    firefox: "26",
    ios: "8.0",
    node: "0.11.15",
    opera: "25",
    opera_mobile: "25",
    safari: "7.1",
    samsung: "3.0"
  },
    "es.math.hypot": {
    chrome: "78",
    edge: "12",
    electron: "7.0",
    firefox: "27",
    ios: "8.0",
    node: "13.0",
    opera: "65",
    safari: "7.1"
  },
    "es.math.imul": {
    android: "4.4",
    chrome: "28",
    edge: "13",
    electron: "0.20",
    firefox: "20",
    ios: "9.0",
    node: "0.11.1",
    opera: "16",
    opera_mobile: "16",
    safari: "9.0",
    samsung: "1.5"
  },
    "es.math.log10": {
    chrome: "38",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    ios: "8.0",
    node: "0.11.15",
    opera: "25",
    opera_mobile: "25",
    safari: "7.1",
    samsung: "3.0"
  },
    "es.math.log1p": {
    chrome: "38",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    ios: "8.0",
    node: "0.11.15",
    opera: "25",
    opera_mobile: "25",
    safari: "7.1",
    samsung: "3.0"
  },
    "es.math.log2": {
    chrome: "38",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    ios: "8.0",
    node: "0.11.15",
    opera: "25",
    opera_mobile: "25",
    safari: "7.1",
    samsung: "3.0"
  },
    "es.math.sign": {
    chrome: "38",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    ios: "9.0",
    node: "0.11.15",
    opera: "25",
    opera_mobile: "25",
    safari: "9.0",
    samsung: "3.0"
  },
    "es.math.sinh": {
    chrome: "39",
    edge: "13",
    electron: "0.20",
    firefox: "25",
    ios: "8.0",
    node: "1.0",
    opera: "26",
    opera_mobile: "26",
    safari: "7.1",
    samsung: "3.4"
  },
    "es.math.tanh": {
    chrome: "38",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    ios: "8.0",
    node: "0.11.15",
    opera: "25",
    opera_mobile: "25",
    safari: "7.1",
    samsung: "3.0"
  },
    "es.math.to-string-tag": {
    chrome: "50",
    edge: "15",
    electron: "1.1",
    firefox: "51",
    ios: "10.0",
    node: "6.0",
    opera: "37",
    opera_mobile: "37",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.math.trunc": {
    chrome: "38",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    ios: "8.0",
    node: "0.11.15",
    opera: "25",
    opera_mobile: "25",
    safari: "7.1",
    samsung: "3.0"
  },
    "es.number.constructor": {
    chrome: "41",
    edge: "13",
    electron: "0.21",
    firefox: "46",
    ios: "9.0",
    node: "1.0",
    opera: "28",
    opera_mobile: "28",
    safari: "9.0",
    samsung: "3.4"
  },
    "es.number.epsilon": {
    chrome: "34",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    ios: "9.0",
    node: "0.11.13",
    opera: "21",
    opera_mobile: "21",
    safari: "9.0",
    samsung: "2.0"
  },
    "es.number.is-finite": {
    android: "4.1",
    chrome: "19",
    edge: "12",
    electron: "0.20",
    firefox: "16",
    ios: "9.0",
    node: "0.7.3",
    opera: "15",
    opera_mobile: "15",
    safari: "9.0",
    samsung: "1.5"
  },
    "es.number.is-integer": {
    chrome: "34",
    edge: "12",
    electron: "0.20",
    firefox: "16",
    ios: "9.0",
    node: "0.11.13",
    opera: "21",
    opera_mobile: "21",
    safari: "9.0",
    samsung: "2.0"
  },
    "es.number.is-nan": {
    android: "4.1",
    chrome: "19",
    edge: "12",
    electron: "0.20",
    firefox: "15",
    ios: "9.0",
    node: "0.7.3",
    opera: "15",
    opera_mobile: "15",
    safari: "9.0",
    samsung: "1.5"
  },
    "es.number.is-safe-integer": {
    chrome: "34",
    edge: "12",
    electron: "0.20",
    firefox: "32",
    ios: "9.0",
    node: "0.11.13",
    opera: "21",
    opera_mobile: "21",
    safari: "9.0",
    samsung: "2.0"
  },
    "es.number.max-safe-integer": {
    chrome: "34",
    edge: "12",
    electron: "0.20",
    firefox: "31",
    ios: "9.0",
    node: "0.11.13",
    opera: "21",
    opera_mobile: "21",
    safari: "9.0",
    samsung: "2.0"
  },
    "es.number.min-safe-integer": {
    chrome: "34",
    edge: "12",
    electron: "0.20",
    firefox: "31",
    ios: "9.0",
    node: "0.11.13",
    opera: "21",
    opera_mobile: "21",
    safari: "9.0",
    samsung: "2.0"
  },
    "es.number.parse-float": {
    chrome: "35",
    edge: "13",
    electron: "0.20",
    firefox: "39",
    ios: "11.0",
    node: "0.11.13",
    opera: "22",
    opera_mobile: "22",
    safari: "11.0",
    samsung: "3.0"
  },
    "es.number.parse-int": {
    chrome: "35",
    edge: "13",
    electron: "0.20",
    firefox: "39",
    ios: "9.0",
    node: "0.11.13",
    opera: "22",
    opera_mobile: "22",
    safari: "9.0",
    samsung: "3.0"
  },
    "es.number.to-fixed": {
    android: "4.4",
    chrome: "26",
    edge: "74",
    electron: "0.20",
    firefox: "4",
    ios: "8.0",
    node: "0.11.0",
    opera: "16",
    opera_mobile: "16",
    safari: "7.1",
    samsung: "1.5"
  },
    "es.number.to-precision": {
    android: "4.4",
    chrome: "26",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    ie: "8",
    ios: "8.0",
    node: "0.11.0",
    opera: "16",
    opera_mobile: "16",
    safari: "7.1",
    samsung: "1.5"
  },
    "es.object.assign": {
    chrome: "49",
    edge: "74",
    electron: "0.37",
    firefox: "36",
    ios: "9.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.object.create": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    ie: "9",
    ios: "3.2",
    node: "0.1.27",
    opera: "12",
    opera_mobile: "12",
    phantom: "1.9",
    safari: "4.0",
    samsung: "1.0"
  },
    "es.object.define-getter": {
    chrome: "62",
    edge: "16",
    electron: "3.0",
    firefox: "48",
    ios: "8.0",
    node: "8.10",
    opera: "49",
    opera_mobile: "46",
    safari: "7.1",
    samsung: "8.0"
  },
    "es.object.define-properties": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    ie: "9",
    ios: "5.1",
    node: "0.1.27",
    opera: "12",
    opera_mobile: "12",
    phantom: "2.0",
    safari: "5.1",
    samsung: "1.0"
  },
    "es.object.define-property": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    ie: "9",
    ios: "5.1",
    node: "0.1.27",
    opera: "12",
    opera_mobile: "12",
    phantom: "2.0",
    safari: "5.1",
    samsung: "1.0"
  },
    "es.object.define-setter": {
    chrome: "62",
    edge: "16",
    electron: "3.0",
    firefox: "48",
    ios: "8.0",
    node: "8.10",
    opera: "49",
    opera_mobile: "46",
    safari: "7.1",
    samsung: "8.0"
  },
    "es.object.entries": {
    chrome: "54",
    edge: "14",
    electron: "1.4",
    firefox: "47",
    ios: "10.3",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    safari: "10.1",
    samsung: "6.0"
  },
    "es.object.freeze": {
    chrome: "44",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    ios: "9.0",
    node: "3.0",
    opera: "31",
    opera_mobile: "31",
    safari: "9.0",
    samsung: "4.0"
  },
    "es.object.from-entries": {
    chrome: "73",
    edge: "74",
    electron: "5.0",
    firefox: "63",
    ios: "12.2",
    node: "12.0",
    opera: "60",
    opera_mobile: "52",
    safari: "12.1",
    samsung: "11.0"
  },
    "es.object.get-own-property-descriptor": {
    chrome: "44",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    ios: "9.0",
    node: "3.0",
    opera: "31",
    opera_mobile: "31",
    safari: "9.0",
    samsung: "4.0"
  },
    "es.object.get-own-property-descriptors": {
    chrome: "54",
    edge: "15",
    electron: "1.4",
    firefox: "50",
    ios: "10.0",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    safari: "10.0",
    samsung: "6.0"
  },
    "es.object.get-own-property-names": {
    chrome: "40",
    edge: "13",
    electron: "0.21",
    firefox: "34",
    ios: "9.0",
    node: "1.0",
    opera: "27",
    opera_mobile: "27",
    safari: "9.0",
    samsung: "3.4"
  },
    "es.object.get-prototype-of": {
    chrome: "44",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    ios: "9.0",
    node: "3.0",
    opera: "31",
    opera_mobile: "31",
    safari: "9.0",
    samsung: "4.0"
  },
    "es.object.is": {
    android: "4.1",
    chrome: "19",
    edge: "12",
    electron: "0.20",
    firefox: "22",
    ios: "9.0",
    node: "0.7.3",
    opera: "15",
    opera_mobile: "15",
    safari: "9.0",
    samsung: "1.5"
  },
    "es.object.is-extensible": {
    chrome: "44",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    ios: "9.0",
    node: "3.0",
    opera: "31",
    opera_mobile: "31",
    safari: "9.0",
    samsung: "4.0"
  },
    "es.object.is-frozen": {
    chrome: "44",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    ios: "9.0",
    node: "3.0",
    opera: "31",
    opera_mobile: "31",
    safari: "9.0",
    samsung: "4.0"
  },
    "es.object.is-sealed": {
    chrome: "44",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    ios: "9.0",
    node: "3.0",
    opera: "31",
    opera_mobile: "31",
    safari: "9.0",
    samsung: "4.0"
  },
    "es.object.keys": {
    chrome: "40",
    edge: "13",
    electron: "0.21",
    firefox: "35",
    ios: "9.0",
    node: "1.0",
    opera: "27",
    opera_mobile: "27",
    safari: "9.0",
    samsung: "3.4"
  },
    "es.object.lookup-getter": {
    chrome: "62",
    edge: "16",
    electron: "3.0",
    firefox: "48",
    ios: "8.0",
    node: "8.10",
    opera: "49",
    opera_mobile: "46",
    safari: "7.1",
    samsung: "8.0"
  },
    "es.object.lookup-setter": {
    chrome: "62",
    edge: "16",
    electron: "3.0",
    firefox: "48",
    ios: "8.0",
    node: "8.10",
    opera: "49",
    opera_mobile: "46",
    safari: "7.1",
    samsung: "8.0"
  },
    "es.object.prevent-extensions": {
    chrome: "44",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    ios: "9.0",
    node: "3.0",
    opera: "31",
    opera_mobile: "31",
    safari: "9.0",
    samsung: "4.0"
  },
    "es.object.seal": {
    chrome: "44",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    ios: "9.0",
    node: "3.0",
    opera: "31",
    opera_mobile: "31",
    safari: "9.0",
    samsung: "4.0"
  },
    "es.object.set-prototype-of": {
    chrome: "34",
    edge: "12",
    electron: "0.20",
    firefox: "31",
    ie: "11",
    ios: "9.0",
    node: "0.11.13",
    opera: "21",
    opera_mobile: "21",
    safari: "9.0",
    samsung: "2.0"
  },
    "es.object.to-string": {
    chrome: "49",
    edge: "15",
    electron: "0.37",
    firefox: "51",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.object.values": {
    chrome: "54",
    edge: "14",
    electron: "1.4",
    firefox: "47",
    ios: "10.3",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    safari: "10.1",
    samsung: "6.0"
  },
    "es.parse-float": {
    chrome: "35",
    edge: "12",
    electron: "0.20",
    firefox: "8",
    ie: "8",
    ios: "8.0",
    node: "0.11.13",
    opera: "22",
    opera_mobile: "22",
    safari: "7.1",
    samsung: "3.0"
  },
    "es.parse-int": {
    chrome: "35",
    edge: "12",
    electron: "0.20",
    firefox: "21",
    ie: "9",
    ios: "8.0",
    node: "0.11.13",
    opera: "22",
    opera_mobile: "22",
    safari: "7.1",
    samsung: "3.0"
  },
    "es.promise": {
    chrome: "67",
    edge: "74",
    electron: "4.0",
    firefox: "69",
    ios: "11.0",
    node: "10.4",
    opera: "54",
    opera_mobile: "48",
    safari: "11.0",
    samsung: "9.0"
  },
    "es.promise.all-settled": {
    chrome: "76",
    edge: "76",
    electron: "6.0",
    firefox: "71",
    ios: "13.0",
    node: "12.9",
    opera: "63",
    opera_mobile: "54",
    safari: "13"
  },
    "es.promise.finally": {
    chrome: "67",
    edge: "74",
    electron: "4.0",
    firefox: "69",
    ios: "13.2.3",
    node: "10.4",
    opera: "54",
    opera_mobile: "48",
    safari: "13.0.3",
    samsung: "9.0"
  },
    "es.reflect.apply": {
    chrome: "49",
    edge: "15",
    electron: "0.37",
    firefox: "42",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.reflect.construct": {
    chrome: "49",
    edge: "15",
    electron: "0.37",
    firefox: "44",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.reflect.define-property": {
    chrome: "49",
    edge: "13",
    electron: "0.37",
    firefox: "42",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.reflect.delete-property": {
    chrome: "49",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.reflect.get": {
    chrome: "49",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.reflect.get-own-property-descriptor": {
    chrome: "49",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.reflect.get-prototype-of": {
    chrome: "49",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.reflect.has": {
    chrome: "49",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.reflect.is-extensible": {
    chrome: "49",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.reflect.own-keys": {
    chrome: "49",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.reflect.prevent-extensions": {
    chrome: "49",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.reflect.set": {
    chrome: "49",
    edge: "74",
    electron: "0.37",
    firefox: "42",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.reflect.set-prototype-of": {
    chrome: "49",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.regexp.constructor": {
    chrome: "51",
    edge: "74",
    electron: "1.2",
    firefox: "49",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.regexp.exec": {
    android: "4.4",
    chrome: "26",
    edge: "13",
    electron: "0.20",
    firefox: "44",
    ios: "10.0",
    node: "0.11.0",
    opera: "16",
    opera_mobile: "16",
    safari: "10.0",
    samsung: "1.5"
  },
    "es.regexp.flags": {
    chrome: "49",
    edge: "74",
    electron: "0.37",
    firefox: "37",
    ios: "9.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "9.0",
    samsung: "5.0"
  },
    "es.regexp.sticky": {
    chrome: "49",
    edge: "13",
    electron: "0.37",
    firefox: "3",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.regexp.test": {
    chrome: "51",
    edge: "74",
    electron: "1.2",
    firefox: "46",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.regexp.to-string": {
    chrome: "50",
    edge: "74",
    electron: "1.1",
    firefox: "46",
    ios: "10.0",
    node: "6.0",
    opera: "37",
    opera_mobile: "37",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.set": {
    chrome: "51",
    edge: "15",
    electron: "1.2",
    firefox: "53",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.string.code-point-at": {
    chrome: "41",
    edge: "13",
    electron: "0.21",
    firefox: "29",
    ios: "9.0",
    node: "1.0",
    opera: "28",
    opera_mobile: "28",
    safari: "9.0",
    samsung: "3.4"
  },
    "es.string.ends-with": {
    chrome: "51",
    edge: "74",
    electron: "1.2",
    firefox: "40",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.string.from-code-point": {
    chrome: "41",
    edge: "13",
    electron: "0.21",
    firefox: "29",
    ios: "9.0",
    node: "1.0",
    opera: "28",
    opera_mobile: "28",
    safari: "9.0",
    samsung: "3.4"
  },
    "es.string.includes": {
    chrome: "51",
    edge: "74",
    electron: "1.2",
    firefox: "40",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.string.iterator": {
    chrome: "39",
    edge: "13",
    electron: "0.20",
    firefox: "36",
    ios: "9.0",
    node: "1.0",
    opera: "26",
    opera_mobile: "26",
    safari: "9.0",
    samsung: "3.4"
  },
    "es.string.match": {
    chrome: "51",
    edge: "74",
    electron: "1.2",
    firefox: "49",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.string.match-all": {
    chrome: "80",
    edge: "80",
    electron: "8.0",
    firefox: "73",
    opera: "67",
    safari: "13.1"
  },
    "es.string.pad-end": {
    chrome: "57",
    edge: "15",
    electron: "1.7",
    firefox: "48",
    ios: "11.0",
    node: "8.0",
    opera: "44",
    opera_mobile: "43",
    safari: "11.0",
    samsung: "7.0"
  },
    "es.string.pad-start": {
    chrome: "57",
    edge: "15",
    electron: "1.7",
    firefox: "48",
    ios: "11.0",
    node: "8.0",
    opera: "44",
    opera_mobile: "43",
    safari: "11.0",
    samsung: "7.0"
  },
    "es.string.raw": {
    chrome: "41",
    edge: "13",
    electron: "0.21",
    firefox: "34",
    ios: "9.0",
    node: "1.0",
    opera: "28",
    opera_mobile: "28",
    safari: "9.0",
    samsung: "3.4"
  },
    "es.string.repeat": {
    chrome: "41",
    edge: "13",
    electron: "0.21",
    firefox: "24",
    ios: "9.0",
    node: "1.0",
    opera: "28",
    opera_mobile: "28",
    safari: "9.0",
    samsung: "3.4"
  },
    "es.string.replace": {
    chrome: "64",
    edge: "74",
    electron: "3.0",
    node: "10.0",
    opera: "51",
    opera_mobile: "47",
    samsung: "9.0"
  },
    "es.string.search": {
    chrome: "51",
    edge: "74",
    electron: "1.2",
    firefox: "49",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.string.split": {
    chrome: "54",
    edge: "74",
    electron: "1.4",
    firefox: "49",
    ios: "10.0",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    safari: "10.0",
    samsung: "6.0"
  },
    "es.string.starts-with": {
    chrome: "51",
    edge: "74",
    electron: "1.2",
    firefox: "40",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.string.trim": {
    chrome: "59",
    edge: "15",
    electron: "1.8",
    firefox: "52",
    ios: "12.2",
    node: "8.3",
    opera: "46",
    opera_mobile: "43",
    safari: "12.1",
    samsung: "7.0"
  },
    "es.string.trim-end": {
    chrome: "66",
    edge: "74",
    electron: "3.0",
    firefox: "61",
    ios: "12.2",
    node: "10.0",
    opera: "53",
    opera_mobile: "47",
    safari: "12.1",
    samsung: "9.0"
  },
    "es.string.trim-start": {
    chrome: "66",
    edge: "74",
    electron: "3.0",
    firefox: "61",
    ios: "12.0",
    node: "10.0",
    opera: "53",
    opera_mobile: "47",
    safari: "12.0",
    samsung: "9.0"
  },
    "es.string.anchor": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "17",
    ios: "6.0",
    node: "0.1.27",
    opera: "15",
    opera_mobile: "15",
    phantom: "2.0",
    safari: "6.0",
    samsung: "1.0"
  },
    "es.string.big": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    ios: "2.0",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "3.1",
    samsung: "1.0"
  },
    "es.string.blink": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    ios: "2.0",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "3.1",
    samsung: "1.0"
  },
    "es.string.bold": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    ios: "2.0",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "3.1",
    samsung: "1.0"
  },
    "es.string.fixed": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    ios: "2.0",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "3.1",
    samsung: "1.0"
  },
    "es.string.fontcolor": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "17",
    ios: "6.0",
    node: "0.1.27",
    opera: "15",
    opera_mobile: "15",
    phantom: "2.0",
    safari: "6.0",
    samsung: "1.0"
  },
    "es.string.fontsize": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "17",
    ios: "6.0",
    node: "0.1.27",
    opera: "15",
    opera_mobile: "15",
    phantom: "2.0",
    safari: "6.0",
    samsung: "1.0"
  },
    "es.string.italics": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    ios: "2.0",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "3.1",
    samsung: "1.0"
  },
    "es.string.link": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "17",
    ios: "6.0",
    node: "0.1.27",
    opera: "15",
    opera_mobile: "15",
    phantom: "2.0",
    safari: "6.0",
    samsung: "1.0"
  },
    "es.string.small": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    ios: "2.0",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "3.1",
    samsung: "1.0"
  },
    "es.string.strike": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    ios: "2.0",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "3.1",
    samsung: "1.0"
  },
    "es.string.sub": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    ios: "2.0",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "3.1",
    samsung: "1.0"
  },
    "es.string.sup": {
    android: "3.0",
    chrome: "5",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    ios: "2.0",
    node: "0.1.27",
    opera: "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    safari: "3.1",
    samsung: "1.0"
  },
    "es.typed-array.float32-array": {
    chrome: "54",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    samsung: "6.0"
  },
    "es.typed-array.float64-array": {
    chrome: "54",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    samsung: "6.0"
  },
    "es.typed-array.int8-array": {
    chrome: "54",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    samsung: "6.0"
  },
    "es.typed-array.int16-array": {
    chrome: "54",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    samsung: "6.0"
  },
    "es.typed-array.int32-array": {
    chrome: "54",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    samsung: "6.0"
  },
    "es.typed-array.uint8-array": {
    chrome: "54",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    samsung: "6.0"
  },
    "es.typed-array.uint8-clamped-array": {
    chrome: "54",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    samsung: "6.0"
  },
    "es.typed-array.uint16-array": {
    chrome: "54",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    samsung: "6.0"
  },
    "es.typed-array.uint32-array": {
    chrome: "54",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    samsung: "6.0"
  },
    "es.typed-array.copy-within": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "34",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.every": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.fill": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.filter": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "38",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.find": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.find-index": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.for-each": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "38",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.from": {
    chrome: "54",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    samsung: "6.0"
  },
    "es.typed-array.includes": {
    chrome: "49",
    edge: "14",
    electron: "0.37",
    firefox: "43",
    ios: "10.0",
    node: "6.0",
    opera: "36",
    opera_mobile: "36",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.index-of": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.iterator": {
    chrome: "47",
    edge: "13",
    electron: "0.36",
    firefox: "37",
    ios: "10.0",
    node: "6.0",
    opera: "34",
    opera_mobile: "34",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.join": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.last-index-of": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.map": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "38",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.of": {
    chrome: "54",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    node: "7.0",
    opera: "41",
    opera_mobile: "41",
    samsung: "6.0"
  },
    "es.typed-array.reduce": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.reduce-right": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.reverse": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.set": {
    android: "4.4",
    chrome: "26",
    edge: "13",
    electron: "0.20",
    firefox: "15",
    ios: "8.0",
    node: "0.11.0",
    opera: "16",
    opera_mobile: "16",
    safari: "7.1",
    samsung: "1.5"
  },
    "es.typed-array.slice": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "38",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.some": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.sort": {
    chrome: "45",
    edge: "13",
    electron: "0.31",
    firefox: "46",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.subarray": {
    android: "4.4",
    chrome: "26",
    edge: "13",
    electron: "0.20",
    firefox: "15",
    ios: "8.0",
    node: "0.11.0",
    opera: "16",
    opera_mobile: "16",
    safari: "7.1",
    samsung: "1.5"
  },
    "es.typed-array.to-locale-string": {
    chrome: "45",
    edge: "74",
    electron: "0.31",
    firefox: "51",
    ios: "10.0",
    node: "4.0",
    opera: "32",
    opera_mobile: "32",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.typed-array.to-string": {
    chrome: "51",
    edge: "13",
    electron: "1.2",
    firefox: "51",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.weak-map": {
    chrome: "51",
    edge: "15",
    electron: "1.2",
    firefox: "53",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "es.weak-set": {
    chrome: "51",
    edge: "15",
    electron: "1.2",
    firefox: "53",
    ios: "10.0",
    node: "6.5",
    opera: "38",
    opera_mobile: "38",
    safari: "10.0",
    samsung: "5.0"
  },
    "esnext.aggregate-error": {
  },
    "esnext.array.is-template-object": {
  },
    "esnext.array.last-index": {
  },
    "esnext.array.last-item": {
  },
    "esnext.async-iterator.constructor": {
  },
    "esnext.async-iterator.as-indexed-pairs": {
  },
    "esnext.async-iterator.drop": {
  },
    "esnext.async-iterator.every": {
  },
    "esnext.async-iterator.filter": {
  },
    "esnext.async-iterator.find": {
  },
    "esnext.async-iterator.flat-map": {
  },
    "esnext.async-iterator.for-each": {
  },
    "esnext.async-iterator.from": {
  },
    "esnext.async-iterator.map": {
  },
    "esnext.async-iterator.reduce": {
  },
    "esnext.async-iterator.some": {
  },
    "esnext.async-iterator.take": {
  },
    "esnext.async-iterator.to-array": {
  },
    "esnext.composite-key": {
  },
    "esnext.composite-symbol": {
  },
    "esnext.global-this": {
    chrome: "71",
    edge: "74",
    electron: "5.0",
    firefox: "65",
    ios: "12.2",
    node: "12.0",
    opera: "58",
    opera_mobile: "50",
    safari: "12.1",
    samsung: "10.0"
  },
    "esnext.iterator.constructor": {
  },
    "esnext.iterator.as-indexed-pairs": {
  },
    "esnext.iterator.drop": {
  },
    "esnext.iterator.every": {
  },
    "esnext.iterator.filter": {
  },
    "esnext.iterator.find": {
  },
    "esnext.iterator.flat-map": {
  },
    "esnext.iterator.for-each": {
  },
    "esnext.iterator.from": {
  },
    "esnext.iterator.map": {
  },
    "esnext.iterator.reduce": {
  },
    "esnext.iterator.some": {
  },
    "esnext.iterator.take": {
  },
    "esnext.iterator.to-array": {
  },
    "esnext.map.delete-all": {
  },
    "esnext.map.every": {
  },
    "esnext.map.filter": {
  },
    "esnext.map.find": {
  },
    "esnext.map.find-key": {
  },
    "esnext.map.from": {
  },
    "esnext.map.group-by": {
  },
    "esnext.map.includes": {
  },
    "esnext.map.key-by": {
  },
    "esnext.map.key-of": {
  },
    "esnext.map.map-keys": {
  },
    "esnext.map.map-values": {
  },
    "esnext.map.merge": {
  },
    "esnext.map.of": {
  },
    "esnext.map.reduce": {
  },
    "esnext.map.some": {
  },
    "esnext.map.update": {
  },
    "esnext.map.update-or-insert": {
  },
    "esnext.map.upsert": {
  },
    "esnext.math.clamp": {
  },
    "esnext.math.deg-per-rad": {
  },
    "esnext.math.degrees": {
  },
    "esnext.math.fscale": {
  },
    "esnext.math.iaddh": {
  },
    "esnext.math.imulh": {
  },
    "esnext.math.isubh": {
  },
    "esnext.math.rad-per-deg": {
  },
    "esnext.math.radians": {
  },
    "esnext.math.scale": {
  },
    "esnext.math.seeded-prng": {
  },
    "esnext.math.signbit": {
  },
    "esnext.math.umulh": {
  },
    "esnext.number.from-string": {
  },
    "esnext.object.iterate-entries": {
  },
    "esnext.object.iterate-keys": {
  },
    "esnext.object.iterate-values": {
  },
    "esnext.observable": {
  },
    "esnext.promise.all-settled": {
    chrome: "76",
    edge: "76",
    electron: "6.0",
    firefox: "71",
    ios: "13.0",
    node: "12.9",
    opera: "63",
    opera_mobile: "54",
    safari: "13"
  },
    "esnext.promise.any": {
  },
    "esnext.promise.try": {
  },
    "esnext.reflect.define-metadata": {
  },
    "esnext.reflect.delete-metadata": {
  },
    "esnext.reflect.get-metadata": {
  },
    "esnext.reflect.get-metadata-keys": {
  },
    "esnext.reflect.get-own-metadata": {
  },
    "esnext.reflect.get-own-metadata-keys": {
  },
    "esnext.reflect.has-metadata": {
  },
    "esnext.reflect.has-own-metadata": {
  },
    "esnext.reflect.metadata": {
  },
    "esnext.set.add-all": {
  },
    "esnext.set.delete-all": {
  },
    "esnext.set.difference": {
  },
    "esnext.set.every": {
  },
    "esnext.set.filter": {
  },
    "esnext.set.find": {
  },
    "esnext.set.from": {
  },
    "esnext.set.intersection": {
  },
    "esnext.set.is-disjoint-from": {
  },
    "esnext.set.is-subset-of": {
  },
    "esnext.set.is-superset-of": {
  },
    "esnext.set.join": {
  },
    "esnext.set.map": {
  },
    "esnext.set.of": {
  },
    "esnext.set.reduce": {
  },
    "esnext.set.some": {
  },
    "esnext.set.symmetric-difference": {
  },
    "esnext.set.union": {
  },
    "esnext.string.at": {
  },
    "esnext.string.code-points": {
  },
    "esnext.string.match-all": {
    chrome: "80",
    edge: "80",
    electron: "8.0",
    firefox: "73",
    opera: "67",
    safari: "13.1"
  },
    "esnext.string.replace-all": {
  },
    "esnext.symbol.async-dispose": {
  },
    "esnext.symbol.dispose": {
  },
    "esnext.symbol.observable": {
  },
    "esnext.symbol.pattern-match": {
  },
    "esnext.symbol.replace-all": {
  },
    "esnext.weak-map.delete-all": {
  },
    "esnext.weak-map.from": {
  },
    "esnext.weak-map.of": {
  },
    "esnext.weak-map.upsert": {
  },
    "esnext.weak-set.add-all": {
  },
    "esnext.weak-set.delete-all": {
  },
    "esnext.weak-set.from": {
  },
    "esnext.weak-set.of": {
  },
    "web.dom-collections.for-each": {
    chrome: "58",
    edge: "16",
    electron: "1.7",
    firefox: "50",
    ios: "10.0",
    node: "0.0.1",
    opera: "45",
    opera_mobile: "43",
    safari: "10.0",
    samsung: "7.0"
  },
    "web.dom-collections.iterator": {
    chrome: "66",
    edge: "74",
    electron: "3.0",
    firefox: "60",
    node: "0.0.1",
    opera: "53",
    opera_mobile: "47",
    safari: "13.1",
    samsung: "9.0"
  },
    "web.immediate": {
    ie: "10",
    node: "0.9.1"
  },
    "web.queue-microtask": {
    chrome: "71",
    edge: "74",
    electron: "5.0",
    firefox: "69",
    ios: "12.2",
    node: "12.0",
    opera: "58",
    opera_mobile: "50",
    safari: "12.1",
    samsung: "10.0"
  },
    "web.timers": {
    android: "1.5",
    chrome: "1",
    edge: "12",
    electron: "0.20",
    firefox: "1",
    ie: "10",
    ios: "1.0",
    node: "0.0.1",
    opera: "7",
    opera_mobile: "7",
    phantom: "1.9",
    safari: "1.0",
    samsung: "1.0"
  },
    "web.url": {
    chrome: "67",
    edge: "74",
    electron: "4.0",
    firefox: "57",
    node: "10.0",
    opera: "54",
    opera_mobile: "48",
    samsung: "9.0"
  },
    "web.url.to-json": {
    chrome: "71",
    edge: "74",
    electron: "5.0",
    firefox: "57",
    node: "10.0",
    opera: "58",
    opera_mobile: "50",
    samsung: "10.0"
  },
    "web.url-search-params": {
    chrome: "67",
    edge: "74",
    electron: "4.0",
    firefox: "57",
    node: "10.0",
    opera: "54",
    opera_mobile: "48",
    samsung: "9.0"
  }
  };

  var leven_1$1 = createCommonjsModule(function (module) {

  var array = [];
  var charCodeCache = [];

  var leven = function leven(left, right) {
    if (left === right) {
      return 0;
    }

    var swap = left;

    if (left.length > right.length) {
      left = right;
      right = swap;
    }

    var leftLength = left.length;
    var rightLength = right.length;

    while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
      leftLength--;
      rightLength--;
    }

    var start = 0;

    while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
      start++;
    }

    leftLength -= start;
    rightLength -= start;

    if (leftLength === 0) {
      return rightLength;
    }

    var bCharCode;
    var result;
    var temp;
    var temp2;
    var i = 0;
    var j = 0;

    while (i < leftLength) {
      charCodeCache[i] = left.charCodeAt(start + i);
      array[i] = ++i;
    }

    while (j < rightLength) {
      bCharCode = right.charCodeAt(start + j);
      temp = j++;
      result = j;

      for (i = 0; i < leftLength; i++) {
        temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;
        temp = array[i];
        result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
      }
    }

    return result;
  };

  module.exports = leven;
  module.exports["default"] = leven;
  });

  function levenArray$1(str, array) {
    var minLeven = Number.POSITIVE_INFINITY;
    var result = undefined;

    for (var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var item = _ref;
      var distance = leven_1$1(str, item);

      if (distance < minLeven) {
        minLeven = distance;
        result = item;
      }
    }

    return result;
  }

  var invariant$1 = function invariant(condition, format, a, b, c, d, e, f) {
    {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }

    if (!condition) {
      var error;

      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1;
      throw error;
    }
  };

  var browser$8 = invariant$1;

  var corejs2BuiltIns = {
    "es6.array.copy-within": {
    chrome: "45",
    edge: "12",
    firefox: "32",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "5",
    opera: "32",
    electron: "0.35"
  },
    "es6.array.every": {
    chrome: "5",
    opera: "10.10",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.array.fill": {
    chrome: "45",
    edge: "12",
    firefox: "31",
    safari: "7.1",
    node: "4",
    ios: "8",
    samsung: "5",
    opera: "32",
    electron: "0.35"
  },
    "es6.array.filter": {
    chrome: "5",
    opera: "10.10",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.array.find": {
    chrome: "45",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "4",
    ios: "8",
    samsung: "5",
    opera: "32",
    electron: "0.35"
  },
    "es6.array.find-index": {
    chrome: "45",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "4",
    ios: "8",
    samsung: "5",
    opera: "32",
    electron: "0.35"
  },
    "es7.array.flat-map": {
    chrome: "69",
    edge: "79",
    firefox: "62",
    safari: "12",
    node: "11",
    ios: "12",
    samsung: "10",
    opera: "56",
    electron: "4.2"
  },
    "es6.array.for-each": {
    chrome: "5",
    opera: "10.10",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.array.from": {
    chrome: "51",
    edge: "15",
    firefox: "36",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es7.array.includes": {
    chrome: "47",
    edge: "14",
    firefox: "43",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "34",
    electron: "0.36"
  },
    "es6.array.index-of": {
    chrome: "5",
    opera: "10.10",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.array.is-array": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "4",
    safari: "4",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.array.iterator": {
    chrome: "38",
    edge: "12",
    firefox: "28",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.array.last-index-of": {
    chrome: "5",
    opera: "10.10",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.array.map": {
    chrome: "5",
    opera: "10.10",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.array.of": {
    chrome: "45",
    edge: "12",
    firefox: "25",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "5",
    opera: "32",
    electron: "0.35"
  },
    "es6.array.reduce": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "3",
    safari: "4",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.array.reduce-right": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "3",
    safari: "4",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.array.some": {
    chrome: "5",
    opera: "10.10",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.array.sort": {
    chrome: "63",
    opera: "50",
    edge: "12",
    firefox: "5",
    safari: "12",
    node: "10",
    ie: "9",
    ios: "12",
    samsung: "8",
    electron: "3.1"
  },
    "es6.array.species": {
    chrome: "51",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.date.now": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "2",
    safari: "4",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.date.to-iso-string": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "3.5",
    safari: "4",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.date.to-json": {
    chrome: "5",
    opera: "12.10",
    edge: "12",
    firefox: "4",
    safari: "10",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "10",
    samsung: "1",
    electron: "1.1"
  },
    "es6.date.to-primitive": {
    chrome: "47",
    edge: "15",
    firefox: "44",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "34",
    electron: "0.36"
  },
    "es6.date.to-string": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.10",
    ie: "10",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.function.bind": {
    chrome: "7",
    opera: "12",
    edge: "12",
    firefox: "4",
    safari: "5.1",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "5"
  },
    "es6.function.has-instance": {
    chrome: "51",
    edge: "15",
    firefox: "50",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.function.name": {
    chrome: "5",
    opera: "10.50",
    edge: "14",
    firefox: "2",
    safari: "4",
    node: "0.10",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.map": {
    chrome: "51",
    edge: "15",
    firefox: "53",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.math.acosh": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.asinh": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.atanh": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.cbrt": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.clz32": {
    chrome: "38",
    edge: "12",
    firefox: "31",
    safari: "9",
    node: "0.12",
    ios: "9",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.cosh": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.expm1": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.fround": {
    chrome: "38",
    edge: "12",
    firefox: "26",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.hypot": {
    chrome: "38",
    edge: "12",
    firefox: "27",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.imul": {
    chrome: "30",
    edge: "12",
    firefox: "23",
    safari: "7",
    node: "0.12",
    android: "4.4",
    ios: "7",
    samsung: "2",
    opera: "17",
    electron: "0.2"
  },
    "es6.math.log1p": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.log10": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.log2": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.sign": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "9",
    node: "0.12",
    ios: "9",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.sinh": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.tanh": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.math.trunc": {
    chrome: "38",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    ios: "8",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.number.constructor": {
    chrome: "41",
    edge: "12",
    firefox: "36",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    opera: "28",
    electron: "0.24"
  },
    "es6.number.epsilon": {
    chrome: "34",
    edge: "12",
    firefox: "25",
    safari: "9",
    node: "0.12",
    ios: "9",
    samsung: "2",
    opera: "21",
    electron: "0.2"
  },
    "es6.number.is-finite": {
    chrome: "19",
    edge: "12",
    firefox: "16",
    safari: "9",
    node: "0.12",
    android: "4.1",
    ios: "9",
    samsung: "1.5",
    opera: "15",
    electron: "0.2"
  },
    "es6.number.is-integer": {
    chrome: "34",
    edge: "12",
    firefox: "16",
    safari: "9",
    node: "0.12",
    ios: "9",
    samsung: "2",
    opera: "21",
    electron: "0.2"
  },
    "es6.number.is-nan": {
    chrome: "19",
    edge: "12",
    firefox: "15",
    safari: "9",
    node: "0.12",
    android: "4.1",
    ios: "9",
    samsung: "1.5",
    opera: "15",
    electron: "0.2"
  },
    "es6.number.is-safe-integer": {
    chrome: "34",
    edge: "12",
    firefox: "32",
    safari: "9",
    node: "0.12",
    ios: "9",
    samsung: "2",
    opera: "21",
    electron: "0.2"
  },
    "es6.number.max-safe-integer": {
    chrome: "34",
    edge: "12",
    firefox: "31",
    safari: "9",
    node: "0.12",
    ios: "9",
    samsung: "2",
    opera: "21",
    electron: "0.2"
  },
    "es6.number.min-safe-integer": {
    chrome: "34",
    edge: "12",
    firefox: "31",
    safari: "9",
    node: "0.12",
    ios: "9",
    samsung: "2",
    opera: "21",
    electron: "0.2"
  },
    "es6.number.parse-float": {
    chrome: "34",
    edge: "12",
    firefox: "25",
    safari: "9",
    node: "0.12",
    ios: "9",
    samsung: "2",
    opera: "21",
    electron: "0.2"
  },
    "es6.number.parse-int": {
    chrome: "34",
    edge: "12",
    firefox: "25",
    safari: "9",
    node: "0.12",
    ios: "9",
    samsung: "2",
    opera: "21",
    electron: "0.2"
  },
    "es6.object.assign": {
    chrome: "49",
    edge: "13",
    firefox: "36",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.object.create": {
    chrome: "5",
    opera: "12",
    edge: "12",
    firefox: "4",
    safari: "4",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es7.object.define-getter": {
    chrome: "62",
    edge: "16",
    firefox: "48",
    safari: "9",
    node: "8.10",
    ios: "9",
    samsung: "8",
    opera: "49",
    electron: "3.1"
  },
    "es7.object.define-setter": {
    chrome: "62",
    edge: "16",
    firefox: "48",
    safari: "9",
    node: "8.10",
    ios: "9",
    samsung: "8",
    opera: "49",
    electron: "3.1"
  },
    "es6.object.define-property": {
    chrome: "5",
    opera: "12",
    edge: "12",
    firefox: "4",
    safari: "5.1",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.object.define-properties": {
    chrome: "5",
    opera: "12",
    edge: "12",
    firefox: "4",
    safari: "4",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es7.object.entries": {
    chrome: "54",
    edge: "14",
    firefox: "47",
    safari: "10.1",
    node: "7",
    ios: "10.3",
    samsung: "6",
    opera: "41",
    electron: "1.5"
  },
    "es6.object.freeze": {
    chrome: "44",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    opera: "31",
    electron: "0.31"
  },
    "es6.object.get-own-property-descriptor": {
    chrome: "44",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    opera: "31",
    electron: "0.31"
  },
    "es7.object.get-own-property-descriptors": {
    chrome: "54",
    edge: "15",
    firefox: "50",
    safari: "10.1",
    node: "7",
    ios: "10.3",
    samsung: "6",
    opera: "41",
    electron: "1.5"
  },
    "es6.object.get-own-property-names": {
    chrome: "40",
    edge: "12",
    firefox: "33",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    opera: "27",
    electron: "0.21"
  },
    "es6.object.get-prototype-of": {
    chrome: "44",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    opera: "31",
    electron: "0.31"
  },
    "es7.object.lookup-getter": {
    chrome: "62",
    edge: "79",
    firefox: "36",
    safari: "9",
    node: "8.10",
    ios: "9",
    samsung: "8",
    opera: "49",
    electron: "3.1"
  },
    "es7.object.lookup-setter": {
    chrome: "62",
    edge: "79",
    firefox: "36",
    safari: "9",
    node: "8.10",
    ios: "9",
    samsung: "8",
    opera: "49",
    electron: "3.1"
  },
    "es6.object.prevent-extensions": {
    chrome: "44",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    opera: "31",
    electron: "0.31"
  },
    "es6.object.to-string": {
    chrome: "57",
    edge: "15",
    firefox: "51",
    safari: "10",
    node: "8",
    ios: "10",
    samsung: "7",
    opera: "44",
    electron: "1.7"
  },
    "es6.object.is": {
    chrome: "19",
    edge: "12",
    firefox: "22",
    safari: "9",
    node: "0.12",
    android: "4.1",
    ios: "9",
    samsung: "1.5",
    opera: "15",
    electron: "0.2"
  },
    "es6.object.is-frozen": {
    chrome: "44",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    opera: "31",
    electron: "0.31"
  },
    "es6.object.is-sealed": {
    chrome: "44",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    opera: "31",
    electron: "0.31"
  },
    "es6.object.is-extensible": {
    chrome: "44",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    opera: "31",
    electron: "0.31"
  },
    "es6.object.keys": {
    chrome: "40",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    opera: "27",
    electron: "0.21"
  },
    "es6.object.seal": {
    chrome: "44",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    opera: "31",
    electron: "0.31"
  },
    "es6.object.set-prototype-of": {
    chrome: "34",
    edge: "12",
    firefox: "31",
    safari: "9",
    node: "0.12",
    ie: "11",
    ios: "9",
    samsung: "2",
    opera: "21",
    electron: "0.2"
  },
    "es7.object.values": {
    chrome: "54",
    edge: "14",
    firefox: "47",
    safari: "10.1",
    node: "7",
    ios: "10.3",
    samsung: "6",
    opera: "41",
    electron: "1.5"
  },
    "es6.promise": {
    chrome: "51",
    edge: "14",
    firefox: "45",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es7.promise.finally": {
    chrome: "63",
    edge: "18",
    firefox: "58",
    safari: "11.1",
    node: "10",
    ios: "11.3",
    samsung: "8",
    opera: "50",
    electron: "3.1"
  },
    "es6.reflect.apply": {
    chrome: "49",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.reflect.construct": {
    chrome: "49",
    edge: "13",
    firefox: "49",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.reflect.define-property": {
    chrome: "49",
    edge: "13",
    firefox: "42",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.reflect.delete-property": {
    chrome: "49",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.reflect.get": {
    chrome: "49",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.reflect.get-own-property-descriptor": {
    chrome: "49",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.reflect.get-prototype-of": {
    chrome: "49",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.reflect.has": {
    chrome: "49",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.reflect.is-extensible": {
    chrome: "49",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.reflect.own-keys": {
    chrome: "49",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.reflect.prevent-extensions": {
    chrome: "49",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.reflect.set": {
    chrome: "49",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.reflect.set-prototype-of": {
    chrome: "49",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.regexp.constructor": {
    chrome: "50",
    edge: "79",
    firefox: "40",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "37",
    electron: "1.1"
  },
    "es6.regexp.flags": {
    chrome: "49",
    edge: "79",
    firefox: "37",
    safari: "9",
    node: "6",
    ios: "9",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "es6.regexp.match": {
    chrome: "50",
    edge: "79",
    firefox: "49",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "37",
    electron: "1.1"
  },
    "es6.regexp.replace": {
    chrome: "50",
    edge: "79",
    firefox: "49",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "37",
    electron: "1.1"
  },
    "es6.regexp.split": {
    chrome: "50",
    edge: "79",
    firefox: "49",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "37",
    electron: "1.1"
  },
    "es6.regexp.search": {
    chrome: "50",
    edge: "79",
    firefox: "49",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "37",
    electron: "1.1"
  },
    "es6.regexp.to-string": {
    chrome: "50",
    edge: "79",
    firefox: "39",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "37",
    electron: "1.1"
  },
    "es6.set": {
    chrome: "51",
    edge: "15",
    firefox: "53",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.symbol": {
    chrome: "51",
    edge: "79",
    firefox: "51",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es7.symbol.async-iterator": {
    chrome: "63",
    edge: "79",
    firefox: "57",
    safari: "12",
    node: "10",
    ios: "12",
    samsung: "8",
    opera: "50",
    electron: "3.1"
  },
    "es6.string.anchor": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es6.string.big": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es6.string.blink": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es6.string.bold": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es6.string.code-point-at": {
    chrome: "41",
    edge: "12",
    firefox: "29",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    opera: "28",
    electron: "0.24"
  },
    "es6.string.ends-with": {
    chrome: "41",
    edge: "12",
    firefox: "29",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    opera: "28",
    electron: "0.24"
  },
    "es6.string.fixed": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es6.string.fontcolor": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es6.string.fontsize": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es6.string.from-code-point": {
    chrome: "41",
    edge: "12",
    firefox: "29",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    opera: "28",
    electron: "0.24"
  },
    "es6.string.includes": {
    chrome: "41",
    edge: "12",
    firefox: "40",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    opera: "28",
    electron: "0.24"
  },
    "es6.string.italics": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es6.string.iterator": {
    chrome: "38",
    edge: "12",
    firefox: "36",
    safari: "9",
    node: "0.12",
    ios: "9",
    samsung: "3",
    opera: "25",
    electron: "0.2"
  },
    "es6.string.link": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es7.string.pad-start": {
    chrome: "57",
    edge: "15",
    firefox: "48",
    safari: "10",
    node: "8",
    ios: "10",
    samsung: "7",
    opera: "44",
    electron: "1.7"
  },
    "es7.string.pad-end": {
    chrome: "57",
    edge: "15",
    firefox: "48",
    safari: "10",
    node: "8",
    ios: "10",
    samsung: "7",
    opera: "44",
    electron: "1.7"
  },
    "es6.string.raw": {
    chrome: "41",
    edge: "12",
    firefox: "34",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    opera: "28",
    electron: "0.24"
  },
    "es6.string.repeat": {
    chrome: "41",
    edge: "12",
    firefox: "24",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    opera: "28",
    electron: "0.24"
  },
    "es6.string.small": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es6.string.starts-with": {
    chrome: "41",
    edge: "12",
    firefox: "29",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    opera: "28",
    electron: "0.24"
  },
    "es6.string.strike": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es6.string.sub": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es6.string.sup": {
    chrome: "5",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.10",
    android: "4",
    ios: "7",
    phantom: "2",
    samsung: "1",
    opera: "15",
    electron: "1.1"
  },
    "es6.string.trim": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "3.5",
    safari: "4",
    node: "0.10",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es7.string.trim-left": {
    chrome: "66",
    edge: "79",
    firefox: "61",
    safari: "12",
    node: "10",
    ios: "12",
    samsung: "9",
    opera: "53",
    electron: "3.1"
  },
    "es7.string.trim-right": {
    chrome: "66",
    edge: "79",
    firefox: "61",
    safari: "12",
    node: "10",
    ios: "12",
    samsung: "9",
    opera: "53",
    electron: "3.1"
  },
    "es6.typed.array-buffer": {
    chrome: "51",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.typed.data-view": {
    chrome: "5",
    opera: "12",
    edge: "12",
    firefox: "15",
    safari: "5.1",
    node: "0.10",
    ie: "10",
    android: "4",
    ios: "6",
    phantom: "2",
    samsung: "1",
    electron: "1.1"
  },
    "es6.typed.int8-array": {
    chrome: "51",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.typed.uint8-array": {
    chrome: "51",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.typed.uint8-clamped-array": {
    chrome: "51",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.typed.int16-array": {
    chrome: "51",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.typed.uint16-array": {
    chrome: "51",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.typed.int32-array": {
    chrome: "51",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.typed.uint32-array": {
    chrome: "51",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.typed.float32-array": {
    chrome: "51",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.typed.float64-array": {
    chrome: "51",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.weak-map": {
    chrome: "51",
    edge: "15",
    firefox: "53",
    safari: "9",
    node: "6.5",
    ios: "9",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "es6.weak-set": {
    chrome: "51",
    edge: "15",
    firefox: "53",
    safari: "9",
    node: "6.5",
    ios: "9",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  }
  };

  var corejs2BuiltIns$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': corejs2BuiltIns
  });

  var require$$0$4 = getCjsExportFromNamespace(corejs2BuiltIns$1);

  var corejs2BuiltIns$2 = require$$0$4;

  var pluginBugfixes = {
    "transform-async-to-generator": {
    chrome: "55",
    edge: "15",
    firefox: "52",
    safari: "10.1",
    node: "7.6",
    ios: "10.3",
    samsung: "6",
    opera: "42",
    electron: "1.6"
  },
    "bugfix/transform-async-arrows-in-class": {
    chrome: "55",
    edge: "15",
    firefox: "52",
    safari: "11",
    node: "7.6",
    ios: "11",
    samsung: "6",
    opera: "42",
    electron: "1.6"
  },
    "transform-parameters": {
    chrome: "49",
    edge: "15",
    firefox: "53",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "bugfix/transform-edge-default-parameters": {
    chrome: "49",
    edge: "18",
    firefox: "52",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "transform-function-name": {
    chrome: "51",
    edge: "14",
    firefox: "53",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "bugfix/transform-edge-function-name": {
    chrome: "51",
    edge: "79",
    firefox: "53",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    opera: "38",
    electron: "1.2"
  },
    "transform-block-scoping": {
    chrome: "49",
    edge: "14",
    firefox: "51",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "bugfix/transform-safari-block-shadowing": {
    chrome: "49",
    edge: "12",
    firefox: "44",
    safari: "11",
    node: "6",
    ie: "11",
    ios: "11",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "bugfix/transform-safari-for-shadowing": {
    chrome: "49",
    edge: "12",
    firefox: "4",
    safari: "11",
    node: "6",
    ie: "11",
    ios: "11",
    samsung: "5",
    opera: "36",
    electron: "1"
  },
    "transform-template-literals": {
    chrome: "41",
    edge: "13",
    firefox: "34",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    opera: "28",
    electron: "0.24"
  },
    "bugfix/transform-tagged-template-caching": {
    chrome: "41",
    edge: "12",
    firefox: "34",
    safari: "13",
    node: "4",
    ios: "13",
    samsung: "3.4",
    opera: "28",
    electron: "0.24"
  }
  };

  var pluginBugfixes$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': pluginBugfixes
  });

  var require$$0$5 = getCjsExportFromNamespace(pluginBugfixes$1);

  var pluginBugfixes$2 = require$$0$5;

  var lib$e = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-async-generators",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("asyncGenerators");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxAsyncGenerators$2 = unwrapExports(lib$e);

  var lib$f = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-dynamic-import",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("dynamicImport");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxDynamicImport$2 = unwrapExports(lib$f);

  var lib$g = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-json-strings",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("jsonStrings");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxJsonStrings$1 = unwrapExports(lib$g);

  var lib$h = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-nullish-coalescing-operator",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("nullishCoalescingOperator");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxNullishCoalescingOperator$1 = unwrapExports(lib$h);

  var lib$i = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-object-rest-spread",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("objectRestSpread");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxObjectRestSpread$2 = unwrapExports(lib$i);

  var lib$j = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-optional-catch-binding",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("optionalCatchBinding");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxOptionalCatchBinding$2 = unwrapExports(lib$j);

  var lib$k = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-optional-chaining",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("optionalChaining");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxOptionalChaining$1 = unwrapExports(lib$k);

  var transformAsyncArrowsInClass = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;
  var OPTS = {
    allowInsertArrow: false,
    specCompliant: false
  };

  var _default = function _default(_ref) {
    var t = _ref.types;
    return {
      name: "transform-async-arrows-in-class",
      visitor: {
        ArrowFunctionExpression: function ArrowFunctionExpression(path) {
          if (path.node.async && path.findParent(t.isClassMethod)) {
            path.arrowFunctionToExpression(OPTS);
          }
        }
      }
    };
  };

  exports["default"] = _default;
  module.exports = exports["default"];
  });

  var bugfixAsyncArrowsInClass = unwrapExports(transformAsyncArrowsInClass);

  var transformEdgeDefaultParameters = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _default = function _default(_ref) {
    var t = _ref.types;

    var isArrowParent = function isArrowParent(p) {
      return p.parentKey === "params" && p.parentPath && t.isArrowFunctionExpression(p.parentPath);
    };

    return {
      name: "transform-edge-default-parameters",
      visitor: {
        AssignmentPattern: function AssignmentPattern(path) {
          var arrowArgParent = path.find(isArrowParent);

          if (arrowArgParent && path.parent.shorthand) {
            path.parent.shorthand = false;
            (path.parent.extra || {}).shorthand = false;
            path.scope.rename(path.parent.key.name);
          }
        }
      }
    };
  };

  exports["default"] = _default;
  module.exports = exports["default"];
  });

  var bugfixEdgeDefaultParameters = unwrapExports(transformEdgeDefaultParameters);

  var transformEdgeFunctionName = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _default = function _default(_ref) {
    var t = _ref.types;
    return {
      name: "transform-edge-function-name",
      visitor: {
        FunctionExpression: {
          exit: function exit(path) {
            if (!path.node.id && t.isIdentifier(path.parent.id)) {
              var id = t.cloneNode(path.parent.id);
              var binding = path.scope.getBinding(id.name);

              if (binding.constantViolations.length) {
                path.scope.rename(id.name);
              }

              path.node.id = id;
            }
          }
        }
      }
    };
  };

  exports["default"] = _default;
  module.exports = exports["default"];
  });

  var bugfixEdgeFunctionName = unwrapExports(transformEdgeFunctionName);

  var transformTaggedTemplateCaching = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _default = function _default(_ref) {
    var t = _ref.types;
    return {
      name: "transform-tagged-template-caching",
      visitor: {
        TaggedTemplateExpression: function TaggedTemplateExpression(path, state) {
          var processed = state.get("processed");

          if (!processed) {
            processed = new Map();
            state.set("processed", processed);
          }

          if (processed.has(path.node)) return path.skip();
          var expressions = path.node.quasi.expressions;
          var identity = state.get("identity");

          if (!identity) {
            identity = path.scope.getProgramParent().generateDeclaredUidIdentifier("_");
            state.set("identity", identity);
            var binding = path.scope.getBinding(identity.name);
            binding.path.get("init").replaceWith(t.arrowFunctionExpression([t.identifier("t")], t.identifier("t")));
          }

          var template = t.taggedTemplateExpression(identity, t.templateLiteral(path.node.quasi.quasis, expressions.map(function () {
            return t.numericLiteral(0);
          })));
          processed.set(template, true);
          var ident = path.scope.getProgramParent().generateDeclaredUidIdentifier("t");
          path.scope.getBinding(ident.name).path.parent.kind = "let";
          var inlineCache = t.logicalExpression("||", ident, t.assignmentExpression("=", ident, template));
          var node = t.callExpression(path.node.tag, [inlineCache].concat(expressions));
          path.replaceWith(node);
        }
      }
    };
  };

  exports["default"] = _default;
  module.exports = exports["default"];
  });

  var bugfixTaggedTemplateCaching = unwrapExports(transformTaggedTemplateCaching);

  var transformSafariBlockShadowing = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = _default;

  function _default(_ref) {
    var t = _ref.types;
    return {
      name: "transform-safari-block-shadowing",
      visitor: {
        VariableDeclarator: function VariableDeclarator(path) {
          var kind = path.parent.kind;
          if (kind !== "let" && kind !== "const") return;
          var block = path.scope.block;
          if (t.isFunction(block) || t.isProgram(block)) return;
          var bindings = t.getOuterBindingIdentifiers(path.node.id);

          for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
            var name = _Object$keys[_i];
            var scope = path.scope;
            if (!scope.hasOwnBinding(name)) continue;

            while (scope = scope.parent) {
              if (scope.hasOwnBinding(name)) {
                path.scope.rename(name);
                break;
              }

              if (t.isFunction(scope.block) || t.isProgram(scope.block)) {
                break;
              }
            }
          }
        }
      }
    };
  }

  module.exports = exports["default"];
  });

  var bugfixSafariBlockShadowing = unwrapExports(transformSafariBlockShadowing);

  var transformSafariForShadowing = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  function handle(declaration) {
    if (!declaration.isVariableDeclaration()) return;
    var fn = declaration.getFunctionParent();
    var name = declaration.node.declarations[0].id.name;

    if (fn && fn.scope.hasOwnBinding(name) && fn.scope.getOwnBinding(name).kind === "param") {
      declaration.scope.rename(name);
    }
  }

  var _default = function _default() {
    return {
      name: "transform-safari-for-shadowing",
      visitor: {
        ForXStatement: function ForXStatement(path) {
          handle(path.get("left"));
        },
        ForStatement: function ForStatement(path) {
          handle(path.get("init"));
        }
      }
    };
  };

  exports["default"] = _default;
  module.exports = exports["default"];
  });

  var bugfixSafariForShadowing = unwrapExports(transformSafariForShadowing);

  var availablePlugins = {
    "bugfix/transform-async-arrows-in-class": bugfixAsyncArrowsInClass,
    "bugfix/transform-edge-default-parameters": bugfixEdgeDefaultParameters,
    "bugfix/transform-edge-function-name": bugfixEdgeFunctionName,
    "bugfix/transform-safari-block-shadowing": bugfixSafariBlockShadowing,
    "bugfix/transform-safari-for-shadowing": bugfixSafariForShadowing,
    "bugfix/transform-tagged-template-caching": bugfixTaggedTemplateCaching,
    "proposal-async-generator-functions": proposalAsyncGeneratorFunctions,
    "proposal-dynamic-import": proposalDynamicImport,
    "proposal-json-strings": proposalJsonStrings,
    "proposal-nullish-coalescing-operator": proposalNullishCoalescingOperator,
    "proposal-numeric-separator": proposalNumericSeparator,
    "proposal-object-rest-spread": proposalObjectRestSpread,
    "proposal-optional-catch-binding": proposalOptionalCatchBinding,
    "proposal-optional-chaining": proposalOptionalChaining,
    "proposal-unicode-property-regex": proposalUnicodePropertyRegex,
    "syntax-async-generators": syntaxAsyncGenerators$2,
    "syntax-dynamic-import": syntaxDynamicImport$2,
    "syntax-json-strings": syntaxJsonStrings$1,
    "syntax-nullish-coalescing-operator": syntaxNullishCoalescingOperator$1,
    "syntax-numeric-separator": syntaxNumericSeparator,
    "syntax-object-rest-spread": syntaxObjectRestSpread$2,
    "syntax-optional-catch-binding": syntaxOptionalCatchBinding$2,
    "syntax-optional-chaining": syntaxOptionalChaining$1,
    "syntax-top-level-await": syntaxTopLevelAwait,
    "transform-arrow-functions": transformArrowFunctions,
    "transform-async-to-generator": transformAsyncToGenerator,
    "transform-block-scoped-functions": transformBlockScopedFunctions,
    "transform-block-scoping": transformBlockScoping,
    "transform-classes": transformClasses,
    "transform-computed-properties": transformComputedProperties,
    "transform-destructuring": transformDestructuring,
    "transform-dotall-regex": transformDotallRegex,
    "transform-duplicate-keys": transformDuplicateKeys,
    "transform-exponentiation-operator": transformExponentialOperator,
    "transform-for-of": transformForOf,
    "transform-function-name": transformFunctionName,
    "transform-literals": transformLiterals,
    "transform-member-expression-literals": transformMemberExpressionLiterals,
    "transform-modules-amd": transformModulesAmd,
    "transform-modules-commonjs": transformModulesCommonjs,
    "transform-modules-systemjs": transformModulesSystemjs,
    "transform-modules-umd": transformModulesUmd,
    "transform-named-capturing-groups-regex": transformNamedCapturingGroupsRegex,
    "transform-new-target": transformNewTarget,
    "transform-object-super": transformObjectSuper,
    "transform-parameters": transformParameters,
    "transform-property-literals": transformPropertyLiterals,
    "transform-regenerator": transformRegenerator,
    "transform-reserved-words": transformReservedWords,
    "transform-shorthand-properties": transformShorthandProperties,
    "transform-spread": transformSpread,
    "transform-sticky-regex": transformStickyRegex,
    "transform-template-literals": transformTemplateLiterals,
    "transform-typeof-symbol": transformTypeofSymbol,
    "transform-unicode-regex": transformUnicodeRegex
  };

  var pluginsFiltered = {};
  var bugfixPluginsFiltered = {};

  for (var _i$3 = 0, _Object$keys$1 = Object.keys(plugins$2); _i$3 < _Object$keys$1.length; _i$3++) {
    var plugin = _Object$keys$1[_i$3];

    if (Object.hasOwnProperty.call(availablePlugins, plugin)) {
      pluginsFiltered[plugin] = plugins$2[plugin];
    }
  }

  for (var _i2$1 = 0, _Object$keys2 = Object.keys(pluginBugfixes$2); _i2$1 < _Object$keys2.length; _i2$1++) {
    var _plugin = _Object$keys2[_i2$1];

    if (Object.hasOwnProperty.call(availablePlugins, _plugin)) {
      bugfixPluginsFiltered[_plugin] = pluginBugfixes$2[_plugin];
    }
  }

  var TopLevelOptions = {
    bugfixes: "bugfixes",
    configPath: "configPath",
    corejs: "corejs",
    debug: "debug",
    exclude: "exclude",
    forceAllTransforms: "forceAllTransforms",
    ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
    include: "include",
    loose: "loose",
    modules: "modules",
    shippedProposals: "shippedProposals",
    spec: "spec",
    targets: "targets",
    useBuiltIns: "useBuiltIns"
  };
  var ModulesOption = {
    "false": false,
    auto: "auto",
    amd: "amd",
    commonjs: "commonjs",
    cjs: "cjs",
    systemjs: "systemjs",
    umd: "umd"
  };
  var UseBuiltInsOption = {
    "false": false,
    entry: "entry",
    usage: "usage"
  };

  var defaultWebIncludes = ["web.timers", "web.immediate", "web.dom.iterable"];
  function getPlatformSpecificDefaultFor (targets) {
    var targetNames = Object.keys(targets);
    var isAnyTarget = !targetNames.length;
    var isWebTarget = targetNames.some(function (name) {
      return name !== "node";
    });
    return isAnyTarget || isWebTarget ? defaultWebIncludes : null;
  }

  var validateTopLevelOptions = function validateTopLevelOptions(options) {
    var validOptions = Object.keys(TopLevelOptions);

    for (var option in options) {
      if (!TopLevelOptions[option]) {
        throw new Error("Invalid Option: " + option + " is not a valid top-level option.\n        Maybe you meant to use '" + levenArray$1(option, validOptions) + "'?");
      }
    }
  };

  var allPluginsList = Object.keys(pluginsFiltered);
  var modulePlugins = ["proposal-dynamic-import"].concat(Object.keys(moduleTransformations).map(function (m) {
    return moduleTransformations[m];
  }));

  var getValidIncludesAndExcludes = function getValidIncludesAndExcludes(type, corejs) {
    return new Set([].concat(allPluginsList, type === "exclude" ? modulePlugins : [], corejs ? corejs == 2 ? [].concat(Object.keys(corejs2BuiltIns$2), defaultWebIncludes) : Object.keys(corejs3Polyfills) : []));
  };

  var pluginToRegExp = function pluginToRegExp(plugin) {
    if (plugin instanceof RegExp) return plugin;

    try {
      return new RegExp("^" + normalizePluginName(plugin) + "$");
    } catch (e) {
      return null;
    }
  };

  var selectPlugins = function selectPlugins(regexp, type, corejs) {
    return Array.from(getValidIncludesAndExcludes(type, corejs)).filter(function (item) {
      return regexp instanceof RegExp && regexp.test(item);
    });
  };

  var flatten$1 = function flatten(array) {
    var _ref;

    return (_ref = []).concat.apply(_ref, array);
  };

  var expandIncludesAndExcludes = function expandIncludesAndExcludes(plugins, type, corejs) {
    if (plugins === void 0) {
      plugins = [];
    }

    if (plugins.length === 0) return [];
    var selectedPlugins = plugins.map(function (plugin) {
      return selectPlugins(pluginToRegExp(plugin), type, corejs);
    });
    var invalidRegExpList = plugins.filter(function (p, i) {
      return selectedPlugins[i].length === 0;
    });
    browser$8(invalidRegExpList.length === 0, "Invalid Option: The plugins/built-ins '" + invalidRegExpList.join(", ") + "' passed to the '" + type + "' option are not\n    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env");
    return flatten$1(selectedPlugins);
  };

  var normalizePluginName = function normalizePluginName(plugin) {
    return plugin.replace(/^(@babel\/|babel-)(plugin-)?/, "");
  };
  var checkDuplicateIncludeExcludes = function checkDuplicateIncludeExcludes(include, exclude) {
    if (include === void 0) {
      include = [];
    }

    if (exclude === void 0) {
      exclude = [];
    }

    var duplicates = include.filter(function (opt) {
      return exclude.indexOf(opt) >= 0;
    });
    browser$8(duplicates.length === 0, "Invalid Option: The plugins/built-ins '" + duplicates.join(", ") + "' were found in both the \"include\" and\n    \"exclude\" options.");
  };

  var normalizeTargets = function normalizeTargets(targets) {
    if (typeof targets === "string" || Array.isArray(targets)) {
      return {
        browsers: targets
      };
    }

    return Object.assign({}, targets);
  };

  var validateConfigPathOption = function validateConfigPathOption(configPath) {
    if (configPath === void 0) {
      configPath = process.cwd();
    }

    browser$8(typeof configPath === "string", "Invalid Option: The configPath option '" + configPath + "' is invalid, only strings are allowed.");
    return configPath;
  };
  var validateBoolOption = function validateBoolOption(name, value, defaultValue) {
    if (typeof value === "undefined") {
      value = defaultValue;
    }

    if (typeof value !== "boolean") {
      throw new Error("Preset env: '" + name + "' option must be a boolean.");
    }

    return value;
  };
  var validateIgnoreBrowserslistConfig = function validateIgnoreBrowserslistConfig(ignoreBrowserslistConfig) {
    return validateBoolOption(TopLevelOptions.ignoreBrowserslistConfig, ignoreBrowserslistConfig, false);
  };
  var validateModulesOption = function validateModulesOption(modulesOpt) {
    if (modulesOpt === void 0) {
      modulesOpt = ModulesOption.auto;
    }

    browser$8(ModulesOption[modulesOpt.toString()] || ModulesOption[modulesOpt.toString()] === ModulesOption["false"], "Invalid Option: The 'modules' option must be one of \n" + " - 'false' to indicate no module processing\n" + " - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs'" + " - 'auto' (default) which will automatically select 'false' if the current\n" + "   process is known to support ES module syntax, or \"commonjs\" otherwise\n");
    return modulesOpt;
  };
  var validateUseBuiltInsOption = function validateUseBuiltInsOption(builtInsOpt) {
    if (builtInsOpt === void 0) {
      builtInsOpt = false;
    }

    browser$8(UseBuiltInsOption[builtInsOpt.toString()] || UseBuiltInsOption[builtInsOpt.toString()] === UseBuiltInsOption["false"], "Invalid Option: The 'useBuiltIns' option must be either\n    'false' (default) to indicate no polyfill,\n    '\"entry\"' to indicate replacing the entry polyfill, or\n    '\"usage\"' to import only used polyfills per file");
    return builtInsOpt;
  };
  function normalizeCoreJSOption(corejs, useBuiltIns) {
    var proposals = false;
    var rawVersion;

    if (useBuiltIns && corejs === undefined) {
      rawVersion = 2;
      console.warn("\nWARNING: We noticed you're using the `useBuiltIns` option without declaring a " + "core-js version. Currently, we assume version 2.x when no version " + "is passed. Since this default version will likely change in future " + "versions of Babel, we recommend explicitly setting the core-js version " + "you are using via the `corejs` option.\n" + "\nYou should also be sure that the version you pass to the `corejs` " + "option matches the version specified in your `package.json`'s " + "`dependencies` section. If it doesn't, you need to run one of the " + "following commands:\n\n" + "  npm install --save core-js@2    npm install --save core-js@3\n" + "  yarn add core-js@2              yarn add core-js@3\n");
    } else if (typeof corejs === "object" && corejs !== null) {
      rawVersion = corejs.version;
      proposals = Boolean(corejs.proposals);
    } else {
      rawVersion = corejs;
    }

    var version = rawVersion ? semver_42(String(rawVersion)) : false;

    if (!useBuiltIns && version) {
      console.log("\nThe `corejs` option only has an effect when the `useBuiltIns` option is not `false`\n");
    }

    if (useBuiltIns && (!version || version.major < 2 || version.major > 3)) {
      throw new RangeError("Invalid Option: The version passed to `corejs` is invalid. Currently, " + "only core-js@2 and core-js@3 are supported.");
    }

    return {
      version: version,
      proposals: proposals
    };
  }
  function normalizeOptions$4(opts) {
    validateTopLevelOptions(opts);
    var useBuiltIns = validateUseBuiltInsOption(opts.useBuiltIns);
    var corejs = normalizeCoreJSOption(opts.corejs, useBuiltIns);
    var include = expandIncludesAndExcludes(opts.include, TopLevelOptions.include, !!corejs.version && corejs.version.major);
    var exclude = expandIncludesAndExcludes(opts.exclude, TopLevelOptions.exclude, !!corejs.version && corejs.version.major);
    checkDuplicateIncludeExcludes(include, exclude);
    var shippedProposals = validateBoolOption(TopLevelOptions.shippedProposals, opts.shippedProposals, false);
    return {
      bugfixes: validateBoolOption(TopLevelOptions.bugfixes, opts.bugfixes, false),
      configPath: validateConfigPathOption(opts.configPath),
      corejs: corejs,
      debug: validateBoolOption(TopLevelOptions.debug, opts.debug, false),
      include: include,
      exclude: exclude,
      forceAllTransforms: validateBoolOption(TopLevelOptions.forceAllTransforms, opts.forceAllTransforms, false),
      ignoreBrowserslistConfig: validateIgnoreBrowserslistConfig(opts.ignoreBrowserslistConfig),
      loose: validateBoolOption(TopLevelOptions.loose, opts.loose, false),
      modules: validateModulesOption(opts.modules),
      shippedProposals: shippedProposals,
      spec: validateBoolOption(TopLevelOptions.spec, opts.spec, false),
      targets: normalizeTargets(opts.targets),
      useBuiltIns: useBuiltIns
    };
  }

  var proposalPlugins = {
    "proposal-numeric-separator": true
  };
  var pluginSyntaxObject = {
    "proposal-async-generator-functions": "syntax-async-generators",
    "proposal-json-strings": "syntax-json-strings",
    "proposal-nullish-coalescing-operator": "syntax-nullish-coalescing-operator",
    "proposal-numeric-separator": "syntax-numeric-separator",
    "proposal-object-rest-spread": "syntax-object-rest-spread",
    "proposal-optional-catch-binding": "syntax-optional-catch-binding",
    "proposal-optional-chaining": "syntax-optional-chaining",
    "proposal-unicode-property-regex": null
  };
  var pluginSyntaxEntries = Object.keys(pluginSyntaxObject).map(function (key) {
    return [key, pluginSyntaxObject[key]];
  });
  var pluginSyntaxMap = new Map(pluginSyntaxEntries);
  var shippedProposals = {
    pluginSyntaxMap: pluginSyntaxMap,
    proposalPlugins: proposalPlugins
  };
  var shippedProposals_1 = shippedProposals.pluginSyntaxMap;
  var shippedProposals_2 = shippedProposals.proposalPlugins;

  var overlappingPlugins = {
    "transform-async-to-generator": [
    "bugfix/transform-async-arrows-in-class"
  ],
    "transform-parameters": [
    "bugfix/transform-edge-default-parameters"
  ],
    "transform-function-name": [
    "bugfix/transform-edge-function-name"
  ],
    "transform-block-scoping": [
    "bugfix/transform-safari-block-shadowing",
    "bugfix/transform-safari-for-shadowing"
  ],
    "transform-template-literals": [
    "bugfix/transform-tagged-template-caching"
  ]
  };

  var overlappingPlugins$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': overlappingPlugins
  });

  var require$$0$6 = getCjsExportFromNamespace(overlappingPlugins$1);

  var overlappingPlugins$2 = require$$0$6;

  var ArrayNatureIterators = ["es6.object.to-string", "es6.array.iterator", "web.dom.iterable"];
  var CommonIterators = ["es6.string.iterator"].concat(ArrayNatureIterators);
  var PromiseDependencies = ["es6.object.to-string", "es6.promise"];
  var BuiltIns = {
    DataView: "es6.typed.data-view",
    Float32Array: "es6.typed.float32-array",
    Float64Array: "es6.typed.float64-array",
    Int8Array: "es6.typed.int8-array",
    Int16Array: "es6.typed.int16-array",
    Int32Array: "es6.typed.int32-array",
    Map: ["es6.map"].concat(CommonIterators),
    Number: "es6.number.constructor",
    Promise: PromiseDependencies,
    RegExp: ["es6.regexp.constructor"],
    Set: ["es6.set"].concat(CommonIterators),
    Symbol: ["es6.symbol", "es7.symbol.async-iterator"],
    Uint8Array: "es6.typed.uint8-array",
    Uint8ClampedArray: "es6.typed.uint8-clamped-array",
    Uint16Array: "es6.typed.uint16-array",
    Uint32Array: "es6.typed.uint32-array",
    WeakMap: ["es6.weak-map"].concat(CommonIterators),
    WeakSet: ["es6.weak-set"].concat(CommonIterators)
  };
  var InstanceProperties = {
    __defineGetter__: ["es7.object.define-getter"],
    __defineSetter__: ["es7.object.define-setter"],
    __lookupGetter__: ["es7.object.lookup-getter"],
    __lookupSetter__: ["es7.object.lookup-setter"],
    anchor: ["es6.string.anchor"],
    big: ["es6.string.big"],
    bind: ["es6.function.bind"],
    blink: ["es6.string.blink"],
    bold: ["es6.string.bold"],
    codePointAt: ["es6.string.code-point-at"],
    copyWithin: ["es6.array.copy-within"],
    endsWith: ["es6.string.ends-with"],
    entries: ArrayNatureIterators,
    every: ["es6.array.is-array"],
    fill: ["es6.array.fill"],
    filter: ["es6.array.filter"],
    "finally": ["es7.promise.finally"].concat(PromiseDependencies),
    find: ["es6.array.find"],
    findIndex: ["es6.array.find-index"],
    fixed: ["es6.string.fixed"],
    flags: ["es6.regexp.flags"],
    flatMap: ["es7.array.flat-map"],
    fontcolor: ["es6.string.fontcolor"],
    fontsize: ["es6.string.fontsize"],
    forEach: ["es6.array.for-each"],
    includes: ["es6.string.includes", "es7.array.includes"],
    indexOf: ["es6.array.index-of"],
    italics: ["es6.string.italics"],
    keys: ArrayNatureIterators,
    lastIndexOf: ["es6.array.last-index-of"],
    link: ["es6.string.link"],
    map: ["es6.array.map"],
    match: ["es6.regexp.match"],
    name: ["es6.function.name"],
    padStart: ["es7.string.pad-start"],
    padEnd: ["es7.string.pad-end"],
    reduce: ["es6.array.reduce"],
    reduceRight: ["es6.array.reduce-right"],
    repeat: ["es6.string.repeat"],
    replace: ["es6.regexp.replace"],
    search: ["es6.regexp.search"],
    slice: ["es6.array.slice"],
    small: ["es6.string.small"],
    some: ["es6.array.some"],
    sort: ["es6.array.sort"],
    split: ["es6.regexp.split"],
    startsWith: ["es6.string.starts-with"],
    strike: ["es6.string.strike"],
    sub: ["es6.string.sub"],
    sup: ["es6.string.sup"],
    toISOString: ["es6.date.to-iso-string"],
    toJSON: ["es6.date.to-json"],
    toString: ["es6.object.to-string", "es6.date.to-string", "es6.regexp.to-string"],
    trim: ["es6.string.trim"],
    trimEnd: ["es7.string.trim-right"],
    trimLeft: ["es7.string.trim-left"],
    trimRight: ["es7.string.trim-right"],
    trimStart: ["es7.string.trim-left"],
    values: ArrayNatureIterators
  };
  var StaticProperties = {
    Array: {
      from: ["es6.array.from", "es6.string.iterator"],
      isArray: "es6.array.is-array",
      of: "es6.array.of"
    },
    Date: {
      now: "es6.date.now"
    },
    Object: {
      assign: "es6.object.assign",
      create: "es6.object.create",
      defineProperty: "es6.object.define-property",
      defineProperties: "es6.object.define-properties",
      entries: "es7.object.entries",
      freeze: "es6.object.freeze",
      getOwnPropertyDescriptors: "es7.object.get-own-property-descriptors",
      getOwnPropertySymbols: "es6.symbol",
      is: "es6.object.is",
      isExtensible: "es6.object.is-extensible",
      isFrozen: "es6.object.is-frozen",
      isSealed: "es6.object.is-sealed",
      keys: "es6.object.keys",
      preventExtensions: "es6.object.prevent-extensions",
      seal: "es6.object.seal",
      setPrototypeOf: "es6.object.set-prototype-of",
      values: "es7.object.values"
    },
    Math: {
      acosh: "es6.math.acosh",
      asinh: "es6.math.asinh",
      atanh: "es6.math.atanh",
      cbrt: "es6.math.cbrt",
      clz32: "es6.math.clz32",
      cosh: "es6.math.cosh",
      expm1: "es6.math.expm1",
      fround: "es6.math.fround",
      hypot: "es6.math.hypot",
      imul: "es6.math.imul",
      log1p: "es6.math.log1p",
      log10: "es6.math.log10",
      log2: "es6.math.log2",
      sign: "es6.math.sign",
      sinh: "es6.math.sinh",
      tanh: "es6.math.tanh",
      trunc: "es6.math.trunc"
    },
    String: {
      fromCodePoint: "es6.string.from-code-point",
      raw: "es6.string.raw"
    },
    Number: {
      EPSILON: "es6.number.epsilon",
      MIN_SAFE_INTEGER: "es6.number.min-safe-integer",
      MAX_SAFE_INTEGER: "es6.number.max-safe-integer",
      isFinite: "es6.number.is-finite",
      isInteger: "es6.number.is-integer",
      isSafeInteger: "es6.number.is-safe-integer",
      isNaN: "es6.number.is-nan",
      parseFloat: "es6.number.parse-float",
      parseInt: "es6.number.parse-int"
    },
    Promise: {
      all: CommonIterators,
      race: CommonIterators
    },
    Reflect: {
      apply: "es6.reflect.apply",
      construct: "es6.reflect.construct",
      defineProperty: "es6.reflect.define-property",
      deleteProperty: "es6.reflect.delete-property",
      get: "es6.reflect.get",
      getOwnPropertyDescriptor: "es6.reflect.get-own-property-descriptor",
      getPrototypeOf: "es6.reflect.get-prototype-of",
      has: "es6.reflect.has",
      isExtensible: "es6.reflect.is-extensible",
      ownKeys: "es6.reflect.own-keys",
      preventExtensions: "es6.reflect.prevent-extensions",
      set: "es6.reflect.set",
      setPrototypeOf: "es6.reflect.set-prototype-of"
    }
  };

  var has$6 = Object.hasOwnProperty.call.bind(Object.hasOwnProperty);
  function getType$1(target) {
    return Object.prototype.toString.call(target).slice(8, -1).toLowerCase();
  }
  function intersection(first, second, third) {
    var result = new Set();

    for (var _iterator = first, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var el = _ref;
      if (second.has(el) && third.has(el)) result.add(el);
    }

    return result;
  }
  function filterStageFromList(list, stageList) {
    return Object.keys(list).reduce(function (result, item) {
      if (!stageList[item]) {
        result[item] = list[item];
      }

      return result;
    }, {});
  }
  function getImportSource(_ref2) {
    var node = _ref2.node;
    if (node.specifiers.length === 0) return node.source.value;
  }
  function getRequireSource(_ref3) {
    var node = _ref3.node;
    if (!isExpressionStatement(node)) return;
    var expression = node.expression;
    var isRequire = isCallExpression(expression) && isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && isStringLiteral(expression.arguments[0]);
    if (isRequire) return expression.arguments[0].value;
  }
  function isPolyfillSource(source) {
    return source === "@babel/polyfill" || source === "core-js";
  }
  var modulePathMap = {
    "regenerator-runtime": "regenerator-runtime/runtime"
  };
  function getModulePath(mod) {
    return modulePathMap[mod] || "core-js/modules/" + mod;
  }
  function createImport(path, mod) {
    return addSideEffect(path, getModulePath(mod));
  }
  function isNamespaced(path) {
    if (!path.node) return false;
    var binding = path.scope.getBinding(path.node.name);
    if (!binding) return false;
    return binding.path.isImportNamespaceSpecifier();
  }

  var NO_DIRECT_POLYFILL_IMPORT = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the `import '@babel/polyfill'` call or use `useBuiltIns: 'entry'` instead.";
  function addCoreJS2UsagePlugin (_ref, _ref2) {
    var t = _ref.types;
    var include = _ref2.include,
        exclude = _ref2.exclude,
        polyfillTargets = _ref2.polyfillTargets,
        debug = _ref2.debug;
    var polyfills = filterItems(corejs2BuiltIns$2, include, exclude, polyfillTargets, getPlatformSpecificDefaultFor(polyfillTargets));
    var addAndRemovePolyfillImports = {
      ImportDeclaration: function ImportDeclaration(path) {
        if (isPolyfillSource(getImportSource(path))) {
          console.warn(NO_DIRECT_POLYFILL_IMPORT);
          path.remove();
        }
      },
      Program: function Program(path) {
        path.get("body").forEach(function (bodyPath) {
          if (isPolyfillSource(getRequireSource(bodyPath))) {
            console.warn(NO_DIRECT_POLYFILL_IMPORT);
            bodyPath.remove();
          }
        });
      },
      ReferencedIdentifier: function ReferencedIdentifier(_ref3) {
        var name = _ref3.node.name,
            parent = _ref3.parent,
            scope = _ref3.scope;
        if (t.isMemberExpression(parent)) return;
        if (!has$6(BuiltIns, name)) return;
        if (scope.getBindingIdentifier(name)) return;
        var BuiltInDependencies = BuiltIns[name];
        this.addUnsupported(BuiltInDependencies);
      },
      CallExpression: function CallExpression(path) {
        if (path.node.arguments.length) return;
        var callee = path.node.callee;
        if (!t.isMemberExpression(callee)) return;
        if (!callee.computed) return;

        if (!path.get("callee.property").matchesPattern("Symbol.iterator")) {
          return;
        }

        this.addImport("web.dom.iterable");
      },
      BinaryExpression: function BinaryExpression(path) {
        if (path.node.operator !== "in") return;
        if (!path.get("left").matchesPattern("Symbol.iterator")) return;
        this.addImport("web.dom.iterable");
      },
      YieldExpression: function YieldExpression(path) {
        if (path.node.delegate) {
          this.addImport("web.dom.iterable");
        }
      },
      MemberExpression: {
        enter: function enter(path) {
          var node = path.node;
          var object = node.object,
              property = node.property;
          if (isNamespaced(path.get("object"))) return;
          var evaluatedPropType = object.name;
          var propertyName = "";
          var instanceType = "";

          if (node.computed) {
            if (t.isStringLiteral(property)) {
              propertyName = property.value;
            } else {
              var result = path.get("property").evaluate();

              if (result.confident && result.value) {
                propertyName = result.value;
              }
            }
          } else {
            propertyName = property.name;
          }

          if (path.scope.getBindingIdentifier(object.name)) {
            var _result = path.get("object").evaluate();

            if (_result.value) {
              instanceType = getType$1(_result.value);
            } else if (_result.deopt && _result.deopt.isIdentifier()) {
              evaluatedPropType = _result.deopt.node.name;
            }
          }

          if (has$6(StaticProperties, evaluatedPropType)) {
            var BuiltInProperties = StaticProperties[evaluatedPropType];

            if (has$6(BuiltInProperties, propertyName)) {
              var StaticPropertyDependencies = BuiltInProperties[propertyName];
              this.addUnsupported(StaticPropertyDependencies);
            }
          }

          if (has$6(InstanceProperties, propertyName)) {
            var InstancePropertyDependencies = InstanceProperties[propertyName];

            if (instanceType) {
              InstancePropertyDependencies = InstancePropertyDependencies.filter(function (module) {
                return module.includes(instanceType);
              });
            }

            this.addUnsupported(InstancePropertyDependencies);
          }
        },
        exit: function exit(path) {
          var name = path.node.object.name;
          if (!has$6(BuiltIns, name)) return;
          if (path.scope.getBindingIdentifier(name)) return;
          var BuiltInDependencies = BuiltIns[name];
          this.addUnsupported(BuiltInDependencies);
        }
      },
      VariableDeclarator: function VariableDeclarator(path) {
        var node = path.node;
        var id = node.id,
            init = node.init;
        if (!t.isObjectPattern(id)) return;
        if (init && path.scope.getBindingIdentifier(init.name)) return;

        for (var _iterator = id.properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref4;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref4 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref4 = _i.value;
          }

          var _ref5 = _ref4,
              key = _ref5.key;

          if (!node.computed && t.isIdentifier(key) && has$6(InstanceProperties, key.name)) {
            var InstancePropertyDependencies = InstanceProperties[key.name];
            this.addUnsupported(InstancePropertyDependencies);
          }
        }
      }
    };
    return {
      name: "corejs2-usage",
      pre: function pre(_ref6) {
        var path = _ref6.path;
        this.polyfillsSet = new Set();

        this.addImport = function (builtIn) {
          if (!this.polyfillsSet.has(builtIn)) {
            this.polyfillsSet.add(builtIn);
            createImport(path, builtIn);
          }
        };

        this.addUnsupported = function (builtIn) {
          var modules = Array.isArray(builtIn) ? builtIn : [builtIn];

          for (var _iterator2 = modules, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref7;

            if (_isArray2) {
              if (_i2 >= _iterator2.length) break;
              _ref7 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done) break;
              _ref7 = _i2.value;
            }

            var module = _ref7;

            if (polyfills.has(module)) {
              this.addImport(module);
            }
          }
        };
      },
      post: function post() {
        if (debug) {
          logUsagePolyfills(this.polyfillsSet, this.file.opts.filename, polyfillTargets, corejs2BuiltIns$2);
        }
      },
      visitor: addAndRemovePolyfillImports
    };
  }

  var corejs3ShippedProposals = [
    "esnext.global-this",
    "esnext.promise.all-settled",
    "esnext.string.match-all"
  ];

  var corejs3ShippedProposals$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': corejs3ShippedProposals
  });

  var require$$0$7 = getCjsExportFromNamespace(corejs3ShippedProposals$1);

  var corejs3ShippedProposals$2 = require$$0$7;

  var debug$2 = typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function () {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
  } : function () {};
  var debug_1 = debug$2;

  var SEMVER_SPEC_VERSION = '2.0.0';
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER$3 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var constants$1 = {
    SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
    MAX_LENGTH: MAX_LENGTH,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$3,
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH
  };

  var re_1 = createCommonjsModule(function (module, exports) {
  var MAX_SAFE_COMPONENT_LENGTH = constants$1.MAX_SAFE_COMPONENT_LENGTH;



  exports = module.exports = {};
  var re = exports.re = [];
  var src = exports.src = [];
  var t = exports.t = {};
  var R = 0;

  var createToken = function createToken(name, value, isGlobal) {
    var index = R++;
    debug_1(index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
  };

  createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
  createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');
  createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');
  createToken('MAINVERSION', "(" + src[t.NUMERICIDENTIFIER] + ")\\." + ("(" + src[t.NUMERICIDENTIFIER] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIER] + ")"));
  createToken('MAINVERSIONLOOSE', "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")"));
  createToken('PRERELEASEIDENTIFIER', "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
  createToken('PRERELEASEIDENTIFIERLOOSE', "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
  createToken('PRERELEASE', "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))");
  createToken('PRERELEASELOOSE', "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))");
  createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');
  createToken('BUILD', "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))");
  createToken('FULLPLAIN', "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?");
  createToken('FULL', "^" + src[t.FULLPLAIN] + "$");
  createToken('LOOSEPLAIN', "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?");
  createToken('LOOSE', "^" + src[t.LOOSEPLAIN] + "$");
  createToken('GTLT', '((?:<|>)?=?)');
  createToken('XRANGEIDENTIFIERLOOSE', src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*");
  createToken('XRANGEIDENTIFIER', src[t.NUMERICIDENTIFIER] + "|x|X|\\*");
  createToken('XRANGEPLAIN', "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?") + ")?)?");
  createToken('XRANGEPLAINLOOSE', "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?") + ")?)?");
  createToken('XRANGE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$");
  createToken('XRANGELOOSE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$");
  createToken('COERCE', "" + ('(^|[^\\d])' + '(\\d{1,') + MAX_SAFE_COMPONENT_LENGTH + "})" + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + "(?:$|[^\\d])");
  createToken('COERCERTL', src[t.COERCE], true);
  createToken('LONETILDE', '(?:~>?)');
  createToken('TILDETRIM', "(\\s*)" + src[t.LONETILDE] + "\\s+", true);
  exports.tildeTrimReplace = '$1~';
  createToken('TILDE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$");
  createToken('TILDELOOSE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$");
  createToken('LONECARET', '(?:\\^)');
  createToken('CARETTRIM', "(\\s*)" + src[t.LONECARET] + "\\s+", true);
  exports.caretTrimReplace = '$1^';
  createToken('CARET', "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$");
  createToken('CARETLOOSE', "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$");
  createToken('COMPARATORLOOSE', "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$");
  createToken('COMPARATOR', "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$");
  createToken('COMPARATORTRIM', "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")", true);
  exports.comparatorTrimReplace = '$1$2$3';
  createToken('HYPHENRANGE', "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAIN] + ")") + "\\s*$");
  createToken('HYPHENRANGELOOSE', "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAINLOOSE] + ")") + "\\s*$");
  createToken('STAR', '(<|>)?=?\\s*\\*');
  });
  var re_2 = re_1.re;
  var re_3 = re_1.src;
  var re_4 = re_1.t;
  var re_5 = re_1.tildeTrimReplace;
  var re_6 = re_1.caretTrimReplace;
  var re_7 = re_1.comparatorTrimReplace;

  var numeric = /^[0-9]+$/;

  var compareIdentifiers = function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);

    if (anum && bnum) {
      a = +a;
      b = +b;
    }

    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };

  var rcompareIdentifiers = function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  };

  var identifiers = {
    compareIdentifiers: compareIdentifiers,
    rcompareIdentifiers: rcompareIdentifiers
  };

  var MAX_LENGTH$1 = constants$1.MAX_LENGTH,
      MAX_SAFE_INTEGER$4 = constants$1.MAX_SAFE_INTEGER;

  var re = re_1.re,
      t$1 = re_1.t;

  var compareIdentifiers$1 = identifiers.compareIdentifiers;

  var SemVer = function () {

    function SemVer(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError("Invalid Version: " + version);
      }

      if (version.length > MAX_LENGTH$1) {
        throw new TypeError("version is longer than " + MAX_LENGTH$1 + " characters");
      }

      debug_1('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      var m = version.trim().match(options.loose ? re[t$1.LOOSE] : re[t$1.FULL]);

      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }

      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER$4 || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER$4 || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER$4 || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      }

      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER$4) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    var _proto = SemVer.prototype;

    _proto.format = function format() {
      this.version = this.major + "." + this.minor + "." + this.patch;

      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join('.');
      }

      return this.version;
    };

    _proto.toString = function toString() {
      return this.version;
    };

    _proto.compare = function compare(other) {
      debug_1('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        if (typeof other === 'string' && other === this.version) {
          return 0;
        }

        other = new SemVer(other, this.options);
      }

      if (other.version === this.version) {
        return 0;
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    _proto.compareMain = function compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers$1(this.major, other.major) || compareIdentifiers$1(this.minor, other.minor) || compareIdentifiers$1(this.patch, other.patch);
    };

    _proto.comparePre = function comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug_1('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers$1(a, b);
        }
      } while (++i);
    };

    _proto.compareBuild = function compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug_1('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers$1(a, b);
        }
      } while (++i);
    };

    _proto.inc = function inc(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error("invalid increment argument: " + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    return SemVer;
  }();

  var semver$1 = SemVer;

  var compare$2 = function compare(a, b, loose) {
    return new semver$1(a, loose).compare(new semver$1(b, loose));
  };

  var compare_1 = compare$2;

  var eq$1 = function eq(a, b, loose) {
    return compare_1(a, b, loose) === 0;
  };

  var eq_1$1 = eq$1;

  var neq = function neq(a, b, loose) {
    return compare_1(a, b, loose) !== 0;
  };

  var neq_1 = neq;

  var gt = function gt(a, b, loose) {
    return compare_1(a, b, loose) > 0;
  };

  var gt_1 = gt;

  var gte = function gte(a, b, loose) {
    return compare_1(a, b, loose) >= 0;
  };

  var gte_1 = gte;

  var lt = function lt(a, b, loose) {
    return compare_1(a, b, loose) < 0;
  };

  var lt_1 = lt;

  var lte = function lte(a, b, loose) {
    return compare_1(a, b, loose) <= 0;
  };

  var lte_1 = lte;

  var cmp = function cmp(a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a === b;

      case '!==':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a !== b;

      case '':
      case '=':
      case '==':
        return eq_1$1(a, b, loose);

      case '!=':
        return neq_1(a, b, loose);

      case '>':
        return gt_1(a, b, loose);

      case '>=':
        return gte_1(a, b, loose);

      case '<':
        return lt_1(a, b, loose);

      case '<=':
        return lte_1(a, b, loose);

      default:
        throw new TypeError("Invalid operator: " + op);
    }
  };

  var cmp_1 = cmp;

  var MAX_LENGTH$2 = constants$1.MAX_LENGTH;

  var re$1 = re_1.re,
      t$2 = re_1.t;



  var parse$7 = function parse(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (version instanceof semver$1) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    if (version.length > MAX_LENGTH$2) {
      return null;
    }

    var r = options.loose ? re$1[t$2.LOOSE] : re$1[t$2.FULL];

    if (!r.test(version)) {
      return null;
    }

    try {
      return new semver$1(version, options);
    } catch (er) {
      return null;
    }
  };

  var parse_1 = parse$7;

  var re$2 = re_1.re,
      t$3 = re_1.t;

  var coerce = function coerce(version, options) {
    if (version instanceof semver$1) {
      return version;
    }

    if (typeof version === 'number') {
      version = String(version);
    }

    if (typeof version !== 'string') {
      return null;
    }

    options = options || {};
    var match = null;

    if (!options.rtl) {
      match = version.match(re$2[t$3.COERCE]);
    } else {
      var next;

      while ((next = re$2[t$3.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }

        re$2[t$3.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }

      re$2[t$3.COERCERTL].lastIndex = -1;
    }

    if (match === null) return null;
    return parse_1(match[2] + "." + (match[3] || '0') + "." + (match[4] || '0'), options);
  };

  var coerce_1 = coerce;

  var has$7 = Function.call.bind({}.hasOwnProperty);

  function compare$3(a, operator, b) {
    return cmp_1(coerce_1(a), operator, coerce_1(b));
  }

  function intersection$1(list, order) {
    var set = list instanceof Set ? list : new Set(list);
    return order.filter(function (name) {
      return set.has(name);
    });
  }

  function sortObjectByKey(object, fn) {
    return Object.keys(object).sort(fn).reduce(function (memo, key) {
      memo[key] = object[key];
      return memo;
    }, {});
  }

  var helpers$1 = {
    compare: compare$3,
    has: has$7,
    intersection: intersection$1,
    semver: coerce_1,
    sortObjectByKey: sortObjectByKey
  };

  var modulesByVersions = {
    "3.0": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.to-string",
    "es.set",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string",
    "es.weak-map",
    "es.weak-set",
    "esnext.aggregate-error",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.immediate",
    "web.queue-microtask",
    "web.timers",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "3.1": [
    "es.string.match-all",
    "es.symbol.match-all",
    "esnext.symbol.replace-all"
  ],
    "3.2": [
    "es.promise.all-settled",
    "esnext.array.is-template-object",
    "esnext.map.update-or-insert",
    "esnext.symbol.async-dispose"
  ],
    "3.3": [
    "es.global-this",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.upsert",
    "esnext.weak-map.upsert"
  ],
    "3.4": [
    "es.json.stringify"
  ],
    "3.5": [
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values"
  ],
    "3.6": [
    "es.regexp.sticky",
    "es.regexp.test"
  ]
  };

  var modulesByVersions$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': modulesByVersions
  });

  var modules = [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.set",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string",
    "es.weak-map",
    "es.weak-set",
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.immediate",
    "web.queue-microtask",
    "web.timers",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ];

  var modules$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': modules
  });

  var modulesByVersions$2 = getCjsExportFromNamespace(modulesByVersions$1);

  var modules$2 = getCjsExportFromNamespace(modules$1);

  var compare$4 = helpers$1.compare,
      intersection$2 = helpers$1.intersection,
      semver$2 = helpers$1.semver;





  var getModulesListForTargetVersion = function (raw) {
    var corejs = semver$2(raw);

    if (corejs.major !== 3) {
      throw RangeError('This version of `core-js-compat` works only with `core-js@3`.');
    }

    var result = [];

    for (var _i = 0, _Object$keys = Object.keys(modulesByVersions$2); _i < _Object$keys.length; _i++) {
      var version = _Object$keys[_i];

      if (compare$4(version, '<=', corejs)) {
        result.push.apply(result, modulesByVersions$2[version]);
      }
    }

    return intersection$2(result, modules$2);
  };

  var ArrayNatureIterators$1 = ["es.array.iterator", "web.dom-collections.iterator"];
  var CommonIterators$1 = ["es.string.iterator"].concat(ArrayNatureIterators$1);
  var ArrayNatureIteratorsWithTag = ["es.object.to-string"].concat(ArrayNatureIterators$1);
  var CommonIteratorsWithTag = ["es.object.to-string"].concat(CommonIterators$1);
  var TypedArrayDependencies = ["es.typed-array.copy-within", "es.typed-array.every", "es.typed-array.fill", "es.typed-array.filter", "es.typed-array.find", "es.typed-array.find-index", "es.typed-array.for-each", "es.typed-array.includes", "es.typed-array.index-of", "es.typed-array.iterator", "es.typed-array.join", "es.typed-array.last-index-of", "es.typed-array.map", "es.typed-array.reduce", "es.typed-array.reduce-right", "es.typed-array.reverse", "es.typed-array.set", "es.typed-array.slice", "es.typed-array.some", "es.typed-array.sort", "es.typed-array.subarray", "es.typed-array.to-locale-string", "es.typed-array.to-string", "es.object.to-string", "es.array.iterator", "es.array-buffer.slice"];
  var TypedArrayStaticMethods = {
    from: "es.typed-array.from",
    of: "es.typed-array.of"
  };
  var PromiseDependencies$1 = ["es.promise", "es.object.to-string"];
  var PromiseDependenciesWithIterators = [].concat(PromiseDependencies$1, CommonIterators$1);
  var SymbolDependencies = ["es.symbol", "es.symbol.description", "es.object.to-string"];
  var MapDependencies = ["es.map", "esnext.map.delete-all", "esnext.map.every", "esnext.map.filter", "esnext.map.find", "esnext.map.find-key", "esnext.map.includes", "esnext.map.key-of", "esnext.map.map-keys", "esnext.map.map-values", "esnext.map.merge", "esnext.map.reduce", "esnext.map.some", "esnext.map.update"].concat(CommonIteratorsWithTag);
  var SetDependencies = ["es.set", "esnext.set.add-all", "esnext.set.delete-all", "esnext.set.difference", "esnext.set.every", "esnext.set.filter", "esnext.set.find", "esnext.set.intersection", "esnext.set.is-disjoint-from", "esnext.set.is-subset-of", "esnext.set.is-superset-of", "esnext.set.join", "esnext.set.map", "esnext.set.reduce", "esnext.set.some", "esnext.set.symmetric-difference", "esnext.set.union"].concat(CommonIteratorsWithTag);
  var WeakMapDependencies = ["es.weak-map", "esnext.weak-map.delete-all"].concat(CommonIteratorsWithTag);
  var WeakSetDependencies = ["es.weak-set", "esnext.weak-set.add-all", "esnext.weak-set.delete-all"].concat(CommonIteratorsWithTag);
  var URLSearchParamsDependencies = ["web.url"].concat(CommonIteratorsWithTag);
  var BuiltIns$1 = {
    AggregateError: ["esnext.aggregate-error"].concat(CommonIterators$1),
    ArrayBuffer: ["es.array-buffer.constructor", "es.array-buffer.slice", "es.object.to-string"],
    DataView: ["es.data-view", "es.array-buffer.slice", "es.object.to-string"],
    Date: ["es.date.to-string"],
    Float32Array: ["es.typed-array.float32-array"].concat(TypedArrayDependencies),
    Float64Array: ["es.typed-array.float64-array"].concat(TypedArrayDependencies),
    Int8Array: ["es.typed-array.int8-array"].concat(TypedArrayDependencies),
    Int16Array: ["es.typed-array.int16-array"].concat(TypedArrayDependencies),
    Int32Array: ["es.typed-array.int32-array"].concat(TypedArrayDependencies),
    Uint8Array: ["es.typed-array.uint8-array"].concat(TypedArrayDependencies),
    Uint8ClampedArray: ["es.typed-array.uint8-clamped-array"].concat(TypedArrayDependencies),
    Uint16Array: ["es.typed-array.uint16-array"].concat(TypedArrayDependencies),
    Uint32Array: ["es.typed-array.uint32-array"].concat(TypedArrayDependencies),
    Map: MapDependencies,
    Number: ["es.number.constructor"],
    Observable: ["esnext.observable", "esnext.symbol.observable", "es.object.to-string"].concat(CommonIteratorsWithTag),
    Promise: PromiseDependencies$1,
    RegExp: ["es.regexp.constructor", "es.regexp.exec", "es.regexp.to-string"],
    Set: SetDependencies,
    Symbol: SymbolDependencies,
    URL: ["web.url"].concat(URLSearchParamsDependencies),
    URLSearchParams: URLSearchParamsDependencies,
    WeakMap: WeakMapDependencies,
    WeakSet: WeakSetDependencies,
    clearImmediate: ["web.immediate"],
    compositeKey: ["esnext.composite-key"],
    compositeSymbol: ["esnext.composite-symbol"].concat(SymbolDependencies),
    fetch: PromiseDependencies$1,
    globalThis: ["es.global-this", "esnext.global-this"],
    parseFloat: ["es.parse-float"],
    parseInt: ["es.parse-int"],
    queueMicrotask: ["web.queue-microtask"],
    setTimeout: ["web.timers"],
    setInterval: ["web.timers"],
    setImmediate: ["web.immediate"]
  };
  var InstanceProperties$1 = {
    at: ["esnext.string.at"],
    anchor: ["es.string.anchor"],
    big: ["es.string.big"],
    bind: ["es.function.bind"],
    blink: ["es.string.blink"],
    bold: ["es.string.bold"],
    codePointAt: ["es.string.code-point-at"],
    codePoints: ["esnext.string.code-points"],
    concat: ["es.array.concat"],
    copyWithin: ["es.array.copy-within"],
    description: ["es.symbol", "es.symbol.description"],
    endsWith: ["es.string.ends-with"],
    entries: ArrayNatureIteratorsWithTag,
    every: ["es.array.every"],
    exec: ["es.regexp.exec"],
    fill: ["es.array.fill"],
    filter: ["es.array.filter"],
    "finally": ["es.promise.finally"].concat(PromiseDependencies$1),
    find: ["es.array.find"],
    findIndex: ["es.array.find-index"],
    fixed: ["es.string.fixed"],
    flags: ["es.regexp.flags"],
    flat: ["es.array.flat", "es.array.unscopables.flat"],
    flatMap: ["es.array.flat-map", "es.array.unscopables.flat-map"],
    fontcolor: ["es.string.fontcolor"],
    fontsize: ["es.string.fontsize"],
    forEach: ["es.array.for-each", "web.dom-collections.for-each"],
    includes: ["es.array.includes", "es.string.includes"],
    indexOf: ["es.array.index-of"],
    italics: ["es.string.italics"],
    join: ["es.array.join"],
    keys: ArrayNatureIteratorsWithTag,
    lastIndex: ["esnext.array.last-index"],
    lastIndexOf: ["es.array.last-index-of"],
    lastItem: ["esnext.array.last-item"],
    link: ["es.string.link"],
    match: ["es.string.match", "es.regexp.exec"],
    matchAll: ["es.string.match-all", "esnext.string.match-all"],
    map: ["es.array.map"],
    name: ["es.function.name"],
    padEnd: ["es.string.pad-end"],
    padStart: ["es.string.pad-start"],
    reduce: ["es.array.reduce"],
    reduceRight: ["es.array.reduce-right"],
    repeat: ["es.string.repeat"],
    replace: ["es.string.replace", "es.regexp.exec"],
    replaceAll: ["esnext.string.replace-all"],
    reverse: ["es.array.reverse"],
    search: ["es.string.search", "es.regexp.exec"],
    slice: ["es.array.slice"],
    small: ["es.string.small"],
    some: ["es.array.some"],
    sort: ["es.array.sort"],
    splice: ["es.array.splice"],
    split: ["es.string.split", "es.regexp.exec"],
    startsWith: ["es.string.starts-with"],
    strike: ["es.string.strike"],
    sub: ["es.string.sub"],
    sup: ["es.string.sup"],
    toFixed: ["es.number.to-fixed"],
    toISOString: ["es.date.to-iso-string"],
    toJSON: ["es.date.to-json", "web.url.to-json"],
    toPrecision: ["es.number.to-precision"],
    toString: ["es.object.to-string", "es.regexp.to-string", "es.date.to-string"],
    trim: ["es.string.trim"],
    trimEnd: ["es.string.trim-end"],
    trimLeft: ["es.string.trim-start"],
    trimRight: ["es.string.trim-end"],
    trimStart: ["es.string.trim-start"],
    values: ArrayNatureIteratorsWithTag,
    __defineGetter__: ["es.object.define-getter"],
    __defineSetter__: ["es.object.define-setter"],
    __lookupGetter__: ["es.object.lookup-getter"],
    __lookupSetter__: ["es.object.lookup-setter"]
  };
  var StaticProperties$1 = {
    Array: {
      from: ["es.array.from", "es.string.iterator"],
      isArray: ["es.array.is-array"],
      of: ["es.array.of"]
    },
    Date: {
      now: "es.date.now"
    },
    Object: {
      assign: "es.object.assign",
      create: "es.object.create",
      defineProperty: "es.object.define-property",
      defineProperties: "es.object.define-properties",
      entries: "es.object.entries",
      freeze: "es.object.freeze",
      fromEntries: ["es.object.from-entries", "es.array.iterator"],
      getOwnPropertyDescriptor: "es.object.get-own-property-descriptor",
      getOwnPropertyDescriptors: "es.object.get-own-property-descriptors",
      getOwnPropertyNames: "es.object.get-own-property-names",
      getOwnPropertySymbols: "es.symbol",
      getPrototypeOf: "es.object.get-prototype-of",
      is: "es.object.is",
      isExtensible: "es.object.is-extensible",
      isFrozen: "es.object.is-frozen",
      isSealed: "es.object.is-sealed",
      keys: "es.object.keys",
      preventExtensions: "es.object.prevent-extensions",
      seal: "es.object.seal",
      setPrototypeOf: "es.object.set-prototype-of",
      values: "es.object.values"
    },
    Math: {
      DEG_PER_RAD: "esnext.math.deg-per-rad",
      RAD_PER_DEG: "esnext.math.rad-per-deg",
      acosh: "es.math.acosh",
      asinh: "es.math.asinh",
      atanh: "es.math.atanh",
      cbrt: "es.math.cbrt",
      clamp: "esnext.math.clamp",
      clz32: "es.math.clz32",
      cosh: "es.math.cosh",
      degrees: "esnext.math.degrees",
      expm1: "es.math.expm1",
      fround: "es.math.fround",
      fscale: "esnext.math.fscale",
      hypot: "es.math.hypot",
      iaddh: "esnext.math.iaddh",
      imul: "es.math.imul",
      imulh: "esnext.math.imulh",
      isubh: "esnext.math.isubh",
      log1p: "es.math.log1p",
      log10: "es.math.log10",
      log2: "es.math.log2",
      radians: "esnext.math.radians",
      scale: "esnext.math.scale",
      seededPRNG: "esnext.math.seeded-prng",
      sign: "es.math.sign",
      signbit: "esnext.math.signbit",
      sinh: "es.math.sinh",
      tanh: "es.math.tanh",
      trunc: "es.math.trunc",
      umulh: "esnext.math.umulh"
    },
    String: {
      fromCodePoint: "es.string.from-code-point",
      raw: "es.string.raw"
    },
    Number: {
      EPSILON: "es.number.epsilon",
      MIN_SAFE_INTEGER: "es.number.min-safe-integer",
      MAX_SAFE_INTEGER: "es.number.max-safe-integer",
      fromString: "esnext.number.from-string",
      isFinite: "es.number.is-finite",
      isInteger: "es.number.is-integer",
      isSafeInteger: "es.number.is-safe-integer",
      isNaN: "es.number.is-nan",
      parseFloat: "es.number.parse-float",
      parseInt: "es.number.parse-int"
    },
    Map: {
      from: ["esnext.map.from"].concat(MapDependencies),
      groupBy: ["esnext.map.group-by"].concat(MapDependencies),
      keyBy: ["esnext.map.key-by"].concat(MapDependencies),
      of: ["esnext.map.of"].concat(MapDependencies)
    },
    Set: {
      from: ["esnext.set.from"].concat(SetDependencies),
      of: ["esnext.set.of"].concat(SetDependencies)
    },
    WeakMap: {
      from: ["esnext.weak-map.from"].concat(WeakMapDependencies),
      of: ["esnext.weak-map.of"].concat(WeakMapDependencies)
    },
    WeakSet: {
      from: ["esnext.weak-set.from"].concat(WeakSetDependencies),
      of: ["esnext.weak-set.of"].concat(WeakSetDependencies)
    },
    Promise: {
      all: PromiseDependenciesWithIterators,
      allSettled: ["es.promise.all-settled", "esnext.promise.all-settled"].concat(PromiseDependenciesWithIterators),
      any: ["esnext.promise.any", "esnext.aggregate-error"].concat(PromiseDependenciesWithIterators),
      race: PromiseDependenciesWithIterators,
      "try": ["esnext.promise.try"].concat(PromiseDependenciesWithIterators)
    },
    Reflect: {
      apply: "es.reflect.apply",
      construct: "es.reflect.construct",
      defineMetadata: "esnext.reflect.define-metadata",
      defineProperty: "es.reflect.define-property",
      deleteMetadata: "esnext.reflect.delete-metadata",
      deleteProperty: "es.reflect.delete-property",
      get: "es.reflect.get",
      getMetadata: "esnext.reflect.get-metadata",
      getMetadataKeys: "esnext.reflect.get-metadata-keys",
      getOwnMetadata: "esnext.reflect.get-own-metadata",
      getOwnMetadataKeys: "esnext.reflect.get-own-metadata-keys",
      getOwnPropertyDescriptor: "es.reflect.get-own-property-descriptor",
      getPrototypeOf: "es.reflect.get-prototype-of",
      has: "es.reflect.has",
      hasMetadata: "esnext.reflect.has-metadata",
      hasOwnMetadata: "esnext.reflect.has-own-metadata",
      isExtensible: "es.reflect.is-extensible",
      metadata: "esnext.reflect.metadata",
      ownKeys: "es.reflect.own-keys",
      preventExtensions: "es.reflect.prevent-extensions",
      set: "es.reflect.set",
      setPrototypeOf: "es.reflect.set-prototype-of"
    },
    Symbol: {
      asyncIterator: ["es.symbol.async-iterator"],
      dispose: ["esnext.symbol.dispose"],
      hasInstance: ["es.symbol.has-instance", "es.function.has-instance"],
      isConcatSpreadable: ["es.symbol.is-concat-spreadable", "es.array.concat"],
      iterator: ["es.symbol.iterator"].concat(CommonIteratorsWithTag),
      match: ["es.symbol.match", "es.string.match"],
      observable: ["esnext.symbol.observable"],
      patternMatch: ["esnext.symbol.pattern-match"],
      replace: ["es.symbol.replace", "es.string.replace"],
      search: ["es.symbol.search", "es.string.search"],
      species: ["es.symbol.species", "es.array.species"],
      split: ["es.symbol.split", "es.string.split"],
      toPrimitive: ["es.symbol.to-primitive", "es.date.to-primitive"],
      toStringTag: ["es.symbol.to-string-tag", "es.object.to-string", "es.math.to-string-tag", "es.json.to-string-tag"],
      unscopables: ["es.symbol.unscopables"]
    },
    ArrayBuffer: {
      isView: ["es.array-buffer.is-view"]
    },
    Int8Array: TypedArrayStaticMethods,
    Uint8Array: TypedArrayStaticMethods,
    Uint8ClampedArray: TypedArrayStaticMethods,
    Int16Array: TypedArrayStaticMethods,
    Uint16Array: TypedArrayStaticMethods,
    Int32Array: TypedArrayStaticMethods,
    Uint32Array: TypedArrayStaticMethods,
    Float32Array: TypedArrayStaticMethods,
    Float64Array: TypedArrayStaticMethods
  };
  var CommonInstanceDependencies = new Set(["es.object.to-string", "es.object.define-getter", "es.object.define-setter", "es.object.lookup-getter", "es.object.lookup-setter", "es.regexp.exec"]);
  var PossibleGlobalObjects = new Set(["global", "globalThis", "self", "window"]);

  var NO_DIRECT_POLYFILL_IMPORT$1 = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the direct import of `core-js` or use `useBuiltIns: 'entry'` instead.";
  var corejs3PolyfillsWithoutProposals = Object.keys(corejs3Polyfills).filter(function (name) {
    return !name.startsWith("esnext.");
  }).reduce(function (memo, key) {
    memo[key] = corejs3Polyfills[key];
    return memo;
  }, {});
  var corejs3PolyfillsWithShippedProposals = corejs3ShippedProposals$2.reduce(function (memo, key) {
    memo[key] = corejs3Polyfills[key];
    return memo;
  }, Object.assign({}, corejs3PolyfillsWithoutProposals));
  function addCoreJS3UsagePlugin (_, _ref) {
    var corejs = _ref.corejs,
        include = _ref.include,
        exclude = _ref.exclude,
        polyfillTargets = _ref.polyfillTargets,
        proposals = _ref.proposals,
        shippedProposals = _ref.shippedProposals,
        debug = _ref.debug;
    var polyfills = filterItems(proposals ? corejs3Polyfills : shippedProposals ? corejs3PolyfillsWithShippedProposals : corejs3PolyfillsWithoutProposals, include, exclude, polyfillTargets, null);
    var available = new Set(getModulesListForTargetVersion(corejs.version));

    function resolveKey(path, computed) {
      var node = path.node,
          parent = path.parent,
          scope = path.scope;
      if (path.isStringLiteral()) return node.value;
      var name = node.name;
      var isIdentifier = path.isIdentifier();
      if (isIdentifier && !(computed || parent.computed)) return name;

      if (!isIdentifier || scope.getBindingIdentifier(name)) {
        var _path$evaluate = path.evaluate(),
            value = _path$evaluate.value;

        if (typeof value === "string") return value;
      }
    }

    function resolveSource(path) {
      var node = path.node,
          scope = path.scope;
      var builtIn, instanceType;

      if (node) {
        builtIn = node.name;

        if (!path.isIdentifier() || scope.getBindingIdentifier(builtIn)) {
          var _path$evaluate2 = path.evaluate(),
              deopt = _path$evaluate2.deopt,
              value = _path$evaluate2.value;

          if (value !== undefined) {
            instanceType = getType$1(value);
          } else if (deopt && deopt.isIdentifier()) {
            builtIn = deopt.node.name;
          }
        }
      }

      return {
        builtIn: builtIn,
        instanceType: instanceType,
        isNamespaced: isNamespaced(path)
      };
    }

    var addAndRemovePolyfillImports = {
      ImportDeclaration: function ImportDeclaration(path) {
        if (isPolyfillSource(getImportSource(path))) {
          console.warn(NO_DIRECT_POLYFILL_IMPORT$1);
          path.remove();
        }
      },
      Program: {
        enter: function enter(path) {
          path.get("body").forEach(function (bodyPath) {
            if (isPolyfillSource(getRequireSource(bodyPath))) {
              console.warn(NO_DIRECT_POLYFILL_IMPORT$1);
              bodyPath.remove();
            }
          });
        },
        exit: function exit(path) {
          var _this = this;

          var filtered = intersection(polyfills, this.polyfillsSet, available);
          var reversed = Array.from(filtered).reverse();

          for (var _iterator = reversed, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref2 = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref2 = _i.value;
            }

            var module = _ref2;

            if (!this.injectedPolyfills.has(module)) {
              createImport(path, module);
            }
          }

          filtered.forEach(function (module) {
            return _this.injectedPolyfills.add(module);
          });
        }
      },
      Import: function Import() {
        this.addUnsupported(PromiseDependencies$1);
      },
      Function: function Function(_ref3) {
        var node = _ref3.node;

        if (node.async) {
          this.addUnsupported(PromiseDependencies$1);
        }
      },
      "ForOfStatement|ArrayPattern": function ForOfStatementArrayPattern() {
        this.addUnsupported(CommonIterators$1);
      },
      SpreadElement: function SpreadElement(_ref4) {
        var parentPath = _ref4.parentPath;

        if (!parentPath.isObjectExpression()) {
          this.addUnsupported(CommonIterators$1);
        }
      },
      YieldExpression: function YieldExpression(_ref5) {
        var node = _ref5.node;

        if (node.delegate) {
          this.addUnsupported(CommonIterators$1);
        }
      },
      ReferencedIdentifier: function ReferencedIdentifier(_ref6) {
        var name = _ref6.node.name,
            scope = _ref6.scope;
        if (scope.getBindingIdentifier(name)) return;
        this.addBuiltInDependencies(name);
      },
      MemberExpression: function MemberExpression(path) {
        var source = resolveSource(path.get("object"));
        var key = resolveKey(path.get("property"));
        this.addPropertyDependencies(source, key);
      },
      ObjectPattern: function ObjectPattern(path) {
        var parentPath = path.parentPath,
            parent = path.parent,
            key = path.key;
        var source;

        if (parentPath.isVariableDeclarator()) {
          source = resolveSource(parentPath.get("init"));
        } else if (parentPath.isAssignmentExpression()) {
          source = resolveSource(parentPath.get("right"));
        } else if (parentPath.isFunctionExpression()) {
          var grand = parentPath.parentPath;

          if (grand.isCallExpression() || grand.isNewExpression()) {
            if (grand.node.callee === parent) {
              source = resolveSource(grand.get("arguments")[key]);
            }
          }
        }

        for (var _iterator2 = path.get("properties"), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
          var _ref7;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref7 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref7 = _i2.value;
          }

          var property = _ref7;

          if (property.isObjectProperty()) {
            var _key = resolveKey(property.get("key"));

            this.addPropertyDependencies(source, _key);
          }
        }
      },
      BinaryExpression: function BinaryExpression(path) {
        if (path.node.operator !== "in") return;
        var source = resolveSource(path.get("right"));
        var key = resolveKey(path.get("left"), true);
        this.addPropertyDependencies(source, key);
      }
    };
    return {
      name: "corejs3-usage",
      pre: function pre() {
        this.injectedPolyfills = new Set();
        this.polyfillsSet = new Set();

        this.addUnsupported = function (builtIn) {
          var modules = Array.isArray(builtIn) ? builtIn : [builtIn];

          for (var _iterator3 = modules, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
            var _ref8;

            if (_isArray3) {
              if (_i3 >= _iterator3.length) break;
              _ref8 = _iterator3[_i3++];
            } else {
              _i3 = _iterator3.next();
              if (_i3.done) break;
              _ref8 = _i3.value;
            }

            var module = _ref8;
            this.polyfillsSet.add(module);
          }
        };

        this.addBuiltInDependencies = function (builtIn) {
          if (has$6(BuiltIns$1, builtIn)) {
            var BuiltInDependencies = BuiltIns$1[builtIn];
            this.addUnsupported(BuiltInDependencies);
          }
        };

        this.addPropertyDependencies = function (source, key) {
          if (source === void 0) {
            source = {};
          }

          var _source = source,
              builtIn = _source.builtIn,
              instanceType = _source.instanceType,
              isNamespaced = _source.isNamespaced;
          if (isNamespaced) return;

          if (PossibleGlobalObjects.has(builtIn)) {
            this.addBuiltInDependencies(key);
          } else if (has$6(StaticProperties$1, builtIn)) {
            var BuiltInProperties = StaticProperties$1[builtIn];

            if (has$6(BuiltInProperties, key)) {
              var StaticPropertyDependencies = BuiltInProperties[key];
              return this.addUnsupported(StaticPropertyDependencies);
            }
          }

          if (!has$6(InstanceProperties$1, key)) return;
          var InstancePropertyDependencies = InstanceProperties$1[key];

          if (instanceType) {
            InstancePropertyDependencies = InstancePropertyDependencies.filter(function (m) {
              return m.includes(instanceType) || CommonInstanceDependencies.has(m);
            });
          }

          this.addUnsupported(InstancePropertyDependencies);
        };
      },
      post: function post() {
        if (debug) {
          logUsagePolyfills(this.injectedPolyfills, this.file.opts.filename, polyfillTargets, corejs3Polyfills);
        }
      },
      visitor: addAndRemovePolyfillImports
    };
  }

  function addRegeneratorUsagePlugin () {
    return {
      name: "regenerator-usage",
      pre: function pre() {
        this.usesRegenerator = false;
      },
      visitor: {
        Function: function Function(path) {
          var node = path.node;

          if (!this.usesRegenerator && (node.generator || node.async)) {
            this.usesRegenerator = true;
            createImport(path, "regenerator-runtime");
          }
        }
      },
      post: function post() {
        if (this.opts.debug && this.usesRegenerator) {
          var filename = this.file.opts.filename;

          if (process.env.BABEL_ENV === "test") {
            filename = filename.replace(/\\/g, "/");
          }

          console.log("\n[" + filename + "] Based on your code and targets, added regenerator-runtime.");
        }
      }
    };
  }

  function replaceCoreJS2EntryPlugin (_, _ref) {
    var include = _ref.include,
        exclude = _ref.exclude,
        polyfillTargets = _ref.polyfillTargets,
        regenerator = _ref.regenerator,
        debug = _ref.debug;
    var polyfills = filterItems(corejs2BuiltIns$2, include, exclude, polyfillTargets, getPlatformSpecificDefaultFor(polyfillTargets));
    var isPolyfillImport = {
      ImportDeclaration: function ImportDeclaration(path) {
        if (isPolyfillSource(getImportSource(path))) {
          this.replaceBySeparateModulesImport(path);
        }
      },
      Program: function Program(path) {
        var _this = this;

        path.get("body").forEach(function (bodyPath) {
          if (isPolyfillSource(getRequireSource(bodyPath))) {
            _this.replaceBySeparateModulesImport(bodyPath);
          }
        });
      }
    };
    return {
      name: "corejs2-entry",
      visitor: isPolyfillImport,
      pre: function pre() {
        this.importPolyfillIncluded = false;

        this.replaceBySeparateModulesImport = function (path) {
          this.importPolyfillIncluded = true;

          if (regenerator) {
            createImport(path, "regenerator-runtime");
          }

          var modules = Array.from(polyfills).reverse();

          for (var _iterator = modules, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref2 = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref2 = _i.value;
            }

            var module = _ref2;
            createImport(path, module);
          }

          path.remove();
        };
      },
      post: function post() {
        if (debug) {
          logEntryPolyfills("@babel/polyfill", this.importPolyfillIncluded, polyfills, this.file.opts.filename, polyfillTargets, corejs2BuiltIns$2);
        }
      }
    };
  }

  var corejsEntries = {
    "core-js": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.set",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string",
    "es.weak-map",
    "es.weak-set",
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.immediate",
    "web.queue-microtask",
    "web.timers",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "core-js/es": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.set",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string",
    "es.weak-map",
    "es.weak-set"
  ],
    "core-js/es/array": [
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.string.iterator"
  ],
    "core-js/es/array-buffer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string"
  ],
    "core-js/es/array-buffer/constructor": [
    "es.array-buffer.constructor",
    "es.object.to-string"
  ],
    "core-js/es/array-buffer/is-view": [
    "es.array-buffer.is-view"
  ],
    "core-js/es/array-buffer/slice": [
    "es.array-buffer.slice"
  ],
    "core-js/es/array/concat": [
    "es.array.concat"
  ],
    "core-js/es/array/copy-within": [
    "es.array.copy-within"
  ],
    "core-js/es/array/entries": [
    "es.array.iterator"
  ],
    "core-js/es/array/every": [
    "es.array.every"
  ],
    "core-js/es/array/fill": [
    "es.array.fill"
  ],
    "core-js/es/array/filter": [
    "es.array.filter"
  ],
    "core-js/es/array/find": [
    "es.array.find"
  ],
    "core-js/es/array/find-index": [
    "es.array.find-index"
  ],
    "core-js/es/array/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
    "core-js/es/array/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
    "core-js/es/array/for-each": [
    "es.array.for-each"
  ],
    "core-js/es/array/from": [
    "es.array.from",
    "es.string.iterator"
  ],
    "core-js/es/array/includes": [
    "es.array.includes"
  ],
    "core-js/es/array/index-of": [
    "es.array.index-of"
  ],
    "core-js/es/array/is-array": [
    "es.array.is-array"
  ],
    "core-js/es/array/iterator": [
    "es.array.iterator"
  ],
    "core-js/es/array/join": [
    "es.array.join"
  ],
    "core-js/es/array/keys": [
    "es.array.iterator"
  ],
    "core-js/es/array/last-index-of": [
    "es.array.last-index-of"
  ],
    "core-js/es/array/map": [
    "es.array.map"
  ],
    "core-js/es/array/of": [
    "es.array.of"
  ],
    "core-js/es/array/reduce": [
    "es.array.reduce"
  ],
    "core-js/es/array/reduce-right": [
    "es.array.reduce-right"
  ],
    "core-js/es/array/reverse": [
    "es.array.reverse"
  ],
    "core-js/es/array/slice": [
    "es.array.slice"
  ],
    "core-js/es/array/some": [
    "es.array.some"
  ],
    "core-js/es/array/sort": [
    "es.array.sort"
  ],
    "core-js/es/array/splice": [
    "es.array.splice"
  ],
    "core-js/es/array/values": [
    "es.array.iterator"
  ],
    "core-js/es/array/virtual": [
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.includes",
    "es.array.index-of",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map"
  ],
    "core-js/es/array/virtual/concat": [
    "es.array.concat"
  ],
    "core-js/es/array/virtual/copy-within": [
    "es.array.copy-within"
  ],
    "core-js/es/array/virtual/entries": [
    "es.array.iterator"
  ],
    "core-js/es/array/virtual/every": [
    "es.array.every"
  ],
    "core-js/es/array/virtual/fill": [
    "es.array.fill"
  ],
    "core-js/es/array/virtual/filter": [
    "es.array.filter"
  ],
    "core-js/es/array/virtual/find": [
    "es.array.find"
  ],
    "core-js/es/array/virtual/find-index": [
    "es.array.find-index"
  ],
    "core-js/es/array/virtual/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
    "core-js/es/array/virtual/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
    "core-js/es/array/virtual/for-each": [
    "es.array.for-each"
  ],
    "core-js/es/array/virtual/includes": [
    "es.array.includes"
  ],
    "core-js/es/array/virtual/index-of": [
    "es.array.index-of"
  ],
    "core-js/es/array/virtual/iterator": [
    "es.array.iterator"
  ],
    "core-js/es/array/virtual/join": [
    "es.array.join"
  ],
    "core-js/es/array/virtual/keys": [
    "es.array.iterator"
  ],
    "core-js/es/array/virtual/last-index-of": [
    "es.array.last-index-of"
  ],
    "core-js/es/array/virtual/map": [
    "es.array.map"
  ],
    "core-js/es/array/virtual/reduce": [
    "es.array.reduce"
  ],
    "core-js/es/array/virtual/reduce-right": [
    "es.array.reduce-right"
  ],
    "core-js/es/array/virtual/reverse": [
    "es.array.reverse"
  ],
    "core-js/es/array/virtual/slice": [
    "es.array.slice"
  ],
    "core-js/es/array/virtual/some": [
    "es.array.some"
  ],
    "core-js/es/array/virtual/sort": [
    "es.array.sort"
  ],
    "core-js/es/array/virtual/splice": [
    "es.array.splice"
  ],
    "core-js/es/array/virtual/values": [
    "es.array.iterator"
  ],
    "core-js/es/data-view": [
    "es.data-view",
    "es.object.to-string"
  ],
    "core-js/es/date": [
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string"
  ],
    "core-js/es/date/now": [
    "es.date.now"
  ],
    "core-js/es/date/to-iso-string": [
    "es.date.to-iso-string",
    "es.date.to-json"
  ],
    "core-js/es/date/to-json": [
    "es.date.to-json"
  ],
    "core-js/es/date/to-primitive": [
    "es.date.to-primitive"
  ],
    "core-js/es/date/to-string": [
    "es.date.to-string"
  ],
    "core-js/es/function": [
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name"
  ],
    "core-js/es/function/bind": [
    "es.function.bind"
  ],
    "core-js/es/function/has-instance": [
    "es.function.has-instance"
  ],
    "core-js/es/function/name": [
    "es.function.name"
  ],
    "core-js/es/function/virtual": [
    "es.function.bind"
  ],
    "core-js/es/function/virtual/bind": [
    "es.function.bind"
  ],
    "core-js/es/global-this": [
    "es.global-this"
  ],
    "core-js/es/instance/bind": [
    "es.function.bind"
  ],
    "core-js/es/instance/code-point-at": [
    "es.string.code-point-at"
  ],
    "core-js/es/instance/concat": [
    "es.array.concat"
  ],
    "core-js/es/instance/copy-within": [
    "es.array.copy-within"
  ],
    "core-js/es/instance/ends-with": [
    "es.string.ends-with"
  ],
    "core-js/es/instance/entries": [
    "es.array.iterator"
  ],
    "core-js/es/instance/every": [
    "es.array.every"
  ],
    "core-js/es/instance/fill": [
    "es.array.fill"
  ],
    "core-js/es/instance/filter": [
    "es.array.filter"
  ],
    "core-js/es/instance/find": [
    "es.array.find"
  ],
    "core-js/es/instance/find-index": [
    "es.array.find-index"
  ],
    "core-js/es/instance/flags": [
    "es.regexp.flags"
  ],
    "core-js/es/instance/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
    "core-js/es/instance/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
    "core-js/es/instance/for-each": [
    "es.array.for-each"
  ],
    "core-js/es/instance/includes": [
    "es.array.includes",
    "es.string.includes"
  ],
    "core-js/es/instance/index-of": [
    "es.array.index-of"
  ],
    "core-js/es/instance/keys": [
    "es.array.iterator"
  ],
    "core-js/es/instance/last-index-of": [
    "es.array.last-index-of"
  ],
    "core-js/es/instance/map": [
    "es.array.map"
  ],
    "core-js/es/instance/match-all": [
    "es.string.match-all"
  ],
    "core-js/es/instance/pad-end": [
    "es.string.pad-end"
  ],
    "core-js/es/instance/pad-start": [
    "es.string.pad-start"
  ],
    "core-js/es/instance/reduce": [
    "es.array.reduce"
  ],
    "core-js/es/instance/reduce-right": [
    "es.array.reduce-right"
  ],
    "core-js/es/instance/repeat": [
    "es.string.repeat"
  ],
    "core-js/es/instance/reverse": [
    "es.array.reverse"
  ],
    "core-js/es/instance/slice": [
    "es.array.slice"
  ],
    "core-js/es/instance/some": [
    "es.array.some"
  ],
    "core-js/es/instance/sort": [
    "es.array.sort"
  ],
    "core-js/es/instance/splice": [
    "es.array.splice"
  ],
    "core-js/es/instance/starts-with": [
    "es.string.starts-with"
  ],
    "core-js/es/instance/trim": [
    "es.string.trim"
  ],
    "core-js/es/instance/trim-end": [
    "es.string.trim-end"
  ],
    "core-js/es/instance/trim-left": [
    "es.string.trim-start"
  ],
    "core-js/es/instance/trim-right": [
    "es.string.trim-end"
  ],
    "core-js/es/instance/trim-start": [
    "es.string.trim-start"
  ],
    "core-js/es/instance/values": [
    "es.array.iterator"
  ],
    "core-js/es/json": [
    "es.json.stringify",
    "es.json.to-string-tag"
  ],
    "core-js/es/json/stringify": [
    "es.json.stringify"
  ],
    "core-js/es/json/to-string-tag": [
    "es.json.to-string-tag"
  ],
    "core-js/es/map": [
    "es.map",
    "es.object.to-string",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/es/math": [
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc"
  ],
    "core-js/es/math/acosh": [
    "es.math.acosh"
  ],
    "core-js/es/math/asinh": [
    "es.math.asinh"
  ],
    "core-js/es/math/atanh": [
    "es.math.atanh"
  ],
    "core-js/es/math/cbrt": [
    "es.math.cbrt"
  ],
    "core-js/es/math/clz32": [
    "es.math.clz32"
  ],
    "core-js/es/math/cosh": [
    "es.math.cosh"
  ],
    "core-js/es/math/expm1": [
    "es.math.expm1"
  ],
    "core-js/es/math/fround": [
    "es.math.fround"
  ],
    "core-js/es/math/hypot": [
    "es.math.hypot"
  ],
    "core-js/es/math/imul": [
    "es.math.imul"
  ],
    "core-js/es/math/log10": [
    "es.math.log10"
  ],
    "core-js/es/math/log1p": [
    "es.math.log1p"
  ],
    "core-js/es/math/log2": [
    "es.math.log2"
  ],
    "core-js/es/math/sign": [
    "es.math.sign"
  ],
    "core-js/es/math/sinh": [
    "es.math.sinh"
  ],
    "core-js/es/math/tanh": [
    "es.math.tanh"
  ],
    "core-js/es/math/to-string-tag": [
    "es.math.to-string-tag"
  ],
    "core-js/es/math/trunc": [
    "es.math.trunc"
  ],
    "core-js/es/number": [
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
    "core-js/es/number/constructor": [
    "es.number.constructor"
  ],
    "core-js/es/number/epsilon": [
    "es.number.epsilon"
  ],
    "core-js/es/number/is-finite": [
    "es.number.is-finite"
  ],
    "core-js/es/number/is-integer": [
    "es.number.is-integer"
  ],
    "core-js/es/number/is-nan": [
    "es.number.is-nan"
  ],
    "core-js/es/number/is-safe-integer": [
    "es.number.is-safe-integer"
  ],
    "core-js/es/number/max-safe-integer": [
    "es.number.max-safe-integer"
  ],
    "core-js/es/number/min-safe-integer": [
    "es.number.min-safe-integer"
  ],
    "core-js/es/number/parse-float": [
    "es.number.parse-float"
  ],
    "core-js/es/number/parse-int": [
    "es.number.parse-int"
  ],
    "core-js/es/number/to-fixed": [
    "es.number.to-fixed"
  ],
    "core-js/es/number/to-precision": [
    "es.number.to-precision"
  ],
    "core-js/es/number/virtual": [
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
    "core-js/es/number/virtual/to-fixed": [
    "es.number.to-fixed"
  ],
    "core-js/es/number/virtual/to-precision": [
    "es.number.to-precision"
  ],
    "core-js/es/object": [
    "es.symbol",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values"
  ],
    "core-js/es/object/assign": [
    "es.object.assign"
  ],
    "core-js/es/object/create": [
    "es.object.create"
  ],
    "core-js/es/object/define-getter": [
    "es.object.define-getter"
  ],
    "core-js/es/object/define-properties": [
    "es.object.define-properties"
  ],
    "core-js/es/object/define-property": [
    "es.object.define-property"
  ],
    "core-js/es/object/define-setter": [
    "es.object.define-setter"
  ],
    "core-js/es/object/entries": [
    "es.object.entries"
  ],
    "core-js/es/object/freeze": [
    "es.object.freeze"
  ],
    "core-js/es/object/from-entries": [
    "es.array.iterator",
    "es.object.from-entries"
  ],
    "core-js/es/object/get-own-property-descriptor": [
    "es.object.get-own-property-descriptor"
  ],
    "core-js/es/object/get-own-property-descriptors": [
    "es.object.get-own-property-descriptors"
  ],
    "core-js/es/object/get-own-property-names": [
    "es.object.get-own-property-names"
  ],
    "core-js/es/object/get-own-property-symbols": [
    "es.symbol"
  ],
    "core-js/es/object/get-prototype-of": [
    "es.object.get-prototype-of"
  ],
    "core-js/es/object/is": [
    "es.object.is"
  ],
    "core-js/es/object/is-extensible": [
    "es.object.is-extensible"
  ],
    "core-js/es/object/is-frozen": [
    "es.object.is-frozen"
  ],
    "core-js/es/object/is-sealed": [
    "es.object.is-sealed"
  ],
    "core-js/es/object/keys": [
    "es.object.keys"
  ],
    "core-js/es/object/lookup-getter": [
    "es.object.lookup-setter"
  ],
    "core-js/es/object/lookup-setter": [
    "es.object.lookup-setter"
  ],
    "core-js/es/object/prevent-extensions": [
    "es.object.prevent-extensions"
  ],
    "core-js/es/object/seal": [
    "es.object.seal"
  ],
    "core-js/es/object/set-prototype-of": [
    "es.object.set-prototype-of"
  ],
    "core-js/es/object/to-string": [
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
    "core-js/es/object/values": [
    "es.object.values"
  ],
    "core-js/es/parse-float": [
    "es.parse-float"
  ],
    "core-js/es/parse-int": [
    "es.parse-int"
  ],
    "core-js/es/promise": [
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/es/promise/all-settled": [
    "es.promise",
    "es.promise.all-settled"
  ],
    "core-js/es/promise/finally": [
    "es.promise",
    "es.promise.finally"
  ],
    "core-js/es/reflect": [
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of"
  ],
    "core-js/es/reflect/apply": [
    "es.reflect.apply"
  ],
    "core-js/es/reflect/construct": [
    "es.reflect.construct"
  ],
    "core-js/es/reflect/define-property": [
    "es.reflect.define-property"
  ],
    "core-js/es/reflect/delete-property": [
    "es.reflect.delete-property"
  ],
    "core-js/es/reflect/get": [
    "es.reflect.get"
  ],
    "core-js/es/reflect/get-own-property-descriptor": [
    "es.reflect.get-own-property-descriptor"
  ],
    "core-js/es/reflect/get-prototype-of": [
    "es.reflect.get-prototype-of"
  ],
    "core-js/es/reflect/has": [
    "es.reflect.has"
  ],
    "core-js/es/reflect/is-extensible": [
    "es.reflect.is-extensible"
  ],
    "core-js/es/reflect/own-keys": [
    "es.reflect.own-keys"
  ],
    "core-js/es/reflect/prevent-extensions": [
    "es.reflect.prevent-extensions"
  ],
    "core-js/es/reflect/set": [
    "es.reflect.set"
  ],
    "core-js/es/reflect/set-prototype-of": [
    "es.reflect.set-prototype-of"
  ],
    "core-js/es/regexp": [
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.string.match",
    "es.string.replace",
    "es.string.search",
    "es.string.split"
  ],
    "core-js/es/regexp/constructor": [
    "es.regexp.constructor"
  ],
    "core-js/es/regexp/flags": [
    "es.regexp.flags"
  ],
    "core-js/es/regexp/match": [
    "es.string.match"
  ],
    "core-js/es/regexp/replace": [
    "es.string.replace"
  ],
    "core-js/es/regexp/search": [
    "es.string.search"
  ],
    "core-js/es/regexp/split": [
    "es.string.split"
  ],
    "core-js/es/regexp/sticky": [
    "es.regexp.sticky"
  ],
    "core-js/es/regexp/test": [
    "es.regexp.exec",
    "es.regexp.test"
  ],
    "core-js/es/regexp/to-string": [
    "es.regexp.to-string"
  ],
    "core-js/es/set": [
    "es.object.to-string",
    "es.set",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/es/string": [
    "es.regexp.exec",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup"
  ],
    "core-js/es/string/anchor": [
    "es.string.anchor"
  ],
    "core-js/es/string/big": [
    "es.string.big"
  ],
    "core-js/es/string/blink": [
    "es.string.blink"
  ],
    "core-js/es/string/bold": [
    "es.string.bold"
  ],
    "core-js/es/string/code-point-at": [
    "es.string.code-point-at"
  ],
    "core-js/es/string/ends-with": [
    "es.string.ends-with"
  ],
    "core-js/es/string/fixed": [
    "es.string.fixed"
  ],
    "core-js/es/string/fontcolor": [
    "es.string.fontcolor"
  ],
    "core-js/es/string/fontsize": [
    "es.string.fontsize"
  ],
    "core-js/es/string/from-code-point": [
    "es.string.from-code-point"
  ],
    "core-js/es/string/includes": [
    "es.string.includes"
  ],
    "core-js/es/string/italics": [
    "es.string.italics"
  ],
    "core-js/es/string/iterator": [
    "es.string.iterator"
  ],
    "core-js/es/string/link": [
    "es.string.link"
  ],
    "core-js/es/string/match": [
    "es.regexp.exec",
    "es.string.match"
  ],
    "core-js/es/string/match-all": [
    "es.string.match-all"
  ],
    "core-js/es/string/pad-end": [
    "es.string.pad-end"
  ],
    "core-js/es/string/pad-start": [
    "es.string.pad-start"
  ],
    "core-js/es/string/raw": [
    "es.string.raw"
  ],
    "core-js/es/string/repeat": [
    "es.string.repeat"
  ],
    "core-js/es/string/replace": [
    "es.regexp.exec",
    "es.string.replace"
  ],
    "core-js/es/string/search": [
    "es.regexp.exec",
    "es.string.search"
  ],
    "core-js/es/string/small": [
    "es.string.small"
  ],
    "core-js/es/string/split": [
    "es.regexp.exec",
    "es.string.split"
  ],
    "core-js/es/string/starts-with": [
    "es.string.starts-with"
  ],
    "core-js/es/string/strike": [
    "es.string.strike"
  ],
    "core-js/es/string/sub": [
    "es.string.sub"
  ],
    "core-js/es/string/sup": [
    "es.string.sup"
  ],
    "core-js/es/string/trim": [
    "es.string.trim"
  ],
    "core-js/es/string/trim-end": [
    "es.string.trim-end"
  ],
    "core-js/es/string/trim-left": [
    "es.string.trim-start"
  ],
    "core-js/es/string/trim-right": [
    "es.string.trim-end"
  ],
    "core-js/es/string/trim-start": [
    "es.string.trim-start"
  ],
    "core-js/es/string/virtual": [
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup"
  ],
    "core-js/es/string/virtual/anchor": [
    "es.string.anchor"
  ],
    "core-js/es/string/virtual/big": [
    "es.string.big"
  ],
    "core-js/es/string/virtual/blink": [
    "es.string.blink"
  ],
    "core-js/es/string/virtual/bold": [
    "es.string.bold"
  ],
    "core-js/es/string/virtual/code-point-at": [
    "es.string.code-point-at"
  ],
    "core-js/es/string/virtual/ends-with": [
    "es.string.ends-with"
  ],
    "core-js/es/string/virtual/fixed": [
    "es.string.fixed"
  ],
    "core-js/es/string/virtual/fontcolor": [
    "es.string.fontcolor"
  ],
    "core-js/es/string/virtual/fontsize": [
    "es.string.fontsize"
  ],
    "core-js/es/string/virtual/includes": [
    "es.string.includes"
  ],
    "core-js/es/string/virtual/italics": [
    "es.string.italics"
  ],
    "core-js/es/string/virtual/iterator": [
    "es.string.iterator"
  ],
    "core-js/es/string/virtual/link": [
    "es.string.link"
  ],
    "core-js/es/string/virtual/match-all": [
    "es.string.match-all"
  ],
    "core-js/es/string/virtual/pad-end": [
    "es.string.pad-end"
  ],
    "core-js/es/string/virtual/pad-start": [
    "es.string.pad-start"
  ],
    "core-js/es/string/virtual/repeat": [
    "es.string.repeat"
  ],
    "core-js/es/string/virtual/small": [
    "es.string.small"
  ],
    "core-js/es/string/virtual/starts-with": [
    "es.string.starts-with"
  ],
    "core-js/es/string/virtual/strike": [
    "es.string.strike"
  ],
    "core-js/es/string/virtual/sub": [
    "es.string.sub"
  ],
    "core-js/es/string/virtual/sup": [
    "es.string.sup"
  ],
    "core-js/es/string/virtual/trim": [
    "es.string.trim"
  ],
    "core-js/es/string/virtual/trim-end": [
    "es.string.trim-end"
  ],
    "core-js/es/string/virtual/trim-left": [
    "es.string.trim-start"
  ],
    "core-js/es/string/virtual/trim-right": [
    "es.string.trim-end"
  ],
    "core-js/es/string/virtual/trim-start": [
    "es.string.trim-start"
  ],
    "core-js/es/symbol": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
    "core-js/es/symbol/async-iterator": [
    "es.symbol.async-iterator"
  ],
    "core-js/es/symbol/description": [
    "es.symbol.description"
  ],
    "core-js/es/symbol/for": [
    "es.symbol"
  ],
    "core-js/es/symbol/has-instance": [
    "es.symbol.has-instance",
    "es.function.has-instance"
  ],
    "core-js/es/symbol/is-concat-spreadable": [
    "es.symbol.is-concat-spreadable",
    "es.array.concat"
  ],
    "core-js/es/symbol/iterator": [
    "es.symbol.iterator",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/es/symbol/key-for": [
    "es.symbol"
  ],
    "core-js/es/symbol/match": [
    "es.symbol.match",
    "es.string.match"
  ],
    "core-js/es/symbol/match-all": [
    "es.symbol.match-all",
    "es.string.match-all"
  ],
    "core-js/es/symbol/replace": [
    "es.symbol.replace",
    "es.string.replace"
  ],
    "core-js/es/symbol/search": [
    "es.symbol.search",
    "es.string.search"
  ],
    "core-js/es/symbol/species": [
    "es.symbol.species"
  ],
    "core-js/es/symbol/split": [
    "es.symbol.split",
    "es.string.split"
  ],
    "core-js/es/symbol/to-primitive": [
    "es.symbol.to-primitive"
  ],
    "core-js/es/symbol/to-string-tag": [
    "es.symbol.to-string-tag",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
    "core-js/es/symbol/unscopables": [
    "es.symbol.unscopables"
  ],
    "core-js/es/typed-array": [
    "es.object.to-string",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/es/typed-array/copy-within": [
    "es.typed-array.copy-within"
  ],
    "core-js/es/typed-array/entries": [
    "es.typed-array.iterator"
  ],
    "core-js/es/typed-array/every": [
    "es.typed-array.every"
  ],
    "core-js/es/typed-array/fill": [
    "es.typed-array.fill"
  ],
    "core-js/es/typed-array/filter": [
    "es.typed-array.filter"
  ],
    "core-js/es/typed-array/find": [
    "es.typed-array.find"
  ],
    "core-js/es/typed-array/find-index": [
    "es.typed-array.find-index"
  ],
    "core-js/es/typed-array/float32-array": [
    "es.object.to-string",
    "es.typed-array.float32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/es/typed-array/float64-array": [
    "es.object.to-string",
    "es.typed-array.float64-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/es/typed-array/for-each": [
    "es.typed-array.for-each"
  ],
    "core-js/es/typed-array/from": [
    "es.typed-array.from"
  ],
    "core-js/es/typed-array/includes": [
    "es.typed-array.includes"
  ],
    "core-js/es/typed-array/index-of": [
    "es.typed-array.index-of"
  ],
    "core-js/es/typed-array/int16-array": [
    "es.object.to-string",
    "es.typed-array.int16-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/es/typed-array/int32-array": [
    "es.object.to-string",
    "es.typed-array.int32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/es/typed-array/int8-array": [
    "es.object.to-string",
    "es.typed-array.int8-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/es/typed-array/iterator": [
    "es.typed-array.iterator"
  ],
    "core-js/es/typed-array/join": [
    "es.typed-array.join"
  ],
    "core-js/es/typed-array/keys": [
    "es.typed-array.iterator"
  ],
    "core-js/es/typed-array/last-index-of": [
    "es.typed-array.last-index-of"
  ],
    "core-js/es/typed-array/map": [
    "es.typed-array.map"
  ],
    "core-js/es/typed-array/methods": [
    "es.object.to-string",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/es/typed-array/of": [
    "es.typed-array.of"
  ],
    "core-js/es/typed-array/reduce": [
    "es.typed-array.reduce"
  ],
    "core-js/es/typed-array/reduce-right": [
    "es.typed-array.reduce-right"
  ],
    "core-js/es/typed-array/reverse": [
    "es.typed-array.reverse"
  ],
    "core-js/es/typed-array/set": [
    "es.typed-array.set"
  ],
    "core-js/es/typed-array/slice": [
    "es.typed-array.slice"
  ],
    "core-js/es/typed-array/some": [
    "es.typed-array.some"
  ],
    "core-js/es/typed-array/sort": [
    "es.typed-array.sort"
  ],
    "core-js/es/typed-array/subarray": [
    "es.typed-array.subarray"
  ],
    "core-js/es/typed-array/to-locale-string": [
    "es.typed-array.to-locale-string"
  ],
    "core-js/es/typed-array/to-string": [
    "es.typed-array.to-string"
  ],
    "core-js/es/typed-array/uint16-array": [
    "es.object.to-string",
    "es.typed-array.uint16-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/es/typed-array/uint32-array": [
    "es.object.to-string",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/es/typed-array/uint8-array": [
    "es.object.to-string",
    "es.typed-array.uint8-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/es/typed-array/uint8-clamped-array": [
    "es.object.to-string",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/es/typed-array/values": [
    "es.typed-array.iterator"
  ],
    "core-js/es/weak-map": [
    "es.object.to-string",
    "es.weak-map",
    "web.dom-collections.iterator"
  ],
    "core-js/es/weak-set": [
    "es.object.to-string",
    "es.weak-set",
    "web.dom-collections.iterator"
  ],
    "core-js/features": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.set",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string",
    "es.weak-map",
    "es.weak-set",
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.immediate",
    "web.queue-microtask",
    "web.timers",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "core-js/features/aggregate-error": [
    "es.string.iterator",
    "esnext.aggregate-error",
    "web.dom-collections.iterator"
  ],
    "core-js/features/array": [
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.string.iterator",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item"
  ],
    "core-js/features/array-buffer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string"
  ],
    "core-js/features/array-buffer/constructor": [
    "es.array-buffer.constructor",
    "es.object.to-string"
  ],
    "core-js/features/array-buffer/is-view": [
    "es.array-buffer.is-view"
  ],
    "core-js/features/array-buffer/slice": [
    "es.array-buffer.slice"
  ],
    "core-js/features/array/concat": [
    "es.array.concat"
  ],
    "core-js/features/array/copy-within": [
    "es.array.copy-within"
  ],
    "core-js/features/array/entries": [
    "es.array.iterator"
  ],
    "core-js/features/array/every": [
    "es.array.every"
  ],
    "core-js/features/array/fill": [
    "es.array.fill"
  ],
    "core-js/features/array/filter": [
    "es.array.filter"
  ],
    "core-js/features/array/find": [
    "es.array.find"
  ],
    "core-js/features/array/find-index": [
    "es.array.find-index"
  ],
    "core-js/features/array/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
    "core-js/features/array/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
    "core-js/features/array/for-each": [
    "es.array.for-each"
  ],
    "core-js/features/array/from": [
    "es.array.from",
    "es.string.iterator"
  ],
    "core-js/features/array/includes": [
    "es.array.includes"
  ],
    "core-js/features/array/index-of": [
    "es.array.index-of"
  ],
    "core-js/features/array/is-array": [
    "es.array.is-array"
  ],
    "core-js/features/array/is-template-object": [
    "esnext.array.is-template-object"
  ],
    "core-js/features/array/iterator": [
    "es.array.iterator"
  ],
    "core-js/features/array/join": [
    "es.array.join"
  ],
    "core-js/features/array/keys": [
    "es.array.iterator"
  ],
    "core-js/features/array/last-index": [
    "esnext.array.last-index"
  ],
    "core-js/features/array/last-index-of": [
    "es.array.last-index-of"
  ],
    "core-js/features/array/last-item": [
    "esnext.array.last-item"
  ],
    "core-js/features/array/map": [
    "es.array.map"
  ],
    "core-js/features/array/of": [
    "es.array.of"
  ],
    "core-js/features/array/reduce": [
    "es.array.reduce"
  ],
    "core-js/features/array/reduce-right": [
    "es.array.reduce-right"
  ],
    "core-js/features/array/reverse": [
    "es.array.reverse"
  ],
    "core-js/features/array/slice": [
    "es.array.slice"
  ],
    "core-js/features/array/some": [
    "es.array.some"
  ],
    "core-js/features/array/sort": [
    "es.array.sort"
  ],
    "core-js/features/array/splice": [
    "es.array.splice"
  ],
    "core-js/features/array/values": [
    "es.array.iterator"
  ],
    "core-js/features/array/virtual": [
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.includes",
    "es.array.index-of",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map"
  ],
    "core-js/features/array/virtual/concat": [
    "es.array.concat"
  ],
    "core-js/features/array/virtual/copy-within": [
    "es.array.copy-within"
  ],
    "core-js/features/array/virtual/entries": [
    "es.array.iterator"
  ],
    "core-js/features/array/virtual/every": [
    "es.array.every"
  ],
    "core-js/features/array/virtual/fill": [
    "es.array.fill"
  ],
    "core-js/features/array/virtual/filter": [
    "es.array.filter"
  ],
    "core-js/features/array/virtual/find": [
    "es.array.find"
  ],
    "core-js/features/array/virtual/find-index": [
    "es.array.find-index"
  ],
    "core-js/features/array/virtual/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
    "core-js/features/array/virtual/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
    "core-js/features/array/virtual/for-each": [
    "es.array.for-each"
  ],
    "core-js/features/array/virtual/includes": [
    "es.array.includes"
  ],
    "core-js/features/array/virtual/index-of": [
    "es.array.index-of"
  ],
    "core-js/features/array/virtual/iterator": [
    "es.array.iterator"
  ],
    "core-js/features/array/virtual/join": [
    "es.array.join"
  ],
    "core-js/features/array/virtual/keys": [
    "es.array.iterator"
  ],
    "core-js/features/array/virtual/last-index-of": [
    "es.array.last-index-of"
  ],
    "core-js/features/array/virtual/map": [
    "es.array.map"
  ],
    "core-js/features/array/virtual/reduce": [
    "es.array.reduce"
  ],
    "core-js/features/array/virtual/reduce-right": [
    "es.array.reduce-right"
  ],
    "core-js/features/array/virtual/reverse": [
    "es.array.reverse"
  ],
    "core-js/features/array/virtual/slice": [
    "es.array.slice"
  ],
    "core-js/features/array/virtual/some": [
    "es.array.some"
  ],
    "core-js/features/array/virtual/sort": [
    "es.array.sort"
  ],
    "core-js/features/array/virtual/splice": [
    "es.array.splice"
  ],
    "core-js/features/array/virtual/values": [
    "es.array.iterator"
  ],
    "core-js/features/async-iterator": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/as-indexed-pairs": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/drop": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/every": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.every",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/filter": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.filter",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/find": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.find",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/flat-map": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.flat-map",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/for-each": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.for-each",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/from": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.from",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/map": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.map",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/reduce": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.reduce",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/some": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.some",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/take": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.take",
    "web.dom-collections.iterator"
  ],
    "core-js/features/async-iterator/to-array": [
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.to-array",
    "web.dom-collections.iterator"
  ],
    "core-js/features/clear-immediate": [
    "web.immediate"
  ],
    "core-js/features/composite-key": [
    "esnext.composite-key"
  ],
    "core-js/features/composite-symbol": [
    "es.symbol",
    "esnext.composite-symbol"
  ],
    "core-js/features/data-view": [
    "es.data-view",
    "es.object.to-string"
  ],
    "core-js/features/date": [
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string"
  ],
    "core-js/features/date/now": [
    "es.date.now"
  ],
    "core-js/features/date/to-iso-string": [
    "es.date.to-iso-string",
    "es.date.to-json"
  ],
    "core-js/features/date/to-json": [
    "es.date.to-json"
  ],
    "core-js/features/date/to-primitive": [
    "es.date.to-primitive"
  ],
    "core-js/features/date/to-string": [
    "es.date.to-string"
  ],
    "core-js/features/dom-collections": [
    "es.array.iterator",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator"
  ],
    "core-js/features/dom-collections/for-each": [
    "web.dom-collections.for-each"
  ],
    "core-js/features/dom-collections/iterator": [
    "web.dom-collections.iterator"
  ],
    "core-js/features/function": [
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name"
  ],
    "core-js/features/function/bind": [
    "es.function.bind"
  ],
    "core-js/features/function/has-instance": [
    "es.function.has-instance"
  ],
    "core-js/features/function/name": [
    "es.function.name"
  ],
    "core-js/features/function/virtual": [
    "es.function.bind"
  ],
    "core-js/features/function/virtual/bind": [
    "es.function.bind"
  ],
    "core-js/features/get-iterator": [
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/features/get-iterator-method": [
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/features/global-this": [
    "es.global-this",
    "esnext.global-this"
  ],
    "core-js/features/instance/at": [
    "esnext.string.at"
  ],
    "core-js/features/instance/bind": [
    "es.function.bind"
  ],
    "core-js/features/instance/code-point-at": [
    "es.string.code-point-at"
  ],
    "core-js/features/instance/code-points": [
    "esnext.string.code-points"
  ],
    "core-js/features/instance/concat": [
    "es.array.concat"
  ],
    "core-js/features/instance/copy-within": [
    "es.array.copy-within"
  ],
    "core-js/features/instance/ends-with": [
    "es.string.ends-with"
  ],
    "core-js/features/instance/entries": [
    "es.array.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/features/instance/every": [
    "es.array.every"
  ],
    "core-js/features/instance/fill": [
    "es.array.fill"
  ],
    "core-js/features/instance/filter": [
    "es.array.filter"
  ],
    "core-js/features/instance/find": [
    "es.array.find"
  ],
    "core-js/features/instance/find-index": [
    "es.array.find-index"
  ],
    "core-js/features/instance/flags": [
    "es.regexp.flags"
  ],
    "core-js/features/instance/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
    "core-js/features/instance/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
    "core-js/features/instance/for-each": [
    "es.array.for-each",
    "web.dom-collections.iterator"
  ],
    "core-js/features/instance/includes": [
    "es.array.includes",
    "es.string.includes"
  ],
    "core-js/features/instance/index-of": [
    "es.array.index-of"
  ],
    "core-js/features/instance/keys": [
    "es.array.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/features/instance/last-index-of": [
    "es.array.last-index-of"
  ],
    "core-js/features/instance/map": [
    "es.array.map"
  ],
    "core-js/features/instance/match-all": [
    "es.string.match-all",
    "esnext.string.match-all"
  ],
    "core-js/features/instance/pad-end": [
    "es.string.pad-end"
  ],
    "core-js/features/instance/pad-start": [
    "es.string.pad-start"
  ],
    "core-js/features/instance/reduce": [
    "es.array.reduce"
  ],
    "core-js/features/instance/reduce-right": [
    "es.array.reduce-right"
  ],
    "core-js/features/instance/repeat": [
    "es.string.repeat"
  ],
    "core-js/features/instance/replace-all": [
    "esnext.string.replace-all"
  ],
    "core-js/features/instance/reverse": [
    "es.array.reverse"
  ],
    "core-js/features/instance/slice": [
    "es.array.slice"
  ],
    "core-js/features/instance/some": [
    "es.array.some"
  ],
    "core-js/features/instance/sort": [
    "es.array.sort"
  ],
    "core-js/features/instance/splice": [
    "es.array.splice"
  ],
    "core-js/features/instance/starts-with": [
    "es.string.starts-with"
  ],
    "core-js/features/instance/trim": [
    "es.string.trim"
  ],
    "core-js/features/instance/trim-end": [
    "es.string.trim-end"
  ],
    "core-js/features/instance/trim-left": [
    "es.string.trim-start"
  ],
    "core-js/features/instance/trim-right": [
    "es.string.trim-end"
  ],
    "core-js/features/instance/trim-start": [
    "es.string.trim-start"
  ],
    "core-js/features/instance/values": [
    "es.array.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/features/is-iterable": [
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/as-indexed-pairs": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/drop": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.drop",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/every": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.every",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/filter": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.filter",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/find": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.find",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/flat-map": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.flat-map",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/for-each": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.for-each",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/from": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.from",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/map": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.map",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/reduce": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.reduce",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/some": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.some",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/take": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.take",
    "web.dom-collections.iterator"
  ],
    "core-js/features/iterator/to-array": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.to-array",
    "web.dom-collections.iterator"
  ],
    "core-js/features/json": [
    "es.json.stringify",
    "es.json.to-string-tag"
  ],
    "core-js/features/json/stringify": [
    "es.json.stringify"
  ],
    "core-js/features/json/to-string-tag": [
    "es.json.to-string-tag"
  ],
    "core-js/features/map": [
    "es.map",
    "es.object.to-string",
    "es.string.iterator",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "web.dom-collections.iterator"
  ],
    "core-js/features/map/delete-all": [
    "es.map",
    "esnext.map.delete-all"
  ],
    "core-js/features/map/every": [
    "es.map",
    "esnext.map.every"
  ],
    "core-js/features/map/filter": [
    "es.map",
    "esnext.map.filter"
  ],
    "core-js/features/map/find": [
    "es.map",
    "esnext.map.find"
  ],
    "core-js/features/map/find-key": [
    "es.map",
    "esnext.map.find-key"
  ],
    "core-js/features/map/from": [
    "es.map",
    "es.string.iterator",
    "esnext.map.from",
    "web.dom-collections.iterator"
  ],
    "core-js/features/map/group-by": [
    "es.map",
    "esnext.map.group-by"
  ],
    "core-js/features/map/includes": [
    "es.map",
    "esnext.map.includes"
  ],
    "core-js/features/map/key-by": [
    "es.map",
    "esnext.map.key-by"
  ],
    "core-js/features/map/key-of": [
    "es.map",
    "esnext.map.key-of"
  ],
    "core-js/features/map/map-keys": [
    "es.map",
    "esnext.map.map-keys"
  ],
    "core-js/features/map/map-values": [
    "es.map",
    "esnext.map.map-values"
  ],
    "core-js/features/map/merge": [
    "es.map",
    "esnext.map.merge"
  ],
    "core-js/features/map/of": [
    "es.map",
    "es.string.iterator",
    "esnext.map.of",
    "web.dom-collections.iterator"
  ],
    "core-js/features/map/reduce": [
    "es.map",
    "esnext.map.reduce"
  ],
    "core-js/features/map/some": [
    "es.map",
    "esnext.map.some"
  ],
    "core-js/features/map/update": [
    "es.map",
    "esnext.map.update"
  ],
    "core-js/features/map/update-or-insert": [
    "es.map",
    "esnext.map.update-or-insert"
  ],
    "core-js/features/map/upsert": [
    "es.map",
    "esnext.map.upsert"
  ],
    "core-js/features/math": [
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh"
  ],
    "core-js/features/math/acosh": [
    "es.math.acosh"
  ],
    "core-js/features/math/asinh": [
    "es.math.asinh"
  ],
    "core-js/features/math/atanh": [
    "es.math.atanh"
  ],
    "core-js/features/math/cbrt": [
    "es.math.cbrt"
  ],
    "core-js/features/math/clamp": [
    "esnext.math.clamp"
  ],
    "core-js/features/math/clz32": [
    "es.math.clz32"
  ],
    "core-js/features/math/cosh": [
    "es.math.cosh"
  ],
    "core-js/features/math/deg-per-rad": [
    "esnext.math.deg-per-rad"
  ],
    "core-js/features/math/degrees": [
    "esnext.math.degrees"
  ],
    "core-js/features/math/expm1": [
    "es.math.expm1"
  ],
    "core-js/features/math/fround": [
    "es.math.fround"
  ],
    "core-js/features/math/fscale": [
    "esnext.math.fscale"
  ],
    "core-js/features/math/hypot": [
    "es.math.hypot"
  ],
    "core-js/features/math/iaddh": [
    "esnext.math.iaddh"
  ],
    "core-js/features/math/imul": [
    "es.math.imul"
  ],
    "core-js/features/math/imulh": [
    "esnext.math.imulh"
  ],
    "core-js/features/math/isubh": [
    "esnext.math.isubh"
  ],
    "core-js/features/math/log10": [
    "es.math.log10"
  ],
    "core-js/features/math/log1p": [
    "es.math.log1p"
  ],
    "core-js/features/math/log2": [
    "es.math.log2"
  ],
    "core-js/features/math/rad-per-deg": [
    "esnext.math.rad-per-deg"
  ],
    "core-js/features/math/radians": [
    "esnext.math.radians"
  ],
    "core-js/features/math/scale": [
    "esnext.math.scale"
  ],
    "core-js/features/math/seeded-prng": [
    "esnext.math.seeded-prng"
  ],
    "core-js/features/math/sign": [
    "es.math.sign"
  ],
    "core-js/features/math/signbit": [
    "esnext.math.signbit"
  ],
    "core-js/features/math/sinh": [
    "es.math.sinh"
  ],
    "core-js/features/math/tanh": [
    "es.math.tanh"
  ],
    "core-js/features/math/to-string-tag": [
    "es.math.to-string-tag"
  ],
    "core-js/features/math/trunc": [
    "es.math.trunc"
  ],
    "core-js/features/math/umulh": [
    "esnext.math.umulh"
  ],
    "core-js/features/number": [
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "esnext.number.from-string"
  ],
    "core-js/features/number/constructor": [
    "es.number.constructor"
  ],
    "core-js/features/number/epsilon": [
    "es.number.epsilon"
  ],
    "core-js/features/number/from-string": [
    "esnext.number.from-string"
  ],
    "core-js/features/number/is-finite": [
    "es.number.is-finite"
  ],
    "core-js/features/number/is-integer": [
    "es.number.is-integer"
  ],
    "core-js/features/number/is-nan": [
    "es.number.is-nan"
  ],
    "core-js/features/number/is-safe-integer": [
    "es.number.is-safe-integer"
  ],
    "core-js/features/number/max-safe-integer": [
    "es.number.max-safe-integer"
  ],
    "core-js/features/number/min-safe-integer": [
    "es.number.min-safe-integer"
  ],
    "core-js/features/number/parse-float": [
    "es.number.parse-float"
  ],
    "core-js/features/number/parse-int": [
    "es.number.parse-int"
  ],
    "core-js/features/number/to-fixed": [
    "es.number.to-fixed"
  ],
    "core-js/features/number/to-precision": [
    "es.number.to-precision"
  ],
    "core-js/features/number/virtual": [
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
    "core-js/features/number/virtual/to-fixed": [
    "es.number.to-fixed"
  ],
    "core-js/features/number/virtual/to-precision": [
    "es.number.to-precision"
  ],
    "core-js/features/object": [
    "es.symbol",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values"
  ],
    "core-js/features/object/assign": [
    "es.object.assign"
  ],
    "core-js/features/object/create": [
    "es.object.create"
  ],
    "core-js/features/object/define-getter": [
    "es.object.define-getter"
  ],
    "core-js/features/object/define-properties": [
    "es.object.define-properties"
  ],
    "core-js/features/object/define-property": [
    "es.object.define-property"
  ],
    "core-js/features/object/define-setter": [
    "es.object.define-setter"
  ],
    "core-js/features/object/entries": [
    "es.object.entries"
  ],
    "core-js/features/object/freeze": [
    "es.object.freeze"
  ],
    "core-js/features/object/from-entries": [
    "es.array.iterator",
    "es.object.from-entries"
  ],
    "core-js/features/object/get-own-property-descriptor": [
    "es.object.get-own-property-descriptor"
  ],
    "core-js/features/object/get-own-property-descriptors": [
    "es.object.get-own-property-descriptors"
  ],
    "core-js/features/object/get-own-property-names": [
    "es.object.get-own-property-names"
  ],
    "core-js/features/object/get-own-property-symbols": [
    "es.symbol"
  ],
    "core-js/features/object/get-prototype-of": [
    "es.object.get-prototype-of"
  ],
    "core-js/features/object/is": [
    "es.object.is"
  ],
    "core-js/features/object/is-extensible": [
    "es.object.is-extensible"
  ],
    "core-js/features/object/is-frozen": [
    "es.object.is-frozen"
  ],
    "core-js/features/object/is-sealed": [
    "es.object.is-sealed"
  ],
    "core-js/features/object/iterate-entries": [
    "esnext.object.iterate-entries"
  ],
    "core-js/features/object/iterate-keys": [
    "esnext.object.iterate-keys"
  ],
    "core-js/features/object/iterate-values": [
    "esnext.object.iterate-values"
  ],
    "core-js/features/object/keys": [
    "es.object.keys"
  ],
    "core-js/features/object/lookup-getter": [
    "es.object.lookup-setter"
  ],
    "core-js/features/object/lookup-setter": [
    "es.object.lookup-setter"
  ],
    "core-js/features/object/prevent-extensions": [
    "es.object.prevent-extensions"
  ],
    "core-js/features/object/seal": [
    "es.object.seal"
  ],
    "core-js/features/object/set-prototype-of": [
    "es.object.set-prototype-of"
  ],
    "core-js/features/object/to-string": [
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
    "core-js/features/object/values": [
    "es.object.values"
  ],
    "core-js/features/observable": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.observable",
    "esnext.symbol.observable",
    "web.dom-collections.iterator"
  ],
    "core-js/features/parse-float": [
    "es.parse-float"
  ],
    "core-js/features/parse-int": [
    "es.parse-int"
  ],
    "core-js/features/promise": [
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.string.iterator",
    "esnext.aggregate-error",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "web.dom-collections.iterator"
  ],
    "core-js/features/promise/all-settled": [
    "es.promise",
    "es.promise.all-settled",
    "esnext.promise.all-settled"
  ],
    "core-js/features/promise/any": [
    "es.promise",
    "esnext.aggregate-error",
    "esnext.promise.any"
  ],
    "core-js/features/promise/finally": [
    "es.promise",
    "es.promise.finally"
  ],
    "core-js/features/promise/try": [
    "es.promise",
    "esnext.promise.try"
  ],
    "core-js/features/queue-microtask": [
    "web.queue-microtask"
  ],
    "core-js/features/reflect": [
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata"
  ],
    "core-js/features/reflect/apply": [
    "es.reflect.apply"
  ],
    "core-js/features/reflect/construct": [
    "es.reflect.construct"
  ],
    "core-js/features/reflect/define-metadata": [
    "esnext.reflect.define-metadata"
  ],
    "core-js/features/reflect/define-property": [
    "es.reflect.define-property"
  ],
    "core-js/features/reflect/delete-metadata": [
    "esnext.reflect.delete-metadata"
  ],
    "core-js/features/reflect/delete-property": [
    "es.reflect.delete-property"
  ],
    "core-js/features/reflect/get": [
    "es.reflect.get"
  ],
    "core-js/features/reflect/get-metadata": [
    "esnext.reflect.get-metadata"
  ],
    "core-js/features/reflect/get-metadata-keys": [
    "esnext.reflect.get-metadata-keys"
  ],
    "core-js/features/reflect/get-own-metadata": [
    "esnext.reflect.get-own-metadata"
  ],
    "core-js/features/reflect/get-own-metadata-keys": [
    "esnext.reflect.get-own-metadata-keys"
  ],
    "core-js/features/reflect/get-own-property-descriptor": [
    "es.reflect.get-own-property-descriptor"
  ],
    "core-js/features/reflect/get-prototype-of": [
    "es.reflect.get-prototype-of"
  ],
    "core-js/features/reflect/has": [
    "es.reflect.has"
  ],
    "core-js/features/reflect/has-metadata": [
    "esnext.reflect.has-metadata"
  ],
    "core-js/features/reflect/has-own-metadata": [
    "esnext.reflect.has-own-metadata"
  ],
    "core-js/features/reflect/is-extensible": [
    "es.reflect.is-extensible"
  ],
    "core-js/features/reflect/metadata": [
    "esnext.reflect.metadata"
  ],
    "core-js/features/reflect/own-keys": [
    "es.reflect.own-keys"
  ],
    "core-js/features/reflect/prevent-extensions": [
    "es.reflect.prevent-extensions"
  ],
    "core-js/features/reflect/set": [
    "es.reflect.set"
  ],
    "core-js/features/reflect/set-prototype-of": [
    "es.reflect.set-prototype-of"
  ],
    "core-js/features/regexp": [
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.string.match",
    "es.string.replace",
    "es.string.search",
    "es.string.split"
  ],
    "core-js/features/regexp/constructor": [
    "es.regexp.constructor"
  ],
    "core-js/features/regexp/flags": [
    "es.regexp.flags"
  ],
    "core-js/features/regexp/match": [
    "es.string.match"
  ],
    "core-js/features/regexp/replace": [
    "es.string.replace"
  ],
    "core-js/features/regexp/search": [
    "es.string.search"
  ],
    "core-js/features/regexp/split": [
    "es.string.split"
  ],
    "core-js/features/regexp/sticky": [
    "es.regexp.sticky"
  ],
    "core-js/features/regexp/test": [
    "es.regexp.exec",
    "es.regexp.test"
  ],
    "core-js/features/regexp/to-string": [
    "es.regexp.to-string"
  ],
    "core-js/features/set": [
    "es.object.to-string",
    "es.set",
    "es.string.iterator",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "web.dom-collections.iterator"
  ],
    "core-js/features/set-immediate": [
    "web.immediate"
  ],
    "core-js/features/set-interval": [
    "web.timers"
  ],
    "core-js/features/set-timeout": [
    "web.timers"
  ],
    "core-js/features/set/add-all": [
    "es.set",
    "esnext.set.add-all"
  ],
    "core-js/features/set/delete-all": [
    "es.set",
    "esnext.set.delete-all"
  ],
    "core-js/features/set/difference": [
    "es.set",
    "es.string.iterator",
    "esnext.set.difference",
    "web.dom-collections.iterator"
  ],
    "core-js/features/set/every": [
    "es.set",
    "esnext.set.every"
  ],
    "core-js/features/set/filter": [
    "es.set",
    "esnext.set.filter"
  ],
    "core-js/features/set/find": [
    "es.set",
    "esnext.set.find"
  ],
    "core-js/features/set/from": [
    "es.set",
    "es.string.iterator",
    "esnext.set.from",
    "web.dom-collections.iterator"
  ],
    "core-js/features/set/intersection": [
    "es.set",
    "esnext.set.intersection"
  ],
    "core-js/features/set/is-disjoint-from": [
    "es.set",
    "esnext.set.is-disjoint-from"
  ],
    "core-js/features/set/is-subset-of": [
    "es.set",
    "es.string.iterator",
    "esnext.set.is-subset-of",
    "web.dom-collections.iterator"
  ],
    "core-js/features/set/is-superset-of": [
    "es.set",
    "esnext.set.is-superset-of"
  ],
    "core-js/features/set/join": [
    "es.set",
    "esnext.set.join"
  ],
    "core-js/features/set/map": [
    "es.set",
    "esnext.set.map"
  ],
    "core-js/features/set/of": [
    "es.set",
    "es.string.iterator",
    "esnext.set.of",
    "web.dom-collections.iterator"
  ],
    "core-js/features/set/reduce": [
    "es.set",
    "esnext.set.reduce"
  ],
    "core-js/features/set/some": [
    "es.set",
    "esnext.set.some"
  ],
    "core-js/features/set/symmetric-difference": [
    "es.set",
    "es.string.iterator",
    "esnext.set.symmetric-difference",
    "web.dom-collections.iterator"
  ],
    "core-js/features/set/union": [
    "es.set",
    "es.string.iterator",
    "esnext.set.union",
    "web.dom-collections.iterator"
  ],
    "core-js/features/string": [
    "es.regexp.exec",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all"
  ],
    "core-js/features/string/anchor": [
    "es.string.anchor"
  ],
    "core-js/features/string/at": [
    "esnext.string.at"
  ],
    "core-js/features/string/big": [
    "es.string.big"
  ],
    "core-js/features/string/blink": [
    "es.string.blink"
  ],
    "core-js/features/string/bold": [
    "es.string.bold"
  ],
    "core-js/features/string/code-point-at": [
    "es.string.code-point-at"
  ],
    "core-js/features/string/code-points": [
    "esnext.string.code-points"
  ],
    "core-js/features/string/ends-with": [
    "es.string.ends-with"
  ],
    "core-js/features/string/fixed": [
    "es.string.fixed"
  ],
    "core-js/features/string/fontcolor": [
    "es.string.fontcolor"
  ],
    "core-js/features/string/fontsize": [
    "es.string.fontsize"
  ],
    "core-js/features/string/from-code-point": [
    "es.string.from-code-point"
  ],
    "core-js/features/string/includes": [
    "es.string.includes"
  ],
    "core-js/features/string/italics": [
    "es.string.italics"
  ],
    "core-js/features/string/iterator": [
    "es.string.iterator"
  ],
    "core-js/features/string/link": [
    "es.string.link"
  ],
    "core-js/features/string/match": [
    "es.regexp.exec",
    "es.string.match"
  ],
    "core-js/features/string/match-all": [
    "es.string.match-all",
    "esnext.string.match-all"
  ],
    "core-js/features/string/pad-end": [
    "es.string.pad-end"
  ],
    "core-js/features/string/pad-start": [
    "es.string.pad-start"
  ],
    "core-js/features/string/raw": [
    "es.string.raw"
  ],
    "core-js/features/string/repeat": [
    "es.string.repeat"
  ],
    "core-js/features/string/replace": [
    "es.regexp.exec",
    "es.string.replace"
  ],
    "core-js/features/string/replace-all": [
    "esnext.string.replace-all"
  ],
    "core-js/features/string/search": [
    "es.regexp.exec",
    "es.string.search"
  ],
    "core-js/features/string/small": [
    "es.string.small"
  ],
    "core-js/features/string/split": [
    "es.regexp.exec",
    "es.string.split"
  ],
    "core-js/features/string/starts-with": [
    "es.string.starts-with"
  ],
    "core-js/features/string/strike": [
    "es.string.strike"
  ],
    "core-js/features/string/sub": [
    "es.string.sub"
  ],
    "core-js/features/string/sup": [
    "es.string.sup"
  ],
    "core-js/features/string/trim": [
    "es.string.trim"
  ],
    "core-js/features/string/trim-end": [
    "es.string.trim-end"
  ],
    "core-js/features/string/trim-left": [
    "es.string.trim-start"
  ],
    "core-js/features/string/trim-right": [
    "es.string.trim-end"
  ],
    "core-js/features/string/trim-start": [
    "es.string.trim-start"
  ],
    "core-js/features/string/virtual": [
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all"
  ],
    "core-js/features/string/virtual/anchor": [
    "es.string.anchor"
  ],
    "core-js/features/string/virtual/at": [
    "esnext.string.at"
  ],
    "core-js/features/string/virtual/big": [
    "es.string.big"
  ],
    "core-js/features/string/virtual/blink": [
    "es.string.blink"
  ],
    "core-js/features/string/virtual/bold": [
    "es.string.bold"
  ],
    "core-js/features/string/virtual/code-point-at": [
    "es.string.code-point-at"
  ],
    "core-js/features/string/virtual/code-points": [
    "esnext.string.code-points"
  ],
    "core-js/features/string/virtual/ends-with": [
    "es.string.ends-with"
  ],
    "core-js/features/string/virtual/fixed": [
    "es.string.fixed"
  ],
    "core-js/features/string/virtual/fontcolor": [
    "es.string.fontcolor"
  ],
    "core-js/features/string/virtual/fontsize": [
    "es.string.fontsize"
  ],
    "core-js/features/string/virtual/includes": [
    "es.string.includes"
  ],
    "core-js/features/string/virtual/italics": [
    "es.string.italics"
  ],
    "core-js/features/string/virtual/iterator": [
    "es.string.iterator"
  ],
    "core-js/features/string/virtual/link": [
    "es.string.link"
  ],
    "core-js/features/string/virtual/match-all": [
    "es.string.match-all",
    "esnext.string.match-all"
  ],
    "core-js/features/string/virtual/pad-end": [
    "es.string.pad-end"
  ],
    "core-js/features/string/virtual/pad-start": [
    "es.string.pad-start"
  ],
    "core-js/features/string/virtual/repeat": [
    "es.string.repeat"
  ],
    "core-js/features/string/virtual/replace-all": [
    "esnext.string.replace-all"
  ],
    "core-js/features/string/virtual/small": [
    "es.string.small"
  ],
    "core-js/features/string/virtual/starts-with": [
    "es.string.starts-with"
  ],
    "core-js/features/string/virtual/strike": [
    "es.string.strike"
  ],
    "core-js/features/string/virtual/sub": [
    "es.string.sub"
  ],
    "core-js/features/string/virtual/sup": [
    "es.string.sup"
  ],
    "core-js/features/string/virtual/trim": [
    "es.string.trim"
  ],
    "core-js/features/string/virtual/trim-end": [
    "es.string.trim-end"
  ],
    "core-js/features/string/virtual/trim-left": [
    "es.string.trim-start"
  ],
    "core-js/features/string/virtual/trim-right": [
    "es.string.trim-end"
  ],
    "core-js/features/string/virtual/trim-start": [
    "es.string.trim-start"
  ],
    "core-js/features/symbol": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all"
  ],
    "core-js/features/symbol/async-dispose": [
    "esnext.symbol.async-dispose"
  ],
    "core-js/features/symbol/async-iterator": [
    "es.symbol.async-iterator"
  ],
    "core-js/features/symbol/description": [
    "es.symbol.description"
  ],
    "core-js/features/symbol/dispose": [
    "esnext.symbol.dispose"
  ],
    "core-js/features/symbol/for": [
    "es.symbol"
  ],
    "core-js/features/symbol/has-instance": [
    "es.symbol.has-instance",
    "es.function.has-instance"
  ],
    "core-js/features/symbol/is-concat-spreadable": [
    "es.symbol.is-concat-spreadable",
    "es.array.concat"
  ],
    "core-js/features/symbol/iterator": [
    "es.symbol.iterator",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/features/symbol/key-for": [
    "es.symbol"
  ],
    "core-js/features/symbol/match": [
    "es.symbol.match",
    "es.string.match"
  ],
    "core-js/features/symbol/match-all": [
    "es.symbol.match-all",
    "es.string.match-all"
  ],
    "core-js/features/symbol/observable": [
    "esnext.symbol.observable"
  ],
    "core-js/features/symbol/pattern-match": [
    "esnext.symbol.pattern-match"
  ],
    "core-js/features/symbol/replace": [
    "es.symbol.replace",
    "es.string.replace"
  ],
    "core-js/features/symbol/replace-all": [
    "esnext.symbol.replace-all"
  ],
    "core-js/features/symbol/search": [
    "es.symbol.search",
    "es.string.search"
  ],
    "core-js/features/symbol/species": [
    "es.symbol.species"
  ],
    "core-js/features/symbol/split": [
    "es.symbol.split",
    "es.string.split"
  ],
    "core-js/features/symbol/to-primitive": [
    "es.symbol.to-primitive"
  ],
    "core-js/features/symbol/to-string-tag": [
    "es.symbol.to-string-tag",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
    "core-js/features/symbol/unscopables": [
    "es.symbol.unscopables"
  ],
    "core-js/features/typed-array": [
    "es.object.to-string",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/features/typed-array/copy-within": [
    "es.typed-array.copy-within"
  ],
    "core-js/features/typed-array/entries": [
    "es.typed-array.iterator"
  ],
    "core-js/features/typed-array/every": [
    "es.typed-array.every"
  ],
    "core-js/features/typed-array/fill": [
    "es.typed-array.fill"
  ],
    "core-js/features/typed-array/filter": [
    "es.typed-array.filter"
  ],
    "core-js/features/typed-array/find": [
    "es.typed-array.find"
  ],
    "core-js/features/typed-array/find-index": [
    "es.typed-array.find-index"
  ],
    "core-js/features/typed-array/float32-array": [
    "es.object.to-string",
    "es.typed-array.float32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/features/typed-array/float64-array": [
    "es.object.to-string",
    "es.typed-array.float64-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/features/typed-array/for-each": [
    "es.typed-array.for-each"
  ],
    "core-js/features/typed-array/from": [
    "es.typed-array.from"
  ],
    "core-js/features/typed-array/includes": [
    "es.typed-array.includes"
  ],
    "core-js/features/typed-array/index-of": [
    "es.typed-array.index-of"
  ],
    "core-js/features/typed-array/int16-array": [
    "es.object.to-string",
    "es.typed-array.int16-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/features/typed-array/int32-array": [
    "es.object.to-string",
    "es.typed-array.int32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/features/typed-array/int8-array": [
    "es.object.to-string",
    "es.typed-array.int8-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/features/typed-array/iterator": [
    "es.typed-array.iterator"
  ],
    "core-js/features/typed-array/join": [
    "es.typed-array.join"
  ],
    "core-js/features/typed-array/keys": [
    "es.typed-array.iterator"
  ],
    "core-js/features/typed-array/last-index-of": [
    "es.typed-array.last-index-of"
  ],
    "core-js/features/typed-array/map": [
    "es.typed-array.map"
  ],
    "core-js/features/typed-array/of": [
    "es.typed-array.of"
  ],
    "core-js/features/typed-array/reduce": [
    "es.typed-array.reduce"
  ],
    "core-js/features/typed-array/reduce-right": [
    "es.typed-array.reduce-right"
  ],
    "core-js/features/typed-array/reverse": [
    "es.typed-array.reverse"
  ],
    "core-js/features/typed-array/set": [
    "es.typed-array.set"
  ],
    "core-js/features/typed-array/slice": [
    "es.typed-array.slice"
  ],
    "core-js/features/typed-array/some": [
    "es.typed-array.some"
  ],
    "core-js/features/typed-array/sort": [
    "es.typed-array.sort"
  ],
    "core-js/features/typed-array/subarray": [
    "es.typed-array.subarray"
  ],
    "core-js/features/typed-array/to-locale-string": [
    "es.typed-array.to-locale-string"
  ],
    "core-js/features/typed-array/to-string": [
    "es.typed-array.to-string"
  ],
    "core-js/features/typed-array/uint16-array": [
    "es.object.to-string",
    "es.typed-array.uint16-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/features/typed-array/uint32-array": [
    "es.object.to-string",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/features/typed-array/uint8-array": [
    "es.object.to-string",
    "es.typed-array.uint8-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/features/typed-array/uint8-clamped-array": [
    "es.object.to-string",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/features/typed-array/values": [
    "es.typed-array.iterator"
  ],
    "core-js/features/url": [
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "core-js/features/url-search-params": [
    "web.url-search-params"
  ],
    "core-js/features/url/to-json": [
    "web.url.to-json"
  ],
    "core-js/features/weak-map": [
    "es.object.to-string",
    "es.weak-map",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "web.dom-collections.iterator"
  ],
    "core-js/features/weak-map/delete-all": [
    "es.weak-map",
    "esnext.weak-map.delete-all"
  ],
    "core-js/features/weak-map/from": [
    "es.string.iterator",
    "es.weak-map",
    "esnext.weak-map.from",
    "web.dom-collections.iterator"
  ],
    "core-js/features/weak-map/of": [
    "es.string.iterator",
    "es.weak-map",
    "esnext.weak-map.of",
    "web.dom-collections.iterator"
  ],
    "core-js/features/weak-map/upsert": [
    "es.weak-map",
    "esnext.weak-map.upsert"
  ],
    "core-js/features/weak-set": [
    "es.object.to-string",
    "es.weak-set",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.dom-collections.iterator"
  ],
    "core-js/features/weak-set/add-all": [
    "es.weak-set",
    "esnext.weak-set.add-all"
  ],
    "core-js/features/weak-set/delete-all": [
    "es.weak-set",
    "esnext.weak-set.delete-all"
  ],
    "core-js/features/weak-set/from": [
    "es.string.iterator",
    "es.weak-set",
    "esnext.weak-set.from",
    "web.dom-collections.iterator"
  ],
    "core-js/features/weak-set/of": [
    "es.string.iterator",
    "es.weak-set",
    "esnext.weak-set.of",
    "web.dom-collections.iterator"
  ],
    "core-js/modules/es.array-buffer.constructor": [
    "es.array-buffer.constructor"
  ],
    "core-js/modules/es.array-buffer.is-view": [
    "es.array-buffer.is-view"
  ],
    "core-js/modules/es.array-buffer.slice": [
    "es.array-buffer.slice"
  ],
    "core-js/modules/es.array.concat": [
    "es.array.concat"
  ],
    "core-js/modules/es.array.copy-within": [
    "es.array.copy-within"
  ],
    "core-js/modules/es.array.every": [
    "es.array.every"
  ],
    "core-js/modules/es.array.fill": [
    "es.array.fill"
  ],
    "core-js/modules/es.array.filter": [
    "es.array.filter"
  ],
    "core-js/modules/es.array.find": [
    "es.array.find"
  ],
    "core-js/modules/es.array.find-index": [
    "es.array.find-index"
  ],
    "core-js/modules/es.array.flat": [
    "es.array.flat"
  ],
    "core-js/modules/es.array.flat-map": [
    "es.array.flat-map"
  ],
    "core-js/modules/es.array.for-each": [
    "es.array.for-each"
  ],
    "core-js/modules/es.array.from": [
    "es.array.from"
  ],
    "core-js/modules/es.array.includes": [
    "es.array.includes"
  ],
    "core-js/modules/es.array.index-of": [
    "es.array.index-of"
  ],
    "core-js/modules/es.array.is-array": [
    "es.array.is-array"
  ],
    "core-js/modules/es.array.iterator": [
    "es.array.iterator"
  ],
    "core-js/modules/es.array.join": [
    "es.array.join"
  ],
    "core-js/modules/es.array.last-index-of": [
    "es.array.last-index-of"
  ],
    "core-js/modules/es.array.map": [
    "es.array.map"
  ],
    "core-js/modules/es.array.of": [
    "es.array.of"
  ],
    "core-js/modules/es.array.reduce": [
    "es.array.reduce"
  ],
    "core-js/modules/es.array.reduce-right": [
    "es.array.reduce-right"
  ],
    "core-js/modules/es.array.reverse": [
    "es.array.reverse"
  ],
    "core-js/modules/es.array.slice": [
    "es.array.slice"
  ],
    "core-js/modules/es.array.some": [
    "es.array.some"
  ],
    "core-js/modules/es.array.sort": [
    "es.array.sort"
  ],
    "core-js/modules/es.array.species": [
    "es.array.species"
  ],
    "core-js/modules/es.array.splice": [
    "es.array.splice"
  ],
    "core-js/modules/es.array.unscopables.flat": [
    "es.array.unscopables.flat"
  ],
    "core-js/modules/es.array.unscopables.flat-map": [
    "es.array.unscopables.flat-map"
  ],
    "core-js/modules/es.data-view": [
    "es.data-view"
  ],
    "core-js/modules/es.date.now": [
    "es.date.now"
  ],
    "core-js/modules/es.date.to-iso-string": [
    "es.date.to-iso-string"
  ],
    "core-js/modules/es.date.to-json": [
    "es.date.to-json"
  ],
    "core-js/modules/es.date.to-primitive": [
    "es.date.to-primitive"
  ],
    "core-js/modules/es.date.to-string": [
    "es.date.to-string"
  ],
    "core-js/modules/es.function.bind": [
    "es.function.bind"
  ],
    "core-js/modules/es.function.has-instance": [
    "es.function.has-instance"
  ],
    "core-js/modules/es.function.name": [
    "es.function.name"
  ],
    "core-js/modules/es.global-this": [
    "es.global-this"
  ],
    "core-js/modules/es.json.stringify": [
    "es.json.stringify"
  ],
    "core-js/modules/es.json.to-string-tag": [
    "es.json.to-string-tag"
  ],
    "core-js/modules/es.map": [
    "es.map"
  ],
    "core-js/modules/es.math.acosh": [
    "es.math.acosh"
  ],
    "core-js/modules/es.math.asinh": [
    "es.math.asinh"
  ],
    "core-js/modules/es.math.atanh": [
    "es.math.atanh"
  ],
    "core-js/modules/es.math.cbrt": [
    "es.math.cbrt"
  ],
    "core-js/modules/es.math.clz32": [
    "es.math.clz32"
  ],
    "core-js/modules/es.math.cosh": [
    "es.math.cosh"
  ],
    "core-js/modules/es.math.expm1": [
    "es.math.expm1"
  ],
    "core-js/modules/es.math.fround": [
    "es.math.fround"
  ],
    "core-js/modules/es.math.hypot": [
    "es.math.hypot"
  ],
    "core-js/modules/es.math.imul": [
    "es.math.imul"
  ],
    "core-js/modules/es.math.log10": [
    "es.math.log10"
  ],
    "core-js/modules/es.math.log1p": [
    "es.math.log1p"
  ],
    "core-js/modules/es.math.log2": [
    "es.math.log2"
  ],
    "core-js/modules/es.math.sign": [
    "es.math.sign"
  ],
    "core-js/modules/es.math.sinh": [
    "es.math.sinh"
  ],
    "core-js/modules/es.math.tanh": [
    "es.math.tanh"
  ],
    "core-js/modules/es.math.to-string-tag": [
    "es.math.to-string-tag"
  ],
    "core-js/modules/es.math.trunc": [
    "es.math.trunc"
  ],
    "core-js/modules/es.number.constructor": [
    "es.number.constructor"
  ],
    "core-js/modules/es.number.epsilon": [
    "es.number.epsilon"
  ],
    "core-js/modules/es.number.is-finite": [
    "es.number.is-finite"
  ],
    "core-js/modules/es.number.is-integer": [
    "es.number.is-integer"
  ],
    "core-js/modules/es.number.is-nan": [
    "es.number.is-nan"
  ],
    "core-js/modules/es.number.is-safe-integer": [
    "es.number.is-safe-integer"
  ],
    "core-js/modules/es.number.max-safe-integer": [
    "es.number.max-safe-integer"
  ],
    "core-js/modules/es.number.min-safe-integer": [
    "es.number.min-safe-integer"
  ],
    "core-js/modules/es.number.parse-float": [
    "es.number.parse-float"
  ],
    "core-js/modules/es.number.parse-int": [
    "es.number.parse-int"
  ],
    "core-js/modules/es.number.to-fixed": [
    "es.number.to-fixed"
  ],
    "core-js/modules/es.number.to-precision": [
    "es.number.to-precision"
  ],
    "core-js/modules/es.object.assign": [
    "es.object.assign"
  ],
    "core-js/modules/es.object.create": [
    "es.object.create"
  ],
    "core-js/modules/es.object.define-getter": [
    "es.object.define-getter"
  ],
    "core-js/modules/es.object.define-properties": [
    "es.object.define-properties"
  ],
    "core-js/modules/es.object.define-property": [
    "es.object.define-property"
  ],
    "core-js/modules/es.object.define-setter": [
    "es.object.define-setter"
  ],
    "core-js/modules/es.object.entries": [
    "es.object.entries"
  ],
    "core-js/modules/es.object.freeze": [
    "es.object.freeze"
  ],
    "core-js/modules/es.object.from-entries": [
    "es.object.from-entries"
  ],
    "core-js/modules/es.object.get-own-property-descriptor": [
    "es.object.get-own-property-descriptor"
  ],
    "core-js/modules/es.object.get-own-property-descriptors": [
    "es.object.get-own-property-descriptors"
  ],
    "core-js/modules/es.object.get-own-property-names": [
    "es.object.get-own-property-names"
  ],
    "core-js/modules/es.object.get-prototype-of": [
    "es.object.get-prototype-of"
  ],
    "core-js/modules/es.object.is": [
    "es.object.is"
  ],
    "core-js/modules/es.object.is-extensible": [
    "es.object.is-extensible"
  ],
    "core-js/modules/es.object.is-frozen": [
    "es.object.is-frozen"
  ],
    "core-js/modules/es.object.is-sealed": [
    "es.object.is-sealed"
  ],
    "core-js/modules/es.object.keys": [
    "es.object.keys"
  ],
    "core-js/modules/es.object.lookup-getter": [
    "es.object.lookup-getter"
  ],
    "core-js/modules/es.object.lookup-setter": [
    "es.object.lookup-setter"
  ],
    "core-js/modules/es.object.prevent-extensions": [
    "es.object.prevent-extensions"
  ],
    "core-js/modules/es.object.seal": [
    "es.object.seal"
  ],
    "core-js/modules/es.object.set-prototype-of": [
    "es.object.set-prototype-of"
  ],
    "core-js/modules/es.object.to-string": [
    "es.object.to-string"
  ],
    "core-js/modules/es.object.values": [
    "es.object.values"
  ],
    "core-js/modules/es.parse-float": [
    "es.parse-float"
  ],
    "core-js/modules/es.parse-int": [
    "es.parse-int"
  ],
    "core-js/modules/es.promise": [
    "es.promise"
  ],
    "core-js/modules/es.promise.all-settled": [
    "es.promise.all-settled"
  ],
    "core-js/modules/es.promise.finally": [
    "es.promise.finally"
  ],
    "core-js/modules/es.reflect.apply": [
    "es.reflect.apply"
  ],
    "core-js/modules/es.reflect.construct": [
    "es.reflect.construct"
  ],
    "core-js/modules/es.reflect.define-property": [
    "es.reflect.define-property"
  ],
    "core-js/modules/es.reflect.delete-property": [
    "es.reflect.delete-property"
  ],
    "core-js/modules/es.reflect.get": [
    "es.reflect.get"
  ],
    "core-js/modules/es.reflect.get-own-property-descriptor": [
    "es.reflect.get-own-property-descriptor"
  ],
    "core-js/modules/es.reflect.get-prototype-of": [
    "es.reflect.get-prototype-of"
  ],
    "core-js/modules/es.reflect.has": [
    "es.reflect.has"
  ],
    "core-js/modules/es.reflect.is-extensible": [
    "es.reflect.is-extensible"
  ],
    "core-js/modules/es.reflect.own-keys": [
    "es.reflect.own-keys"
  ],
    "core-js/modules/es.reflect.prevent-extensions": [
    "es.reflect.prevent-extensions"
  ],
    "core-js/modules/es.reflect.set": [
    "es.reflect.set"
  ],
    "core-js/modules/es.reflect.set-prototype-of": [
    "es.reflect.set-prototype-of"
  ],
    "core-js/modules/es.regexp.constructor": [
    "es.regexp.constructor"
  ],
    "core-js/modules/es.regexp.exec": [
    "es.regexp.exec"
  ],
    "core-js/modules/es.regexp.flags": [
    "es.regexp.flags"
  ],
    "core-js/modules/es.regexp.sticky": [
    "es.regexp.sticky"
  ],
    "core-js/modules/es.regexp.test": [
    "es.regexp.test"
  ],
    "core-js/modules/es.regexp.to-string": [
    "es.regexp.to-string"
  ],
    "core-js/modules/es.set": [
    "es.set"
  ],
    "core-js/modules/es.string.anchor": [
    "es.string.anchor"
  ],
    "core-js/modules/es.string.big": [
    "es.string.big"
  ],
    "core-js/modules/es.string.blink": [
    "es.string.blink"
  ],
    "core-js/modules/es.string.bold": [
    "es.string.bold"
  ],
    "core-js/modules/es.string.code-point-at": [
    "es.string.code-point-at"
  ],
    "core-js/modules/es.string.ends-with": [
    "es.string.ends-with"
  ],
    "core-js/modules/es.string.fixed": [
    "es.string.fixed"
  ],
    "core-js/modules/es.string.fontcolor": [
    "es.string.fontcolor"
  ],
    "core-js/modules/es.string.fontsize": [
    "es.string.fontsize"
  ],
    "core-js/modules/es.string.from-code-point": [
    "es.string.from-code-point"
  ],
    "core-js/modules/es.string.includes": [
    "es.string.includes"
  ],
    "core-js/modules/es.string.italics": [
    "es.string.italics"
  ],
    "core-js/modules/es.string.iterator": [
    "es.string.iterator"
  ],
    "core-js/modules/es.string.link": [
    "es.string.link"
  ],
    "core-js/modules/es.string.match": [
    "es.string.match"
  ],
    "core-js/modules/es.string.match-all": [
    "es.string.match-all"
  ],
    "core-js/modules/es.string.pad-end": [
    "es.string.pad-end"
  ],
    "core-js/modules/es.string.pad-start": [
    "es.string.pad-start"
  ],
    "core-js/modules/es.string.raw": [
    "es.string.raw"
  ],
    "core-js/modules/es.string.repeat": [
    "es.string.repeat"
  ],
    "core-js/modules/es.string.replace": [
    "es.string.replace"
  ],
    "core-js/modules/es.string.search": [
    "es.string.search"
  ],
    "core-js/modules/es.string.small": [
    "es.string.small"
  ],
    "core-js/modules/es.string.split": [
    "es.string.split"
  ],
    "core-js/modules/es.string.starts-with": [
    "es.string.starts-with"
  ],
    "core-js/modules/es.string.strike": [
    "es.string.strike"
  ],
    "core-js/modules/es.string.sub": [
    "es.string.sub"
  ],
    "core-js/modules/es.string.sup": [
    "es.string.sup"
  ],
    "core-js/modules/es.string.trim": [
    "es.string.trim"
  ],
    "core-js/modules/es.string.trim-end": [
    "es.string.trim-end"
  ],
    "core-js/modules/es.string.trim-start": [
    "es.string.trim-start"
  ],
    "core-js/modules/es.symbol": [
    "es.symbol"
  ],
    "core-js/modules/es.symbol.async-iterator": [
    "es.symbol.async-iterator"
  ],
    "core-js/modules/es.symbol.description": [
    "es.symbol.description"
  ],
    "core-js/modules/es.symbol.has-instance": [
    "es.symbol.has-instance"
  ],
    "core-js/modules/es.symbol.is-concat-spreadable": [
    "es.symbol.is-concat-spreadable"
  ],
    "core-js/modules/es.symbol.iterator": [
    "es.symbol.iterator"
  ],
    "core-js/modules/es.symbol.match": [
    "es.symbol.match"
  ],
    "core-js/modules/es.symbol.match-all": [
    "es.symbol.match-all"
  ],
    "core-js/modules/es.symbol.replace": [
    "es.symbol.replace"
  ],
    "core-js/modules/es.symbol.search": [
    "es.symbol.search"
  ],
    "core-js/modules/es.symbol.species": [
    "es.symbol.species"
  ],
    "core-js/modules/es.symbol.split": [
    "es.symbol.split"
  ],
    "core-js/modules/es.symbol.to-primitive": [
    "es.symbol.to-primitive"
  ],
    "core-js/modules/es.symbol.to-string-tag": [
    "es.symbol.to-string-tag"
  ],
    "core-js/modules/es.symbol.unscopables": [
    "es.symbol.unscopables"
  ],
    "core-js/modules/es.typed-array.copy-within": [
    "es.typed-array.copy-within"
  ],
    "core-js/modules/es.typed-array.every": [
    "es.typed-array.every"
  ],
    "core-js/modules/es.typed-array.fill": [
    "es.typed-array.fill"
  ],
    "core-js/modules/es.typed-array.filter": [
    "es.typed-array.filter"
  ],
    "core-js/modules/es.typed-array.find": [
    "es.typed-array.find"
  ],
    "core-js/modules/es.typed-array.find-index": [
    "es.typed-array.find-index"
  ],
    "core-js/modules/es.typed-array.float32-array": [
    "es.typed-array.float32-array"
  ],
    "core-js/modules/es.typed-array.float64-array": [
    "es.typed-array.float64-array"
  ],
    "core-js/modules/es.typed-array.for-each": [
    "es.typed-array.for-each"
  ],
    "core-js/modules/es.typed-array.from": [
    "es.typed-array.from"
  ],
    "core-js/modules/es.typed-array.includes": [
    "es.typed-array.includes"
  ],
    "core-js/modules/es.typed-array.index-of": [
    "es.typed-array.index-of"
  ],
    "core-js/modules/es.typed-array.int16-array": [
    "es.typed-array.int16-array"
  ],
    "core-js/modules/es.typed-array.int32-array": [
    "es.typed-array.int32-array"
  ],
    "core-js/modules/es.typed-array.int8-array": [
    "es.typed-array.int8-array"
  ],
    "core-js/modules/es.typed-array.iterator": [
    "es.typed-array.iterator"
  ],
    "core-js/modules/es.typed-array.join": [
    "es.typed-array.join"
  ],
    "core-js/modules/es.typed-array.last-index-of": [
    "es.typed-array.last-index-of"
  ],
    "core-js/modules/es.typed-array.map": [
    "es.typed-array.map"
  ],
    "core-js/modules/es.typed-array.of": [
    "es.typed-array.of"
  ],
    "core-js/modules/es.typed-array.reduce": [
    "es.typed-array.reduce"
  ],
    "core-js/modules/es.typed-array.reduce-right": [
    "es.typed-array.reduce-right"
  ],
    "core-js/modules/es.typed-array.reverse": [
    "es.typed-array.reverse"
  ],
    "core-js/modules/es.typed-array.set": [
    "es.typed-array.set"
  ],
    "core-js/modules/es.typed-array.slice": [
    "es.typed-array.slice"
  ],
    "core-js/modules/es.typed-array.some": [
    "es.typed-array.some"
  ],
    "core-js/modules/es.typed-array.sort": [
    "es.typed-array.sort"
  ],
    "core-js/modules/es.typed-array.subarray": [
    "es.typed-array.subarray"
  ],
    "core-js/modules/es.typed-array.to-locale-string": [
    "es.typed-array.to-locale-string"
  ],
    "core-js/modules/es.typed-array.to-string": [
    "es.typed-array.to-string"
  ],
    "core-js/modules/es.typed-array.uint16-array": [
    "es.typed-array.uint16-array"
  ],
    "core-js/modules/es.typed-array.uint32-array": [
    "es.typed-array.uint32-array"
  ],
    "core-js/modules/es.typed-array.uint8-array": [
    "es.typed-array.uint8-array"
  ],
    "core-js/modules/es.typed-array.uint8-clamped-array": [
    "es.typed-array.uint8-clamped-array"
  ],
    "core-js/modules/es.weak-map": [
    "es.weak-map"
  ],
    "core-js/modules/es.weak-set": [
    "es.weak-set"
  ],
    "core-js/modules/esnext.aggregate-error": [
    "esnext.aggregate-error"
  ],
    "core-js/modules/esnext.array.is-template-object": [
    "esnext.array.is-template-object"
  ],
    "core-js/modules/esnext.array.last-index": [
    "esnext.array.last-index"
  ],
    "core-js/modules/esnext.array.last-item": [
    "esnext.array.last-item"
  ],
    "core-js/modules/esnext.async-iterator.as-indexed-pairs": [
    "esnext.async-iterator.as-indexed-pairs"
  ],
    "core-js/modules/esnext.async-iterator.constructor": [
    "esnext.async-iterator.constructor"
  ],
    "core-js/modules/esnext.async-iterator.drop": [
    "esnext.async-iterator.drop"
  ],
    "core-js/modules/esnext.async-iterator.every": [
    "esnext.async-iterator.every"
  ],
    "core-js/modules/esnext.async-iterator.filter": [
    "esnext.async-iterator.filter"
  ],
    "core-js/modules/esnext.async-iterator.find": [
    "esnext.async-iterator.find"
  ],
    "core-js/modules/esnext.async-iterator.flat-map": [
    "esnext.async-iterator.flat-map"
  ],
    "core-js/modules/esnext.async-iterator.for-each": [
    "esnext.async-iterator.for-each"
  ],
    "core-js/modules/esnext.async-iterator.from": [
    "esnext.async-iterator.from"
  ],
    "core-js/modules/esnext.async-iterator.map": [
    "esnext.async-iterator.map"
  ],
    "core-js/modules/esnext.async-iterator.reduce": [
    "esnext.async-iterator.reduce"
  ],
    "core-js/modules/esnext.async-iterator.some": [
    "esnext.async-iterator.some"
  ],
    "core-js/modules/esnext.async-iterator.take": [
    "esnext.async-iterator.take"
  ],
    "core-js/modules/esnext.async-iterator.to-array": [
    "esnext.async-iterator.to-array"
  ],
    "core-js/modules/esnext.composite-key": [
    "esnext.composite-key"
  ],
    "core-js/modules/esnext.composite-symbol": [
    "esnext.composite-symbol"
  ],
    "core-js/modules/esnext.global-this": [
    "esnext.global-this"
  ],
    "core-js/modules/esnext.iterator.as-indexed-pairs": [
    "esnext.iterator.as-indexed-pairs"
  ],
    "core-js/modules/esnext.iterator.constructor": [
    "esnext.iterator.constructor"
  ],
    "core-js/modules/esnext.iterator.drop": [
    "esnext.iterator.drop"
  ],
    "core-js/modules/esnext.iterator.every": [
    "esnext.iterator.every"
  ],
    "core-js/modules/esnext.iterator.filter": [
    "esnext.iterator.filter"
  ],
    "core-js/modules/esnext.iterator.find": [
    "esnext.iterator.find"
  ],
    "core-js/modules/esnext.iterator.flat-map": [
    "esnext.iterator.flat-map"
  ],
    "core-js/modules/esnext.iterator.for-each": [
    "esnext.iterator.for-each"
  ],
    "core-js/modules/esnext.iterator.from": [
    "esnext.iterator.from"
  ],
    "core-js/modules/esnext.iterator.map": [
    "esnext.iterator.map"
  ],
    "core-js/modules/esnext.iterator.reduce": [
    "esnext.iterator.reduce"
  ],
    "core-js/modules/esnext.iterator.some": [
    "esnext.iterator.some"
  ],
    "core-js/modules/esnext.iterator.take": [
    "esnext.iterator.take"
  ],
    "core-js/modules/esnext.iterator.to-array": [
    "esnext.iterator.to-array"
  ],
    "core-js/modules/esnext.map.delete-all": [
    "esnext.map.delete-all"
  ],
    "core-js/modules/esnext.map.every": [
    "esnext.map.every"
  ],
    "core-js/modules/esnext.map.filter": [
    "esnext.map.filter"
  ],
    "core-js/modules/esnext.map.find": [
    "esnext.map.find"
  ],
    "core-js/modules/esnext.map.find-key": [
    "esnext.map.find-key"
  ],
    "core-js/modules/esnext.map.from": [
    "esnext.map.from"
  ],
    "core-js/modules/esnext.map.group-by": [
    "esnext.map.group-by"
  ],
    "core-js/modules/esnext.map.includes": [
    "esnext.map.includes"
  ],
    "core-js/modules/esnext.map.key-by": [
    "esnext.map.key-by"
  ],
    "core-js/modules/esnext.map.key-of": [
    "esnext.map.key-of"
  ],
    "core-js/modules/esnext.map.map-keys": [
    "esnext.map.map-keys"
  ],
    "core-js/modules/esnext.map.map-values": [
    "esnext.map.map-values"
  ],
    "core-js/modules/esnext.map.merge": [
    "esnext.map.merge"
  ],
    "core-js/modules/esnext.map.of": [
    "esnext.map.of"
  ],
    "core-js/modules/esnext.map.reduce": [
    "esnext.map.reduce"
  ],
    "core-js/modules/esnext.map.some": [
    "esnext.map.some"
  ],
    "core-js/modules/esnext.map.update": [
    "esnext.map.update"
  ],
    "core-js/modules/esnext.map.update-or-insert": [
    "esnext.map.update-or-insert"
  ],
    "core-js/modules/esnext.map.upsert": [
    "esnext.map.upsert"
  ],
    "core-js/modules/esnext.math.clamp": [
    "esnext.math.clamp"
  ],
    "core-js/modules/esnext.math.deg-per-rad": [
    "esnext.math.deg-per-rad"
  ],
    "core-js/modules/esnext.math.degrees": [
    "esnext.math.degrees"
  ],
    "core-js/modules/esnext.math.fscale": [
    "esnext.math.fscale"
  ],
    "core-js/modules/esnext.math.iaddh": [
    "esnext.math.iaddh"
  ],
    "core-js/modules/esnext.math.imulh": [
    "esnext.math.imulh"
  ],
    "core-js/modules/esnext.math.isubh": [
    "esnext.math.isubh"
  ],
    "core-js/modules/esnext.math.rad-per-deg": [
    "esnext.math.rad-per-deg"
  ],
    "core-js/modules/esnext.math.radians": [
    "esnext.math.radians"
  ],
    "core-js/modules/esnext.math.scale": [
    "esnext.math.scale"
  ],
    "core-js/modules/esnext.math.seeded-prng": [
    "esnext.math.seeded-prng"
  ],
    "core-js/modules/esnext.math.signbit": [
    "esnext.math.signbit"
  ],
    "core-js/modules/esnext.math.umulh": [
    "esnext.math.umulh"
  ],
    "core-js/modules/esnext.number.from-string": [
    "esnext.number.from-string"
  ],
    "core-js/modules/esnext.object.iterate-entries": [
    "esnext.object.iterate-entries"
  ],
    "core-js/modules/esnext.object.iterate-keys": [
    "esnext.object.iterate-keys"
  ],
    "core-js/modules/esnext.object.iterate-values": [
    "esnext.object.iterate-values"
  ],
    "core-js/modules/esnext.observable": [
    "esnext.observable"
  ],
    "core-js/modules/esnext.promise.all-settled": [
    "esnext.promise.all-settled"
  ],
    "core-js/modules/esnext.promise.any": [
    "esnext.promise.any"
  ],
    "core-js/modules/esnext.promise.try": [
    "esnext.promise.try"
  ],
    "core-js/modules/esnext.reflect.define-metadata": [
    "esnext.reflect.define-metadata"
  ],
    "core-js/modules/esnext.reflect.delete-metadata": [
    "esnext.reflect.delete-metadata"
  ],
    "core-js/modules/esnext.reflect.get-metadata": [
    "esnext.reflect.get-metadata"
  ],
    "core-js/modules/esnext.reflect.get-metadata-keys": [
    "esnext.reflect.get-metadata-keys"
  ],
    "core-js/modules/esnext.reflect.get-own-metadata": [
    "esnext.reflect.get-own-metadata"
  ],
    "core-js/modules/esnext.reflect.get-own-metadata-keys": [
    "esnext.reflect.get-own-metadata-keys"
  ],
    "core-js/modules/esnext.reflect.has-metadata": [
    "esnext.reflect.has-metadata"
  ],
    "core-js/modules/esnext.reflect.has-own-metadata": [
    "esnext.reflect.has-own-metadata"
  ],
    "core-js/modules/esnext.reflect.metadata": [
    "esnext.reflect.metadata"
  ],
    "core-js/modules/esnext.set.add-all": [
    "esnext.set.add-all"
  ],
    "core-js/modules/esnext.set.delete-all": [
    "esnext.set.delete-all"
  ],
    "core-js/modules/esnext.set.difference": [
    "esnext.set.difference"
  ],
    "core-js/modules/esnext.set.every": [
    "esnext.set.every"
  ],
    "core-js/modules/esnext.set.filter": [
    "esnext.set.filter"
  ],
    "core-js/modules/esnext.set.find": [
    "esnext.set.find"
  ],
    "core-js/modules/esnext.set.from": [
    "esnext.set.from"
  ],
    "core-js/modules/esnext.set.intersection": [
    "esnext.set.intersection"
  ],
    "core-js/modules/esnext.set.is-disjoint-from": [
    "esnext.set.is-disjoint-from"
  ],
    "core-js/modules/esnext.set.is-subset-of": [
    "esnext.set.is-subset-of"
  ],
    "core-js/modules/esnext.set.is-superset-of": [
    "esnext.set.is-superset-of"
  ],
    "core-js/modules/esnext.set.join": [
    "esnext.set.join"
  ],
    "core-js/modules/esnext.set.map": [
    "esnext.set.map"
  ],
    "core-js/modules/esnext.set.of": [
    "esnext.set.of"
  ],
    "core-js/modules/esnext.set.reduce": [
    "esnext.set.reduce"
  ],
    "core-js/modules/esnext.set.some": [
    "esnext.set.some"
  ],
    "core-js/modules/esnext.set.symmetric-difference": [
    "esnext.set.symmetric-difference"
  ],
    "core-js/modules/esnext.set.union": [
    "esnext.set.union"
  ],
    "core-js/modules/esnext.string.at": [
    "esnext.string.at"
  ],
    "core-js/modules/esnext.string.code-points": [
    "esnext.string.code-points"
  ],
    "core-js/modules/esnext.string.match-all": [
    "esnext.string.match-all"
  ],
    "core-js/modules/esnext.string.replace-all": [
    "esnext.string.replace-all"
  ],
    "core-js/modules/esnext.symbol.async-dispose": [
    "esnext.symbol.async-dispose"
  ],
    "core-js/modules/esnext.symbol.dispose": [
    "esnext.symbol.dispose"
  ],
    "core-js/modules/esnext.symbol.observable": [
    "esnext.symbol.observable"
  ],
    "core-js/modules/esnext.symbol.pattern-match": [
    "esnext.symbol.pattern-match"
  ],
    "core-js/modules/esnext.symbol.replace-all": [
    "esnext.symbol.replace-all"
  ],
    "core-js/modules/esnext.weak-map.delete-all": [
    "esnext.weak-map.delete-all"
  ],
    "core-js/modules/esnext.weak-map.from": [
    "esnext.weak-map.from"
  ],
    "core-js/modules/esnext.weak-map.of": [
    "esnext.weak-map.of"
  ],
    "core-js/modules/esnext.weak-map.upsert": [
    "esnext.weak-map.upsert"
  ],
    "core-js/modules/esnext.weak-set.add-all": [
    "esnext.weak-set.add-all"
  ],
    "core-js/modules/esnext.weak-set.delete-all": [
    "esnext.weak-set.delete-all"
  ],
    "core-js/modules/esnext.weak-set.from": [
    "esnext.weak-set.from"
  ],
    "core-js/modules/esnext.weak-set.of": [
    "esnext.weak-set.of"
  ],
    "core-js/modules/web.dom-collections.for-each": [
    "web.dom-collections.for-each"
  ],
    "core-js/modules/web.dom-collections.iterator": [
    "web.dom-collections.iterator"
  ],
    "core-js/modules/web.immediate": [
    "web.immediate"
  ],
    "core-js/modules/web.queue-microtask": [
    "web.queue-microtask"
  ],
    "core-js/modules/web.timers": [
    "web.timers"
  ],
    "core-js/modules/web.url": [
    "web.url"
  ],
    "core-js/modules/web.url-search-params": [
    "web.url-search-params"
  ],
    "core-js/modules/web.url.to-json": [
    "web.url.to-json"
  ],
    "core-js/proposals": [
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "core-js/proposals/array-is-template-object": [
    "esnext.array.is-template-object"
  ],
    "core-js/proposals/array-last": [
    "esnext.array.last-index",
    "esnext.array.last-item"
  ],
    "core-js/proposals/collection-methods": [
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.weak-map.delete-all",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all"
  ],
    "core-js/proposals/collection-of-from": [
    "esnext.map.from",
    "esnext.map.of",
    "esnext.set.from",
    "esnext.set.of",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-set.from",
    "esnext.weak-set.of"
  ],
    "core-js/proposals/efficient-64-bit-arithmetic": [
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.umulh"
  ],
    "core-js/proposals/global-this": [
    "esnext.global-this"
  ],
    "core-js/proposals/iterator-helpers": [
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array"
  ],
    "core-js/proposals/keys-composition": [
    "esnext.composite-key",
    "esnext.composite-symbol"
  ],
    "core-js/proposals/map-update-or-insert": [
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.weak-map.upsert"
  ],
    "core-js/proposals/map-upsert": [
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.weak-map.upsert"
  ],
    "core-js/proposals/math-extensions": [
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale"
  ],
    "core-js/proposals/math-signbit": [
    "esnext.math.signbit"
  ],
    "core-js/proposals/number-from-string": [
    "esnext.number.from-string"
  ],
    "core-js/proposals/object-iteration": [
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values"
  ],
    "core-js/proposals/observable": [
    "esnext.observable",
    "esnext.symbol.observable"
  ],
    "core-js/proposals/pattern-matching": [
    "esnext.symbol.pattern-match"
  ],
    "core-js/proposals/promise-all-settled": [
    "esnext.promise.all-settled"
  ],
    "core-js/proposals/promise-any": [
    "esnext.aggregate-error",
    "esnext.promise.any"
  ],
    "core-js/proposals/promise-try": [
    "esnext.promise.try"
  ],
    "core-js/proposals/reflect-metadata": [
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata"
  ],
    "core-js/proposals/seeded-random": [
    "esnext.math.seeded-prng"
  ],
    "core-js/proposals/set-methods": [
    "esnext.set.difference",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.symmetric-difference",
    "esnext.set.union"
  ],
    "core-js/proposals/string-at": [
    "esnext.string.at"
  ],
    "core-js/proposals/string-code-points": [
    "esnext.string.code-points"
  ],
    "core-js/proposals/string-match-all": [
    "esnext.string.match-all"
  ],
    "core-js/proposals/string-replace-all": [
    "esnext.string.replace-all",
    "esnext.symbol.replace-all"
  ],
    "core-js/proposals/url": [
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "core-js/proposals/using-statement": [
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose"
  ],
    "core-js/stable": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.set",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string",
    "es.weak-map",
    "es.weak-set",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.immediate",
    "web.queue-microtask",
    "web.timers",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "core-js/stable/array": [
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.string.iterator"
  ],
    "core-js/stable/array-buffer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string"
  ],
    "core-js/stable/array-buffer/constructor": [
    "es.array-buffer.constructor",
    "es.object.to-string"
  ],
    "core-js/stable/array-buffer/is-view": [
    "es.array-buffer.is-view"
  ],
    "core-js/stable/array-buffer/slice": [
    "es.array-buffer.slice"
  ],
    "core-js/stable/array/concat": [
    "es.array.concat"
  ],
    "core-js/stable/array/copy-within": [
    "es.array.copy-within"
  ],
    "core-js/stable/array/entries": [
    "es.array.iterator"
  ],
    "core-js/stable/array/every": [
    "es.array.every"
  ],
    "core-js/stable/array/fill": [
    "es.array.fill"
  ],
    "core-js/stable/array/filter": [
    "es.array.filter"
  ],
    "core-js/stable/array/find": [
    "es.array.find"
  ],
    "core-js/stable/array/find-index": [
    "es.array.find-index"
  ],
    "core-js/stable/array/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
    "core-js/stable/array/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
    "core-js/stable/array/for-each": [
    "es.array.for-each"
  ],
    "core-js/stable/array/from": [
    "es.array.from",
    "es.string.iterator"
  ],
    "core-js/stable/array/includes": [
    "es.array.includes"
  ],
    "core-js/stable/array/index-of": [
    "es.array.index-of"
  ],
    "core-js/stable/array/is-array": [
    "es.array.is-array"
  ],
    "core-js/stable/array/iterator": [
    "es.array.iterator"
  ],
    "core-js/stable/array/join": [
    "es.array.join"
  ],
    "core-js/stable/array/keys": [
    "es.array.iterator"
  ],
    "core-js/stable/array/last-index-of": [
    "es.array.last-index-of"
  ],
    "core-js/stable/array/map": [
    "es.array.map"
  ],
    "core-js/stable/array/of": [
    "es.array.of"
  ],
    "core-js/stable/array/reduce": [
    "es.array.reduce"
  ],
    "core-js/stable/array/reduce-right": [
    "es.array.reduce-right"
  ],
    "core-js/stable/array/reverse": [
    "es.array.reverse"
  ],
    "core-js/stable/array/slice": [
    "es.array.slice"
  ],
    "core-js/stable/array/some": [
    "es.array.some"
  ],
    "core-js/stable/array/sort": [
    "es.array.sort"
  ],
    "core-js/stable/array/splice": [
    "es.array.splice"
  ],
    "core-js/stable/array/values": [
    "es.array.iterator"
  ],
    "core-js/stable/array/virtual": [
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.includes",
    "es.array.index-of",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map"
  ],
    "core-js/stable/array/virtual/concat": [
    "es.array.concat"
  ],
    "core-js/stable/array/virtual/copy-within": [
    "es.array.copy-within"
  ],
    "core-js/stable/array/virtual/entries": [
    "es.array.iterator"
  ],
    "core-js/stable/array/virtual/every": [
    "es.array.every"
  ],
    "core-js/stable/array/virtual/fill": [
    "es.array.fill"
  ],
    "core-js/stable/array/virtual/filter": [
    "es.array.filter"
  ],
    "core-js/stable/array/virtual/find": [
    "es.array.find"
  ],
    "core-js/stable/array/virtual/find-index": [
    "es.array.find-index"
  ],
    "core-js/stable/array/virtual/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
    "core-js/stable/array/virtual/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
    "core-js/stable/array/virtual/for-each": [
    "es.array.for-each"
  ],
    "core-js/stable/array/virtual/includes": [
    "es.array.includes"
  ],
    "core-js/stable/array/virtual/index-of": [
    "es.array.index-of"
  ],
    "core-js/stable/array/virtual/iterator": [
    "es.array.iterator"
  ],
    "core-js/stable/array/virtual/join": [
    "es.array.join"
  ],
    "core-js/stable/array/virtual/keys": [
    "es.array.iterator"
  ],
    "core-js/stable/array/virtual/last-index-of": [
    "es.array.last-index-of"
  ],
    "core-js/stable/array/virtual/map": [
    "es.array.map"
  ],
    "core-js/stable/array/virtual/reduce": [
    "es.array.reduce"
  ],
    "core-js/stable/array/virtual/reduce-right": [
    "es.array.reduce-right"
  ],
    "core-js/stable/array/virtual/reverse": [
    "es.array.reverse"
  ],
    "core-js/stable/array/virtual/slice": [
    "es.array.slice"
  ],
    "core-js/stable/array/virtual/some": [
    "es.array.some"
  ],
    "core-js/stable/array/virtual/sort": [
    "es.array.sort"
  ],
    "core-js/stable/array/virtual/splice": [
    "es.array.splice"
  ],
    "core-js/stable/array/virtual/values": [
    "es.array.iterator"
  ],
    "core-js/stable/clear-immediate": [
    "web.immediate"
  ],
    "core-js/stable/data-view": [
    "es.data-view",
    "es.object.to-string"
  ],
    "core-js/stable/date": [
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string"
  ],
    "core-js/stable/date/now": [
    "es.date.now"
  ],
    "core-js/stable/date/to-iso-string": [
    "es.date.to-iso-string",
    "es.date.to-json"
  ],
    "core-js/stable/date/to-json": [
    "es.date.to-json"
  ],
    "core-js/stable/date/to-primitive": [
    "es.date.to-primitive"
  ],
    "core-js/stable/date/to-string": [
    "es.date.to-string"
  ],
    "core-js/stable/dom-collections": [
    "es.array.iterator",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator"
  ],
    "core-js/stable/dom-collections/for-each": [
    "web.dom-collections.for-each"
  ],
    "core-js/stable/dom-collections/iterator": [
    "web.dom-collections.iterator"
  ],
    "core-js/stable/function": [
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name"
  ],
    "core-js/stable/function/bind": [
    "es.function.bind"
  ],
    "core-js/stable/function/has-instance": [
    "es.function.has-instance"
  ],
    "core-js/stable/function/name": [
    "es.function.name"
  ],
    "core-js/stable/function/virtual": [
    "es.function.bind"
  ],
    "core-js/stable/function/virtual/bind": [
    "es.function.bind"
  ],
    "core-js/stable/global-this": [
    "es.global-this"
  ],
    "core-js/stable/instance/bind": [
    "es.function.bind"
  ],
    "core-js/stable/instance/code-point-at": [
    "es.string.code-point-at"
  ],
    "core-js/stable/instance/concat": [
    "es.array.concat"
  ],
    "core-js/stable/instance/copy-within": [
    "es.array.copy-within"
  ],
    "core-js/stable/instance/ends-with": [
    "es.string.ends-with"
  ],
    "core-js/stable/instance/entries": [
    "es.array.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/stable/instance/every": [
    "es.array.every"
  ],
    "core-js/stable/instance/fill": [
    "es.array.fill"
  ],
    "core-js/stable/instance/filter": [
    "es.array.filter"
  ],
    "core-js/stable/instance/find": [
    "es.array.find"
  ],
    "core-js/stable/instance/find-index": [
    "es.array.find-index"
  ],
    "core-js/stable/instance/flags": [
    "es.regexp.flags"
  ],
    "core-js/stable/instance/flat": [
    "es.array.flat",
    "es.array.unscopables.flat"
  ],
    "core-js/stable/instance/flat-map": [
    "es.array.flat-map",
    "es.array.unscopables.flat-map"
  ],
    "core-js/stable/instance/for-each": [
    "es.array.for-each",
    "web.dom-collections.iterator"
  ],
    "core-js/stable/instance/includes": [
    "es.array.includes",
    "es.string.includes"
  ],
    "core-js/stable/instance/index-of": [
    "es.array.index-of"
  ],
    "core-js/stable/instance/keys": [
    "es.array.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/stable/instance/last-index-of": [
    "es.array.last-index-of"
  ],
    "core-js/stable/instance/map": [
    "es.array.map"
  ],
    "core-js/stable/instance/match-all": [
    "es.string.match-all"
  ],
    "core-js/stable/instance/pad-end": [
    "es.string.pad-end"
  ],
    "core-js/stable/instance/pad-start": [
    "es.string.pad-start"
  ],
    "core-js/stable/instance/reduce": [
    "es.array.reduce"
  ],
    "core-js/stable/instance/reduce-right": [
    "es.array.reduce-right"
  ],
    "core-js/stable/instance/repeat": [
    "es.string.repeat"
  ],
    "core-js/stable/instance/reverse": [
    "es.array.reverse"
  ],
    "core-js/stable/instance/slice": [
    "es.array.slice"
  ],
    "core-js/stable/instance/some": [
    "es.array.some"
  ],
    "core-js/stable/instance/sort": [
    "es.array.sort"
  ],
    "core-js/stable/instance/splice": [
    "es.array.splice"
  ],
    "core-js/stable/instance/starts-with": [
    "es.string.starts-with"
  ],
    "core-js/stable/instance/trim": [
    "es.string.trim"
  ],
    "core-js/stable/instance/trim-end": [
    "es.string.trim-end"
  ],
    "core-js/stable/instance/trim-left": [
    "es.string.trim-start"
  ],
    "core-js/stable/instance/trim-right": [
    "es.string.trim-end"
  ],
    "core-js/stable/instance/trim-start": [
    "es.string.trim-start"
  ],
    "core-js/stable/instance/values": [
    "es.array.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/stable/json": [
    "es.json.stringify",
    "es.json.to-string-tag"
  ],
    "core-js/stable/json/stringify": [
    "es.json.stringify"
  ],
    "core-js/stable/json/to-string-tag": [
    "es.json.to-string-tag"
  ],
    "core-js/stable/map": [
    "es.map",
    "es.object.to-string",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/stable/math": [
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc"
  ],
    "core-js/stable/math/acosh": [
    "es.math.acosh"
  ],
    "core-js/stable/math/asinh": [
    "es.math.asinh"
  ],
    "core-js/stable/math/atanh": [
    "es.math.atanh"
  ],
    "core-js/stable/math/cbrt": [
    "es.math.cbrt"
  ],
    "core-js/stable/math/clz32": [
    "es.math.clz32"
  ],
    "core-js/stable/math/cosh": [
    "es.math.cosh"
  ],
    "core-js/stable/math/expm1": [
    "es.math.expm1"
  ],
    "core-js/stable/math/fround": [
    "es.math.fround"
  ],
    "core-js/stable/math/hypot": [
    "es.math.hypot"
  ],
    "core-js/stable/math/imul": [
    "es.math.imul"
  ],
    "core-js/stable/math/log10": [
    "es.math.log10"
  ],
    "core-js/stable/math/log1p": [
    "es.math.log1p"
  ],
    "core-js/stable/math/log2": [
    "es.math.log2"
  ],
    "core-js/stable/math/sign": [
    "es.math.sign"
  ],
    "core-js/stable/math/sinh": [
    "es.math.sinh"
  ],
    "core-js/stable/math/tanh": [
    "es.math.tanh"
  ],
    "core-js/stable/math/to-string-tag": [
    "es.math.to-string-tag"
  ],
    "core-js/stable/math/trunc": [
    "es.math.trunc"
  ],
    "core-js/stable/number": [
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
    "core-js/stable/number/constructor": [
    "es.number.constructor"
  ],
    "core-js/stable/number/epsilon": [
    "es.number.epsilon"
  ],
    "core-js/stable/number/is-finite": [
    "es.number.is-finite"
  ],
    "core-js/stable/number/is-integer": [
    "es.number.is-integer"
  ],
    "core-js/stable/number/is-nan": [
    "es.number.is-nan"
  ],
    "core-js/stable/number/is-safe-integer": [
    "es.number.is-safe-integer"
  ],
    "core-js/stable/number/max-safe-integer": [
    "es.number.max-safe-integer"
  ],
    "core-js/stable/number/min-safe-integer": [
    "es.number.min-safe-integer"
  ],
    "core-js/stable/number/parse-float": [
    "es.number.parse-float"
  ],
    "core-js/stable/number/parse-int": [
    "es.number.parse-int"
  ],
    "core-js/stable/number/to-fixed": [
    "es.number.to-fixed"
  ],
    "core-js/stable/number/to-precision": [
    "es.number.to-precision"
  ],
    "core-js/stable/number/virtual": [
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
    "core-js/stable/number/virtual/to-fixed": [
    "es.number.to-fixed"
  ],
    "core-js/stable/number/virtual/to-precision": [
    "es.number.to-precision"
  ],
    "core-js/stable/object": [
    "es.symbol",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values"
  ],
    "core-js/stable/object/assign": [
    "es.object.assign"
  ],
    "core-js/stable/object/create": [
    "es.object.create"
  ],
    "core-js/stable/object/define-getter": [
    "es.object.define-getter"
  ],
    "core-js/stable/object/define-properties": [
    "es.object.define-properties"
  ],
    "core-js/stable/object/define-property": [
    "es.object.define-property"
  ],
    "core-js/stable/object/define-setter": [
    "es.object.define-setter"
  ],
    "core-js/stable/object/entries": [
    "es.object.entries"
  ],
    "core-js/stable/object/freeze": [
    "es.object.freeze"
  ],
    "core-js/stable/object/from-entries": [
    "es.array.iterator",
    "es.object.from-entries"
  ],
    "core-js/stable/object/get-own-property-descriptor": [
    "es.object.get-own-property-descriptor"
  ],
    "core-js/stable/object/get-own-property-descriptors": [
    "es.object.get-own-property-descriptors"
  ],
    "core-js/stable/object/get-own-property-names": [
    "es.object.get-own-property-names"
  ],
    "core-js/stable/object/get-own-property-symbols": [
    "es.symbol"
  ],
    "core-js/stable/object/get-prototype-of": [
    "es.object.get-prototype-of"
  ],
    "core-js/stable/object/is": [
    "es.object.is"
  ],
    "core-js/stable/object/is-extensible": [
    "es.object.is-extensible"
  ],
    "core-js/stable/object/is-frozen": [
    "es.object.is-frozen"
  ],
    "core-js/stable/object/is-sealed": [
    "es.object.is-sealed"
  ],
    "core-js/stable/object/keys": [
    "es.object.keys"
  ],
    "core-js/stable/object/lookup-getter": [
    "es.object.lookup-setter"
  ],
    "core-js/stable/object/lookup-setter": [
    "es.object.lookup-setter"
  ],
    "core-js/stable/object/prevent-extensions": [
    "es.object.prevent-extensions"
  ],
    "core-js/stable/object/seal": [
    "es.object.seal"
  ],
    "core-js/stable/object/set-prototype-of": [
    "es.object.set-prototype-of"
  ],
    "core-js/stable/object/to-string": [
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
    "core-js/stable/object/values": [
    "es.object.values"
  ],
    "core-js/stable/parse-float": [
    "es.parse-float"
  ],
    "core-js/stable/parse-int": [
    "es.parse-int"
  ],
    "core-js/stable/promise": [
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.finally",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/stable/promise/all-settled": [
    "es.promise",
    "es.promise.all-settled"
  ],
    "core-js/stable/promise/finally": [
    "es.promise",
    "es.promise.finally"
  ],
    "core-js/stable/queue-microtask": [
    "web.queue-microtask"
  ],
    "core-js/stable/reflect": [
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of"
  ],
    "core-js/stable/reflect/apply": [
    "es.reflect.apply"
  ],
    "core-js/stable/reflect/construct": [
    "es.reflect.construct"
  ],
    "core-js/stable/reflect/define-property": [
    "es.reflect.define-property"
  ],
    "core-js/stable/reflect/delete-property": [
    "es.reflect.delete-property"
  ],
    "core-js/stable/reflect/get": [
    "es.reflect.get"
  ],
    "core-js/stable/reflect/get-own-property-descriptor": [
    "es.reflect.get-own-property-descriptor"
  ],
    "core-js/stable/reflect/get-prototype-of": [
    "es.reflect.get-prototype-of"
  ],
    "core-js/stable/reflect/has": [
    "es.reflect.has"
  ],
    "core-js/stable/reflect/is-extensible": [
    "es.reflect.is-extensible"
  ],
    "core-js/stable/reflect/own-keys": [
    "es.reflect.own-keys"
  ],
    "core-js/stable/reflect/prevent-extensions": [
    "es.reflect.prevent-extensions"
  ],
    "core-js/stable/reflect/set": [
    "es.reflect.set"
  ],
    "core-js/stable/reflect/set-prototype-of": [
    "es.reflect.set-prototype-of"
  ],
    "core-js/stable/regexp": [
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.string.match",
    "es.string.replace",
    "es.string.search",
    "es.string.split"
  ],
    "core-js/stable/regexp/constructor": [
    "es.regexp.constructor"
  ],
    "core-js/stable/regexp/flags": [
    "es.regexp.flags"
  ],
    "core-js/stable/regexp/match": [
    "es.string.match"
  ],
    "core-js/stable/regexp/replace": [
    "es.string.replace"
  ],
    "core-js/stable/regexp/search": [
    "es.string.search"
  ],
    "core-js/stable/regexp/split": [
    "es.string.split"
  ],
    "core-js/stable/regexp/sticky": [
    "es.regexp.sticky"
  ],
    "core-js/stable/regexp/test": [
    "es.regexp.exec",
    "es.regexp.test"
  ],
    "core-js/stable/regexp/to-string": [
    "es.regexp.to-string"
  ],
    "core-js/stable/set": [
    "es.object.to-string",
    "es.set",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/stable/set-immediate": [
    "web.immediate"
  ],
    "core-js/stable/set-interval": [
    "web.timers"
  ],
    "core-js/stable/set-timeout": [
    "web.timers"
  ],
    "core-js/stable/string": [
    "es.regexp.exec",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup"
  ],
    "core-js/stable/string/anchor": [
    "es.string.anchor"
  ],
    "core-js/stable/string/big": [
    "es.string.big"
  ],
    "core-js/stable/string/blink": [
    "es.string.blink"
  ],
    "core-js/stable/string/bold": [
    "es.string.bold"
  ],
    "core-js/stable/string/code-point-at": [
    "es.string.code-point-at"
  ],
    "core-js/stable/string/ends-with": [
    "es.string.ends-with"
  ],
    "core-js/stable/string/fixed": [
    "es.string.fixed"
  ],
    "core-js/stable/string/fontcolor": [
    "es.string.fontcolor"
  ],
    "core-js/stable/string/fontsize": [
    "es.string.fontsize"
  ],
    "core-js/stable/string/from-code-point": [
    "es.string.from-code-point"
  ],
    "core-js/stable/string/includes": [
    "es.string.includes"
  ],
    "core-js/stable/string/italics": [
    "es.string.italics"
  ],
    "core-js/stable/string/iterator": [
    "es.string.iterator"
  ],
    "core-js/stable/string/link": [
    "es.string.link"
  ],
    "core-js/stable/string/match": [
    "es.regexp.exec",
    "es.string.match"
  ],
    "core-js/stable/string/match-all": [
    "es.string.match-all"
  ],
    "core-js/stable/string/pad-end": [
    "es.string.pad-end"
  ],
    "core-js/stable/string/pad-start": [
    "es.string.pad-start"
  ],
    "core-js/stable/string/raw": [
    "es.string.raw"
  ],
    "core-js/stable/string/repeat": [
    "es.string.repeat"
  ],
    "core-js/stable/string/replace": [
    "es.regexp.exec",
    "es.string.replace"
  ],
    "core-js/stable/string/search": [
    "es.regexp.exec",
    "es.string.search"
  ],
    "core-js/stable/string/small": [
    "es.string.small"
  ],
    "core-js/stable/string/split": [
    "es.regexp.exec",
    "es.string.split"
  ],
    "core-js/stable/string/starts-with": [
    "es.string.starts-with"
  ],
    "core-js/stable/string/strike": [
    "es.string.strike"
  ],
    "core-js/stable/string/sub": [
    "es.string.sub"
  ],
    "core-js/stable/string/sup": [
    "es.string.sup"
  ],
    "core-js/stable/string/trim": [
    "es.string.trim"
  ],
    "core-js/stable/string/trim-end": [
    "es.string.trim-end"
  ],
    "core-js/stable/string/trim-left": [
    "es.string.trim-start"
  ],
    "core-js/stable/string/trim-right": [
    "es.string.trim-end"
  ],
    "core-js/stable/string/trim-start": [
    "es.string.trim-start"
  ],
    "core-js/stable/string/virtual": [
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup"
  ],
    "core-js/stable/string/virtual/anchor": [
    "es.string.anchor"
  ],
    "core-js/stable/string/virtual/big": [
    "es.string.big"
  ],
    "core-js/stable/string/virtual/blink": [
    "es.string.blink"
  ],
    "core-js/stable/string/virtual/bold": [
    "es.string.bold"
  ],
    "core-js/stable/string/virtual/code-point-at": [
    "es.string.code-point-at"
  ],
    "core-js/stable/string/virtual/ends-with": [
    "es.string.ends-with"
  ],
    "core-js/stable/string/virtual/fixed": [
    "es.string.fixed"
  ],
    "core-js/stable/string/virtual/fontcolor": [
    "es.string.fontcolor"
  ],
    "core-js/stable/string/virtual/fontsize": [
    "es.string.fontsize"
  ],
    "core-js/stable/string/virtual/includes": [
    "es.string.includes"
  ],
    "core-js/stable/string/virtual/italics": [
    "es.string.italics"
  ],
    "core-js/stable/string/virtual/iterator": [
    "es.string.iterator"
  ],
    "core-js/stable/string/virtual/link": [
    "es.string.link"
  ],
    "core-js/stable/string/virtual/match-all": [
    "es.string.match-all"
  ],
    "core-js/stable/string/virtual/pad-end": [
    "es.string.pad-end"
  ],
    "core-js/stable/string/virtual/pad-start": [
    "es.string.pad-start"
  ],
    "core-js/stable/string/virtual/repeat": [
    "es.string.repeat"
  ],
    "core-js/stable/string/virtual/small": [
    "es.string.small"
  ],
    "core-js/stable/string/virtual/starts-with": [
    "es.string.starts-with"
  ],
    "core-js/stable/string/virtual/strike": [
    "es.string.strike"
  ],
    "core-js/stable/string/virtual/sub": [
    "es.string.sub"
  ],
    "core-js/stable/string/virtual/sup": [
    "es.string.sup"
  ],
    "core-js/stable/string/virtual/trim": [
    "es.string.trim"
  ],
    "core-js/stable/string/virtual/trim-end": [
    "es.string.trim-end"
  ],
    "core-js/stable/string/virtual/trim-left": [
    "es.string.trim-start"
  ],
    "core-js/stable/string/virtual/trim-right": [
    "es.string.trim-end"
  ],
    "core-js/stable/string/virtual/trim-start": [
    "es.string.trim-start"
  ],
    "core-js/stable/symbol": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
    "core-js/stable/symbol/async-iterator": [
    "es.symbol.async-iterator"
  ],
    "core-js/stable/symbol/description": [
    "es.symbol.description"
  ],
    "core-js/stable/symbol/for": [
    "es.symbol"
  ],
    "core-js/stable/symbol/has-instance": [
    "es.symbol.has-instance",
    "es.function.has-instance"
  ],
    "core-js/stable/symbol/is-concat-spreadable": [
    "es.symbol.is-concat-spreadable",
    "es.array.concat"
  ],
    "core-js/stable/symbol/iterator": [
    "es.symbol.iterator",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
    "core-js/stable/symbol/key-for": [
    "es.symbol"
  ],
    "core-js/stable/symbol/match": [
    "es.symbol.match",
    "es.string.match"
  ],
    "core-js/stable/symbol/match-all": [
    "es.symbol.match-all",
    "es.string.match-all"
  ],
    "core-js/stable/symbol/replace": [
    "es.symbol.replace",
    "es.string.replace"
  ],
    "core-js/stable/symbol/search": [
    "es.symbol.search",
    "es.string.search"
  ],
    "core-js/stable/symbol/species": [
    "es.symbol.species"
  ],
    "core-js/stable/symbol/split": [
    "es.symbol.split",
    "es.string.split"
  ],
    "core-js/stable/symbol/to-primitive": [
    "es.symbol.to-primitive"
  ],
    "core-js/stable/symbol/to-string-tag": [
    "es.symbol.to-string-tag",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string"
  ],
    "core-js/stable/symbol/unscopables": [
    "es.symbol.unscopables"
  ],
    "core-js/stable/typed-array": [
    "es.object.to-string",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/stable/typed-array/copy-within": [
    "es.typed-array.copy-within"
  ],
    "core-js/stable/typed-array/entries": [
    "es.typed-array.iterator"
  ],
    "core-js/stable/typed-array/every": [
    "es.typed-array.every"
  ],
    "core-js/stable/typed-array/fill": [
    "es.typed-array.fill"
  ],
    "core-js/stable/typed-array/filter": [
    "es.typed-array.filter"
  ],
    "core-js/stable/typed-array/find": [
    "es.typed-array.find"
  ],
    "core-js/stable/typed-array/find-index": [
    "es.typed-array.find-index"
  ],
    "core-js/stable/typed-array/float32-array": [
    "es.object.to-string",
    "es.typed-array.float32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/stable/typed-array/float64-array": [
    "es.object.to-string",
    "es.typed-array.float64-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/stable/typed-array/for-each": [
    "es.typed-array.for-each"
  ],
    "core-js/stable/typed-array/from": [
    "es.typed-array.from"
  ],
    "core-js/stable/typed-array/includes": [
    "es.typed-array.includes"
  ],
    "core-js/stable/typed-array/index-of": [
    "es.typed-array.index-of"
  ],
    "core-js/stable/typed-array/int16-array": [
    "es.object.to-string",
    "es.typed-array.int16-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/stable/typed-array/int32-array": [
    "es.object.to-string",
    "es.typed-array.int32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/stable/typed-array/int8-array": [
    "es.object.to-string",
    "es.typed-array.int8-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/stable/typed-array/iterator": [
    "es.typed-array.iterator"
  ],
    "core-js/stable/typed-array/join": [
    "es.typed-array.join"
  ],
    "core-js/stable/typed-array/keys": [
    "es.typed-array.iterator"
  ],
    "core-js/stable/typed-array/last-index-of": [
    "es.typed-array.last-index-of"
  ],
    "core-js/stable/typed-array/map": [
    "es.typed-array.map"
  ],
    "core-js/stable/typed-array/of": [
    "es.typed-array.of"
  ],
    "core-js/stable/typed-array/reduce": [
    "es.typed-array.reduce"
  ],
    "core-js/stable/typed-array/reduce-right": [
    "es.typed-array.reduce-right"
  ],
    "core-js/stable/typed-array/reverse": [
    "es.typed-array.reverse"
  ],
    "core-js/stable/typed-array/set": [
    "es.typed-array.set"
  ],
    "core-js/stable/typed-array/slice": [
    "es.typed-array.slice"
  ],
    "core-js/stable/typed-array/some": [
    "es.typed-array.some"
  ],
    "core-js/stable/typed-array/sort": [
    "es.typed-array.sort"
  ],
    "core-js/stable/typed-array/subarray": [
    "es.typed-array.subarray"
  ],
    "core-js/stable/typed-array/to-locale-string": [
    "es.typed-array.to-locale-string"
  ],
    "core-js/stable/typed-array/to-string": [
    "es.typed-array.to-string"
  ],
    "core-js/stable/typed-array/uint16-array": [
    "es.object.to-string",
    "es.typed-array.uint16-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/stable/typed-array/uint32-array": [
    "es.object.to-string",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/stable/typed-array/uint8-array": [
    "es.object.to-string",
    "es.typed-array.uint8-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/stable/typed-array/uint8-clamped-array": [
    "es.object.to-string",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string"
  ],
    "core-js/stable/typed-array/values": [
    "es.typed-array.iterator"
  ],
    "core-js/stable/url": [
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "core-js/stable/url-search-params": [
    "web.url-search-params"
  ],
    "core-js/stable/url/to-json": [
    "web.url.to-json"
  ],
    "core-js/stable/weak-map": [
    "es.object.to-string",
    "es.weak-map",
    "web.dom-collections.iterator"
  ],
    "core-js/stable/weak-set": [
    "es.object.to-string",
    "es.weak-set",
    "web.dom-collections.iterator"
  ],
    "core-js/stage": [
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "core-js/stage/0": [
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "core-js/stage/1": [
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.number.from-string",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of"
  ],
    "core-js/stage/2": [
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.set.difference",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.replace-all",
    "esnext.weak-map.upsert"
  ],
    "core-js/stage/3": [
    "esnext.aggregate-error",
    "esnext.global-this",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.replace-all"
  ],
    "core-js/stage/4": [
    "esnext.global-this",
    "esnext.promise.all-settled",
    "esnext.string.match-all"
  ],
    "core-js/stage/pre": [
    "esnext.aggregate-error",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "core-js/web": [
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.immediate",
    "web.queue-microtask",
    "web.timers",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "core-js/web/dom-collections": [
    "web.dom-collections.for-each",
    "web.dom-collections.iterator"
  ],
    "core-js/web/immediate": [
    "web.immediate"
  ],
    "core-js/web/queue-microtask": [
    "web.queue-microtask"
  ],
    "core-js/web/timers": [
    "web.timers"
  ],
    "core-js/web/url": [
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
    "core-js/web/url-search-params": [
    "web.url-search-params"
  ]
  };

  function isBabelPolyfillSource(source) {
    return source === "@babel/polyfill" || source === "babel-polyfill";
  }

  function isCoreJSSource(source) {
    if (typeof source === "string") {
      source = source.replace(/\\/g, "/").replace(/(\/(index)?)?(\.js)?$/i, "").toLowerCase();
    }

    return has$6(corejsEntries, source) && corejsEntries[source];
  }

  var BABEL_POLYFILL_DEPRECATION = "\n  `@babel/polyfill` is deprecated. Please, use required parts of `core-js`\n  and `regenerator-runtime/runtime` separately";
  function replaceCoreJS3EntryPlugin (_, _ref) {
    var corejs = _ref.corejs,
        include = _ref.include,
        exclude = _ref.exclude,
        polyfillTargets = _ref.polyfillTargets,
        debug = _ref.debug;
    var polyfills = filterItems(corejs3Polyfills, include, exclude, polyfillTargets, null);
    var available = new Set(getModulesListForTargetVersion(corejs.version));

    function shouldReplace(source, modules) {
      if (!modules) return false;

      if (modules.length === 1 && polyfills.has(modules[0]) && available.has(modules[0]) && getModulePath(modules[0]) === source) {
        return false;
      }

      return true;
    }

    var isPolyfillImport = {
      ImportDeclaration: function ImportDeclaration(path) {
        var source = getImportSource(path);
        if (!source) return;

        if (isBabelPolyfillSource(source)) {
          console.warn(BABEL_POLYFILL_DEPRECATION);
        } else {
          var modules = isCoreJSSource(source);

          if (shouldReplace(source, modules)) {
            this.replaceBySeparateModulesImport(path, modules);
          }
        }
      },
      Program: {
        enter: function enter(path) {
          var _this = this;

          path.get("body").forEach(function (bodyPath) {
            var source = getRequireSource(bodyPath);
            if (!source) return;

            if (isBabelPolyfillSource(source)) {
              console.warn(BABEL_POLYFILL_DEPRECATION);
            } else {
              var modules = isCoreJSSource(source);

              if (shouldReplace(source, modules)) {
                _this.replaceBySeparateModulesImport(bodyPath, modules);
              }
            }
          });
        },
        exit: function exit(path) {
          var _this2 = this;

          var filtered = intersection(polyfills, this.polyfillsSet, available);
          var reversed = Array.from(filtered).reverse();

          for (var _iterator = reversed, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref2 = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref2 = _i.value;
            }

            var module = _ref2;

            if (!this.injectedPolyfills.has(module)) {
              createImport(path, module);
            }
          }

          filtered.forEach(function (module) {
            return _this2.injectedPolyfills.add(module);
          });
        }
      }
    };
    return {
      name: "corejs3-entry",
      visitor: isPolyfillImport,
      pre: function pre() {
        this.injectedPolyfills = new Set();
        this.polyfillsSet = new Set();

        this.replaceBySeparateModulesImport = function (path, modules) {
          for (var _iterator2 = modules, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref3;

            if (_isArray2) {
              if (_i2 >= _iterator2.length) break;
              _ref3 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done) break;
              _ref3 = _i2.value;
            }

            var module = _ref3;
            this.polyfillsSet.add(module);
          }

          path.remove();
        };
      },
      post: function post() {
        if (debug) {
          logEntryPolyfills("core-js", this.injectedPolyfills.size > 0, this.injectedPolyfills, this.file.opts.filename, polyfillTargets, corejs3Polyfills);
        }
      }
    };
  }

  function isRegeneratorSource(source) {
    return source === "regenerator-runtime/runtime";
  }

  function removeRegeneratorEntryPlugin () {
    var visitor = {
      ImportDeclaration: function ImportDeclaration(path) {
        if (isRegeneratorSource(getImportSource(path))) {
          this.regeneratorImportExcluded = true;
          path.remove();
        }
      },
      Program: function Program(path) {
        var _this = this;

        path.get("body").forEach(function (bodyPath) {
          if (isRegeneratorSource(getRequireSource(bodyPath))) {
            _this.regeneratorImportExcluded = true;
            bodyPath.remove();
          }
        });
      }
    };
    return {
      name: "regenerator-entry",
      visitor: visitor,
      pre: function pre() {
        this.regeneratorImportExcluded = false;
      },
      post: function post() {
        if (this.opts.debug && this.regeneratorImportExcluded) {
          var filename = this.file.opts.filename;

          if (process.env.BABEL_ENV === "test") {
            filename = filename.replace(/\\/g, "/");
          }

          console.log("\n[" + filename + "] Based on your targets, regenerator-runtime import excluded.");
        }
      }
    };
  }

  var pluginLists = {
    withProposals: {
      withoutBugfixes: pluginsFiltered,
      withBugfixes: Object.assign({}, pluginsFiltered, bugfixPluginsFiltered)
    },
    withoutProposals: {
      withoutBugfixes: filterStageFromList(pluginsFiltered, shippedProposals_2),
      withBugfixes: filterStageFromList(Object.assign({}, pluginsFiltered, bugfixPluginsFiltered), shippedProposals_2)
    }
  };

  function getPluginList(proposals, bugfixes) {
    if (proposals) {
      if (bugfixes) return pluginLists.withProposals.withBugfixes;else return pluginLists.withProposals.withoutBugfixes;
    } else {
      if (bugfixes) return pluginLists.withoutProposals.withBugfixes;else return pluginLists.withoutProposals.withoutBugfixes;
    }
  }

  var getPlugin = function getPlugin(pluginName) {
    var plugin = availablePlugins[pluginName];

    if (!plugin) {
      throw new Error("Could not find plugin \"" + pluginName + "\". Ensure there is an entry in ./available-plugins.js for it.");
    }

    return plugin;
  };

  var transformIncludesAndExcludes = function transformIncludesAndExcludes(opts) {
    return opts.reduce(function (result, opt) {
      var target = opt.match(/^(es|es6|es7|esnext|web)\./) ? "builtIns" : "plugins";
      result[target].add(opt);
      return result;
    }, {
      all: opts,
      plugins: new Set(),
      builtIns: new Set()
    });
  };
  var getModulesPluginNames = function getModulesPluginNames(_ref) {
    var modules = _ref.modules,
        transformations = _ref.transformations,
        shouldTransformESM = _ref.shouldTransformESM,
        shouldTransformDynamicImport = _ref.shouldTransformDynamicImport,
        shouldParseTopLevelAwait = _ref.shouldParseTopLevelAwait;
    var modulesPluginNames = [];

    if (modules !== false && transformations[modules]) {
      if (shouldTransformESM) {
        modulesPluginNames.push(transformations[modules]);
      }

      if (shouldTransformDynamicImport && shouldTransformESM && modules !== "umd") {
        modulesPluginNames.push("proposal-dynamic-import");
      } else {
        if (shouldTransformDynamicImport) {
          console.warn("Dynamic import can only be supported when transforming ES modules" + " to AMD, CommonJS or SystemJS. Only the parser plugin will be enabled.");
        }

        modulesPluginNames.push("syntax-dynamic-import");
      }
    } else {
      modulesPluginNames.push("syntax-dynamic-import");
    }

    if (shouldParseTopLevelAwait) {
      modulesPluginNames.push("syntax-top-level-await");
    }

    return modulesPluginNames;
  };
  var getPolyfillPlugins = function getPolyfillPlugins(_ref2) {
    var useBuiltIns = _ref2.useBuiltIns,
        corejs = _ref2.corejs,
        polyfillTargets = _ref2.polyfillTargets,
        include = _ref2.include,
        exclude = _ref2.exclude,
        proposals = _ref2.proposals,
        shippedProposals = _ref2.shippedProposals,
        regenerator = _ref2.regenerator,
        debug = _ref2.debug;
    var polyfillPlugins = [];

    if (useBuiltIns === "usage" || useBuiltIns === "entry") {
      var pluginOptions = {
        corejs: corejs,
        polyfillTargets: polyfillTargets,
        include: include,
        exclude: exclude,
        proposals: proposals,
        shippedProposals: shippedProposals,
        regenerator: regenerator,
        debug: debug
      };

      if (corejs) {
        if (useBuiltIns === "usage") {
          if (corejs.major === 2) {
            polyfillPlugins.push([addCoreJS2UsagePlugin, pluginOptions]);
          } else {
            polyfillPlugins.push([addCoreJS3UsagePlugin, pluginOptions]);
          }

          if (regenerator) {
            polyfillPlugins.push([addRegeneratorUsagePlugin, pluginOptions]);
          }
        } else {
          if (corejs.major === 2) {
            polyfillPlugins.push([replaceCoreJS2EntryPlugin, pluginOptions]);
          } else {
            polyfillPlugins.push([replaceCoreJS3EntryPlugin, pluginOptions]);

            if (!regenerator) {
              polyfillPlugins.push([removeRegeneratorEntryPlugin, pluginOptions]);
            }
          }
        }
      }
    }

    return polyfillPlugins;
  };

  function supportsStaticESM$1(caller) {
    return !!(caller && caller.supportsStaticESM);
  }

  function supportsDynamicImport(caller) {
    return !!(caller && caller.supportsDynamicImport);
  }

  function supportsTopLevelAwait(caller) {
    return !!(caller && caller.supportsTopLevelAwait);
  }

  var presetEnv = declare(function (api, opts) {
    api.assertVersion(7);

    var _normalizeOptions = normalizeOptions$4(opts),
        bugfixes = _normalizeOptions.bugfixes,
        configPath = _normalizeOptions.configPath,
        debug = _normalizeOptions.debug,
        optionsExclude = _normalizeOptions.exclude,
        forceAllTransforms = _normalizeOptions.forceAllTransforms,
        ignoreBrowserslistConfig = _normalizeOptions.ignoreBrowserslistConfig,
        optionsInclude = _normalizeOptions.include,
        loose = _normalizeOptions.loose,
        modules = _normalizeOptions.modules,
        shippedProposals = _normalizeOptions.shippedProposals,
        spec = _normalizeOptions.spec,
        optionsTargets = _normalizeOptions.targets,
        useBuiltIns = _normalizeOptions.useBuiltIns,
        _normalizeOptions$cor = _normalizeOptions.corejs,
        corejs = _normalizeOptions$cor.version,
        proposals = _normalizeOptions$cor.proposals;

    var hasUglifyTarget = false;

    if (optionsTargets && optionsTargets.uglify) {
      hasUglifyTarget = true;
      delete optionsTargets.uglify;
      console.log("");
      console.log("The uglify target has been deprecated. Set the top level");
      console.log("option `forceAllTransforms: true` instead.");
      console.log("");
    }

    if (optionsTargets && optionsTargets.esmodules && optionsTargets.browsers) {
      console.log("");
      console.log("@babel/preset-env: esmodules and browsers targets have been specified together.");
      console.log("`browsers` target, `" + optionsTargets.browsers + "` will be ignored.");
      console.log("");
    }

    var targets = getTargets(optionsTargets, {
      ignoreBrowserslistConfig: ignoreBrowserslistConfig,
      configPath: configPath
    });
    var include = transformIncludesAndExcludes(optionsInclude);
    var exclude = transformIncludesAndExcludes(optionsExclude);
    var transformTargets = forceAllTransforms || hasUglifyTarget ? {} : targets;
    var modulesPluginNames = getModulesPluginNames({
      modules: modules,
      transformations: moduleTransformations,
      shouldTransformESM: modules !== "auto" || !api.caller || !api.caller(supportsStaticESM$1),
      shouldTransformDynamicImport: modules !== "auto" || !api.caller || !api.caller(supportsDynamicImport),
      shouldParseTopLevelAwait: !api.caller || api.caller(supportsTopLevelAwait)
    });
    var pluginNames = filterItems(getPluginList(shippedProposals, bugfixes), include.plugins, exclude.plugins, transformTargets, modulesPluginNames, getOptionSpecificExcludesFor({
      loose: loose
    }), shippedProposals_1);
    removeUnnecessaryItems(pluginNames, overlappingPlugins$2);
    var polyfillPlugins = getPolyfillPlugins({
      useBuiltIns: useBuiltIns,
      corejs: corejs,
      polyfillTargets: targets,
      include: include.builtIns,
      exclude: exclude.builtIns,
      proposals: proposals,
      shippedProposals: shippedProposals,
      regenerator: pluginNames.has("transform-regenerator"),
      debug: debug
    });
    var pluginUseBuiltIns = useBuiltIns !== false;
    var plugins = Array.from(pluginNames).map(function (pluginName) {
      return [getPlugin(pluginName), {
        spec: spec,
        loose: loose,
        useBuiltIns: pluginUseBuiltIns
      }];
    }).concat(polyfillPlugins);

    if (debug) {
      console.log("@babel/preset-env: `DEBUG` option");
      console.log("\nUsing targets:");
      console.log(JSON.stringify(prettifyTargets(targets), null, 2));
      console.log("\nUsing modules transform: " + modules.toString());
      console.log("\nUsing plugins:");
      pluginNames.forEach(function (pluginName) {
        logPluginOrPolyfill(pluginName, targets, pluginsFiltered);
      });

      if (!useBuiltIns) {
        console.log("\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.");
      } else {
        console.log("\nUsing polyfills with `" + useBuiltIns + "` option:");
      }
    }

    return {
      plugins: plugins
    };
  });

  var presetFlow = declare(function (api, _ref) {
    var all = _ref.all,
        allowDeclareFields = _ref.allowDeclareFields;
    api.assertVersion(7);
    return {
      plugins: [[transformFlowStripTypes, {
        all: all,
        allowDeclareFields: allowDeclareFields
      }]]
    };
  });

  var presetReact = declare(function (api, opts) {
    api.assertVersion(7);
    var pragma = opts.pragma,
        pragmaFrag = opts.pragmaFrag;
    var pure = opts.pure,
        _opts$throwIfNamespac = opts.throwIfNamespace,
        throwIfNamespace = _opts$throwIfNamespac === void 0 ? true : _opts$throwIfNamespac,
        useSpread = opts.useSpread,
        _opts$runtime = opts.runtime,
        runtime = _opts$runtime === void 0 ? "classic" : _opts$runtime,
        importSource = opts.importSource;

    if (runtime === "classic") {
      pragma = pragma || "React.createElement";
      pragmaFrag = pragmaFrag || "React.Fragment";
    }

    var development = !!opts.development;
    var useBuiltIns = !!opts.useBuiltIns;

    if (typeof development !== "boolean") {
      throw new Error("@babel/preset-react 'development' option must be a boolean.");
    }

    var transformReactJSXPlugin = runtime === "automatic" && development ? transformReactJSXDevelopment : transformReactJSX;
    return {
      plugins: [[transformReactJSXPlugin, {
        importSource: importSource,
        pragma: pragma,
        pragmaFrag: pragmaFrag,
        runtime: runtime,
        throwIfNamespace: throwIfNamespace,
        useBuiltIns: useBuiltIns,
        useSpread: useSpread,
        pure: pure
      }], transformReactDisplayName, development && runtime === "classic" && transformReactJSXSource, development && runtime === "classic" && transformReactJSXSelf].filter(Boolean)
    };
  });

  var presetTypescript = declare(function (api, _ref) {
    var _ref$allExtensions = _ref.allExtensions,
        allExtensions = _ref$allExtensions === void 0 ? false : _ref$allExtensions,
        allowDeclareFields = _ref.allowDeclareFields,
        allowNamespaces = _ref.allowNamespaces,
        jsxPragma = _ref.jsxPragma,
        _ref$isTSX = _ref.isTSX,
        isTSX = _ref$isTSX === void 0 ? false : _ref$isTSX,
        onlyRemoveTypeImports = _ref.onlyRemoveTypeImports;
    api.assertVersion(7);

    if (typeof allExtensions !== "boolean") {
      throw new Error(".allExtensions must be a boolean, or undefined");
    }

    if (typeof isTSX !== "boolean") {
      throw new Error(".isTSX must be a boolean, or undefined");
    }

    if (isTSX && !allExtensions) {
      throw new Error("isTSX:true requires allExtensions:true");
    }

    var pluginOptions = function pluginOptions(isTSX) {
      return {
        allowDeclareFields: allowDeclareFields,
        allowNamespaces: allowNamespaces,
        isTSX: isTSX,
        jsxPragma: jsxPragma,
        onlyRemoveTypeImports: onlyRemoveTypeImports
      };
    };

    return {
      overrides: allExtensions ? [{
        plugins: [[transformTypeScript, pluginOptions(isTSX)]]
      }] : [{
        test: /\.ts$/,
        plugins: [[transformTypeScript, pluginOptions(false)]]
      }, {
        test: /\.tsx$/,
        plugins: [[transformTypeScript, pluginOptions(true)]]
      }]
    };
  });

  var scriptTypes = ["text/jsx", "text/babel"];
  var headEl;
  var inlineScriptCount = 0;

  function transformCode(transformFn, script) {
    var source;

    if (script.url != null) {
      source = script.url;
    } else {
      source = "Inline Babel script";
      inlineScriptCount++;

      if (inlineScriptCount > 1) {
        source += " (" + inlineScriptCount + ")";
      }
    }

    return transformFn(script.content, buildBabelOptions(script, source)).code;
  }

  function buildBabelOptions(script, filename) {
    return {
      filename: filename,
      presets: script.presets || ["react", "es2015"],
      plugins: script.plugins || ["proposal-class-properties", "proposal-object-rest-spread", "transform-flow-strip-types"],
      sourceMaps: "inline",
      sourceFileName: filename
    };
  }

  function run$1(transformFn, script) {
    var scriptEl = document.createElement("script");
    scriptEl.text = transformCode(transformFn, script);
    headEl.appendChild(scriptEl);
  }

  function load(url, successCallback, errorCallback) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);

    if ("overrideMimeType" in xhr) {
      xhr.overrideMimeType("text/plain");
    }

    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 0 || xhr.status === 200) {
          successCallback(xhr.responseText);
        } else {
          errorCallback();
          throw new Error("Could not load " + url);
        }
      }
    };

    return xhr.send(null);
  }

  function getPluginsOrPresetsFromScript(script, attributeName) {
    var rawValue = script.getAttribute(attributeName);

    if (rawValue === "") {
      return [];
    }

    if (!rawValue) {
      return null;
    }

    return rawValue.split(",").map(function (item) {
      return item.trim();
    });
  }

  function loadScripts(transformFn, scripts) {
    var result = [];
    var count = scripts.length;

    function check() {
      var script, i;

      for (i = 0; i < count; i++) {
        script = result[i];

        if (script.loaded && !script.executed) {
          script.executed = true;
          run$1(transformFn, script);
        } else if (!script.loaded && !script.error && !script.async) {
          break;
        }
      }
    }

    scripts.forEach(function (script, i) {
      var scriptData = {
        async: script.hasAttribute("async"),
        error: false,
        executed: false,
        plugins: getPluginsOrPresetsFromScript(script, "data-plugins"),
        presets: getPluginsOrPresetsFromScript(script, "data-presets")
      };

      if (script.src) {
        result[i] = Object.assign({}, scriptData, {
          content: null,
          loaded: false,
          url: script.src
        });
        load(script.src, function (content) {
          result[i].loaded = true;
          result[i].content = content;
          check();
        }, function () {
          result[i].error = true;
          check();
        });
      } else {
        result[i] = Object.assign({}, scriptData, {
          content: script.innerHTML,
          loaded: true,
          url: script.getAttribute("data-module") || null
        });
      }
    });
    check();
  }

  function runScripts(transformFn, scripts) {
    headEl = document.getElementsByTagName("head")[0];

    if (!scripts) {
      scripts = document.getElementsByTagName("script");
    }

    var jsxScripts = [];

    for (var i = 0; i < scripts.length; i++) {
      var script = scripts.item(i);
      var type = script.type.split(";")[0];

      if (scriptTypes.indexOf(type) !== -1) {
        jsxScripts.push(script);
      }
    }

    if (jsxScripts.length === 0) {
      return;
    }

    console.warn("You are using the in-browser Babel transformer. Be sure to precompile " + "your scripts for production - https://babeljs.io/docs/setup/");
    loadScripts(transformFn, jsxScripts);
  }

  var isArray$4 = Array.isArray || function (arg) {
    return Object.prototype.toString.call(arg) === "[object Array]";
  };

  function loadBuiltin(builtinTable, name) {
    if (isArray$4(name) && typeof name[0] === "string") {
      if (Object.prototype.hasOwnProperty.call(builtinTable, name[0])) {
        return [builtinTable[name[0]]].concat(name.slice(1));
      }

      return;
    } else if (typeof name === "string") {
      return builtinTable[name];
    }

    return name;
  }

  function processOptions(options) {
    var presets = (options.presets || []).map(function (presetName) {
      var preset = loadBuiltin(availablePresets, presetName);

      if (preset) {
        if (isArray$4(preset) && typeof preset[0] === "object" && Object.prototype.hasOwnProperty.call(preset[0], "buildPreset")) {
          preset[0] = Object.assign({}, preset[0], {
            buildPreset: preset[0].buildPreset
          });
        }
      } else {
        throw new Error("Invalid preset specified in Babel options: \"" + presetName + "\"");
      }

      return preset;
    });
    var plugins = (options.plugins || []).map(function (pluginName) {
      var plugin = loadBuiltin(availablePlugins$1, pluginName);

      if (!plugin) {
        throw new Error("Invalid plugin specified in Babel options: \"" + pluginName + "\"");
      }

      return plugin;
    });
    return Object.assign({
      babelrc: false
    }, options, {
      presets: presets,
      plugins: plugins
    });
  }

  function transform$1(code, options) {
    return transform(code, processOptions(options));
  }
  function transformFromAst$1(ast, code, options) {
    return transformFromAst(ast, code, processOptions(options));
  }
  var availablePlugins$1 = {};
  var availablePresets = {};
  var buildExternalHelpers = babelBuildExternalHelpers;
  function registerPlugin(name, plugin) {
    if (Object.prototype.hasOwnProperty.call(availablePlugins$1, name)) {
      console.warn("A plugin named \"" + name + "\" is already registered, it will be overridden");
    }

    availablePlugins$1[name] = plugin;
  }
  function registerPlugins(newPlugins) {
    Object.keys(newPlugins).forEach(function (name) {
      return registerPlugin(name, newPlugins[name]);
    });
  }
  function registerPreset(name, preset) {
    if (Object.prototype.hasOwnProperty.call(availablePresets, name)) {
      if (name === "env") {
        console.warn("@babel/preset-env is now included in @babel/standalone, please remove @babel/preset-env-standalone");
      } else {
        console.warn("A preset named \"" + name + "\" is already registered, it will be overridden");
      }
    }

    availablePresets[name] = preset;
  }
  function registerPresets(newPresets) {
    Object.keys(newPresets).forEach(function (name) {
      return registerPreset(name, newPresets[name]);
    });
  }
  registerPlugins(all);
  registerPresets({
    env: presetEnv,
    es2015: preset2015,
    es2016: function es2016() {
      return {
        plugins: [availablePlugins$1["transform-exponentiation-operator"]]
      };
    },
    es2017: function es2017() {
      return {
        plugins: [availablePlugins$1["transform-async-to-generator"]]
      };
    },
    react: presetReact,
    "stage-0": presetStage0,
    "stage-1": presetStage1,
    "stage-2": presetStage2,
    "stage-3": presetStage3,
    "es2015-loose": {
      presets: [[preset2015, {
        loose: true
      }]]
    },
    "es2015-no-commonjs": {
      presets: [[preset2015, {
        modules: false
      }]]
    },
    typescript: presetTypescript,
    flow: presetFlow
  });
  var version$7 = "7.9.0";

  function onDOMContentLoaded() {
    transformScriptTags();
  }

  if (typeof window !== "undefined" && window && window.addEventListener) {
    window.addEventListener("DOMContentLoaded", onDOMContentLoaded, false);
  }

  function transformScriptTags(scriptTags) {
    runScripts(transform$1, scriptTags);
  }
  function disableScriptTags() {
    window.removeEventListener("DOMContentLoaded", onDOMContentLoaded);
  }

  exports.availablePlugins = availablePlugins$1;
  exports.availablePresets = availablePresets;
  exports.buildExternalHelpers = buildExternalHelpers;
  exports.disableScriptTags = disableScriptTags;
  exports.registerPlugin = registerPlugin;
  exports.registerPlugins = registerPlugins;
  exports.registerPreset = registerPreset;
  exports.registerPresets = registerPresets;
  exports.transform = transform$1;
  exports.transformFromAst = transformFromAst$1;
  exports.transformScriptTags = transformScriptTags;
  exports.version = version$7;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
